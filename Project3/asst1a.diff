diff --git a/defs.mk b/defs.mk
new file mode 100644
index 0000000..5b736af
--- /dev/null
+++ b/defs.mk
@@ -0,0 +1,175 @@
+# This file was generated by configure. Edits will disappear if you rerun
+# configure. If you find that you need to edit this file to make things
+# work, let the course staff know and we'll try to fix the configure script.
+#
+# 
+# The purpose of this file is to hold all the makefile definitions
+# needed to adjust the OS/161 build process to any particular
+# environment. If I've done it right, all you need to do is rerun the
+# configure script and make clean if you decide to work from Linux or
+# BSD instead of Digital Unix. If I've done it mostly right, you may
+# need to edit this file but you still hopefully won't need to edit
+# any of the makefiles.
+#
+
+
+#
+# Initialize various variables that we set only with += in case some make
+# has a default value we weren't expecting.
+#
+CFLAGS=
+KCFLAGS=
+HOST_CFLAGS=
+LDFLAGS=
+KLDFLAGS=
+HOST_LDFLAGS=
+LIBS=
+HOST_LIBS=
+
+#
+# Location of installed runnable system tree.
+#
+# This must be an absolute path, because it is used from different
+# levels of the source tree.
+#
+OSTREE=$(HOME)/cs161/root
+
+#
+# Name of the platform we're building OS/161 to run on.
+#
+PLATFORM=mips
+
+#
+# As of cs161-toolchain-1.2 the MIPS toolchain is a mips-linux one
+# that generates more or less SVR4 ELF ABI compliant code. This means
+# that by default all code is PIC (position-independent code), which
+# is all very well but not what we want. So we use -fno-pic to turn
+# this behavior off. It turns out you need -mno-abicalls too to turn
+# it off completely.
+#
+CFLAGS+=-mno-abicalls -fno-pic
+KCFLAGS+=-mno-abicalls -fno-pic
+
+# If using an older cs161-toolchain for MIPS, you'll need this instead:
+#LDFLAGS+=-Ttext 0x1000
+#
+# Because OS/161 runs on one architecture (probably MIPS or ANT32) and
+# is compiled on another (probably Alpha or i386) it is important to
+# make sure the right compiler (and assembler, linker, etc.) is used
+# at every point.
+#
+# A compiler compiles *running on* one platform, and *generates code*
+# that may run on a different platform. Thus, supposing that you are 
+# building MIPS OS/161 on i386 Linux, there are four possible compilers.
+# (If you are building some other OS/161 or building on some other
+# platform, make the appropriate substitutions.) These four are:
+#
+#    (1) runs on i386 Linux, generates code for i386 Linux
+#    (2) runs on i386 Linux, generates code for MIPS OS/161
+#    (3) runs on MIPS OS/161, generates code for i386 Linux
+#    (4) runs on MIPS OS/161, generates code for MIPS OS/161
+#
+# Note that when building on i386 Linux, there is no use for a
+# compiler that runs on MIPS OS/161; you can't run it. Thus cases
+# (3) and (4) do not interest us.
+#
+# However, in the course of the build, there are places where it is
+# necessary to compile and run programs on the machine the build is
+# happening on. Thus, the makefiles need to be able to access *both*
+# compiler (1) and compiler (2).
+#
+# We do this by defining the make variable CC to be the common case,
+# compiler (2), and the make variable HOST_CC to be compiler (1). 
+# Similar variables are defined for the other bits of the toolchain,
+# like AS (assembler), LD (linker), and SIZE (size program).
+#
+# Then, programs to be run during the build can be compiled with 
+# HOST_CC, and components of the system can be built with CC.
+#
+
+
+# CC: compiler, when compiling to object files
+CC=cs161-gcc 
+# LDCC: compiler, when linking
+LDCC=cs161-gcc
+# AS: assembler.
+AS=cs161-as
+# LD: linker
+LD=cs161-ld
+# AR: archiver (librarian)
+AR=cs161-ar
+# RANLIB: library postprocessor
+RANLIB=cs161-ranlib
+# NM: prints symbol tables
+NM=cs161-nm
+# SIZE: prints size of binaries
+SIZE=cs161-size
+# STRIP: strips debug info
+STRIP=cs161-strip
+
+
+# compiler for host system
+HOST_CC=gcc
+
+# compiler for host system, when linking
+HOST_LDCC=gcc
+
+# assembler for host system
+HOST_AS=as
+
+# linker for host system
+HOST_LD=ld
+
+# archiver (librarian) for host system
+HOST_AR=ar
+
+# ranlib (library postprocessor) for host system... or "true" to skip it
+HOST_RANLIB=ranlib
+
+# nm for host system
+HOST_NM=nm
+
+# size for host system
+HOST_SIZE=size
+
+# strip for host system
+HOST_STRIP=strip
+
+
+# The HOST_... versions are for compiling/linking for the host system.
+# The K... versions are for the kernel build. 
+
+# Compile flags. 
+# The kernel has its own debug/optimize setting in the kernel config, so
+# we don't include ours.
+CFLAGS+=-Wall -W -Wwrite-strings -O2
+KCFLAGS+=-Wall -W -Wwrite-strings
+HOST_CFLAGS+=-Wall -W -Wwrite-strings -O2 -I$(OSTREE)/hostinclude
+
+# Linker flags
+LDFLAGS+=
+KLDFLAGS+=
+HOST_LDFLAGS+=
+
+# Libraries
+# 
+LIBS+=
+HOST_LIBS+=
+
+
+# These are cflags used to conditionally compile src/lib/hostcompat.
+COMPAT_CFLAGS=
+
+# These are make targets that we conditionally enable when installing
+# in src/lib/hostcompat.
+COMPAT_TARGETS=
+
+
+# When we compile OS/161 programs, we want to use the OS/161 header files
+# and libraries. By default, gcc will look in some include directory and
+# some lib directory that it was told to use when it was compiled. We 
+# assume that directory isn't ours. (If it is, all these variables can
+# be set to empty, but everything will still work if you don't.)
+TREE_CFLAGS=-nostdinc -I$(OSTREE)/include
+TREE_LDFLAGS=-nostdlib -L$(OSTREE)/lib $(OSTREE)/lib/crt0.o
+TREE_LIBS=-lc
diff --git a/kern/compile/ASST1/Makefile b/kern/compile/ASST1/Makefile
new file mode 100644
index 0000000..3e24232
--- /dev/null
+++ b/kern/compile/ASST1/Makefile
@@ -0,0 +1,196 @@
+# Automatically generated by config.
+# Edit arch/mips/conf/Makefile.mips instead, and rerun config.
+#
+
+#
+# Makefile.mips
+#
+# OS/161 kernel makefile base for the MIPS r2000/r3000.
+#
+# The actual makefiles used are copies of this file - if you want to edit,
+# edit kern/arch/mips/conf/Makefile.mips and rerun config.
+#
+
+
+#
+# Filename for the kernel.
+#
+KERNEL=kernel
+
+#
+# Get the defs that were dumped out from the kernel config tool.
+# This defines:
+#	S		Path for top of kernel source tree
+#	ARCH		Architecture ("mips")
+#	DEBUGFLAGS	-O2 or -g
+#	CONFNAME	The name of the kernel config, e.g., ASST1
+#
+include defs.mk
+
+#
+# Get the tree-wide defs.
+# This defines (that we use):
+#	OSTREE		Path for top of installed system tree
+#	CC		C compiler
+#	KCFLAGS		C compiler flags for kernel
+#	LD		Linker
+#	KLDFLAGS	Linker flags for kernel
+#	SIZE		Object file size tool
+#
+include $S/../defs.mk
+
+#
+# Adjust defs for building the kernel.
+#
+# The LOAD_ADDRESS is the virtual address where the kernel will be loaded
+# into memory. This is in the direct-mapped cached segment of the MIPS
+# address space. -Ttext is the linker option for setting it.
+#
+# -T provides the linker with a "linker script". This is a piece of
+# obscure mumble that tells the linker how to put together the output
+# program. The only reason we need it is that the linker breaks if you
+# try to use -Ttext and its default built-in linker script at the same
+# time.
+#
+# -nostdinc prevents including header files other than our own, and 
+# -nostdlib prevents linking against any standard libraries. Because
+# the kernel has to be a completely standalone program, this is important.
+#
+# -ffreestanding tells gcc this is not an ordinary program, so it will
+# make fewer unwise assumptions about standard library functions.
+#
+# We define _KERNEL so certain source files that are shared between the
+# kernel and userland (like strcpy.c) can tell the difference so they know
+# which header files to use.
+#
+# -G 0 tells the assembler and linker not to reference global variables
+# via the "global pointer" (MIPS gp register) because we don't support 
+# handling the gp register.
+#
+LOAD_ADDRESS=0x80001000
+INCLUDES=-nostdinc -I$S/include -I$S/dev -I. 
+CFLAGS=$(KCFLAGS) $(DEBUGFLAGS) $(INCLUDES) -ffreestanding -D_KERNEL -G 0
+LDFLAGS=$(KLDFLAGS) -nostdlib \
+	-Ttext $(LOAD_ADDRESS) -T $S/arch/mips/conf/ldscript \
+	-G 0
+
+#
+# Rules for compiling various kinds of source files, by suffix.
+# (There's nothing magical about these names and make.)
+#
+# We don't actually use C++ in OS/161, although, with some fiddling,
+# you might be able to. But you must turn off exceptions and RTTI in
+# order to do so (the implementations of these in gcc are completely 
+# unsuitable for kernels.)
+#
+COMPILE.cc=$(CC) $(CFLAGS) -fno-rtti -fno-exceptions -c
+COMPILE.c=$(CC) $(CFLAGS) -c
+COMPILE.l=false   # redefine when needed 
+COMPILE.y=false   # redefine when needed 
+COMPILE.S=$(CC) $(CFLAGS) -c
+
+#
+# This should expand to all the header files in the kernel so they can
+# be fed to tags.
+#
+TAGS_HEADERS=$S/include/*.h $S/include/kern/*.h $S/arch/$(ARCH)/include/*.h
+
+#
+# Default make rule: build the kernel.
+#
+all: $(KERNEL)
+
+#
+# Here's how we link the kernel. 
+#
+# vers.c/.o is generated on every build. It contains a numeric serial
+# number incremented every time newvers.sh is run.  These values are
+# printed out by newvers.sh and are also displayed at boot time. This
+# makes it possible to tell at a glance whether you're actually
+# running the same kernel you just compiled.
+#
+# The version number is kept in the file called "version" in the build
+# directory.
+#
+# By immemorial tradition, "size" is run on the kernel after it's linked.
+#
+$(KERNEL):
+	$S/conf/newvers.sh $(CONFNAME)
+	$(COMPILE.c) vers.c
+	$(LD) $(LDFLAGS) $(OBJS) vers.o -o $(KERNEL)
+	$(SIZE) $(KERNEL)
+
+#
+# Use the -M argument to gcc to get it to output dependency information.
+# Note that we use -M, which includes deps for #include <...> files,
+# rather than -MM, which doesn't. This is because we are the operating
+# system: the #include <...> files are part of our project - in fact, in
+# the kernel they're the kernel's own include files - and they will be
+# changing!
+#
+depend:
+	$(CC) $(CFLAGS) -M $(SRCS) > depend.mk
+
+#
+# Remove everything generated during the compile.
+# (To remove absolutely everything automatically generated, you can just
+# blow away the whole compile directory.)
+#
+clean:
+	rm -f *.o *.a tags $(KERNEL)
+
+#
+# Rerun config for this configuration.
+#
+reconfig:
+	(cd ../../conf && ./config $(CONFNAME))
+
+#
+# [ -d $(OSTREE) ] succeeds if $(OSTREE) is a directory.
+# (See test(1).) Thus, if $(OSTREE) doesn't exist, it will be created.
+#
+
+# The kernel gets installed at the top of the installed system tree.
+# Since with OS/161 it's relatively likely that you'll be working with
+# several configurations at once, it gets installed under the name of
+# this config, and a symbolic link with the "real" name is set up to
+# point to the last kernel installed.
+#
+install:
+	[ -d $(OSTREE) ] || mkdir $(OSTREE)
+	cp $(KERNEL) $(OSTREE)/$(KERNEL)-$(CONFNAME)
+	-rm -f $(OSTREE)/$(KERNEL)
+	ln -s $(KERNEL)-$(CONFNAME) $(OSTREE)/$(KERNEL)
+
+#
+# Run tags on all the sources and header files. This is probably not
+# the most useful way to do this and needs attention. (XXX)
+#
+tags:
+	ctags -wtd $(SRCS) $(TAGS_HEADERS)
+
+#
+# This tells make that these rules are not files so it (hopefully)
+# won't become confused if files by those names appear.
+#
+.PHONY: all depend clean install tags reconfig
+
+#
+# Get the list of source files from where it was generated by the 
+# kernel config tool.
+#
+# This sets SRCS and OBJS, and also defines a rule for compiling each
+# source file.
+#
+include files.mk
+
+# Get dependency information.
+include depend.mk
+
+#
+# Tell make that the kernel depends on the object files listed in $(OBJS).
+# This (unlike the link commands that also use $(OBJS) above) must come
+# after the include of files.mk, because of the way make reads its input
+# and evaluates variables.
+#
+$(KERNEL): $(OBJS)
diff --git a/kern/compile/ASST1/__printf.o b/kern/compile/ASST1/__printf.o
new file mode 100644
index 0000000..6a402db
Binary files /dev/null and b/kern/compile/ASST1/__printf.o differ
diff --git a/kern/compile/ASST1/array.o b/kern/compile/ASST1/array.o
new file mode 100644
index 0000000..1b04508
Binary files /dev/null and b/kern/compile/ASST1/array.o differ
diff --git a/kern/compile/ASST1/arraytest.o b/kern/compile/ASST1/arraytest.o
new file mode 100644
index 0000000..15d2c4f
Binary files /dev/null and b/kern/compile/ASST1/arraytest.o differ
diff --git a/kern/compile/ASST1/atoi.o b/kern/compile/ASST1/atoi.o
new file mode 100644
index 0000000..e83f366
Binary files /dev/null and b/kern/compile/ASST1/atoi.o differ
diff --git a/kern/compile/ASST1/autoconf.c b/kern/compile/ASST1/autoconf.c
new file mode 100644
index 0000000..c9cdf87
--- /dev/null
+++ b/kern/compile/ASST1/autoconf.c
@@ -0,0 +1,455 @@
+/* Automatically generated; do not edit */
+#include <types.h>
+#include <lib.h>
+#include "autoconf.h"
+
+static void autoconf_beep(struct beep_softc *, int);
+static void autoconf_con(struct con_softc *, int);
+static void autoconf_emu(struct emu_softc *, int);
+static void autoconf_lhd(struct lhd_softc *, int);
+static void autoconf_lrandom(struct lrandom_softc *, int);
+static void autoconf_lser(struct lser_softc *, int);
+static void autoconf_ltimer(struct ltimer_softc *, int);
+static void autoconf_ltrace(struct ltrace_softc *, int);
+static void autoconf_pseudorand(struct pseudorand_softc *, int);
+static void autoconf_random(struct random_softc *, int);
+static void autoconf_rtclock(struct rtclock_softc *, int);
+static int nextunit_beep;
+static int nextunit_con;
+static int nextunit_emu;
+static int nextunit_lhd;
+static int nextunit_lrandom;
+static int nextunit_lser;
+static int nextunit_ltimer;
+static int nextunit_ltrace;
+static int nextunit_random;
+static int nextunit_rtclock;
+
+static
+int
+tryattach_emu_to_lamebus(int devunit, struct lamebus_softc *bus, int busunit)
+{
+	struct emu_softc *dev;
+	int result;
+
+	dev = attach_emu_to_lamebus(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("emu%d at lamebus%d", devunit, busunit);
+	result = config_emu(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_emu = devunit+1;
+	autoconf_emu(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_ltrace_to_lamebus(int devunit, struct lamebus_softc *bus, int busunit)
+{
+	struct ltrace_softc *dev;
+	int result;
+
+	dev = attach_ltrace_to_lamebus(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("ltrace%d at lamebus%d", devunit, busunit);
+	result = config_ltrace(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_ltrace = devunit+1;
+	autoconf_ltrace(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_ltimer_to_lamebus(int devunit, struct lamebus_softc *bus, int busunit)
+{
+	struct ltimer_softc *dev;
+	int result;
+
+	dev = attach_ltimer_to_lamebus(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("ltimer%d at lamebus%d", devunit, busunit);
+	result = config_ltimer(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_ltimer = devunit+1;
+	autoconf_ltimer(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_lrandom_to_lamebus(int devunit, struct lamebus_softc *bus, int busunit)
+{
+	struct lrandom_softc *dev;
+	int result;
+
+	dev = attach_lrandom_to_lamebus(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("lrandom%d at lamebus%d", devunit, busunit);
+	result = config_lrandom(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_lrandom = devunit+1;
+	autoconf_lrandom(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_lhd_to_lamebus(int devunit, struct lamebus_softc *bus, int busunit)
+{
+	struct lhd_softc *dev;
+	int result;
+
+	dev = attach_lhd_to_lamebus(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("lhd%d at lamebus%d", devunit, busunit);
+	result = config_lhd(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_lhd = devunit+1;
+	autoconf_lhd(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_lser_to_lamebus(int devunit, struct lamebus_softc *bus, int busunit)
+{
+	struct lser_softc *dev;
+	int result;
+
+	dev = attach_lser_to_lamebus(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("lser%d at lamebus%d", devunit, busunit);
+	result = config_lser(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_lser = devunit+1;
+	autoconf_lser(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_beep_to_ltimer(int devunit, struct ltimer_softc *bus, int busunit)
+{
+	struct beep_softc *dev;
+	int result;
+
+	dev = attach_beep_to_ltimer(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("beep%d at ltimer%d", devunit, busunit);
+	result = config_beep(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_beep = devunit+1;
+	autoconf_beep(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_con_to_lser(int devunit, struct lser_softc *bus, int busunit)
+{
+	struct con_softc *dev;
+	int result;
+
+	dev = attach_con_to_lser(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("con%d at lser%d", devunit, busunit);
+	result = config_con(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_con = devunit+1;
+	autoconf_con(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_rtclock_to_ltimer(int devunit, struct ltimer_softc *bus, int busunit)
+{
+	struct rtclock_softc *dev;
+	int result;
+
+	dev = attach_rtclock_to_ltimer(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("rtclock%d at ltimer%d", devunit, busunit);
+	result = config_rtclock(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_rtclock = devunit+1;
+	autoconf_rtclock(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_random_to_lrandom(int devunit, struct lrandom_softc *bus, int busunit)
+{
+	struct random_softc *dev;
+	int result;
+
+	dev = attach_random_to_lrandom(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("random%d at lrandom%d", devunit, busunit);
+	result = config_random(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_random = devunit+1;
+	autoconf_random(dev, devunit);
+	return 0;
+}
+
+static
+int
+tryattach_random_to_pseudorand(int devunit, struct pseudorand_softc *bus, int busunit)
+{
+	struct random_softc *dev;
+	int result;
+
+	dev = attach_random_to_pseudorand(devunit, bus);
+	if (dev==NULL) {
+		return -1;
+	}
+	kprintf("random%d at pseudorand%d", devunit, busunit);
+	result = config_random(dev, devunit);
+	if (result != 0) {
+		kprintf(": %s\n", strerror(result));
+		/* should really clean up dev */
+		return result;
+	}
+	kprintf("\n");
+	nextunit_random = devunit+1;
+	autoconf_random(dev, devunit);
+	return 0;
+}
+
+
+static
+void
+autoconf_con(struct con_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+}
+
+static
+void
+autoconf_lser(struct lser_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+	{
+		if (nextunit_con <= 0) {
+			tryattach_con_to_lser(0, bus, busunit);
+		}
+	}
+}
+
+static
+void
+autoconf_lhd(struct lhd_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+}
+
+static
+void
+autoconf_emu(struct emu_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+}
+
+void
+autoconf_pseudorand(struct pseudorand_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+	if (busunit==0) {
+		if (nextunit_random <= 0) {
+			tryattach_random_to_pseudorand(0, bus, busunit);
+		}
+	}
+}
+
+static
+void
+autoconf_random(struct random_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+}
+
+static
+void
+autoconf_ltimer(struct ltimer_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+	{
+		if (nextunit_beep <= 0) {
+			tryattach_beep_to_ltimer(0, bus, busunit);
+		}
+	}
+	{
+		if (nextunit_rtclock <= 0) {
+			tryattach_rtclock_to_ltimer(0, bus, busunit);
+		}
+	}
+}
+
+void
+autoconf_lamebus(struct lamebus_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+	{
+		int result, devunit=nextunit_emu;
+		do {
+			result = tryattach_emu_to_lamebus(devunit, bus, busunit);
+			devunit++;
+		} while (result==0);
+	}
+	{
+		int result, devunit=nextunit_ltrace;
+		do {
+			result = tryattach_ltrace_to_lamebus(devunit, bus, busunit);
+			devunit++;
+		} while (result==0);
+	}
+	{
+		int result, devunit=nextunit_ltimer;
+		do {
+			result = tryattach_ltimer_to_lamebus(devunit, bus, busunit);
+			devunit++;
+		} while (result==0);
+	}
+	{
+		int result, devunit=nextunit_lrandom;
+		do {
+			result = tryattach_lrandom_to_lamebus(devunit, bus, busunit);
+			devunit++;
+		} while (result==0);
+	}
+	{
+		int result, devunit=nextunit_lhd;
+		do {
+			result = tryattach_lhd_to_lamebus(devunit, bus, busunit);
+			devunit++;
+		} while (result==0);
+	}
+	{
+		int result, devunit=nextunit_lser;
+		do {
+			result = tryattach_lser_to_lamebus(devunit, bus, busunit);
+			devunit++;
+		} while (result==0);
+	}
+}
+
+static
+void
+autoconf_beep(struct beep_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+}
+
+static
+void
+autoconf_lrandom(struct lrandom_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+	{
+		if (nextunit_random <= 0) {
+			tryattach_random_to_lrandom(0, bus, busunit);
+		}
+	}
+}
+
+static
+void
+autoconf_rtclock(struct rtclock_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+}
+
+static
+void
+autoconf_ltrace(struct ltrace_softc *bus, int busunit)
+{
+	(void)bus; (void)busunit;
+}
+
+void
+pseudoconfig(void)
+{
+	{
+		struct pseudorand_softc *s;
+		
+		s = pseudoattach_pseudorand(0);
+		if (s!=NULL) {
+			kprintf("pseudorand0 (virtual)\n");
+			autoconf_pseudorand(s, 0);
+		}
+	}
+}
+
diff --git a/kern/compile/ASST1/autoconf.h b/kern/compile/ASST1/autoconf.h
new file mode 100644
index 0000000..13ab76c
--- /dev/null
+++ b/kern/compile/ASST1/autoconf.h
@@ -0,0 +1,48 @@
+/* Automatically generated; do not edit */
+#ifndef _AUTOCONF_H_
+#define _AUTOCONF_H_
+
+struct lamebus_softc;
+struct emu_softc;
+struct ltrace_softc;
+struct ltimer_softc;
+struct lrandom_softc;
+struct lhd_softc;
+struct lser_softc;
+struct beep_softc;
+struct con_softc;
+struct rtclock_softc;
+struct random_softc;
+struct pseudorand_softc;
+struct random_softc;
+
+void autoconf_lamebus(struct lamebus_softc *dev, int unit);
+
+struct emu_softc *attach_emu_to_lamebus(int devunit, struct lamebus_softc *bus);
+struct ltrace_softc *attach_ltrace_to_lamebus(int devunit, struct lamebus_softc *bus);
+struct ltimer_softc *attach_ltimer_to_lamebus(int devunit, struct lamebus_softc *bus);
+struct lrandom_softc *attach_lrandom_to_lamebus(int devunit, struct lamebus_softc *bus);
+struct lhd_softc *attach_lhd_to_lamebus(int devunit, struct lamebus_softc *bus);
+struct lser_softc *attach_lser_to_lamebus(int devunit, struct lamebus_softc *bus);
+struct beep_softc *attach_beep_to_ltimer(int devunit, struct ltimer_softc *bus);
+struct con_softc *attach_con_to_lser(int devunit, struct lser_softc *bus);
+struct rtclock_softc *attach_rtclock_to_ltimer(int devunit, struct ltimer_softc *bus);
+struct random_softc *attach_random_to_lrandom(int devunit, struct lrandom_softc *bus);
+struct pseudorand_softc *pseudoattach_pseudorand(int devunit);
+struct random_softc *attach_random_to_pseudorand(int devunit, struct pseudorand_softc *bus);
+
+int config_emu(struct emu_softc *dev, int unit);
+int config_ltrace(struct ltrace_softc *dev, int unit);
+int config_ltimer(struct ltimer_softc *dev, int unit);
+int config_lrandom(struct lrandom_softc *dev, int unit);
+int config_lhd(struct lhd_softc *dev, int unit);
+int config_lser(struct lser_softc *dev, int unit);
+int config_beep(struct beep_softc *dev, int unit);
+int config_con(struct con_softc *dev, int unit);
+int config_rtclock(struct rtclock_softc *dev, int unit);
+int config_random(struct random_softc *dev, int unit);
+int config_random(struct random_softc *dev, int unit);
+
+void pseudoconfig(void);
+
+#endif /* _AUTOCONF_H_ */
diff --git a/kern/compile/ASST1/autoconf.o b/kern/compile/ASST1/autoconf.o
new file mode 100644
index 0000000..30b97b7
Binary files /dev/null and b/kern/compile/ASST1/autoconf.o differ
diff --git a/kern/compile/ASST1/beep.o b/kern/compile/ASST1/beep.o
new file mode 100644
index 0000000..706d627
Binary files /dev/null and b/kern/compile/ASST1/beep.o differ
diff --git a/kern/compile/ASST1/beep_ltimer.o b/kern/compile/ASST1/beep_ltimer.o
new file mode 100644
index 0000000..df5deda
Binary files /dev/null and b/kern/compile/ASST1/beep_ltimer.o differ
diff --git a/kern/compile/ASST1/bitmap.o b/kern/compile/ASST1/bitmap.o
new file mode 100644
index 0000000..22436a9
Binary files /dev/null and b/kern/compile/ASST1/bitmap.o differ
diff --git a/kern/compile/ASST1/bitmaptest.o b/kern/compile/ASST1/bitmaptest.o
new file mode 100644
index 0000000..bac1f3f
Binary files /dev/null and b/kern/compile/ASST1/bitmaptest.o differ
diff --git a/kern/compile/ASST1/bzero.o b/kern/compile/ASST1/bzero.o
new file mode 100644
index 0000000..61c19c4
Binary files /dev/null and b/kern/compile/ASST1/bzero.o differ
diff --git a/kern/compile/ASST1/cache_mips1.o b/kern/compile/ASST1/cache_mips1.o
new file mode 100644
index 0000000..4dd3394
Binary files /dev/null and b/kern/compile/ASST1/cache_mips1.o differ
diff --git a/kern/compile/ASST1/catlock.o b/kern/compile/ASST1/catlock.o
new file mode 100644
index 0000000..59e0339
Binary files /dev/null and b/kern/compile/ASST1/catlock.o differ
diff --git a/kern/compile/ASST1/catsem.o b/kern/compile/ASST1/catsem.o
new file mode 100644
index 0000000..9efb842
Binary files /dev/null and b/kern/compile/ASST1/catsem.o differ
diff --git a/kern/compile/ASST1/con_lser.o b/kern/compile/ASST1/con_lser.o
new file mode 100644
index 0000000..847b946
Binary files /dev/null and b/kern/compile/ASST1/con_lser.o differ
diff --git a/kern/compile/ASST1/console.o b/kern/compile/ASST1/console.o
new file mode 100644
index 0000000..9c831fe
Binary files /dev/null and b/kern/compile/ASST1/console.o differ
diff --git a/kern/compile/ASST1/copyinout.o b/kern/compile/ASST1/copyinout.o
new file mode 100644
index 0000000..07fceef
Binary files /dev/null and b/kern/compile/ASST1/copyinout.o differ
diff --git a/kern/compile/ASST1/defs.mk b/kern/compile/ASST1/defs.mk
new file mode 100644
index 0000000..09db3ea
--- /dev/null
+++ b/kern/compile/ASST1/defs.mk
@@ -0,0 +1,5 @@
+# Automatically generated by config; do not edit
+S=../..
+ARCH=mips
+DEBUGFLAGS=-g
+CONFNAME=ASST1
diff --git a/kern/compile/ASST1/depend.mk b/kern/compile/ASST1/depend.mk
new file mode 100644
index 0000000..3861979
--- /dev/null
+++ b/kern/compile/ASST1/depend.mk
@@ -0,0 +1,357 @@
+console.o: ../../dev/generic/console.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h machine/spl.h \
+  ../../include/synch.h ../../dev/generic/console.h ../../include/dev.h \
+  ../../include/vfs.h ../../include/uio.h autoconf.h
+emu.o: ../../dev/lamebus/emu.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/kern/unistd.h ../../include/kern/stat.h \
+  ../../include/lib.h machine/setjmp.h ../../include/synch.h \
+  ../../include/array.h ../../include/uio.h ../../include/vfs.h \
+  ../../include/emufs.h ../../include/vnode.h ../../include/fs.h \
+  ../../dev/lamebus/emu.h machine/bus.h machine/vm.h \
+  ../../dev/lamebus/lamebus.h autoconf.h
+lser.o: ../../dev/lamebus/lser.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  machine/spl.h machine/bus.h machine/vm.h ../../dev/lamebus/lamebus.h \
+  ../../dev/lamebus/lser.h autoconf.h
+lhd.o: ../../dev/lamebus/lhd.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/synch.h ../../include/kern/errno.h machine/bus.h \
+  machine/vm.h ../../dev/lamebus/lamebus.h ../../include/uio.h \
+  ../../include/vfs.h ../../dev/lamebus/lhd.h ../../include/dev.h \
+  autoconf.h
+pseudorand.o: ../../dev/generic/pseudorand.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/uio.h ../../dev/generic/pseudorand.h \
+  autoconf.h
+random.o: ../../dev/generic/random.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/kern/unistd.h ../../include/lib.h machine/setjmp.h \
+  ../../include/uio.h ../../include/vfs.h ../../dev/generic/random.h \
+  ../../include/dev.h autoconf.h
+ltimer.o: ../../dev/lamebus/ltimer.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/clock.h opt-synchprobs.h machine/bus.h \
+  machine/vm.h ../../dev/lamebus/lamebus.h ../../dev/lamebus/ltimer.h \
+  autoconf.h
+lamebus.o: ../../dev/lamebus/lamebus.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h machine/spl.h ../../dev/lamebus/lamebus.h
+lrandom.o: ../../dev/lamebus/lrandom.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/uio.h machine/bus.h machine/vm.h \
+  ../../dev/lamebus/lamebus.h ../../dev/lamebus/lrandom.h autoconf.h
+beep.o: ../../dev/generic/beep.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../dev/generic/beep.h \
+  autoconf.h
+ltrace.o: ../../dev/lamebus/ltrace.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h machine/bus.h machine/vm.h ../../dev/lamebus/lamebus.h \
+  ../../dev/lamebus/ltrace.h autoconf.h
+rtclock.o: ../../dev/generic/rtclock.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../include/clock.h \
+  opt-synchprobs.h ../../dev/generic/rtclock.h autoconf.h
+ltimer_att.o: ../../dev/lamebus/ltimer_att.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../dev/lamebus/lamebus.h ../../dev/lamebus/ltimer.h \
+  autoconf.h
+con_lser.o: ../../dev/lamebus/con_lser.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../dev/generic/console.h ../../dev/lamebus/lser.h \
+  autoconf.h
+lhd_att.o: ../../dev/lamebus/lhd_att.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../dev/lamebus/lamebus.h ../../dev/lamebus/lhd.h \
+  ../../include/dev.h autoconf.h
+random_lrandom.o: ../../dev/lamebus/random_lrandom.c \
+  ../../include/types.h machine/types.h ../../include/kern/types.h \
+  ../../include/lib.h machine/setjmp.h ../../dev/generic/random.h \
+  ../../include/dev.h ../../dev/lamebus/lrandom.h autoconf.h
+rtclock_ltimer.o: ../../dev/lamebus/rtclock_ltimer.c \
+  ../../include/types.h machine/types.h ../../include/kern/types.h \
+  ../../include/lib.h machine/setjmp.h ../../dev/generic/rtclock.h \
+  ../../dev/lamebus/ltimer.h autoconf.h
+ltrace_att.o: ../../dev/lamebus/ltrace_att.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../dev/lamebus/lamebus.h ../../dev/lamebus/ltrace.h \
+  autoconf.h
+lser_att.o: ../../dev/lamebus/lser_att.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../dev/lamebus/lamebus.h ../../dev/lamebus/lser.h \
+  autoconf.h
+lrandom_att.o: ../../dev/lamebus/lrandom_att.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../dev/lamebus/lamebus.h \
+  ../../dev/lamebus/lrandom.h autoconf.h
+emu_att.o: ../../dev/lamebus/emu_att.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../dev/lamebus/lamebus.h ../../dev/lamebus/emu.h \
+  autoconf.h
+beep_ltimer.o: ../../dev/lamebus/beep_ltimer.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../dev/generic/beep.h ../../dev/lamebus/ltimer.h \
+  autoconf.h
+pseudorand_att.o: ../../dev/generic/pseudorand_att.c \
+  ../../include/types.h machine/types.h ../../include/kern/types.h \
+  ../../include/lib.h machine/setjmp.h ../../dev/generic/random.h \
+  ../../include/dev.h ../../dev/generic/pseudorand.h autoconf.h
+catlock.o: ../../asst1/catlock.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/test.h ../../include/thread.h machine/pcb.h
+catsem.o: ../../asst1/catsem.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/test.h ../../include/thread.h machine/pcb.h
+sfs_vnode.o: ../../fs/sfs/sfs_vnode.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/synch.h ../../include/array.h \
+  ../../include/bitmap.h ../../include/kern/stat.h \
+  ../../include/kern/errno.h ../../include/kern/unistd.h \
+  ../../include/uio.h ../../include/dev.h ../../include/sfs.h \
+  ../../include/vnode.h ../../include/fs.h ../../include/kern/sfs.h
+sfs_fs.o: ../../fs/sfs/sfs_fs.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/kern/errno.h ../../include/array.h ../../include/bitmap.h \
+  ../../include/uio.h ../../include/dev.h ../../include/sfs.h \
+  ../../include/vnode.h ../../include/fs.h ../../include/kern/sfs.h \
+  ../../include/vfs.h
+dumbvm.o: ../../arch/mips/mips/dumbvm.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../include/thread.h \
+  machine/pcb.h ../../include/curthread.h ../../include/addrspace.h \
+  ../../include/vm.h machine/vm.h opt-dumbvm.h machine/spl.h \
+  machine/tlb.h
+stoplight.o: ../../asst1/stoplight.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/test.h ../../include/thread.h \
+  machine/pcb.h
+sfs_io.o: ../../fs/sfs/sfs_io.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../include/uio.h \
+  ../../include/sfs.h ../../include/vnode.h ../../include/fs.h \
+  ../../include/kern/sfs.h ../../include/dev.h
+cache_mips1.o: ../../arch/mips/mips/cache_mips1.S machine/asmdefs.h
+exception.o: ../../arch/mips/mips/exception.S machine/asmdefs.h \
+  machine/specialreg.h
+lamebus_mips.o: ../../arch/mips/mips/lamebus_mips.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/kern/unistd.h \
+  ../../include/lib.h machine/setjmp.h ../../include/synch.h \
+  machine/spl.h machine/pcb.h ../../include/dev.h machine/bus.h \
+  machine/vm.h ../../dev/lamebus/lamebus.h autoconf.h
+interrupt.o: ../../arch/mips/mips/interrupt.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h machine/bus.h machine/vm.h ../../dev/lamebus/lamebus.h \
+  machine/spl.h machine/pcb.h
+pcb.o: ../../arch/mips/mips/pcb.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  machine/pcb.h machine/spl.h machine/switchframe.h \
+  ../../include/thread.h
+ram.o: ../../arch/mips/mips/ram.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/vm.h machine/vm.h machine/pcb.h
+spl.o: ../../arch/mips/mips/spl.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  machine/spl.h machine/specialreg.h
+start.o: ../../arch/mips/mips/start.S machine/asmdefs.h \
+  machine/specialreg.h
+switch.o: ../../arch/mips/mips/switch.S machine/asmdefs.h
+syscall.o: ../../arch/mips/mips/syscall.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h machine/pcb.h machine/spl.h \
+  machine/trapframe.h ../../include/kern/callno.h ../../include/syscall.h
+threadstart.o: ../../arch/mips/mips/threadstart.S machine/asmdefs.h
+trap.o: ../../arch/mips/mips/trap.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  machine/trapframe.h machine/specialreg.h machine/pcb.h machine/spl.h \
+  ../../include/vm.h machine/vm.h ../../include/thread.h \
+  ../../include/curthread.h
+tlb_mips1.o: ../../arch/mips/mips/tlb_mips1.S machine/asmdefs.h \
+  machine/specialreg.h
+mips-setjmp.o: ../../../lib/libc/mips-setjmp.S machine/asmdefs.h
+copyinout.o: ../../lib/copyinout.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h machine/pcb.h ../../include/vm.h \
+  machine/vm.h ../../include/thread.h ../../include/curthread.h
+array.o: ../../lib/array.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../include/array.h
+bitmap.o: ../../lib/bitmap.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/kern/errno.h ../../include/bitmap.h
+queue.o: ../../lib/queue.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../include/queue.h
+kheap.o: ../../lib/kheap.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/vm.h machine/vm.h machine/spl.h
+kprintf.o: ../../lib/kprintf.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/stdarg.h ../../include/lib.h \
+  machine/setjmp.h ../../include/kern/unistd.h ../../include/synch.h \
+  ../../include/vfs.h ../../include/thread.h machine/pcb.h machine/spl.h
+kgets.o: ../../lib/kgets.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h
+misc.o: ../../lib/misc.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errmsg.h \
+  ../../include/lib.h machine/setjmp.h
+ntoh.o: ../../lib/ntoh.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h
+__printf.o: ../../../lib/libc/__printf.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/stdarg.h
+snprintf.o: ../../../lib/libc/snprintf.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/stdarg.h
+atoi.o: ../../../lib/libc/atoi.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h
+bzero.o: ../../../lib/libc/bzero.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h
+memcpy.o: ../../../lib/libc/memcpy.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+memmove.o: ../../../lib/libc/memmove.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+strcat.o: ../../../lib/libc/strcat.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+strchr.o: ../../../lib/libc/strchr.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+strcmp.o: ../../../lib/libc/strcmp.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+strcpy.o: ../../../lib/libc/strcpy.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+strlen.o: ../../../lib/libc/strlen.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+strrchr.o: ../../../lib/libc/strrchr.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+strtok_r.o: ../../../lib/libc/strtok_r.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h
+init.o: ../../dev/init.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  machine/spl.h ../../include/dev.h autoconf.h
+device.o: ../../fs/vfs/device.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/synch.h ../../include/kern/errno.h \
+  ../../include/kern/unistd.h ../../include/kern/stat.h \
+  ../../include/vnode.h ../../include/uio.h ../../include/dev.h
+vfscwd.o: ../../fs/vfs/vfscwd.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/synch.h ../../include/kern/errno.h \
+  ../../include/kern/stat.h ../../include/vfs.h ../../include/fs.h \
+  ../../include/vnode.h ../../include/uio.h ../../include/thread.h \
+  machine/pcb.h ../../include/curthread.h
+vfslist.o: ../../fs/vfs/vfslist.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/synch.h ../../include/array.h ../../include/kern/errno.h \
+  ../../include/vfs.h ../../include/vnode.h ../../include/fs.h \
+  ../../include/dev.h
+vfslookup.o: ../../fs/vfs/vfslookup.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/kern/limits.h ../../include/lib.h machine/setjmp.h \
+  ../../include/synch.h ../../include/vfs.h ../../include/vnode.h \
+  ../../include/fs.h
+vfspath.o: ../../fs/vfs/vfspath.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/kern/limits.h ../../include/kern/unistd.h \
+  ../../include/vfs.h ../../include/vnode.h ../../include/lib.h \
+  machine/setjmp.h
+vnode.o: ../../fs/vfs/vnode.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../include/synch.h \
+  ../../include/vnode.h
+devnull.o: ../../fs/vfs/devnull.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../include/vfs.h \
+  ../../include/dev.h ../../include/uio.h
+hardclock.o: ../../thread/hardclock.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h machine/spl.h ../../include/thread.h machine/pcb.h \
+  ../../include/clock.h opt-synchprobs.h
+synch.o: ../../thread/synch.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/synch.h ../../include/thread.h machine/pcb.h \
+  ../../include/curthread.h machine/spl.h
+scheduler.o: ../../thread/scheduler.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/scheduler.h ../../include/thread.h \
+  machine/pcb.h machine/spl.h ../../include/queue.h
+thread.o: ../../thread/thread.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/kern/errno.h ../../include/array.h machine/spl.h \
+  machine/pcb.h ../../include/thread.h ../../include/curthread.h \
+  ../../include/scheduler.h ../../include/addrspace.h ../../include/vm.h \
+  machine/vm.h opt-dumbvm.h ../../include/vnode.h opt-synchprobs.h
+main.o: ../../main/main.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/kern/unistd.h ../../include/lib.h machine/setjmp.h \
+  machine/spl.h ../../include/test.h ../../include/synch.h \
+  ../../include/thread.h machine/pcb.h ../../include/scheduler.h \
+  ../../include/dev.h ../../include/vfs.h ../../include/vm.h machine/vm.h \
+  ../../include/syscall.h ../../include/version.h
+menu.o: ../../main/menu.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/kern/unistd.h ../../include/kern/limits.h \
+  ../../include/lib.h machine/setjmp.h ../../include/clock.h \
+  opt-synchprobs.h ../../include/thread.h machine/pcb.h \
+  ../../include/syscall.h ../../include/uio.h ../../include/vfs.h \
+  ../../include/sfs.h ../../include/vnode.h ../../include/fs.h \
+  ../../include/kern/sfs.h ../../include/test.h opt-synchprobs.h \
+  opt-sfs.h opt-net.h
+loadelf.o: ../../userprog/loadelf.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/lib.h machine/setjmp.h ../../include/uio.h \
+  ../../include/elf.h ../../include/addrspace.h ../../include/vm.h \
+  machine/vm.h opt-dumbvm.h ../../include/thread.h machine/pcb.h \
+  ../../include/curthread.h ../../include/vnode.h
+runprogram.o: ../../userprog/runprogram.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/kern/unistd.h \
+  ../../include/kern/errno.h ../../include/lib.h machine/setjmp.h \
+  ../../include/addrspace.h ../../include/vm.h machine/vm.h opt-dumbvm.h \
+  ../../include/thread.h machine/pcb.h ../../include/curthread.h \
+  ../../include/vfs.h ../../include/test.h
+uio.o: ../../userprog/uio.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/uio.h ../../include/thread.h machine/pcb.h \
+  ../../include/curthread.h
+arraytest.o: ../../test/arraytest.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/array.h ../../include/test.h
+bitmaptest.o: ../../test/bitmaptest.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/bitmap.h ../../include/test.h
+queuetest.o: ../../test/queuetest.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/queue.h ../../include/test.h
+threadtest.o: ../../test/threadtest.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/synch.h ../../include/thread.h \
+  machine/pcb.h ../../include/test.h
+tt3.o: ../../test/tt3.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  machine/spl.h ../../include/synch.h ../../include/thread.h \
+  machine/pcb.h ../../include/test.h opt-synchprobs.h
+synchtest.o: ../../test/synchtest.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/lib.h machine/setjmp.h \
+  ../../include/synch.h ../../include/thread.h machine/pcb.h \
+  ../../include/test.h ../../include/clock.h opt-synchprobs.h
+malloctest.o: ../../test/malloctest.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../include/synch.h ../../include/thread.h \
+  machine/pcb.h ../../include/test.h
+fstest.o: ../../test/fstest.c ../../include/types.h machine/types.h \
+  ../../include/kern/types.h ../../include/kern/errno.h \
+  ../../include/kern/unistd.h ../../include/lib.h machine/setjmp.h \
+  ../../include/synch.h ../../include/fs.h ../../include/vnode.h \
+  ../../include/vfs.h ../../include/uio.h ../../include/test.h \
+  ../../include/thread.h machine/pcb.h
+autoconf.o: ../../compile/ASST1/autoconf.c ../../include/types.h \
+  machine/types.h ../../include/kern/types.h ../../include/lib.h \
+  machine/setjmp.h ../../compile/ASST1/autoconf.h
diff --git a/kern/compile/ASST1/device.o b/kern/compile/ASST1/device.o
new file mode 100644
index 0000000..10a1746
Binary files /dev/null and b/kern/compile/ASST1/device.o differ
diff --git a/kern/compile/ASST1/devnull.o b/kern/compile/ASST1/devnull.o
new file mode 100644
index 0000000..08fa2d3
Binary files /dev/null and b/kern/compile/ASST1/devnull.o differ
diff --git a/kern/compile/ASST1/dumbvm.o b/kern/compile/ASST1/dumbvm.o
new file mode 100644
index 0000000..bdee2da
Binary files /dev/null and b/kern/compile/ASST1/dumbvm.o differ
diff --git a/kern/compile/ASST1/emu.o b/kern/compile/ASST1/emu.o
new file mode 100644
index 0000000..79f2fba
Binary files /dev/null and b/kern/compile/ASST1/emu.o differ
diff --git a/kern/compile/ASST1/emu_att.o b/kern/compile/ASST1/emu_att.o
new file mode 100644
index 0000000..5366d49
Binary files /dev/null and b/kern/compile/ASST1/emu_att.o differ
diff --git a/kern/compile/ASST1/exception.o b/kern/compile/ASST1/exception.o
new file mode 100644
index 0000000..53b6d6a
Binary files /dev/null and b/kern/compile/ASST1/exception.o differ
diff --git a/kern/compile/ASST1/files.mk b/kern/compile/ASST1/files.mk
new file mode 100644
index 0000000..8a8ce3a
--- /dev/null
+++ b/kern/compile/ASST1/files.mk
@@ -0,0 +1,461 @@
+# Automatically generated by config; do not edit
+console.o: ${S}/dev/generic/console.c
+	${COMPILE.c} ${S}/dev/generic/console.c
+SRCS+=${S}/dev/generic/console.c
+OBJS+=console.o
+
+emu.o: ${S}/dev/lamebus/emu.c
+	${COMPILE.c} ${S}/dev/lamebus/emu.c
+SRCS+=${S}/dev/lamebus/emu.c
+OBJS+=emu.o
+
+lser.o: ${S}/dev/lamebus/lser.c
+	${COMPILE.c} ${S}/dev/lamebus/lser.c
+SRCS+=${S}/dev/lamebus/lser.c
+OBJS+=lser.o
+
+lhd.o: ${S}/dev/lamebus/lhd.c
+	${COMPILE.c} ${S}/dev/lamebus/lhd.c
+SRCS+=${S}/dev/lamebus/lhd.c
+OBJS+=lhd.o
+
+pseudorand.o: ${S}/dev/generic/pseudorand.c
+	${COMPILE.c} ${S}/dev/generic/pseudorand.c
+SRCS+=${S}/dev/generic/pseudorand.c
+OBJS+=pseudorand.o
+
+random.o: ${S}/dev/generic/random.c
+	${COMPILE.c} ${S}/dev/generic/random.c
+SRCS+=${S}/dev/generic/random.c
+OBJS+=random.o
+
+ltimer.o: ${S}/dev/lamebus/ltimer.c
+	${COMPILE.c} ${S}/dev/lamebus/ltimer.c
+SRCS+=${S}/dev/lamebus/ltimer.c
+OBJS+=ltimer.o
+
+lamebus.o: ${S}/dev/lamebus/lamebus.c
+	${COMPILE.c} ${S}/dev/lamebus/lamebus.c
+SRCS+=${S}/dev/lamebus/lamebus.c
+OBJS+=lamebus.o
+
+lrandom.o: ${S}/dev/lamebus/lrandom.c
+	${COMPILE.c} ${S}/dev/lamebus/lrandom.c
+SRCS+=${S}/dev/lamebus/lrandom.c
+OBJS+=lrandom.o
+
+beep.o: ${S}/dev/generic/beep.c
+	${COMPILE.c} ${S}/dev/generic/beep.c
+SRCS+=${S}/dev/generic/beep.c
+OBJS+=beep.o
+
+ltrace.o: ${S}/dev/lamebus/ltrace.c
+	${COMPILE.c} ${S}/dev/lamebus/ltrace.c
+SRCS+=${S}/dev/lamebus/ltrace.c
+OBJS+=ltrace.o
+
+rtclock.o: ${S}/dev/generic/rtclock.c
+	${COMPILE.c} ${S}/dev/generic/rtclock.c
+SRCS+=${S}/dev/generic/rtclock.c
+OBJS+=rtclock.o
+
+ltimer_att.o: ${S}/dev/lamebus/ltimer_att.c
+	${COMPILE.c} ${S}/dev/lamebus/ltimer_att.c
+SRCS+=${S}/dev/lamebus/ltimer_att.c
+OBJS+=ltimer_att.o
+
+con_lser.o: ${S}/dev/lamebus/con_lser.c
+	${COMPILE.c} ${S}/dev/lamebus/con_lser.c
+SRCS+=${S}/dev/lamebus/con_lser.c
+OBJS+=con_lser.o
+
+lhd_att.o: ${S}/dev/lamebus/lhd_att.c
+	${COMPILE.c} ${S}/dev/lamebus/lhd_att.c
+SRCS+=${S}/dev/lamebus/lhd_att.c
+OBJS+=lhd_att.o
+
+random_lrandom.o: ${S}/dev/lamebus/random_lrandom.c
+	${COMPILE.c} ${S}/dev/lamebus/random_lrandom.c
+SRCS+=${S}/dev/lamebus/random_lrandom.c
+OBJS+=random_lrandom.o
+
+rtclock_ltimer.o: ${S}/dev/lamebus/rtclock_ltimer.c
+	${COMPILE.c} ${S}/dev/lamebus/rtclock_ltimer.c
+SRCS+=${S}/dev/lamebus/rtclock_ltimer.c
+OBJS+=rtclock_ltimer.o
+
+ltrace_att.o: ${S}/dev/lamebus/ltrace_att.c
+	${COMPILE.c} ${S}/dev/lamebus/ltrace_att.c
+SRCS+=${S}/dev/lamebus/ltrace_att.c
+OBJS+=ltrace_att.o
+
+lser_att.o: ${S}/dev/lamebus/lser_att.c
+	${COMPILE.c} ${S}/dev/lamebus/lser_att.c
+SRCS+=${S}/dev/lamebus/lser_att.c
+OBJS+=lser_att.o
+
+lrandom_att.o: ${S}/dev/lamebus/lrandom_att.c
+	${COMPILE.c} ${S}/dev/lamebus/lrandom_att.c
+SRCS+=${S}/dev/lamebus/lrandom_att.c
+OBJS+=lrandom_att.o
+
+emu_att.o: ${S}/dev/lamebus/emu_att.c
+	${COMPILE.c} ${S}/dev/lamebus/emu_att.c
+SRCS+=${S}/dev/lamebus/emu_att.c
+OBJS+=emu_att.o
+
+beep_ltimer.o: ${S}/dev/lamebus/beep_ltimer.c
+	${COMPILE.c} ${S}/dev/lamebus/beep_ltimer.c
+SRCS+=${S}/dev/lamebus/beep_ltimer.c
+OBJS+=beep_ltimer.o
+
+pseudorand_att.o: ${S}/dev/generic/pseudorand_att.c
+	${COMPILE.c} ${S}/dev/generic/pseudorand_att.c
+SRCS+=${S}/dev/generic/pseudorand_att.c
+OBJS+=pseudorand_att.o
+
+catlock.o: ${S}/asst1/catlock.c
+	${COMPILE.c} ${S}/asst1/catlock.c
+SRCS+=${S}/asst1/catlock.c
+OBJS+=catlock.o
+
+catsem.o: ${S}/asst1/catsem.c
+	${COMPILE.c} ${S}/asst1/catsem.c
+SRCS+=${S}/asst1/catsem.c
+OBJS+=catsem.o
+
+sfs_vnode.o: ${S}/fs/sfs/sfs_vnode.c
+	${COMPILE.c} ${S}/fs/sfs/sfs_vnode.c
+SRCS+=${S}/fs/sfs/sfs_vnode.c
+OBJS+=sfs_vnode.o
+
+sfs_fs.o: ${S}/fs/sfs/sfs_fs.c
+	${COMPILE.c} ${S}/fs/sfs/sfs_fs.c
+SRCS+=${S}/fs/sfs/sfs_fs.c
+OBJS+=sfs_fs.o
+
+dumbvm.o: ${S}/arch/mips/mips/dumbvm.c
+	${COMPILE.c} ${S}/arch/mips/mips/dumbvm.c
+SRCS+=${S}/arch/mips/mips/dumbvm.c
+OBJS+=dumbvm.o
+
+stoplight.o: ${S}/asst1/stoplight.c
+	${COMPILE.c} ${S}/asst1/stoplight.c
+SRCS+=${S}/asst1/stoplight.c
+OBJS+=stoplight.o
+
+sfs_io.o: ${S}/fs/sfs/sfs_io.c
+	${COMPILE.c} ${S}/fs/sfs/sfs_io.c
+SRCS+=${S}/fs/sfs/sfs_io.c
+OBJS+=sfs_io.o
+
+cache_mips1.o: ${S}/arch/mips/mips/cache_mips1.S
+	${COMPILE.S} ${S}/arch/mips/mips/cache_mips1.S
+SRCS+=${S}/arch/mips/mips/cache_mips1.S
+OBJS+=cache_mips1.o
+
+exception.o: ${S}/arch/mips/mips/exception.S
+	${COMPILE.S} ${S}/arch/mips/mips/exception.S
+SRCS+=${S}/arch/mips/mips/exception.S
+OBJS+=exception.o
+
+lamebus_mips.o: ${S}/arch/mips/mips/lamebus_mips.c
+	${COMPILE.c} ${S}/arch/mips/mips/lamebus_mips.c
+SRCS+=${S}/arch/mips/mips/lamebus_mips.c
+OBJS+=lamebus_mips.o
+
+interrupt.o: ${S}/arch/mips/mips/interrupt.c
+	${COMPILE.c} ${S}/arch/mips/mips/interrupt.c
+SRCS+=${S}/arch/mips/mips/interrupt.c
+OBJS+=interrupt.o
+
+pcb.o: ${S}/arch/mips/mips/pcb.c
+	${COMPILE.c} ${S}/arch/mips/mips/pcb.c
+SRCS+=${S}/arch/mips/mips/pcb.c
+OBJS+=pcb.o
+
+ram.o: ${S}/arch/mips/mips/ram.c
+	${COMPILE.c} ${S}/arch/mips/mips/ram.c
+SRCS+=${S}/arch/mips/mips/ram.c
+OBJS+=ram.o
+
+spl.o: ${S}/arch/mips/mips/spl.c
+	${COMPILE.c} ${S}/arch/mips/mips/spl.c
+SRCS+=${S}/arch/mips/mips/spl.c
+OBJS+=spl.o
+
+start.o: ${S}/arch/mips/mips/start.S
+	${COMPILE.S} ${S}/arch/mips/mips/start.S
+SRCS+=${S}/arch/mips/mips/start.S
+OBJS+=start.o
+
+switch.o: ${S}/arch/mips/mips/switch.S
+	${COMPILE.S} ${S}/arch/mips/mips/switch.S
+SRCS+=${S}/arch/mips/mips/switch.S
+OBJS+=switch.o
+
+syscall.o: ${S}/arch/mips/mips/syscall.c
+	${COMPILE.c} ${S}/arch/mips/mips/syscall.c
+SRCS+=${S}/arch/mips/mips/syscall.c
+OBJS+=syscall.o
+
+threadstart.o: ${S}/arch/mips/mips/threadstart.S
+	${COMPILE.S} ${S}/arch/mips/mips/threadstart.S
+SRCS+=${S}/arch/mips/mips/threadstart.S
+OBJS+=threadstart.o
+
+trap.o: ${S}/arch/mips/mips/trap.c
+	${COMPILE.c} ${S}/arch/mips/mips/trap.c
+SRCS+=${S}/arch/mips/mips/trap.c
+OBJS+=trap.o
+
+tlb_mips1.o: ${S}/arch/mips/mips/tlb_mips1.S
+	${COMPILE.S} ${S}/arch/mips/mips/tlb_mips1.S
+SRCS+=${S}/arch/mips/mips/tlb_mips1.S
+OBJS+=tlb_mips1.o
+
+mips-setjmp.o: ${S}/../lib/libc/mips-setjmp.S
+	${COMPILE.S} ${S}/../lib/libc/mips-setjmp.S
+SRCS+=${S}/../lib/libc/mips-setjmp.S
+OBJS+=mips-setjmp.o
+
+copyinout.o: ${S}/lib/copyinout.c
+	${COMPILE.c} ${S}/lib/copyinout.c
+SRCS+=${S}/lib/copyinout.c
+OBJS+=copyinout.o
+
+array.o: ${S}/lib/array.c
+	${COMPILE.c} ${S}/lib/array.c
+SRCS+=${S}/lib/array.c
+OBJS+=array.o
+
+bitmap.o: ${S}/lib/bitmap.c
+	${COMPILE.c} ${S}/lib/bitmap.c
+SRCS+=${S}/lib/bitmap.c
+OBJS+=bitmap.o
+
+queue.o: ${S}/lib/queue.c
+	${COMPILE.c} ${S}/lib/queue.c
+SRCS+=${S}/lib/queue.c
+OBJS+=queue.o
+
+kheap.o: ${S}/lib/kheap.c
+	${COMPILE.c} ${S}/lib/kheap.c
+SRCS+=${S}/lib/kheap.c
+OBJS+=kheap.o
+
+kprintf.o: ${S}/lib/kprintf.c
+	${COMPILE.c} ${S}/lib/kprintf.c
+SRCS+=${S}/lib/kprintf.c
+OBJS+=kprintf.o
+
+kgets.o: ${S}/lib/kgets.c
+	${COMPILE.c} ${S}/lib/kgets.c
+SRCS+=${S}/lib/kgets.c
+OBJS+=kgets.o
+
+misc.o: ${S}/lib/misc.c
+	${COMPILE.c} ${S}/lib/misc.c
+SRCS+=${S}/lib/misc.c
+OBJS+=misc.o
+
+ntoh.o: ${S}/lib/ntoh.c
+	${COMPILE.c} ${S}/lib/ntoh.c
+SRCS+=${S}/lib/ntoh.c
+OBJS+=ntoh.o
+
+__printf.o: ${S}/../lib/libc/__printf.c
+	${COMPILE.c} ${S}/../lib/libc/__printf.c
+SRCS+=${S}/../lib/libc/__printf.c
+OBJS+=__printf.o
+
+snprintf.o: ${S}/../lib/libc/snprintf.c
+	${COMPILE.c} ${S}/../lib/libc/snprintf.c
+SRCS+=${S}/../lib/libc/snprintf.c
+OBJS+=snprintf.o
+
+atoi.o: ${S}/../lib/libc/atoi.c
+	${COMPILE.c} ${S}/../lib/libc/atoi.c
+SRCS+=${S}/../lib/libc/atoi.c
+OBJS+=atoi.o
+
+bzero.o: ${S}/../lib/libc/bzero.c
+	${COMPILE.c} ${S}/../lib/libc/bzero.c
+SRCS+=${S}/../lib/libc/bzero.c
+OBJS+=bzero.o
+
+memcpy.o: ${S}/../lib/libc/memcpy.c
+	${COMPILE.c} ${S}/../lib/libc/memcpy.c
+SRCS+=${S}/../lib/libc/memcpy.c
+OBJS+=memcpy.o
+
+memmove.o: ${S}/../lib/libc/memmove.c
+	${COMPILE.c} ${S}/../lib/libc/memmove.c
+SRCS+=${S}/../lib/libc/memmove.c
+OBJS+=memmove.o
+
+strcat.o: ${S}/../lib/libc/strcat.c
+	${COMPILE.c} ${S}/../lib/libc/strcat.c
+SRCS+=${S}/../lib/libc/strcat.c
+OBJS+=strcat.o
+
+strchr.o: ${S}/../lib/libc/strchr.c
+	${COMPILE.c} ${S}/../lib/libc/strchr.c
+SRCS+=${S}/../lib/libc/strchr.c
+OBJS+=strchr.o
+
+strcmp.o: ${S}/../lib/libc/strcmp.c
+	${COMPILE.c} ${S}/../lib/libc/strcmp.c
+SRCS+=${S}/../lib/libc/strcmp.c
+OBJS+=strcmp.o
+
+strcpy.o: ${S}/../lib/libc/strcpy.c
+	${COMPILE.c} ${S}/../lib/libc/strcpy.c
+SRCS+=${S}/../lib/libc/strcpy.c
+OBJS+=strcpy.o
+
+strlen.o: ${S}/../lib/libc/strlen.c
+	${COMPILE.c} ${S}/../lib/libc/strlen.c
+SRCS+=${S}/../lib/libc/strlen.c
+OBJS+=strlen.o
+
+strrchr.o: ${S}/../lib/libc/strrchr.c
+	${COMPILE.c} ${S}/../lib/libc/strrchr.c
+SRCS+=${S}/../lib/libc/strrchr.c
+OBJS+=strrchr.o
+
+strtok_r.o: ${S}/../lib/libc/strtok_r.c
+	${COMPILE.c} ${S}/../lib/libc/strtok_r.c
+SRCS+=${S}/../lib/libc/strtok_r.c
+OBJS+=strtok_r.o
+
+init.o: ${S}/dev/init.c
+	${COMPILE.c} ${S}/dev/init.c
+SRCS+=${S}/dev/init.c
+OBJS+=init.o
+
+device.o: ${S}/fs/vfs/device.c
+	${COMPILE.c} ${S}/fs/vfs/device.c
+SRCS+=${S}/fs/vfs/device.c
+OBJS+=device.o
+
+vfscwd.o: ${S}/fs/vfs/vfscwd.c
+	${COMPILE.c} ${S}/fs/vfs/vfscwd.c
+SRCS+=${S}/fs/vfs/vfscwd.c
+OBJS+=vfscwd.o
+
+vfslist.o: ${S}/fs/vfs/vfslist.c
+	${COMPILE.c} ${S}/fs/vfs/vfslist.c
+SRCS+=${S}/fs/vfs/vfslist.c
+OBJS+=vfslist.o
+
+vfslookup.o: ${S}/fs/vfs/vfslookup.c
+	${COMPILE.c} ${S}/fs/vfs/vfslookup.c
+SRCS+=${S}/fs/vfs/vfslookup.c
+OBJS+=vfslookup.o
+
+vfspath.o: ${S}/fs/vfs/vfspath.c
+	${COMPILE.c} ${S}/fs/vfs/vfspath.c
+SRCS+=${S}/fs/vfs/vfspath.c
+OBJS+=vfspath.o
+
+vnode.o: ${S}/fs/vfs/vnode.c
+	${COMPILE.c} ${S}/fs/vfs/vnode.c
+SRCS+=${S}/fs/vfs/vnode.c
+OBJS+=vnode.o
+
+devnull.o: ${S}/fs/vfs/devnull.c
+	${COMPILE.c} ${S}/fs/vfs/devnull.c
+SRCS+=${S}/fs/vfs/devnull.c
+OBJS+=devnull.o
+
+hardclock.o: ${S}/thread/hardclock.c
+	${COMPILE.c} ${S}/thread/hardclock.c
+SRCS+=${S}/thread/hardclock.c
+OBJS+=hardclock.o
+
+synch.o: ${S}/thread/synch.c
+	${COMPILE.c} ${S}/thread/synch.c
+SRCS+=${S}/thread/synch.c
+OBJS+=synch.o
+
+scheduler.o: ${S}/thread/scheduler.c
+	${COMPILE.c} ${S}/thread/scheduler.c
+SRCS+=${S}/thread/scheduler.c
+OBJS+=scheduler.o
+
+thread.o: ${S}/thread/thread.c
+	${COMPILE.c} ${S}/thread/thread.c
+SRCS+=${S}/thread/thread.c
+OBJS+=thread.o
+
+main.o: ${S}/main/main.c
+	${COMPILE.c} ${S}/main/main.c
+SRCS+=${S}/main/main.c
+OBJS+=main.o
+
+menu.o: ${S}/main/menu.c
+	${COMPILE.c} ${S}/main/menu.c
+SRCS+=${S}/main/menu.c
+OBJS+=menu.o
+
+loadelf.o: ${S}/userprog/loadelf.c
+	${COMPILE.c} ${S}/userprog/loadelf.c
+SRCS+=${S}/userprog/loadelf.c
+OBJS+=loadelf.o
+
+runprogram.o: ${S}/userprog/runprogram.c
+	${COMPILE.c} ${S}/userprog/runprogram.c
+SRCS+=${S}/userprog/runprogram.c
+OBJS+=runprogram.o
+
+uio.o: ${S}/userprog/uio.c
+	${COMPILE.c} ${S}/userprog/uio.c
+SRCS+=${S}/userprog/uio.c
+OBJS+=uio.o
+
+arraytest.o: ${S}/test/arraytest.c
+	${COMPILE.c} ${S}/test/arraytest.c
+SRCS+=${S}/test/arraytest.c
+OBJS+=arraytest.o
+
+bitmaptest.o: ${S}/test/bitmaptest.c
+	${COMPILE.c} ${S}/test/bitmaptest.c
+SRCS+=${S}/test/bitmaptest.c
+OBJS+=bitmaptest.o
+
+queuetest.o: ${S}/test/queuetest.c
+	${COMPILE.c} ${S}/test/queuetest.c
+SRCS+=${S}/test/queuetest.c
+OBJS+=queuetest.o
+
+threadtest.o: ${S}/test/threadtest.c
+	${COMPILE.c} ${S}/test/threadtest.c
+SRCS+=${S}/test/threadtest.c
+OBJS+=threadtest.o
+
+tt3.o: ${S}/test/tt3.c
+	${COMPILE.c} ${S}/test/tt3.c
+SRCS+=${S}/test/tt3.c
+OBJS+=tt3.o
+
+synchtest.o: ${S}/test/synchtest.c
+	${COMPILE.c} ${S}/test/synchtest.c
+SRCS+=${S}/test/synchtest.c
+OBJS+=synchtest.o
+
+malloctest.o: ${S}/test/malloctest.c
+	${COMPILE.c} ${S}/test/malloctest.c
+SRCS+=${S}/test/malloctest.c
+OBJS+=malloctest.o
+
+fstest.o: ${S}/test/fstest.c
+	${COMPILE.c} ${S}/test/fstest.c
+SRCS+=${S}/test/fstest.c
+OBJS+=fstest.o
+
+autoconf.o: ${S}/compile/ASST1/autoconf.c
+	${COMPILE.c} ${S}/compile/ASST1/autoconf.c
+SRCS+=${S}/compile/ASST1/autoconf.c
+OBJS+=autoconf.o
+
diff --git a/kern/compile/ASST1/fstest.o b/kern/compile/ASST1/fstest.o
new file mode 100644
index 0000000..4283a39
Binary files /dev/null and b/kern/compile/ASST1/fstest.o differ
diff --git a/kern/compile/ASST1/hardclock.o b/kern/compile/ASST1/hardclock.o
new file mode 100644
index 0000000..7f693f7
Binary files /dev/null and b/kern/compile/ASST1/hardclock.o differ
diff --git a/kern/compile/ASST1/init.o b/kern/compile/ASST1/init.o
new file mode 100644
index 0000000..6dac799
Binary files /dev/null and b/kern/compile/ASST1/init.o differ
diff --git a/kern/compile/ASST1/interrupt.o b/kern/compile/ASST1/interrupt.o
new file mode 100644
index 0000000..11a7e40
Binary files /dev/null and b/kern/compile/ASST1/interrupt.o differ
diff --git a/kern/compile/ASST1/kernel b/kern/compile/ASST1/kernel
new file mode 100755
index 0000000..d9e6ad5
Binary files /dev/null and b/kern/compile/ASST1/kernel differ
diff --git a/kern/compile/ASST1/kgets.o b/kern/compile/ASST1/kgets.o
new file mode 100644
index 0000000..1a55f5f
Binary files /dev/null and b/kern/compile/ASST1/kgets.o differ
diff --git a/kern/compile/ASST1/kheap.o b/kern/compile/ASST1/kheap.o
new file mode 100644
index 0000000..533b6dd
Binary files /dev/null and b/kern/compile/ASST1/kheap.o differ
diff --git a/kern/compile/ASST1/kprintf.o b/kern/compile/ASST1/kprintf.o
new file mode 100644
index 0000000..1e4ae9d
Binary files /dev/null and b/kern/compile/ASST1/kprintf.o differ
diff --git a/kern/compile/ASST1/lamebus.o b/kern/compile/ASST1/lamebus.o
new file mode 100644
index 0000000..6cfb323
Binary files /dev/null and b/kern/compile/ASST1/lamebus.o differ
diff --git a/kern/compile/ASST1/lamebus_mips.o b/kern/compile/ASST1/lamebus_mips.o
new file mode 100644
index 0000000..c794ff2
Binary files /dev/null and b/kern/compile/ASST1/lamebus_mips.o differ
diff --git a/kern/compile/ASST1/lhd.o b/kern/compile/ASST1/lhd.o
new file mode 100644
index 0000000..857ebef
Binary files /dev/null and b/kern/compile/ASST1/lhd.o differ
diff --git a/kern/compile/ASST1/lhd_att.o b/kern/compile/ASST1/lhd_att.o
new file mode 100644
index 0000000..e149ebb
Binary files /dev/null and b/kern/compile/ASST1/lhd_att.o differ
diff --git a/kern/compile/ASST1/loadelf.o b/kern/compile/ASST1/loadelf.o
new file mode 100644
index 0000000..bae5c4f
Binary files /dev/null and b/kern/compile/ASST1/loadelf.o differ
diff --git a/kern/compile/ASST1/lrandom.o b/kern/compile/ASST1/lrandom.o
new file mode 100644
index 0000000..c67d541
Binary files /dev/null and b/kern/compile/ASST1/lrandom.o differ
diff --git a/kern/compile/ASST1/lrandom_att.o b/kern/compile/ASST1/lrandom_att.o
new file mode 100644
index 0000000..2584072
Binary files /dev/null and b/kern/compile/ASST1/lrandom_att.o differ
diff --git a/kern/compile/ASST1/lser.o b/kern/compile/ASST1/lser.o
new file mode 100644
index 0000000..43f9440
Binary files /dev/null and b/kern/compile/ASST1/lser.o differ
diff --git a/kern/compile/ASST1/lser_att.o b/kern/compile/ASST1/lser_att.o
new file mode 100644
index 0000000..995bbdd
Binary files /dev/null and b/kern/compile/ASST1/lser_att.o differ
diff --git a/kern/compile/ASST1/ltimer.o b/kern/compile/ASST1/ltimer.o
new file mode 100644
index 0000000..3310566
Binary files /dev/null and b/kern/compile/ASST1/ltimer.o differ
diff --git a/kern/compile/ASST1/ltimer_att.o b/kern/compile/ASST1/ltimer_att.o
new file mode 100644
index 0000000..23c9288
Binary files /dev/null and b/kern/compile/ASST1/ltimer_att.o differ
diff --git a/kern/compile/ASST1/ltrace.o b/kern/compile/ASST1/ltrace.o
new file mode 100644
index 0000000..633c858
Binary files /dev/null and b/kern/compile/ASST1/ltrace.o differ
diff --git a/kern/compile/ASST1/ltrace_att.o b/kern/compile/ASST1/ltrace_att.o
new file mode 100644
index 0000000..78be100
Binary files /dev/null and b/kern/compile/ASST1/ltrace_att.o differ
diff --git a/kern/compile/ASST1/machine b/kern/compile/ASST1/machine
new file mode 120000
index 0000000..c12f325
--- /dev/null
+++ b/kern/compile/ASST1/machine
@@ -0,0 +1 @@
+../../arch/mips/include
\ No newline at end of file
diff --git a/kern/compile/ASST1/main.o b/kern/compile/ASST1/main.o
new file mode 100644
index 0000000..cdbaf8a
Binary files /dev/null and b/kern/compile/ASST1/main.o differ
diff --git a/kern/compile/ASST1/malloctest.o b/kern/compile/ASST1/malloctest.o
new file mode 100644
index 0000000..4af377e
Binary files /dev/null and b/kern/compile/ASST1/malloctest.o differ
diff --git a/kern/compile/ASST1/memcpy.o b/kern/compile/ASST1/memcpy.o
new file mode 100644
index 0000000..c7954bf
Binary files /dev/null and b/kern/compile/ASST1/memcpy.o differ
diff --git a/kern/compile/ASST1/memmove.o b/kern/compile/ASST1/memmove.o
new file mode 100644
index 0000000..d9ec9b6
Binary files /dev/null and b/kern/compile/ASST1/memmove.o differ
diff --git a/kern/compile/ASST1/menu.o b/kern/compile/ASST1/menu.o
new file mode 100644
index 0000000..42a3103
Binary files /dev/null and b/kern/compile/ASST1/menu.o differ
diff --git a/kern/compile/ASST1/mips-setjmp.o b/kern/compile/ASST1/mips-setjmp.o
new file mode 100644
index 0000000..667f50f
Binary files /dev/null and b/kern/compile/ASST1/mips-setjmp.o differ
diff --git a/kern/compile/ASST1/misc.o b/kern/compile/ASST1/misc.o
new file mode 100644
index 0000000..3c47329
Binary files /dev/null and b/kern/compile/ASST1/misc.o differ
diff --git a/kern/compile/ASST1/ntoh.o b/kern/compile/ASST1/ntoh.o
new file mode 100644
index 0000000..a2d2827
Binary files /dev/null and b/kern/compile/ASST1/ntoh.o differ
diff --git a/kern/compile/ASST1/opt-dumbvm.h b/kern/compile/ASST1/opt-dumbvm.h
new file mode 100644
index 0000000..7db9b01
--- /dev/null
+++ b/kern/compile/ASST1/opt-dumbvm.h
@@ -0,0 +1,5 @@
+/* Automatically generated; do not edit */
+#ifndef _OPT_DUMBVM_H_
+#define _OPT_DUMBVM_H_
+#define OPT_DUMBVM 1
+#endif /* _OPT_DUMBVM_H_ */
diff --git a/kern/compile/ASST1/opt-net.h b/kern/compile/ASST1/opt-net.h
new file mode 100644
index 0000000..0340a83
--- /dev/null
+++ b/kern/compile/ASST1/opt-net.h
@@ -0,0 +1,5 @@
+/* Automatically generated; do not edit */
+#ifndef _OPT_NET_H_
+#define _OPT_NET_H_
+#define OPT_NET 0
+#endif /* _OPT_NET_H_ */
diff --git a/kern/compile/ASST1/opt-netfs.h b/kern/compile/ASST1/opt-netfs.h
new file mode 100644
index 0000000..cd21c56
--- /dev/null
+++ b/kern/compile/ASST1/opt-netfs.h
@@ -0,0 +1,5 @@
+/* Automatically generated; do not edit */
+#ifndef _OPT_NETFS_H_
+#define _OPT_NETFS_H_
+#define OPT_NETFS 0
+#endif /* _OPT_NETFS_H_ */
diff --git a/kern/compile/ASST1/opt-sfs.h b/kern/compile/ASST1/opt-sfs.h
new file mode 100644
index 0000000..94095ad
--- /dev/null
+++ b/kern/compile/ASST1/opt-sfs.h
@@ -0,0 +1,5 @@
+/* Automatically generated; do not edit */
+#ifndef _OPT_SFS_H_
+#define _OPT_SFS_H_
+#define OPT_SFS 1
+#endif /* _OPT_SFS_H_ */
diff --git a/kern/compile/ASST1/opt-synchprobs.h b/kern/compile/ASST1/opt-synchprobs.h
new file mode 100644
index 0000000..57b9186
--- /dev/null
+++ b/kern/compile/ASST1/opt-synchprobs.h
@@ -0,0 +1,5 @@
+/* Automatically generated; do not edit */
+#ifndef _OPT_SYNCHPROBS_H_
+#define _OPT_SYNCHPROBS_H_
+#define OPT_SYNCHPROBS 1
+#endif /* _OPT_SYNCHPROBS_H_ */
diff --git a/kern/compile/ASST1/pcb.o b/kern/compile/ASST1/pcb.o
new file mode 100644
index 0000000..6797af8
Binary files /dev/null and b/kern/compile/ASST1/pcb.o differ
diff --git a/kern/compile/ASST1/pseudorand.o b/kern/compile/ASST1/pseudorand.o
new file mode 100644
index 0000000..4327386
Binary files /dev/null and b/kern/compile/ASST1/pseudorand.o differ
diff --git a/kern/compile/ASST1/pseudorand_att.o b/kern/compile/ASST1/pseudorand_att.o
new file mode 100644
index 0000000..0d2ac13
Binary files /dev/null and b/kern/compile/ASST1/pseudorand_att.o differ
diff --git a/kern/compile/ASST1/queue.o b/kern/compile/ASST1/queue.o
new file mode 100644
index 0000000..411a307
Binary files /dev/null and b/kern/compile/ASST1/queue.o differ
diff --git a/kern/compile/ASST1/queuetest.o b/kern/compile/ASST1/queuetest.o
new file mode 100644
index 0000000..c349d78
Binary files /dev/null and b/kern/compile/ASST1/queuetest.o differ
diff --git a/kern/compile/ASST1/ram.o b/kern/compile/ASST1/ram.o
new file mode 100644
index 0000000..6a5796a
Binary files /dev/null and b/kern/compile/ASST1/ram.o differ
diff --git a/kern/compile/ASST1/random.o b/kern/compile/ASST1/random.o
new file mode 100644
index 0000000..dd31511
Binary files /dev/null and b/kern/compile/ASST1/random.o differ
diff --git a/kern/compile/ASST1/random_lrandom.o b/kern/compile/ASST1/random_lrandom.o
new file mode 100644
index 0000000..9098cee
Binary files /dev/null and b/kern/compile/ASST1/random_lrandom.o differ
diff --git a/kern/compile/ASST1/rtclock.o b/kern/compile/ASST1/rtclock.o
new file mode 100644
index 0000000..6758d8f
Binary files /dev/null and b/kern/compile/ASST1/rtclock.o differ
diff --git a/kern/compile/ASST1/rtclock_ltimer.o b/kern/compile/ASST1/rtclock_ltimer.o
new file mode 100644
index 0000000..22fafdd
Binary files /dev/null and b/kern/compile/ASST1/rtclock_ltimer.o differ
diff --git a/kern/compile/ASST1/runprogram.o b/kern/compile/ASST1/runprogram.o
new file mode 100644
index 0000000..6ced3ad
Binary files /dev/null and b/kern/compile/ASST1/runprogram.o differ
diff --git a/kern/compile/ASST1/scheduler.o b/kern/compile/ASST1/scheduler.o
new file mode 100644
index 0000000..fb5d671
Binary files /dev/null and b/kern/compile/ASST1/scheduler.o differ
diff --git a/kern/compile/ASST1/sfs_fs.o b/kern/compile/ASST1/sfs_fs.o
new file mode 100644
index 0000000..ccb13fe
Binary files /dev/null and b/kern/compile/ASST1/sfs_fs.o differ
diff --git a/kern/compile/ASST1/sfs_io.o b/kern/compile/ASST1/sfs_io.o
new file mode 100644
index 0000000..703827b
Binary files /dev/null and b/kern/compile/ASST1/sfs_io.o differ
diff --git a/kern/compile/ASST1/sfs_vnode.o b/kern/compile/ASST1/sfs_vnode.o
new file mode 100644
index 0000000..8e48110
Binary files /dev/null and b/kern/compile/ASST1/sfs_vnode.o differ
diff --git a/kern/compile/ASST1/snprintf.o b/kern/compile/ASST1/snprintf.o
new file mode 100644
index 0000000..5e97f3c
Binary files /dev/null and b/kern/compile/ASST1/snprintf.o differ
diff --git a/kern/compile/ASST1/spl.o b/kern/compile/ASST1/spl.o
new file mode 100644
index 0000000..fa1bd45
Binary files /dev/null and b/kern/compile/ASST1/spl.o differ
diff --git a/kern/compile/ASST1/start.o b/kern/compile/ASST1/start.o
new file mode 100644
index 0000000..d67a5c5
Binary files /dev/null and b/kern/compile/ASST1/start.o differ
diff --git a/kern/compile/ASST1/stoplight.o b/kern/compile/ASST1/stoplight.o
new file mode 100644
index 0000000..4063cd4
Binary files /dev/null and b/kern/compile/ASST1/stoplight.o differ
diff --git a/kern/compile/ASST1/strcat.o b/kern/compile/ASST1/strcat.o
new file mode 100644
index 0000000..cd7cbc4
Binary files /dev/null and b/kern/compile/ASST1/strcat.o differ
diff --git a/kern/compile/ASST1/strchr.o b/kern/compile/ASST1/strchr.o
new file mode 100644
index 0000000..86bb9c9
Binary files /dev/null and b/kern/compile/ASST1/strchr.o differ
diff --git a/kern/compile/ASST1/strcmp.o b/kern/compile/ASST1/strcmp.o
new file mode 100644
index 0000000..a0caea6
Binary files /dev/null and b/kern/compile/ASST1/strcmp.o differ
diff --git a/kern/compile/ASST1/strcpy.o b/kern/compile/ASST1/strcpy.o
new file mode 100644
index 0000000..087324d
Binary files /dev/null and b/kern/compile/ASST1/strcpy.o differ
diff --git a/kern/compile/ASST1/strlen.o b/kern/compile/ASST1/strlen.o
new file mode 100644
index 0000000..cd46bda
Binary files /dev/null and b/kern/compile/ASST1/strlen.o differ
diff --git a/kern/compile/ASST1/strrchr.o b/kern/compile/ASST1/strrchr.o
new file mode 100644
index 0000000..f07109d
Binary files /dev/null and b/kern/compile/ASST1/strrchr.o differ
diff --git a/kern/compile/ASST1/strtok_r.o b/kern/compile/ASST1/strtok_r.o
new file mode 100644
index 0000000..f1ee591
Binary files /dev/null and b/kern/compile/ASST1/strtok_r.o differ
diff --git a/kern/compile/ASST1/switch.o b/kern/compile/ASST1/switch.o
new file mode 100644
index 0000000..b34925f
Binary files /dev/null and b/kern/compile/ASST1/switch.o differ
diff --git a/kern/compile/ASST1/synch.o b/kern/compile/ASST1/synch.o
new file mode 100644
index 0000000..9ea10ff
Binary files /dev/null and b/kern/compile/ASST1/synch.o differ
diff --git a/kern/compile/ASST1/synchtest.o b/kern/compile/ASST1/synchtest.o
new file mode 100644
index 0000000..105cb9c
Binary files /dev/null and b/kern/compile/ASST1/synchtest.o differ
diff --git a/kern/compile/ASST1/syscall.o b/kern/compile/ASST1/syscall.o
new file mode 100644
index 0000000..e8f0b30
Binary files /dev/null and b/kern/compile/ASST1/syscall.o differ
diff --git a/kern/compile/ASST1/thread.o b/kern/compile/ASST1/thread.o
new file mode 100644
index 0000000..57f4c21
Binary files /dev/null and b/kern/compile/ASST1/thread.o differ
diff --git a/kern/compile/ASST1/threadstart.o b/kern/compile/ASST1/threadstart.o
new file mode 100644
index 0000000..36bc904
Binary files /dev/null and b/kern/compile/ASST1/threadstart.o differ
diff --git a/kern/compile/ASST1/threadtest.o b/kern/compile/ASST1/threadtest.o
new file mode 100644
index 0000000..fd139b0
Binary files /dev/null and b/kern/compile/ASST1/threadtest.o differ
diff --git a/kern/compile/ASST1/tlb_mips1.o b/kern/compile/ASST1/tlb_mips1.o
new file mode 100644
index 0000000..c4899a7
Binary files /dev/null and b/kern/compile/ASST1/tlb_mips1.o differ
diff --git a/kern/compile/ASST1/trap.o b/kern/compile/ASST1/trap.o
new file mode 100644
index 0000000..7a2277d
Binary files /dev/null and b/kern/compile/ASST1/trap.o differ
diff --git a/kern/compile/ASST1/tt3.o b/kern/compile/ASST1/tt3.o
new file mode 100644
index 0000000..abc78ce
Binary files /dev/null and b/kern/compile/ASST1/tt3.o differ
diff --git a/kern/compile/ASST1/uio.o b/kern/compile/ASST1/uio.o
new file mode 100644
index 0000000..d4d4265
Binary files /dev/null and b/kern/compile/ASST1/uio.o differ
diff --git a/kern/compile/ASST1/vers.c b/kern/compile/ASST1/vers.c
new file mode 100644
index 0000000..689e239
--- /dev/null
+++ b/kern/compile/ASST1/vers.c
@@ -0,0 +1,3 @@
+/* This file is automatically generated. Edits will be lost.*/
+const int buildversion = 2;
+const char buildconfig[] = "ASST1";
diff --git a/kern/compile/ASST1/vers.o b/kern/compile/ASST1/vers.o
new file mode 100644
index 0000000..fca708d
Binary files /dev/null and b/kern/compile/ASST1/vers.o differ
diff --git a/kern/compile/ASST1/version b/kern/compile/ASST1/version
new file mode 100644
index 0000000..0cfbf08
--- /dev/null
+++ b/kern/compile/ASST1/version
@@ -0,0 +1 @@
+2
diff --git a/kern/compile/ASST1/vfscwd.o b/kern/compile/ASST1/vfscwd.o
new file mode 100644
index 0000000..804a963
Binary files /dev/null and b/kern/compile/ASST1/vfscwd.o differ
diff --git a/kern/compile/ASST1/vfslist.o b/kern/compile/ASST1/vfslist.o
new file mode 100644
index 0000000..4d11099
Binary files /dev/null and b/kern/compile/ASST1/vfslist.o differ
diff --git a/kern/compile/ASST1/vfslookup.o b/kern/compile/ASST1/vfslookup.o
new file mode 100644
index 0000000..f9694bc
Binary files /dev/null and b/kern/compile/ASST1/vfslookup.o differ
diff --git a/kern/compile/ASST1/vfspath.o b/kern/compile/ASST1/vfspath.o
new file mode 100644
index 0000000..294bf95
Binary files /dev/null and b/kern/compile/ASST1/vfspath.o differ
diff --git a/kern/compile/ASST1/vnode.o b/kern/compile/ASST1/vnode.o
new file mode 100644
index 0000000..3825671
Binary files /dev/null and b/kern/compile/ASST1/vnode.o differ
diff --git a/kern/include/synch.h b/kern/include/synch.h
index 3583e78..0efd470 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -3,6 +3,7 @@
  */
 
 #ifndef _SYNCH_H_
+#include <queue.h> //global thread variable
 #define _SYNCH_H_
 
 /*
@@ -17,7 +18,7 @@
  * The name field is for easier debugging. A copy of the name is made
  * internally.
  */
-
+extern struct thread *curthread;
 struct semaphore {
 	char *name;
 	volatile int count;
@@ -51,6 +52,8 @@ void              sem_destroy(struct semaphore *);
 struct lock {
 	char *name;
 	// add what you need here
+        volatile int lock_occupied;
+	volatile struct thread *lock_holder;
 	// (don't forget to mark things volatile as needed)
 };
 
@@ -90,6 +93,8 @@ void         lock_destroy(struct lock *);
 struct cv {
 	char *name;
 	// add what you need here
+        int count;
+	struct queue *thread_queue;
 	// (don't forget to mark things volatile as needed)
 };
 
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index cdc47a3..6e18de3 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -7,6 +7,7 @@
 #include <lib.h>
 #include <synch.h>
 #include <thread.h>
+#include <queue.h>
 #include <curthread.h>
 #include <machine/spl.h>
 
@@ -18,8 +19,8 @@ struct semaphore *
 sem_create(const char *namearg, int initial_count)
 {
 	struct semaphore *sem;
-
-	sem = kmalloc(sizeof(struct semaphore));
+        assert(initial_count >= 0)
+	sem = kmalloc(sizeof(struct semaphore));    
 	if (sem == NULL) {
 		return NULL;
 	}
@@ -113,7 +114,8 @@ lock_create(const char *name)
 	}
 	
 	// add stuff here as needed
-	
+        lock->lock_occupied = 0;
+	lock->lock_holder = NULL;	
 	return lock;
 }
 
@@ -126,32 +128,56 @@ lock_destroy(struct lock *lock)
 	
 	kfree(lock->name);
 	kfree(lock);
+        lock = NULL;
 }
 
 void
 lock_acquire(struct lock *lock)
 {
 	// Write this
+        int spl;
+	assert(lock != NULL);
+	assert(in_interrupt==0);
 
-	(void)lock;  // suppress warning until code gets written
+	spl = splhigh();
+	assert(!lock_do_i_hold(lock));
+	while (lock->lock_occupied == 1 && lock->lock_holder != curthread) {
+		thread_sleep(lock);
+	}
+	
+	lock->lock_occupied = 1;
+	lock->lock_holder = curthread;
+	splx(spl);
+	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
 	// Write this
+        assert(lock != NULL);
+	assert(lock->lock_holder);
+	assert(lock_do_i_hold(lock));
 
-	(void)lock;  // suppress warning until code gets written
+	int spl;
+	spl = splhigh();
+	lock->lock_occupied = 0;
+	lock->lock_holder = NULL;
+	thread_wakeup(lock);
+	splx(spl);
+       //(void)lock;  // suppress warning until code gets written
 }
 
 int
 lock_do_i_hold(struct lock *lock)
 {
 	// Write this
+        assert(lock != NULL);
 
-	(void)lock;  // suppress warning until code gets written
+	return (lock->lock_holder == curthread);
+	//(void)lock;  // suppress warning until code gets written
 
-	return 1;    // dummy until code gets written
+	//return 1;    // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -176,7 +202,9 @@ cv_create(const char *name)
 	}
 	
 	// add stuff here as needed
-	
+        cv->count=0;
+
+	cv->thread_queue = q_create(1);	
 	return cv;
 }
 
@@ -186,31 +214,57 @@ cv_destroy(struct cv *cv)
 	assert(cv != NULL);
 
 	// add stuff here as needed
-	
+        assert(cv->count == 0);
+	assert(q_empty(cv->thread_queue));
+
+	q_destroy(cv->thread_queue);	
 	kfree(cv->name);
 	kfree(cv);
+        cv = NULL;
 }
 
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+        int spl;
+
+	spl = splhigh();
+	lock_release(lock);
+	cv->count++;
+	q_preallocate(cv->thread_queue,cv->count);
+	q_addtail(cv->thread_queue, curthread);
+	thread_sleep(curthread);
+	lock_acquire(lock);
+	splx(spl);        
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+        int spl = splhigh();
+	cv->count--;
+
+	struct thread *next_thread = q_remhead(cv->thread_queue);
+
+	thread_wakeup(next_thread);
+	splx(spl);        
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
 	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+        while(cv->count > 0) {
+		cv_signal(cv, lock);
+        } 
+	assert(cv->count == 0);
+	assert(q_empty(cv->thread_queue));        
+	//(void)cv;    // suppress warning until code gets written
+	//(void)lock;  // suppress warning until code gets written
 }
diff --git a/os161-1.10/.cvsignore b/os161-1.10/.cvsignore
new file mode 100644
index 0000000..1eda58e
--- /dev/null
+++ b/os161-1.10/.cvsignore
@@ -0,0 +1 @@
+defs.mk
diff --git a/os161-1.10/CHANGES b/os161-1.10/CHANGES
new file mode 100644
index 0000000..ee2b110
--- /dev/null
+++ b/os161-1.10/CHANGES
@@ -0,0 +1,313 @@
+20040203 dholland	OS/161 1.10 released.
+20040203 dholland	Support for hosting OS/161 on Solaris.
+20040202 dholland	Update stdarg.h for gcc 3.x; remove machine/stdarg.h.
+
+20031227 dholland	OS/161 1.09 released.
+20031224 dholland	Add missing man page for triplesort.
+20031224 dholland	Fix failed compile in lnet.c, currently a null driver.
+20031224 dholland	Fix badcall so it doesn't blow up on empty stdin.
+20031224 dholland	Fix argument handling in bin/ln.
+20031224 dholland	Fix link count leak in base system sfs_rename().
+20031224 dholland	Fix silly use-after-free in an SFS mount error path.
+20031224 dholland	Fix handling of unaligned sections in dumbvm.
+20031224 dholland	Change "asst1probs" to "synchprobs".
+20031224 dholland	Refer to assts by content, not number, where possible.
+20031224 dholland	Fix some nonsensical but working code in /bin/pwd.
+20031224 dholland	Update stack assertions in mips/trap.c for 4k stacks.
+20031224 dholland	Install kernels using their configuration name.
+20031224 dholland	Clarify some aspects of the locks/CVs API.
+20031224 dholland	Fix assorted comment typos and glitches.
+20030626 dholland	Commit the fix for a refcounting mistake in SFS.
+20030626 dholland	Fix glitch in one of the dup2 tests in testbin/badcall.
+20030626 dholland	Add missing sized type in mksfs/support.h.
+20030626 dholland	Fix "make depend" glitch in dumpsfs.
+20030626 dholland	Fix minor off-by-one error in menu code.
+20030421 dholland       Fix assertion failure in kernel heap dump code.
+20030421 dholland       Fix crash in testbin/dirconc.
+
+20030221 dholland	OS/161 1.08 released.
+20030221 dholland	Fix broken hostcompat build with some Linux libcs.
+20030207 gwa/dholland	Fix broken ASST1 build caused by rushed release.
+
+20030131 dholland	OS/161 1.07 released.
+20030131 gwa		New assignment 1 problems for 2003.
+20030129 dholland	Make console device full-duplex.
+20030129 dholland	Check for short reads when loading executable headers.
+20030129 dholland	Make rmtest a single standalone executable.
+20030129 dholland	Make first thread stack also 4k rather than 8k.
+20030129 dholland	Fix minor VFS bug handling multiple leading slashes.
+20030129 dholland	Remove code duplication in triple* tests.
+20030129 dholland	Add triplesort test (like triplemat).
+20030128 dholland	Make f_test a single standalone executable.
+20030128 dholland	Add t_ prefix to struct thread members for consistency.
+20030128 dholland	bzero by words instead of bytes when properly aligned.
+20030128 dholland	Add memcmp() to libc.
+20030127 dholland	Minor fixes to parallelvm.
+
+20030117 dholland	OS/161 1.06 released.
+20030110 dholland	Fix bug in setjmp/longjmp.
+20030110 dholland	Add small explanatory comment to dev/lamebus/emu.c.
+20021120 dholland	Have configure script provide NM and HOST_NM.
+20021120 dholland	Merge hostcompat fixes for Mac OS X.
+20021001 dholland	Avoid undefined C behavior in atoi().
+20020920 dholland	Provide string names for mips trap codes.
+20020920 dholland	Fix handling of boot-time kernel memory faults.
+
+20020917 dholland	OS/161 1.05 released.
+20020913 dholland	Created this changelog from CVS log data.
+20020904 dholland	Cleanup/improvement for testbin/malloctest.
+20020904 dholland	Adjust prototype for __time() for hostcompat reasons.
+20020904 dholland	Add parallelvm and dirconc to the default build.
+20020904 dholland	Add mode to testbin/crash to fork and run everything.
+20020904 dholland	Retry certain I/O errors in emufs and sfs.
+20020904 dholland	Make vfs_close not fail.
+20020830 dholland	Prohibit slashes and colons in volume names in mksfs.
+20020830 dholland	_O_RDWRMASK -> O_ACCMODE, per POSIX.
+20020830 dholland	Shrink kernel stacks from 8k to 4k.
+20020830 dholland	Merge the code for the 'p' and 's' menu commands.
+20020830 dholland	Don't use OPEN_MAX in the base system.
+20020829 dholland	Include a copy of the error strings in the kernel.
+20020829 dholland	Assert that spl is 0 on syscall entry and exit.
+20020829 dholland	Fixes and new tests for testbin/badcall.
+20020829 dholland	Add code and menu command for dumping kernel heap.
+20020827 dholland	Close current directory at shutdown time.
+20020827 dholland	Clear bootfs at shutdown time.
+20020827 dholland	Remove extraneous magic argument from free_kpages().
+20020827 dholland	Fix dangling lock bug in emufs.
+20020826 dholland	Man page fixes for read, write, waitpid.
+20020808 dholland	Make Ant-32 port mostly work.
+20020625 dholland	Kernel makefile tweak for stupid makes.
+20020618 dholland	Fixes to the Ant-32 port.
+20020617 dholland	Update the (unreleased) Ant-32 port.
+20020523 dholland	Make matmult exit 1 on failure.
+20020523 dholland	Fix various forking userlevel tests to wait properly.
+20020523 dholland	Check for short reads when loading executables.
+20020523 dholland	Fix bug in tt3 test.
+20020523 dholland	Some make/build fixes.
+20020523 dholland	More mips calling conventions fixes.
+20020522 dholland	Fix bug in new mips exception code.
+20020522 dholland	Revamp testbin/badcall.
+20020515 dholland	Various accumulated minor cleanups and fixes.
+20020515 dholland	New tests: dirconc, parallelvm.
+20020515 dholland	Add missing V() in lhd driver.
+20020515 dholland	Fixes for the thread code.
+20020515 dholland	Tweak mips exception code for gdb's benefit.
+20020515 dholland	Clean up dumbvm code.
+20020515 dholland	Initialize mips stacks better, for gdb's benefit.
+20020425 dholland	Fixes for testbin/f_test.
+20020424 dholland	Fix kmalloc bug (found by Richard Eisenberg).
+20020424 dholland	Fix incorrect error codes in testbin/badcall.
+20020424 dholland	Move stray assert in vfs code.
+20020407 dholland	Fix off-by-one error in lhd driver.
+20020325 dholland	Fix memory leak in malloctest.
+20020318 dholland	Patch for race in thread_exit (fixed properly 5/15).
+20020305 dholland	Fix spl leak on thread_fork failure.
+20020305 dholland	Fix for testbin/crash.
+
+20020216 dholland	OS/161 1.04 released.
+20020216 dholland	Fix warning in kmalloc debugging code.
+20020216 dholland	Adjust testbin/badcall to assignment 2 requirements.
+20020215 dholland	Add cpu_halt() to supplement cpu_idle(), to fix crash.
+20020215 dholland	Fixes for matmult.
+20020215 dholland	Fix garbled comment in vm.h.
+20020215 dholland	Fix prototype of _exit().
+20020208 dholland	Fix stack frame of mips __start for gdb's benefit.
+20020208 dholland	Fix queue bug.
+20020208 dholland	Fix bug in testbin/{badcall,crash,faulter}.
+
+20020131 dholland	OS/161 1.03 released.
+20020131 dholland	Yield more on thread start (OPT_ASST1PROBS only).
+20020131 dholland	Fix whalemating code to match assignment.
+20020131 dholland	New asst1 problems for 2002.
+20020131 dholland	Include fix in mips pcb.h.
+20020130 fedorova	Adjust tt3 iteration counts/sizes.
+20020129 georgi 	Fix broken mksfs and dumpsfs build.
+20020124 dholland	Put time() in libc; add __time() syscall.
+20020124 dholland	Have hostcompat make stdout and stderr unbuffered.
+20020124 dholland	Add sample optimizing config (ASST2-OPT).
+20020124 dholland	New tests: dirseek, rmdirtest, triplemat.
+20020123 dholland	Move matmult2 over original matmult.
+20020123 dholland	Assert nobody's waiting when destroying a semaphore.
+20020123 dholland	Add driver for new ltrace device.
+20020123 dholland	Fix cosmetic bug in hardclock config.
+20020121 dholland	Support ls over emufs.
+20020121 dholland	Fix bug in copyinstr/copyoutstr code.
+20020121 dholland	Fix broken Linux build of libhostcompat.
+20020119 dholland	Alter dumbvm and loadelf for new toolchain.
+20020117 dholland	Check for stack overflow during context switch.
+20020117 dholland	Stop using -O2 with -g for mips.
+20020117 dholland	More mips calling conventions fixes.
+20020117 dholland	Correct the inline asm in spl.c.
+20020117 dholland	Remove machine/inlineasm.h; fold into spl.c.
+20020117 dholland	Avoid using default make-supplied CFLAGS.
+20020117 dholland	Fix use of libhostcompat in mksfs and dumpsfs.
+20020117 dholland	Fix cosmetic bug in configure script.
+20020116 dholland	Adjust various things for new toolchain.
+20020110 dholland	Install hostcompat includes properly.
+20020110 dholland	Various fixes for new gcc (3.0.3) and binutils.
+20020104 dholland	More man pages.
+20020103 dholland	Remove excess register saves from mips context switch.
+20020103 dholland	Move old getcwd to __getcwd; put POSIX getcwd in libc.
+20020103 dholland	Tinker with tt3 test.
+20020102 dholland	Change thread_fork so it can return errors.
+20020102 dholland	Preallocate various things to avoid dying in mi_switch.
+20010925 dholland	Add a bunch of consistency checks to sfs.
+20010925 dholland	Fix bug in new panic code.
+20010925 dholland	Add menu command to panic intentionally.
+20010925 dholland	Fix bug in emufs.
+20010925 dholland	memcpy by words instead of bytes when properly aligned.
+20010925 dholland	Use setjmp() and longjmp() for aborting copyin/copyout.
+20010925 dholland	Add code for setjmp() and longjmp().
+20010921 dholland	Add VOP_KILL (undoes VOP_INIT, which can now fail too.)
+20010921 dholland	Fix race conditions in vnode reclaim.
+20010921 dholland	Fix VFS behavior for things like "rmdir foo:".
+
+20010921 dholland	OS/161 1.02 released.
+20010921 dholland	Revise device config/attach code.
+20010920 dholland	Standards compliance fixes for strchr/strrchr.
+20010920 dholland	Fix bug in system().
+20010919 dholland	More man pages.
+20010918 dholland	Changed MAXNAMLEN to NAME_MAX.
+20010918 dholland	Fix bug in kernel menu pwd command.
+20010918 dholland	Panic handling improvements.
+20010918 dholland	Kernel bootup and shutdown cleanup.
+20010918 dholland	Fixes for testbin/badcall.
+20010824 dholland	Make config script probe for <err.h>. 
+20010821 dholland	Changes to queue code for consistent naming.
+20010808 dholland	Add man pages.
+20010808 dholland	Add explicit support for host-runnable programs.
+20010807 dholland	Clean up -nostdinc/-nostdlib handling.
+20010807 dholland	Fix bug in cp.
+20010807 dholland	New test in testbin/crash.
+20010807 dholland	Fixes for testbin/malloctest.
+20010806 dholland	Fix glitch in testbin/badcall.
+20010806 dholland	New test: randcall.
+20010804 dholland	Add missing strrchr proto to <string.h>.
+20010803 dholland	Clean up ls; among other things, fix ls -R.
+20010803 dholland	Fixes for testbin/badcall.
+20010803 dholland	Add memset() to libc.
+20010803 dholland	Split part of testbin/crash to new testbin/badcall.
+20010802 dholland	Add comments to testbin describing intended uses.
+20010802 dholland	Fix testbin/ctest to be large enough to be interesting.
+20010802 dholland	Fix testbin/sort to be quicksort instead of bubble.
+20010802 dholland	Various minor testbin fixes/cleanup.
+20010802 dholland	Add dummy <fcntl.h> to make porting easier.
+20010802 dholland	Add dummy <time.h> to make porting easier.
+20010802 dholland	Add dummy <sys/ioctl.h> to make porting easier.
+20010802 dholland	Add dummy <sys/reboot.h> to make porting easier.
+20010802 dholland	Add dummy <sys/wait.h> to make porting easier.
+20010802 dholland	Have kfree deadbeef out free blocks.
+20010801 dholland	Time execution of every kernel menu command.
+20010801 dholland	Add getinterval() function for subtracting times.
+20010801 dholland	Print commands as they execute from the command string.
+20010801 dholland	New test tt3; add atoi from libc to kernel build.
+20010801 dholland	Add memcpy from libc.
+20010801 dholland	Fix size_t and add memcpy() to libc.
+20010801 dholland	Reset mips TLB at boot time.
+20010801 dholland	Revise kernel menu layout.
+20010801 dholland	Add tests for arrays, bitmaps, queues, and semaphores.
+20010801 dholland	Add "reconfig" rule to kernel makefiles.
+20010801 dholland	Fix queue code.
+20010731 dholland	Move main.c from kern/thread to kern/main.
+20010730 dholland	Add kernel menu command to unmount things.
+20010730 dholland	Add vfs_unmountall() for shutdown time.
+20010730 dholland	Report mounts to the console as they happen.
+20010730 dholland	Abolish pointless kernel shutdown functions.
+20010726 dholland	Add random: device accessible through VFS.
+20010726 dholland	Add pseudorand device for when hardware is missing.
+20010726 dholland	Add config support for pseudo-devices.
+20010724 dholland	Yield randomly at thread start if OPT_ASST1PROBS set.
+20010724 dholland	Clarify comments in mips exception.S.
+20010724 dholland	Don't allow calling P() from an interrupt handler.
+20010724 dholland	Fixes for lser driver.
+20010723 dholland	More mips calling conventions fixes.
+20010626 dholland	Add pwd and sync to kernel menu.
+20010626 dholland	Massive changes to kernel menu UI.
+20010619 dholland	Change as_copy so it can return error codes.
+20010619 dholland	Merge bitmap_isset() from sol3.
+20010619 dholland	Various fixes for new dumbvm.
+20010619 dholland	Fix overly enthusiastic test in vnode_check().
+20010619 dholland	Provide a sketch of the skeleton for doing fork.
+20010618 dholland	Add asserts to synch code.
+20010618 dholland	Clean up/clarify syscall entry code.
+20010618 dholland	New dumbvm supporting multiple address spaces.
+20010618 dholland	Remove mips dependencies from loadelf.c.
+20010618 dholland	Add hacks to prevent looping "Unknown syscall -1".
+20010615 dholland	Merge the kmalloc and kfree from sol3.
+20010614 dholland	Move kernel menu stuff to its own file.
+20010614 dholland	Fixes for sfs and vfs layer.
+20010612 dholland	Add sfs_rwblock to encapsulate sfs_device->d_io().
+20010612 dholland	Add lbolt and clocksleep() functionality to kernel.
+20010612 dholland	Add -W to standard warning options.
+20010611 dholland	Abolish rcsids.
+20010611 dholland	Fix memory leak on error in thread_fork.
+20010611 dholland	Don't panic if kmalloc fails. Add checks.
+20010611 dholland	Add VOP_MAGIC to vnode ops tables, and lots of checks.
+20010611 dholland	Add array_setguy().
+20010608 dholland	Add random() and srandom() to libc.
+20010608 dholland	Add some framework for user-level malloc to libc.
+20010608 dholland	Correct prototypes for read() and write().
+20010608 dholland	kprintf synchronization cleanups.
+20010523 dholland	Add warning about the consequences of touching paddr 0.
+20010523 dholland	Fix open count handling on VOP_CLOSE error.
+20010523 dholland	New test: malloctest.
+20010428 dholland	Handle multiple leading slashes on pathnames.
+20010423 dholland	Fix deadlock in vfs layer.
+20010423 dholland	Fix bug in testbin/dirtest.
+20010423 dholland	Fix multiple bugs in ls.
+20010422 dholland	Fix bug in sfs.
+20010419 dholland	Fix bug in sfs (patch from Amos Blackman).
+20010416 dholland	Fix fstest code.
+20010416 dholland	Remove stray debug output from dumpsfs.
+20010414 dholland	Fix host mksfs/dumpsfs build on DU.
+20010414 dholland	Makefile fix: build mksfs and dumpsfs by default.
+20010414 dholland	Fix bug in sfs (found by Dafina Toncheva).
+20010414 dholland	Fix endianness bug in dumpsfs.
+20010414 dholland	Do a sync at shutdown time.
+20010414 dholland	Format depend.mk files consistently.
+20010414 dholland	Fix memory leak in sfs.
+20010413 dholland	Allow VOP_FSYNC on sfs directories.
+20010412 dholland	Detect infinite loop triggerable by uio misuse.
+20010411 dholland	Fix bug in bitmap code.
+20010406 dholland	Fix calling conventions in mips asm code.
+20010323 dholland	Fix multi-sector lhd I/Os (found by Jeff DeSoto).
+20010322 dholland	Fix bug in comment in pcb.c (found by Jeffrey Enos).
+20010319 dholland	Make matmult smaller.
+20010318 moorthi	Fix bug in array code.
+20010314 dholland	Fix bug in mv (found by Edward Lim).
+20010314 dholland	Fix bug in testbin/crash (found by Mike Vernal).
+20010314 dholland	Fix bug in bitmap code.
+20010308 moorthi	Fix bug in sfs.
+
+20010226 dholland	OS/161 1.01 released.
+20010226 dholland	Add a lock to the console device.
+20010226 dholland	Fix another bug in copyin/copyout code.
+20010226 dholland	Add vfs_getdevname().
+20010226 dholland	Use device name for FSes that don't return a volname.
+20010226 dholland	Fix two bugs in pwd.
+20010226 dholland	Make /bin/pwd work in emufs.
+20010225 dholland	Fix bug in mips trap code.
+20010225 dholland	Fix bug in mips copyin/copyout code.
+20010224 dholland	Add appropriate volatile keywords in various places.
+20010224 dholland	Fix synchronization in placeholder kmalloc.
+20010221 dholland	Fix bug in CV code.
+
+20010208 dholland	OS/161 1.00 released.
+20010208 dholland	Add EBADF to error list.
+20010208 dholland	Fix specification of VOP_STAT.
+20010208 blackman	Fix naming of queue functions.
+20010208 blackman	Driver for lrandom device.
+20010207 dholland	Check all calls to thread_fork for failure.
+20010206 dholland	Fix comment in mips/specialreg.h.
+20010205 dholland	Prevent recursive scheduler calls. (Fixes crash.)
+20010205 dholland	Make syscall wrapper generation more robust.
+20010205 dholland	Fix bug in cp.
+
+20010202 dholland	OS/161 0.99 released.
+20010202 dholland	Add host-sh (host-runnable version) to sh makefile.
+20010202 dholland	Add licensing boilerplate.
+20010201 dholland	Switch from getfilesize() to fstat().
+20010201 dholland	Add system().
+20010130 dholland	Add strtok() and strtok_r().
+20010129 dholland	Add ELF code.
+20010111 dholland	Fix bug in ls.
diff --git a/os161-1.10/COPYING b/os161-1.10/COPYING
new file mode 100644
index 0000000..36173bc
--- /dev/null
+++ b/os161-1.10/COPYING
@@ -0,0 +1,32 @@
+This license covers all portions of OS/161 except for those files
+bearing their own copyright and/or licensing notices.
+
+/*
+ * Copyright (c) 2000, 2001, 2002, 2003
+ *	The President and Fellows of Harvard College.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
diff --git a/os161-1.10/Makefile b/os161-1.10/Makefile
new file mode 100644
index 0000000..0854f21
--- /dev/null
+++ b/os161-1.10/Makefile
@@ -0,0 +1,63 @@
+#
+# Toplevel makefile for OS/161.
+#
+#
+# Rules:
+#    all (default):  depend, compile, and install system.
+#    build:          depend, compile, and install system from scratch.
+#    compile:        compile and install binaries.
+#    includes:       install header files.
+#    tags:           generate/regenerate "tags" files.
+#    depend:         update make dependency information.
+#    clean:          remove generated files.
+#
+# The "compile" rule subsumes both compilation and installation,
+# because certain parts must be installed before subsequent parts
+# can be built. Note that it does *not* install include files.
+#
+# The "includes" rule installs header files from the kernel and
+# libraries into the include directory of the system tree.
+#
+
+all:
+	$(MAKE) includes
+	$(MAKE) depend
+	$(MAKE) compile
+
+build:
+	$(MAKE) clean
+	$(MAKE) all
+
+compile:
+	(cd lib && $(MAKE))
+	(cd lib && $(MAKE) install)
+	(cd bin && $(MAKE))
+	(cd sbin && $(MAKE))
+	(cd testbin && $(MAKE))
+	(cd bin && $(MAKE) install)
+	(cd sbin && $(MAKE) install)
+	(cd testbin && $(MAKE) install)
+	(cd man && $(MAKE) install)
+	(cd kern && $(MAKE))
+	(cd kern && $(MAKE) install)
+
+includes:
+	(cd kern && $(MAKE) includes)
+	(cd include && $(MAKE) includes)
+	(cd lib/hostcompat && $(MAKE) includes)
+
+tags depend clean:
+	(cd include && $(MAKE) $@)
+	(cd lib && $(MAKE) $@)
+	(cd bin && $(MAKE) $@)
+	(cd sbin && $(MAKE) $@)
+	(cd testbin && $(MAKE) $@)
+	(cd man && $(MAKE) $@)
+	(cd kern && $(MAKE) $@)
+
+clean: cleanhere
+cleanhere:
+	rm -f *~ mk/*~
+
+
+.PHONY: all build compile includes tags depend clean cleanhere
diff --git a/os161-1.10/bin/Makefile b/os161-1.10/bin/Makefile
new file mode 100644
index 0000000..d119f8b
--- /dev/null
+++ b/os161-1.10/bin/Makefile
@@ -0,0 +1,26 @@
+#
+# Makefile for src/bin (sources for programs installed in /bin)
+#
+
+include ../defs.mk
+
+all depend tags clean install:
+	(cd true && $(MAKE) $@)
+	(cd false && $(MAKE) $@)
+	(cd sync && $(MAKE) $@)
+	(cd mkdir && $(MAKE) $@)
+	(cd rmdir && $(MAKE) $@)
+	(cd pwd && $(MAKE) $@)
+	(cd cat && $(MAKE) $@)
+	(cd cp && $(MAKE) $@)
+	(cd ln && $(MAKE) $@)
+	(cd mv && $(MAKE) $@)
+	(cd rm && $(MAKE) $@)
+	(cd ls && $(MAKE) $@)
+	(cd sh && $(MAKE) $@)
+
+clean: cleanhere
+cleanhere:
+	rm -f *~
+
+.PHONY: all depend tags clean cleanhere install
diff --git a/os161-1.10/bin/cat/.cvsignore b/os161-1.10/bin/cat/.cvsignore
new file mode 100644
index 0000000..ef07ddc
--- /dev/null
+++ b/os161-1.10/bin/cat/.cvsignore
@@ -0,0 +1 @@
+cat
diff --git a/os161-1.10/bin/cat/Makefile b/os161-1.10/bin/cat/Makefile
new file mode 100644
index 0000000..21d3402
--- /dev/null
+++ b/os161-1.10/bin/cat/Makefile
@@ -0,0 +1,9 @@
+# Makefile for cat
+
+SRCS=cat.c
+PROG=cat
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/cat/cat.c b/os161-1.10/bin/cat/cat.c
new file mode 100644
index 0000000..d01ab8d
--- /dev/null
+++ b/os161-1.10/bin/cat/cat.c
@@ -0,0 +1,91 @@
+#include <unistd.h>
+#include <string.h>
+#include <err.h>
+
+/*
+ * cat - concatenate and print
+ * Usage: cat [files]
+ */
+
+
+
+/* Print a file that's already been opened. */
+static
+void
+docat(const char *name, int fd)
+{
+	char buf[1024];
+	int len, wr, wrtot;
+
+	/*
+	 * As long as we get more than zero bytes, we haven't hit EOF.
+	 * Zero means EOF. Less than zero means an error occurred.
+	 * We may read less than we asked for, though, in various cases
+	 * for various reasons.
+	 */
+	while ((len = read(fd, buf, sizeof(buf)))>0) {
+		/*
+		 * Likewise, we may actually write less than we attempted
+		 * to. So loop until we're done.
+		 */
+		wrtot = 0;
+		while (wrtot < len) {
+			wr = write(STDOUT_FILENO, buf+wrtot, len-wrtot);
+			if (wr<0) {
+				err(1, "stdout");
+			}
+			wrtot += wr;
+		}
+	}
+	/*
+	 * If we got a read error, print it and exit.
+	 */
+	if (len<0) {
+		err(1, "%s", name);
+	}
+}
+
+/* Print a file by name. */
+static
+void
+cat(const char *file)
+{
+	int fd;
+
+	/*
+	 * "-" means print stdin.
+	 */
+	if (!strcmp(file, "-")) {
+		docat("stdin", STDIN_FILENO);
+		return;
+	}
+
+	/*
+	 * Open the file, print it, and close it.
+	 * Bail out if we can't open it.
+	 */
+	fd = open(file, O_RDONLY);
+	if (fd<0) {
+		err(1, "%s", file);
+	}
+	docat(file, fd);
+	close(fd);
+}
+
+
+int
+main(int argc, char *argv[])
+{
+	if (argc==1) {
+		/* No args - just do stdin */
+		docat("stdin", STDIN_FILENO);
+	}
+	else {
+		/* Print all the files specified on the command line. */
+		int i;
+		for (i=1; i<argc; i++) {
+			cat(argv[i]);
+		}
+	}
+	return 0;
+}
diff --git a/os161-1.10/bin/cat/depend.mk b/os161-1.10/bin/cat/depend.mk
new file mode 100644
index 0000000..94637dd
--- /dev/null
+++ b/os161-1.10/bin/cat/depend.mk
@@ -0,0 +1,12 @@
+
+cat.o: \
+ cat.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/bin/cp/.cvsignore b/os161-1.10/bin/cp/.cvsignore
new file mode 100644
index 0000000..91e3283
--- /dev/null
+++ b/os161-1.10/bin/cp/.cvsignore
@@ -0,0 +1 @@
+cp
diff --git a/os161-1.10/bin/cp/Makefile b/os161-1.10/bin/cp/Makefile
new file mode 100644
index 0000000..5c5bf6b
--- /dev/null
+++ b/os161-1.10/bin/cp/Makefile
@@ -0,0 +1,9 @@
+# Makefile for cp
+
+SRCS=cp.c
+PROG=cp
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/cp/cp.c b/os161-1.10/bin/cp/cp.c
new file mode 100644
index 0000000..089cd6a
--- /dev/null
+++ b/os161-1.10/bin/cp/cp.c
@@ -0,0 +1,84 @@
+#include <unistd.h>
+#include <err.h>
+
+/*
+ * cp - copy a file.
+ * Usage: cp oldfile newfile
+ */
+
+
+/* Copy one file to another. */
+static
+void
+copy(const char *from, const char *to)
+{
+	int fromfd;
+	int tofd;
+	char buf[1024];
+	int len, wr, wrtot;
+
+	/*
+	 * Open the files, and give up if they won't open
+	 */
+	fromfd = open(from, O_RDONLY);
+	if (fromfd<0) {
+		err(1, "%s", from);
+	}
+	tofd = open(to, O_WRONLY|O_CREAT|O_TRUNC);
+	if (tofd<0) {
+		err(1, "%s", to);
+	}
+
+	/*
+	 * As long as we get more than zero bytes, we haven't hit EOF.
+	 * Zero means EOF. Less than zero means an error occurred.
+	 * We may read less than we asked for, though, in various cases
+	 * for various reasons.
+	 */
+	while ((len = read(fromfd, buf, sizeof(buf)))>0) {
+		/*
+		 * Likewise, we may actually write less than we attempted
+		 * to. So loop until we're done.
+		 */
+		wrtot = 0;
+		while (wrtot < len) {
+			wr = write(tofd, buf+wrtot, len-wrtot);
+			if (wr<0) {
+				err(1, "%s", to);
+			}
+			wrtot += wr;
+		}
+	}
+	/*
+	 * If we got a read error, print it and exit.
+	 */
+	if (len<0) {
+		err(1, "%s", from);
+	}
+
+	if (close(fromfd) < 0) {
+		err(1, "%s: close", from);
+	}
+
+	if (close(tofd) < 0) {
+		err(1, "%s: close", to);
+	}
+}
+
+int
+main(int argc, char *argv[])
+{
+	/*
+	 * Just do it.
+	 *
+	 * We don't allow the Unix model where you can do
+	 *    cp file1 file2 file3 destination-directory
+	 *
+	 * although this would be pretty easy to add.
+	 */
+	if (argc!=3) {
+		errx(1, "Usage: cp OLDFILE NEWFILE");
+	}
+	copy(argv[1], argv[2]);
+	return 0;
+}
diff --git a/os161-1.10/bin/cp/depend.mk b/os161-1.10/bin/cp/depend.mk
new file mode 100644
index 0000000..10e8c59
--- /dev/null
+++ b/os161-1.10/bin/cp/depend.mk
@@ -0,0 +1,11 @@
+
+cp.o: \
+ cp.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/bin/false/.cvsignore b/os161-1.10/bin/false/.cvsignore
new file mode 100644
index 0000000..c508d53
--- /dev/null
+++ b/os161-1.10/bin/false/.cvsignore
@@ -0,0 +1 @@
+false
diff --git a/os161-1.10/bin/false/Makefile b/os161-1.10/bin/false/Makefile
new file mode 100644
index 0000000..7f73933
--- /dev/null
+++ b/os161-1.10/bin/false/Makefile
@@ -0,0 +1,9 @@
+# Makefile for false
+
+SRCS=false.c
+PROG=false
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/false/depend.mk b/os161-1.10/bin/false/depend.mk
new file mode 100644
index 0000000..f0fbc95
--- /dev/null
+++ b/os161-1.10/bin/false/depend.mk
@@ -0,0 +1,10 @@
+
+false.o: \
+ false.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdlib.h
diff --git a/os161-1.10/bin/false/false.c b/os161-1.10/bin/false/false.c
new file mode 100644
index 0000000..e0ccb3f
--- /dev/null
+++ b/os161-1.10/bin/false/false.c
@@ -0,0 +1,16 @@
+#include <unistd.h>
+#include <stdlib.h>
+
+/*
+ * false - fail.
+ *
+ * "All software sucks. Ok, so maybe /bin/true doesn't. But /bin/false
+ * sure does - it fails all the time."
+ */
+
+int
+main()
+{
+	/* Just exit with a failure code. */
+	exit(1);
+}
diff --git a/os161-1.10/bin/ln/.cvsignore b/os161-1.10/bin/ln/.cvsignore
new file mode 100644
index 0000000..1183674
--- /dev/null
+++ b/os161-1.10/bin/ln/.cvsignore
@@ -0,0 +1 @@
+ln
diff --git a/os161-1.10/bin/ln/Makefile b/os161-1.10/bin/ln/Makefile
new file mode 100644
index 0000000..f8eb56e
--- /dev/null
+++ b/os161-1.10/bin/ln/Makefile
@@ -0,0 +1,9 @@
+# Makefile for ln
+
+SRCS=ln.c
+PROG=ln
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/ln/depend.mk b/os161-1.10/bin/ln/depend.mk
new file mode 100644
index 0000000..ac1d5eb
--- /dev/null
+++ b/os161-1.10/bin/ln/depend.mk
@@ -0,0 +1,13 @@
+
+ln.o: \
+ ln.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/bin/ln/ln.c b/os161-1.10/bin/ln/ln.c
new file mode 100644
index 0000000..403f92d
--- /dev/null
+++ b/os161-1.10/bin/ln/ln.c
@@ -0,0 +1,64 @@
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <err.h>
+
+/*
+ * ln - hardlink or symlink files
+ *
+ * Usage: ln oldfile newfile
+ *        ln -s symlinkcontents symlinkfile
+ */
+
+
+/*
+ * Create a symlink with filename PATH that contains text TEXT.
+ * When fed to ls -l, this produces something that looks like
+ *
+ * lrwxrwxrwx  [stuff]   PATH -> TEXT
+ */
+static
+void
+dosymlink(const char *text, const char *path)
+{
+	if (symlink(text, path)) {
+		err(1, "%s", path);
+	}
+}
+
+/*
+ * Create a hard link such that NEWFILE names the same file as
+ * OLDFILE. Since it's a hard link, the two names for the file
+ * are equal; both are the "real" file.
+ */
+static
+void
+dohardlink(const char *oldfile, const char *newfile)
+{
+	if (link(oldfile, newfile)) {
+		err(1, "%s or %s", oldfile, newfile);
+		exit(1);
+	}
+}
+
+int
+main(int argc, char *argv[])
+{
+	/*
+	 * Just do whatever was asked for.
+	 *
+	 * We don't allow the Unix model where you can do
+	 *    ln [-s] file1 file2 file3 destination-directory
+	 */
+	if (argc==4 && !strcmp(argv[1], "-s")) {
+		dosymlink(argv[2], argv[3]);
+	}
+	else if (argc==3) {
+		dohardlink(argv[1], argv[2]);
+	}
+	else {
+		warnx("Usage: ln oldfile newfile");
+		errx(1, "       ln -s symlinkcontents symlinkfile\n");
+	}
+	return 0;
+}
diff --git a/os161-1.10/bin/ls/.cvsignore b/os161-1.10/bin/ls/.cvsignore
new file mode 100644
index 0000000..9e2740c
--- /dev/null
+++ b/os161-1.10/bin/ls/.cvsignore
@@ -0,0 +1 @@
+ls
diff --git a/os161-1.10/bin/ls/Makefile b/os161-1.10/bin/ls/Makefile
new file mode 100644
index 0000000..a819a74
--- /dev/null
+++ b/os161-1.10/bin/ls/Makefile
@@ -0,0 +1,9 @@
+# Makefile for ls
+
+SRCS=ls.c
+PROG=ls
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/ls/depend.mk b/os161-1.10/bin/ls/depend.mk
new file mode 100644
index 0000000..f92b234
--- /dev/null
+++ b/os161-1.10/bin/ls/depend.mk
@@ -0,0 +1,17 @@
+
+ls.o: \
+ ls.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/bin/ls/ls.c b/os161-1.10/bin/ls/ls.c
new file mode 100644
index 0000000..afb7664
--- /dev/null
+++ b/os161-1.10/bin/ls/ls.c
@@ -0,0 +1,316 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <err.h>
+
+/*
+ * ls - list files.
+ * Usage: ls [-adlRs] [files]
+ *    -a   Show files whose names begin with a dot.
+ *    -d   Don't list contents of directories specified on the command line.
+ *    -l   Long format listing.
+ *    -R   Recurse into subdirectories found.
+ *    -s   (with -l) Show block counts.
+ */
+
+/* Flags for which options we're using. */
+static int aopt=0;
+static int dopt=0;
+static int lopt=0;
+static int Ropt=0;
+static int sopt=0;
+
+/* Process an option character. */
+static
+void
+option(int ch)
+{
+	switch (ch) {
+		case 'a': aopt=1; break;
+		case 'd': dopt=1; break;
+		case 'l': lopt=1; break;
+		case 'R': Ropt=1; break;
+		case 's': sopt=1; break;
+	        default:
+			errx(1, "Unknown option -%c", ch);
+	}
+}
+
+/*
+ * Utility function to find the non-directory part of a pathname.
+ */
+static
+const char *
+basename(const char *path)
+{
+	const char *s;
+
+	s = strrchr(path, '/');
+	if (s) {
+		return s+1;
+	}
+	return path;
+}
+
+/*
+ * Utility function to check if a name refers to a directory.
+ */
+static
+int
+isdir(const char *path)
+{
+	struct stat buf;
+	int fd;
+
+	/* Assume stat() may not be implemented; use fstat */
+	fd = open(path, O_RDONLY);
+	if (fd<0) {
+		err(1, "%s", path);
+	}
+	if (fstat(fd, &buf)<0) {
+		err(1, "%s: fstat", path);
+	}
+	close(fd);
+
+	return S_ISDIR(buf.st_mode);
+}
+
+/*
+ * When listing one of several subdirectories, show the name of the
+ * directory.
+ */
+static
+void
+printheader(const char *file)
+{
+	/* No blank line before the first header */
+	static int first=1;
+	if (first) {
+		first = 0;
+	}
+	else {
+		printf("\n");
+	}
+	printf("%s:\n", file);
+}
+
+/*
+ * Show a single file.
+ * We don't do the neat multicolumn listing that Unix ls does.
+ */
+static
+void
+print(const char *path)
+{
+	struct stat statbuf;
+	const char *file;
+	int typech;
+
+	if (lopt || sopt) {
+		int fd;
+
+		fd = open(path, O_RDONLY);
+		if (fd<0) {
+			err(1, "%s", path);
+		}
+		if (fstat(fd, &statbuf)<0) {
+			err(1, "%s: fstat", path);
+		}
+		close(fd);
+	}
+
+	file = basename(path);
+
+	if (sopt) {
+		printf("%3d ", statbuf.st_blocks);
+	}
+
+	if (lopt) {
+		if (S_ISREG(statbuf.st_mode)) {
+			typech = '-';
+		}
+		else if (S_ISDIR(statbuf.st_mode)) {
+			typech = 'd';
+		}
+		else if (S_ISLNK(statbuf.st_mode)) {
+			typech = 'l';
+		}
+		else if (S_ISCHR(statbuf.st_mode)) {
+			typech = 'c';
+		}
+		else if (S_ISBLK(statbuf.st_mode)) {
+			typech = 'b';
+		}
+		else {
+			typech = '?';
+		}
+
+		printf("%crwx------ %2d root  %-8u",
+		       typech,
+		       statbuf.st_nlink,
+		       statbuf.st_size);
+	}
+	printf("%s\n", file);
+}
+
+/*
+ * List a directory.
+ */
+static
+void
+listdir(const char *path, int showheader)
+{
+	int fd;
+	char buf[1024];
+	char newpath[1024];
+	int len;
+
+	if (showheader) {
+		printheader(path);
+	}
+
+	/*
+	 * Open it.
+	 */
+	fd = open(path, O_RDONLY);
+	if (fd<0) {
+		err(1, "%s", path);
+	}
+
+	/*
+	 * List the directory.
+	 */
+	while ((len = getdirentry(fd, buf, sizeof(buf)-1)) > 0) {
+		buf[len] = 0;
+
+		/* Assemble the full name of the new item */
+		snprintf(newpath, sizeof(newpath), "%s/%s", path, buf);
+
+		if (aopt || buf[0]!='.') {
+			/* Print it */
+			print(newpath);
+		}
+	}
+	if (len<0) {
+		err(1, "%s: getdirentry", path);
+	}
+
+	/* Done */
+	close(fd);
+}
+
+static
+void
+recursedir(const char *path)
+{
+	int fd;
+	char buf[1024];
+	char newpath[1024];
+	int len;
+
+	/*
+	 * Open it.
+	 */
+	fd = open(path, O_RDONLY);
+	if (fd<0) {
+		err(1, "%s", path);
+	}
+
+	/*
+	 * List the directory.
+	 */
+	while ((len = getdirentry(fd, buf, sizeof(buf)-1)) > 0) {
+		buf[len] = 0;
+
+		/* Assemble the full name of the new item */
+		snprintf(newpath, sizeof(newpath), "%s/%s", path, buf);
+
+		if (!aopt && buf[0]=='.') {
+			/* skip this one */
+			continue;
+		}
+
+		if (!strcmp(buf, ".") || !strcmp(buf, "..")) {
+			/* always skip these */
+			continue;
+		}
+
+		if (!isdir(newpath)) {
+			continue;
+		}
+
+		listdir(newpath, 1 /*showheader*/);
+		if (Ropt) {
+			recursedir(newpath);
+		}
+	}
+	if (len<0) {
+		err(1, "%s", path);
+	}
+
+	close(fd);
+}
+
+static
+void
+listitem(const char *path, int showheader)
+{
+	if (!dopt && isdir(path)) {
+		listdir(path, showheader || Ropt);
+		if (Ropt) {
+			recursedir(path);
+		}
+	}
+	else {
+		print(path);
+	}
+}
+
+int
+main(int argc, char *argv[])
+{
+	int i,j, items=0;
+
+	/*
+	 * Go through the arguments and count how many non-option args.
+	 */
+	for (i=1; i<argc; i++) {
+		if (argv[i][0]!='-') {
+			items++;
+		}
+	}
+
+	/*
+	 * Now go through the options for real, processing them.
+	 */
+	for (i=1; i<argc; i++) {
+		if (argv[i][0]=='-') {
+			/*
+			 * This word is an option.
+			 * Process all the option characters in it.
+			 */
+			for (j=1; argv[i][j]; j++) {
+				option(argv[i][j]);
+			}
+		}
+		else {
+			/*
+			 * This word isn't an option; list it.
+			 */
+			listitem(argv[i], items>1);
+		}
+	}
+
+	/*
+	 * If no filenames were specified to list, list the current
+	 * directory.
+	 */
+	if (items==0) {
+		listitem(".", 0);
+	}
+
+	return 0;
+}
diff --git a/os161-1.10/bin/mkdir/.cvsignore b/os161-1.10/bin/mkdir/.cvsignore
new file mode 100644
index 0000000..ed33c5c
--- /dev/null
+++ b/os161-1.10/bin/mkdir/.cvsignore
@@ -0,0 +1 @@
+mkdir
diff --git a/os161-1.10/bin/mkdir/Makefile b/os161-1.10/bin/mkdir/Makefile
new file mode 100644
index 0000000..2b75b2c
--- /dev/null
+++ b/os161-1.10/bin/mkdir/Makefile
@@ -0,0 +1,9 @@
+# Makefile for mkdir
+
+SRCS=mkdir.c
+PROG=mkdir
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/mkdir/depend.mk b/os161-1.10/bin/mkdir/depend.mk
new file mode 100644
index 0000000..42144ef
--- /dev/null
+++ b/os161-1.10/bin/mkdir/depend.mk
@@ -0,0 +1,13 @@
+
+mkdir.o: \
+ mkdir.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/bin/mkdir/mkdir.c b/os161-1.10/bin/mkdir/mkdir.c
new file mode 100644
index 0000000..de4a977
--- /dev/null
+++ b/os161-1.10/bin/mkdir/mkdir.c
@@ -0,0 +1,24 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <err.h>
+
+/*
+ * mkdir - create a directory.
+ * Usage: mkdir DIRECTORY
+ *
+ * Just calls the mkdir() system call.
+ */
+
+int
+main(int argc, char *argv[])
+{
+	if (argc!=2) {
+		errx(1, "Usage: mkdir DIRECTORY");
+	}
+
+	if (mkdir(argv[1], 0775)) {
+		err(1, "%s", argv[1]);
+	}
+	return 0;
+}
diff --git a/os161-1.10/bin/mv/.cvsignore b/os161-1.10/bin/mv/.cvsignore
new file mode 100644
index 0000000..4291d7f
--- /dev/null
+++ b/os161-1.10/bin/mv/.cvsignore
@@ -0,0 +1 @@
+mv
diff --git a/os161-1.10/bin/mv/Makefile b/os161-1.10/bin/mv/Makefile
new file mode 100644
index 0000000..68e1599
--- /dev/null
+++ b/os161-1.10/bin/mv/Makefile
@@ -0,0 +1,9 @@
+# Makefile for mv
+
+SRCS=mv.c
+PROG=mv
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/mv/depend.mk b/os161-1.10/bin/mv/depend.mk
new file mode 100644
index 0000000..c4d1bc8
--- /dev/null
+++ b/os161-1.10/bin/mv/depend.mk
@@ -0,0 +1,11 @@
+
+mv.o: \
+ mv.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/bin/mv/mv.c b/os161-1.10/bin/mv/mv.c
new file mode 100644
index 0000000..19a2df9
--- /dev/null
+++ b/os161-1.10/bin/mv/mv.c
@@ -0,0 +1,35 @@
+#include <unistd.h>
+#include <err.h>
+
+/*
+ * mv - move (rename) files.
+ * Usage: mv oldfile newfile
+ *
+ * Just calls rename() on them. If it fails, we don't attempt to
+ * figure out which filename was wrong or what happened.
+ *
+ * In certain circumstances, Unix mv will fall back to copying and
+ * deleting the old copy. We don't do that.
+ *
+ * We also don't allow the Unix form of
+ *     mv file1 file2 file3 destination-dir
+ */
+
+static
+void
+dorename(const char *oldfile, const char *newfile)
+{
+	if (rename(oldfile, newfile)) {
+		err(1, "%s or %s", oldfile, newfile);
+	}
+}
+
+int
+main(int argc, char *argv[])
+{
+	if (argc!=3) {
+		errx(1, "Usage: mv oldfile newfile");
+	}
+	dorename(argv[1], argv[2]);
+	return 0;
+}
diff --git a/os161-1.10/bin/pwd/.cvsignore b/os161-1.10/bin/pwd/.cvsignore
new file mode 100644
index 0000000..f748bdd
--- /dev/null
+++ b/os161-1.10/bin/pwd/.cvsignore
@@ -0,0 +1 @@
+pwd
diff --git a/os161-1.10/bin/pwd/Makefile b/os161-1.10/bin/pwd/Makefile
new file mode 100644
index 0000000..14e5ce1
--- /dev/null
+++ b/os161-1.10/bin/pwd/Makefile
@@ -0,0 +1,9 @@
+# Makefile for pwd
+
+SRCS=pwd.c
+PROG=pwd
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/pwd/depend.mk b/os161-1.10/bin/pwd/depend.mk
new file mode 100644
index 0000000..41dba83
--- /dev/null
+++ b/os161-1.10/bin/pwd/depend.mk
@@ -0,0 +1,15 @@
+
+pwd.o: \
+ pwd.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/limits.h \
+ $(OSTREE)/include/kern/limits.h
diff --git a/os161-1.10/bin/pwd/pwd.c b/os161-1.10/bin/pwd/pwd.c
new file mode 100644
index 0000000..2233d27
--- /dev/null
+++ b/os161-1.10/bin/pwd/pwd.c
@@ -0,0 +1,26 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <err.h>
+#include <limits.h>
+
+/*
+ * pwd - print working directory.
+ * Usage: pwd
+ *
+ * Just uses the getcwd library call (which in turn uses the __getcwd
+ * system call.)
+ */
+
+int
+main()
+{
+	char buf[PATH_MAX+1], *p;
+
+	p = getcwd(buf, sizeof(buf));
+	if (p == NULL) {
+		err(1, ".");
+	}
+	printf("%s\n", buf);
+	return 0;
+}
diff --git a/os161-1.10/bin/rm/.cvsignore b/os161-1.10/bin/rm/.cvsignore
new file mode 100644
index 0000000..80aaf07
--- /dev/null
+++ b/os161-1.10/bin/rm/.cvsignore
@@ -0,0 +1 @@
+rm
diff --git a/os161-1.10/bin/rm/Makefile b/os161-1.10/bin/rm/Makefile
new file mode 100644
index 0000000..7705ab4
--- /dev/null
+++ b/os161-1.10/bin/rm/Makefile
@@ -0,0 +1,9 @@
+# Makefile for rm
+
+SRCS=rm.c
+PROG=rm
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/rm/depend.mk b/os161-1.10/bin/rm/depend.mk
new file mode 100644
index 0000000..62d6177
--- /dev/null
+++ b/os161-1.10/bin/rm/depend.mk
@@ -0,0 +1,11 @@
+
+rm.o: \
+ rm.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/bin/rm/rm.c b/os161-1.10/bin/rm/rm.c
new file mode 100644
index 0000000..c2a0f46
--- /dev/null
+++ b/os161-1.10/bin/rm/rm.c
@@ -0,0 +1,35 @@
+#include <unistd.h>
+#include <err.h>
+
+/*
+ * rm - remove (delete) files
+ * Usage: rm file...
+ */
+
+/* Delete a single file. */
+static
+void
+doremove(const char *file)
+{
+	if (remove(file)) {
+		err(1, "%s", file);
+	}
+}
+
+int
+main(int argc, char *argv[])
+{
+	int i;
+
+	if (argc<2) {
+		/* Must have at least one file. */
+		errx(1, "Usage: rm FILES");
+	}
+
+	/* Just delete everything on the command line. */
+	for (i=1; i<argc; i++) {
+		doremove(argv[i]);
+	}
+
+	return 0;
+}
diff --git a/os161-1.10/bin/rmdir/.cvsignore b/os161-1.10/bin/rmdir/.cvsignore
new file mode 100644
index 0000000..40b2aae
--- /dev/null
+++ b/os161-1.10/bin/rmdir/.cvsignore
@@ -0,0 +1 @@
+rmdir
diff --git a/os161-1.10/bin/rmdir/Makefile b/os161-1.10/bin/rmdir/Makefile
new file mode 100644
index 0000000..242fe78
--- /dev/null
+++ b/os161-1.10/bin/rmdir/Makefile
@@ -0,0 +1,9 @@
+# Makefile for rmdir
+
+SRCS=rmdir.c
+PROG=rmdir
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/rmdir/depend.mk b/os161-1.10/bin/rmdir/depend.mk
new file mode 100644
index 0000000..f361720
--- /dev/null
+++ b/os161-1.10/bin/rmdir/depend.mk
@@ -0,0 +1,11 @@
+
+rmdir.o: \
+ rmdir.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/bin/rmdir/rmdir.c b/os161-1.10/bin/rmdir/rmdir.c
new file mode 100644
index 0000000..bbeebce
--- /dev/null
+++ b/os161-1.10/bin/rmdir/rmdir.c
@@ -0,0 +1,22 @@
+#include <unistd.h>
+#include <err.h>
+
+/*
+ * rmdir - remove a directory
+ * Usage: rmdir DIRECTORY
+ *
+ * Just calls the rmdir() system call.
+ */
+
+int
+main(int argc, char *argv[])
+{
+	if (argc!=2) {
+		errx(1, "Usage: rmdir DIRECTORY");
+	}
+
+	if (rmdir(argv[1])) {
+		err(1, "%s", argv[1]);
+	}
+	return 0;
+}
diff --git a/os161-1.10/bin/sh/.cvsignore b/os161-1.10/bin/sh/.cvsignore
new file mode 100644
index 0000000..2948747
--- /dev/null
+++ b/os161-1.10/bin/sh/.cvsignore
@@ -0,0 +1,3 @@
+sh
+host-sh
+*.ho
diff --git a/os161-1.10/bin/sh/Makefile b/os161-1.10/bin/sh/Makefile
new file mode 100644
index 0000000..9244c92
--- /dev/null
+++ b/os161-1.10/bin/sh/Makefile
@@ -0,0 +1,9 @@
+# Makefile for sh
+
+SRCS=sh.c
+PROG=sh
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+include ../../mk/hostprog.mk
diff --git a/os161-1.10/bin/sh/depend.mk b/os161-1.10/bin/sh/depend.mk
new file mode 100644
index 0000000..db813ac
--- /dev/null
+++ b/os161-1.10/bin/sh/depend.mk
@@ -0,0 +1,3 @@
+
+sh.o: \
+ sh.c
diff --git a/os161-1.10/bin/sh/dependh.mk b/os161-1.10/bin/sh/dependh.mk
new file mode 100644
index 0000000..325543a
--- /dev/null
+++ b/os161-1.10/bin/sh/dependh.mk
@@ -0,0 +1,4 @@
+
+sh.ho: \
+ sh.c \
+ $(OSTREE)/hostinclude/hostcompat.h
diff --git a/os161-1.10/bin/sh/sh.c b/os161-1.10/bin/sh/sh.c
new file mode 100644
index 0000000..cf5adb2
--- /dev/null
+++ b/os161-1.10/bin/sh/sh.c
@@ -0,0 +1,23 @@
+/*
+ * sh - shell
+ * Usage: up to you
+ */
+
+#ifdef HOST
+#include "hostcompat.h"
+#endif
+
+int
+main(int argc, char *argv[])
+{
+#ifdef HOST
+	hostcompat_init(argc, argv);
+#endif
+
+	/* Write this */
+
+	(void)argc;
+	(void)argv;
+
+	return 1;
+}
diff --git a/os161-1.10/bin/sync/.cvsignore b/os161-1.10/bin/sync/.cvsignore
new file mode 100644
index 0000000..def1d9c
--- /dev/null
+++ b/os161-1.10/bin/sync/.cvsignore
@@ -0,0 +1 @@
+sync
diff --git a/os161-1.10/bin/sync/Makefile b/os161-1.10/bin/sync/Makefile
new file mode 100644
index 0000000..a74a073
--- /dev/null
+++ b/os161-1.10/bin/sync/Makefile
@@ -0,0 +1,9 @@
+# Makefile for sync
+
+SRCS=sync.c
+PROG=sync
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/sync/depend.mk b/os161-1.10/bin/sync/depend.mk
new file mode 100644
index 0000000..4f79baa
--- /dev/null
+++ b/os161-1.10/bin/sync/depend.mk
@@ -0,0 +1,9 @@
+
+sync.o: \
+ sync.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
diff --git a/os161-1.10/bin/sync/sync.c b/os161-1.10/bin/sync/sync.c
new file mode 100644
index 0000000..218f66e
--- /dev/null
+++ b/os161-1.10/bin/sync/sync.c
@@ -0,0 +1,14 @@
+#include <unistd.h>
+
+/*
+ * sync - force kernel buffers (write-back disk cache) to disk.
+ *
+ * Just calls the sync() system call.
+ */
+
+int
+main()
+{
+	sync();
+	return 0;
+}
diff --git a/os161-1.10/bin/true/.cvsignore b/os161-1.10/bin/true/.cvsignore
new file mode 100644
index 0000000..27ba77d
--- /dev/null
+++ b/os161-1.10/bin/true/.cvsignore
@@ -0,0 +1 @@
+true
diff --git a/os161-1.10/bin/true/Makefile b/os161-1.10/bin/true/Makefile
new file mode 100644
index 0000000..4a9e1fe
--- /dev/null
+++ b/os161-1.10/bin/true/Makefile
@@ -0,0 +1,9 @@
+# Makefile for true
+
+SRCS=true.c
+PROG=true
+BINDIR=/bin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/bin/true/depend.mk b/os161-1.10/bin/true/depend.mk
new file mode 100644
index 0000000..1fd4de7
--- /dev/null
+++ b/os161-1.10/bin/true/depend.mk
@@ -0,0 +1,10 @@
+
+true.o: \
+ true.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdlib.h
diff --git a/os161-1.10/bin/true/true.c b/os161-1.10/bin/true/true.c
new file mode 100644
index 0000000..f054c18
--- /dev/null
+++ b/os161-1.10/bin/true/true.c
@@ -0,0 +1,13 @@
+#include <unistd.h>
+#include <stdlib.h>
+
+/*
+ * true - succeed.
+ */
+
+int
+main()
+{
+	/* Just exit with success. */
+	exit(0);
+}
diff --git a/os161-1.10/configure b/os161-1.10/configure
new file mode 100755
index 0000000..f222a4f
--- /dev/null
+++ b/os161-1.10/configure
@@ -0,0 +1,387 @@
+#!/bin/sh
+#
+# Configure script for OS/161 tree.
+# This generates the file "defs.mk" at the top level of the tree.
+#
+# Usage: ./configure [options]
+#   where you can get a list of the options by doing ./configure --help.
+#
+# Must be run with the top of the OS/161 tree as its current directory.
+#
+# Note: while this superficially acts like a GNU Autoconf configure
+# script, it was not generated by autoconf. Scripts generated by 
+# autoconf are much harder to read. :-)
+#
+
+
+# gcc warnings to use.
+# (If you change this, rerun the script to propagate it to defs.mk.)
+# -Werror will be added if the --werror argument is given.
+WARNINGS='-Wall -W -Wwrite-strings'
+
+# Target hardware platform.
+PLATFORM='mips'
+
+# Default optimize/debug flag: optimize.
+OPTFLAGS='-O2'
+
+# Default location of the root of the installed system.
+# Note that we quote it such that the reference to the home directory
+# is a make variable, not a shell variable. This means it gets expanded
+# when make runs rather than when this script runs.
+OSTREE='$(HOME)/cs161/root'
+
+# Default toolchain name.
+TOOLPREFIX="cs161-" 
+
+##################################################
+
+#
+# Check to make sure we're in the right place.
+
+if [ ! -d kern/userprog ]; then
+    echo 'Please run configure from the top of the OS/161 tree.'
+    exit 1
+fi
+
+#
+# Process the command-line options.
+
+while [ "x$1" != x ]; do
+    case "$1" in
+	--debug) OPTFLAGS='-g';;
+	--werror|--Werror) WARNINGS="$WARNINGS -Werror";;
+	--ostree=*) OSTREE=`echo $1 | sed 's,^[^=]*=,,'`;;
+	--toolprefix=*) TOOLPREFIX=`echo $1 | sed 's,^[^=]*=,,'`;;
+	--help|*)
+		more <<EOF
+Usage: ./configure [options]
+  where the options are:
+    --help               Print this message.
+
+    --debug              Compile the user-level programs with debug info.
+                         This is disabled by default because there's no
+                         support for userlevel source debugging in OS/161.
+                         (Note: debug info in the kernel is controlled by
+                         the kernel config file.)
+
+    --werror             Compile with -Werror, so that compiler warnings 
+                         are turned into errors and cause the build to
+			 stop. Recommended, because on long builds you 
+                         don't always notice warnings as they go by, but
+                         disabled by default.
+
+    --ostree=PATH        Install the compiled system in a directory tree
+                         rooted at PATH. Default is \$HOME/cs161/root.
+
+    --toolprefix=NAME    Set up to use compiler and tools named with a
+                         prefix of NAME. The default is "cs161-", so the
+                         tools used are called cs161-gcc, cs161-ld, etc.
+                         The directory with these tools should be on your
+                         shell's search path.
+EOF
+    exit
+    ;;
+    esac
+shift
+done
+
+####################
+
+# Assume gcc on the host. It would be nice to probe this, but for now
+# it doesn't seem worthwhile.
+
+HOST_CC=gcc
+
+####################
+
+# Figure out if the host system needs us to use ranlib or not. Assume
+# that if it exists, we should use it. This is a bad assumption on
+# BSD/OS 2.1, but hopefully that won't come up, as BSD/OS 2.1 is quite
+# out of date now.
+
+echo -n 'Checking for ranlib... '
+
+STUFF=`(ranlib) 2>&1`
+
+if echo $STUFF | grep 'not found' >/dev/null 2>&1; then
+    echo 'no'
+    HOST_RANLIB=true
+else
+    echo 'yes'
+    HOST_RANLIB=ranlib
+fi
+
+
+####################
+
+# Check if the host system supports 4.4BSD <err.h>.
+
+echo -n "Checking for <err.h>... "
+
+cat > __conftest.c <<EOF
+#include <err.h>
+int
+main()
+{
+    err(0, "works");
+    return 1;
+}
+EOF
+
+OK=0
+if $HOST_CC __conftest.c -o __conftest >/dev/null 2>&1; then
+    if ./__conftest >/dev/null 2>&1; then
+	OK=1
+    fi
+fi
+
+rm -f __conf*
+
+if [ $OK = 1 ]; then
+    echo 'yes'
+else
+    echo 'no'
+    COMPAT_CFLAGS="${COMPATCFLAGS} -DNEED_ERR"
+    COMPAT_TARGETS="${HOSTTARGETS} install-errh"
+fi
+
+####################
+
+# Now generate defs.mk.
+
+echo 'Generating defs.mk.'
+
+(
+    # First, put an explanatory comment at the top.
+    cat <<EOF
+# This file was generated by configure. Edits will disappear if you rerun
+# configure. If you find that you need to edit this file to make things
+# work, let the course staff know and we'll try to fix the configure script.
+#
+# 
+# The purpose of this file is to hold all the makefile definitions
+# needed to adjust the OS/161 build process to any particular
+# environment. If I've done it right, all you need to do is rerun the
+# configure script and make clean if you decide to work from Linux or
+# BSD instead of Digital Unix. If I've done it mostly right, you may
+# need to edit this file but you still hopefully won't need to edit
+# any of the makefiles.
+#
+
+EOF
+    # Initialize various variables.
+cat <<EOF
+
+#
+# Initialize various variables that we set only with += in case some make
+# has a default value we weren't expecting.
+#
+CFLAGS=
+KCFLAGS=
+HOST_CFLAGS=
+LDFLAGS=
+KLDFLAGS=
+HOST_LDFLAGS=
+LIBS=
+HOST_LIBS=
+
+EOF
+
+    # Define OSTREE.
+
+cat <<EOF
+#
+# Location of installed runnable system tree.
+#
+# This must be an absolute path, because it is used from different
+# levels of the source tree.
+#
+OSTREE=${OSTREE}
+
+EOF
+
+    # Define PLATFORM.
+cat <<EOF
+#
+# Name of the platform we're building OS/161 to run on.
+#
+PLATFORM=${PLATFORM}
+
+EOF
+
+if [ "x$PLATFORM" = xmips ]; then
+cat <<EOF
+#
+# As of cs161-toolchain-1.2 the MIPS toolchain is a mips-linux one
+# that generates more or less SVR4 ELF ABI compliant code. This means
+# that by default all code is PIC (position-independent code), which
+# is all very well but not what we want. So we use -fno-pic to turn
+# this behavior off. It turns out you need -mno-abicalls too to turn
+# it off completely.
+#
+CFLAGS+=-mno-abicalls -fno-pic
+KCFLAGS+=-mno-abicalls -fno-pic
+
+# If using an older cs161-toolchain for MIPS, you'll need this instead:
+#LDFLAGS+=-Ttext 0x1000
+EOF
+fi
+
+    # Long explanatory comment about the two sets of compiler tools.
+    cat <<EOF
+#
+# Because OS/161 runs on one architecture (probably MIPS or ANT32) and
+# is compiled on another (probably Alpha or i386) it is important to
+# make sure the right compiler (and assembler, linker, etc.) is used
+# at every point.
+#
+# A compiler compiles *running on* one platform, and *generates code*
+# that may run on a different platform. Thus, supposing that you are 
+# building MIPS OS/161 on i386 Linux, there are four possible compilers.
+# (If you are building some other OS/161 or building on some other
+# platform, make the appropriate substitutions.) These four are:
+#
+#    (1) runs on i386 Linux, generates code for i386 Linux
+#    (2) runs on i386 Linux, generates code for MIPS OS/161
+#    (3) runs on MIPS OS/161, generates code for i386 Linux
+#    (4) runs on MIPS OS/161, generates code for MIPS OS/161
+#
+# Note that when building on i386 Linux, there is no use for a
+# compiler that runs on MIPS OS/161; you can't run it. Thus cases
+# (3) and (4) do not interest us.
+#
+# However, in the course of the build, there are places where it is
+# necessary to compile and run programs on the machine the build is
+# happening on. Thus, the makefiles need to be able to access *both*
+# compiler (1) and compiler (2).
+#
+# We do this by defining the make variable CC to be the common case,
+# compiler (2), and the make variable HOST_CC to be compiler (1). 
+# Similar variables are defined for the other bits of the toolchain,
+# like AS (assembler), LD (linker), and SIZE (size program).
+#
+# Then, programs to be run during the build can be compiled with 
+# HOST_CC, and components of the system can be built with CC.
+#
+
+EOF
+
+    # define CC, LDCC, AS, LD, AR, RANLIB, SIZE, STRIP,
+    # the tools for building OS/161.
+
+    cat <<EOF
+
+# CC: compiler, when compiling to object files
+CC=${TOOLPREFIX}gcc 
+# LDCC: compiler, when linking
+LDCC=${TOOLPREFIX}gcc
+# AS: assembler.
+AS=${TOOLPREFIX}as
+# LD: linker
+LD=${TOOLPREFIX}ld
+# AR: archiver (librarian)
+AR=${TOOLPREFIX}ar
+# RANLIB: library postprocessor
+RANLIB=${TOOLPREFIX}ranlib
+# NM: prints symbol tables
+NM=${TOOLPREFIX}nm
+# SIZE: prints size of binaries
+SIZE=${TOOLPREFIX}size
+# STRIP: strips debug info
+STRIP=${TOOLPREFIX}strip
+
+EOF
+
+    # define HOST_CC, HOST_LDCC, HOST_AS, HOST_LD, HOST_AR, HOST_RANLIB,
+    # HOST_NM, HOST_SIZE, HOST_STRIP, the tools for building programs 
+    # that run on the host system.
+
+cat <<EOF
+
+# compiler for host system
+HOST_CC=${HOST_CC}
+
+# compiler for host system, when linking
+HOST_LDCC=${HOST_CC}
+
+# assembler for host system
+HOST_AS=as
+
+# linker for host system
+HOST_LD=ld
+
+# archiver (librarian) for host system
+HOST_AR=ar
+
+# ranlib (library postprocessor) for host system... or "true" to skip it
+HOST_RANLIB=${HOST_RANLIB}
+
+# nm for host system
+HOST_NM=nm
+
+# size for host system
+HOST_SIZE=size
+
+# strip for host system
+HOST_STRIP=strip
+
+EOF
+
+    # Define compiler and linker flags we're going to use based on the
+    # requests above.
+
+    # This keeps the shell from interpreting the $() inside the here-document.
+    HINC='-I$(OSTREE)/hostinclude'
+
+    cat <<EOF
+
+# The HOST_... versions are for compiling/linking for the host system.
+# The K... versions are for the kernel build. 
+
+# Compile flags. 
+# The kernel has its own debug/optimize setting in the kernel config, so
+# we don't include ours.
+CFLAGS+=${WARNINGS} ${OPTFLAGS}
+KCFLAGS+=${WARNINGS}
+HOST_CFLAGS+=${WARNINGS} ${OPTFLAGS} ${HINC}
+
+# Linker flags
+LDFLAGS+=
+KLDFLAGS+=
+HOST_LDFLAGS+=
+
+# Libraries
+# 
+LIBS+=
+HOST_LIBS+=
+
+EOF
+
+    # Config information for the hostcompat library
+    cat <<EOF
+
+# These are cflags used to conditionally compile src/lib/hostcompat.
+COMPAT_CFLAGS=${COMPAT_CFLAGS}
+
+# These are make targets that we conditionally enable when installing
+# in src/lib/hostcompat.
+COMPAT_TARGETS=${COMPAT_TARGETS}
+
+EOF
+
+    # Define additional flags for making the toolchain do what we want.
+    cat <<EOF
+
+# When we compile OS/161 programs, we want to use the OS/161 header files
+# and libraries. By default, gcc will look in some include directory and
+# some lib directory that it was told to use when it was compiled. We 
+# assume that directory isn't ours. (If it is, all these variables can
+# be set to empty, but everything will still work if you don't.)
+EOF
+echo 'TREE_CFLAGS=-nostdinc -I$(OSTREE)/include'
+echo 'TREE_LDFLAGS=-nostdlib -L$(OSTREE)/lib $(OSTREE)/lib/crt0.o'
+echo 'TREE_LIBS=-lc'
+
+) > defs.mk
+
diff --git a/os161-1.10/defs.mk.sample b/os161-1.10/defs.mk.sample
new file mode 100644
index 0000000..0740a14
--- /dev/null
+++ b/os161-1.10/defs.mk.sample
@@ -0,0 +1,190 @@
+# This is a sample defs.mk, based on one generated by configure. 
+# If configure screws up or won't do what you want (it's not very flexible),
+# copy this file over the defs.mk it generated and edit as necessary.
+
+# 
+# The purpose of this file is to hold all the makefile definitions
+# needed to adjust the OS/161 build process to any particular
+# environment. Hopefully, even if you need to use it and edit by hand,
+# you still won't need to edit any of the other makefiles when changing
+# environments. Do remember to make clean if you change environments 
+# though.
+#
+
+#
+# Initialize various variables that we set only with += in case some make
+# has a default value we weren't expecting.
+#
+CFLAGS=
+KCFLAGS=
+HOST_CFLAGS=
+LDFLAGS=
+KLDFLAGS=
+HOST_LDFLAGS=
+LIBS=
+HOST_LIBS=
+
+#
+# Location of installed runnable system tree.
+#
+# This must be an absolute path, because it is used from different
+# levels of the source tree.
+#
+OSTREE=$(HOME)/cs161/root
+
+#
+# Name of the platform we're building OS/161 to run on.
+#
+PLATFORM=mips
+
+#
+# As of cs161-toolchain-1.2 the MIPS toolchain is a mips-linux one
+# that generates more or less SVR4 ELF ABI compliant code. This means
+# that by default all code is PIC (position-independent code), which
+# is all very well but not what we want. So we use -fno-pic to turn
+# this behavior off. It turns out you need -mno-abicalls too to turn
+# it off completely.
+#
+# Comment this out if not on MIPS.
+#
+CFLAGS+=-mno-abicalls -fno-pic
+KCFLAGS+=-mno-abicalls -fno-pic
+
+# If using an older cs161 MIPS toolchain, you'll need this instead:
+#LDFLAGS+=-Ttext 0x1000
+
+#
+# Because OS/161 runs on one architecture (probably MIPS or ANT32) and
+# is compiled on another (probably Alpha or i386) it is important to
+# make sure the right compiler (and assembler, linker, etc.) is used
+# at every point.
+#
+# A compiler compiles *running on* one platform, and *generates code*
+# that may run on a different platform. Thus, supposing that you are 
+# building MIPS OS/161 on i386 Linux, there are four possible compilers.
+# (If you are building some other OS/161 or building on some other
+# platform, make the appropriate substitutions.) These four are:
+#
+#    (1) runs on i386 Linux, generates code for i386 Linux
+#    (2) runs on i386 Linux, generates code for MIPS OS/161
+#    (3) runs on MIPS OS/161, generates code for i386 Linux
+#    (4) runs on MIPS OS/161, generates code for MIPS OS/161
+#
+# Note that when building on i386 Linux, there is no use for a
+# compiler that runs on MIPS OS/161; you can't run it. Thus cases
+# (3) and (4) do not interest us.
+#
+# However, in the course of the build, there are places where it is
+# necessary to compile and run programs on the machine the build is
+# happening on. Thus, the makefiles need to be able to access *both*
+# compiler (1) and compiler (2).
+#
+# We do this by defining the make variable CC to be the common case,
+# compiler (2), and the make variable HOST_CC to be compiler (1). 
+# Similar variables are defined for the other bits of the toolchain,
+# like AS (assembler), LD (linker), and SIZE (size program).
+#
+# Then, programs to be run during the build can be compiled with 
+# HOST_CC, and components of the system can be built with CC.
+#
+
+# The default names are cs161-gcc, cs161-ld, etc. These are the ones
+# installed in ~lib161/usr. If you compile your own copies, they may
+# be named something else, such as sde-gcc, mips-linux-gcc, etc.
+TOOL=cs161-
+
+# CC: compiler, when compiling to object files
+CC=$(TOOL)gcc 
+
+# LDCC: compiler, when linking.
+LDCC=$(TOOL)gcc
+
+# AS: assembler.
+AS=$(TOOL)as
+
+# LD: linker
+LD=$(TOOL)ld
+
+# AR: archiver (librarian)
+AR=$(TOOL)ar
+
+# RANLIB: library postprocessor
+RANLIB=$(TOOL)ranlib
+
+# SIZE: prints size of binaries
+SIZE=$(TOOL)size
+
+# STRIP: strips debug info
+STRIP=$(TOOL)strip
+
+
+# compiler for host system
+HOST_CC=gcc
+
+# compiler for host system, when linking
+HOST_LDCC=gcc
+
+# assembler for host system
+HOST_AS=as
+
+# linker for host system
+HOST_LD=ld
+
+# archiver (librarian) for host system
+HOST_AR=ar
+
+# ranlib (library postprocessor) for host system... or "true" to skip it
+HOST_RANLIB=ranlib
+
+# size for host system
+HOST_SIZE=size
+
+# strip for host system
+HOST_STRIP=strip
+
+
+
+WARNINGS=-Wall -W -Wwrite-strings
+# This will make the build stop on warnings, instead of letting them scroll
+# by and get missed. Recommended, but turned off by default because it can
+# be annoying.
+#WARNINGS+=-Werror
+
+# The HOST_... versions are for compiling/linking for the host system.
+# The K... versions are for the kernel build. 
+
+# Compile flags. 
+# The kernel has its own debug/optimize setting in the kernel config, so
+# we don't include -O2.
+CFLAGS+=$(WARNINGS) -O2
+KCFLAGS+=$(WARNINGS)
+HOST_CFLAGS+=$(WARNINGS) -O2 -I$(OSTREE)/hostinclude
+
+# Linker flags
+LDFLAGS+=
+KLDFLAGS+=
+HOST_LDFLAGS+=
+
+# Libraries
+# 
+LIBS+=
+HOST_LIBS+=
+
+
+# If your host system doesn't support the 4.4BSD <err.h> and its
+# functions (err, errx, warn, warnx, verr, verrx, vwarn, vwarnx),
+# uncomment the next two lines.
+#COMPAT_CFLAGS+=-DNEED_ERR
+#COMPAT_TARGETS+=install_errh
+
+
+# When we compile OS/161 programs, we want to use the OS/161 header files
+# and libraries. By default, gcc will look in some include directory and
+# some lib directory that it was told to use when it was compiled. 
+#
+# If that directory isn't our OSTREE, leave these alone. If it is,
+# you can comment them out.
+TREE_CFLAGS=-nostdinc -I$(OSTREE)/include
+TREE_LDFLAGS=-nostdlib -L$(OSTREE)/lib $(OSTREE)/lib/crt0.o
+TREE_LIBS=-lc
+
diff --git a/os161-1.10/include/Makefile b/os161-1.10/include/Makefile
new file mode 100644
index 0000000..1218e9d
--- /dev/null
+++ b/os161-1.10/include/Makefile
@@ -0,0 +1,54 @@
+#
+# Makefile for OS/161 user-level include files.
+#
+
+include ../defs.mk
+
+# The place include files go.
+INCDIR=$(OSTREE)/include
+
+# 
+# [ -d $(INCDIR) ] succeeds if $(INCDIR) is a directory.
+# (See test(1).) Thus, if $(INCDIR) doesn't exist, it will be
+# created.
+#
+# The -p option to mkdir causes it to create any missing levels
+# of intermediate directories.
+#
+# All *.h files are installed, as are those in the subdirectory "sys".
+#
+# (Traditionally in Unix, the "sys" include files are the ones that
+# come from the kernel, like kern/*.h in OS/161. Unfortunately, some
+# poor design decisions put a bunch of user-level declarations in
+# various sys/*.h headers, and now many those header names are fixed
+# by standards committees and defined to have various user-level
+# things in them. So nowadays, if you are being properly careful to
+# separate userland from the kernel, you end up with sys/*.h belonging
+# to userland and kernel headers going elsewhere.)
+#
+# To avoid causing huge numbers of unnecessary recompiles, we don't
+# install header files unless they're actually different.
+#
+includes:
+	[ -d $(INCDIR) ] || mkdir -p $(INCDIR)
+	[ -d $(INCDIR)/sys ] || mkdir -p $(INCDIR)/sys
+	@echo "Installing library includes..."
+	@for h in *.h sys/*.h; do \
+		if diff $$h $(OSTREE)/include/$$h >/dev/null 2>&1; then \
+			true; \
+		else \
+			echo "Installing $$h"; \
+			cp $$h $(OSTREE)/include/$$h; \
+	        fi; \
+	done
+
+install tags depend:;
+
+clean:
+	rm -f *~ */*~
+
+#
+# This tells make that includes, install, depend, and clean are not files
+# so it (hopefully) won't become confused if files by those names appear.
+#
+.PHONY: includes install depend clean
diff --git a/os161-1.10/include/assert.h b/os161-1.10/include/assert.h
new file mode 100644
index 0000000..157242d
--- /dev/null
+++ b/os161-1.10/include/assert.h
@@ -0,0 +1,36 @@
+#ifndef _ASSERT_H_
+#define _ASSERT_H_
+
+/*
+ * Required by ANSI
+ */
+#undef assert
+
+/*
+ * Function to call when an assert fails.
+ */
+void __bad_assert(const char *file, int line, const char *msg);
+
+/*
+ * Asserts are only "on" if NDEBUG isn't set. (This is standard C.)
+ *
+ * If asserts are off, we retain the expression but ignore it by
+ * casting it to void. If the expression has no side-effects, or is
+ * constant, this should generate no code. On the other hand, if it
+ * has side effects, the side effects are preserved. This way if you
+ * write 
+ *         assert(myfunc() == 0);
+ *
+ * to check that myfunc() didn't fail, turning off asserts will not
+ * cause a bug by causing the call to evaporate. Note that this
+ * behavior is not standard and should not be relied upon.
+ */
+
+#ifdef NDEBUG
+#define assert(x) ((void)(x))
+#else
+#define assert(x) ((x) ? (void)0 : __bad_assert(__FILE__, __LINE__, #x))
+#endif
+
+
+#endif /* _ASSERT_H_ */
diff --git a/os161-1.10/include/err.h b/os161-1.10/include/err.h
new file mode 100644
index 0000000..730db35
--- /dev/null
+++ b/os161-1.10/include/err.h
@@ -0,0 +1,28 @@
+#ifndef _ERR_H_
+#define _ERR_H_
+
+#include <stdarg.h>
+
+/*
+ * 4.4BSD error-printing functions.
+ *
+ * These print the program name and the supplied message, and
+ * (non-*x versions only) the string for the error currently
+ * stored in "errno", and a newline. The err* versions then
+ * exit with the supplied exitcode.
+ *
+ * The v* versions are to the non-v* versions like vprintf is to
+ * printf.
+ */
+
+void warn(const char *fmt, ...);
+void warnx(const char *fmt, ...);
+void err(int exitcode, const char *fmt, ...);
+void errx(int exitcode, const char *fmt, ...);
+
+void vwarn(const char *fmt, va_list);
+void vwarnx(const char *fmt, va_list);
+void verr(int exitcode, const char *fmt, va_list);
+void verrx(int exitcode, const char *fmt, va_list);
+
+#endif /* _ERR_H_ */
diff --git a/os161-1.10/include/errno.h b/os161-1.10/include/errno.h
new file mode 100644
index 0000000..f338376
--- /dev/null
+++ b/os161-1.10/include/errno.h
@@ -0,0 +1,10 @@
+#ifndef _ERRNO_H_
+#define _ERRNO_H_
+
+/* Get the error codes from the kernel. */
+#include <kern/errno.h>
+
+/* Declare the standard global variable errno. */
+extern int errno;
+
+#endif /* _ERRNO_H_ */
diff --git a/os161-1.10/include/fcntl.h b/os161-1.10/include/fcntl.h
new file mode 100644
index 0000000..fd4a86e
--- /dev/null
+++ b/os161-1.10/include/fcntl.h
@@ -0,0 +1,2 @@
+/* This file is for UNIX compat. In OS/161, everything's in <unistd.h> */
+#include <unistd.h>
diff --git a/os161-1.10/include/limits.h b/os161-1.10/include/limits.h
new file mode 100644
index 0000000..5c75bdc
--- /dev/null
+++ b/os161-1.10/include/limits.h
@@ -0,0 +1,2 @@
+/* Get the limits the kernel exports. libc doesn't have any limits :-) */ 
+#include <kern/limits.h>
diff --git a/os161-1.10/include/setjmp.h b/os161-1.10/include/setjmp.h
new file mode 100644
index 0000000..1a03bfd
--- /dev/null
+++ b/os161-1.10/include/setjmp.h
@@ -0,0 +1,23 @@
+#ifndef _SETJMP_H_
+#define _SETJMP_H_
+
+/* Get the (machine-dependent) definition of jmp_buf. */
+#include <machine/setjmp.h>
+
+/*
+ * Functions.
+ *
+ * setjmp saves the current processor state in the jmp_buf and 
+ * returns 0. A subsequent call to longjmp with the same jmp_buf
+ * causes execution to return to where setjmp was called. setjmp
+ * returns a second time, this time returning CODE. (If CODE is
+ * 0, it is forced to 1.)
+ *
+ * If the stack frame that called setjmp returns before longjmp is
+ * called, the results are undefined. 
+ */
+
+int setjmp(jmp_buf jb);
+void longjmp(jmp_buf jb, int code);
+
+#endif /* _SETJMP_H_ */
diff --git a/os161-1.10/include/stdarg.h b/os161-1.10/include/stdarg.h
new file mode 100644
index 0000000..610ef80
--- /dev/null
+++ b/os161-1.10/include/stdarg.h
@@ -0,0 +1,18 @@
+#ifndef _STDARG_H_
+#define _STDARG_H_
+
+/*
+ * As of gcc 3.0, the stdarg declarations can be made
+ * machine-independent because gcc abstracts the implementations away
+ * for us.
+ */
+
+typedef __builtin_va_list __va_list;
+typedef __va_list va_list;
+
+#define va_start(ap,fmt) __builtin_stdarg_start(ap,fmt)
+#define va_arg(ap,t) __builtin_va_arg(ap,t)
+#define va_copy(ap1,ap2) __builtin_va_copy(ap1,ap2)
+#define va_end(ap) __builtin_va_end(ap)
+
+#endif /* _STDARG_H_ */
diff --git a/os161-1.10/include/stdio.h b/os161-1.10/include/stdio.h
new file mode 100644
index 0000000..e72eea2
--- /dev/null
+++ b/os161-1.10/include/stdio.h
@@ -0,0 +1,42 @@
+#ifndef _STDIO_H_
+#define _STDIO_H_
+
+/*
+ * According to ANSI C we are not supposed to do this, but we're not 
+ * exactly ANSI-compliant anyway.
+ */
+#include <sys/types.h>
+#include <stdarg.h>
+
+/* Constant returned by a bunch of stdio functions on error */
+#define EOF (-1)
+
+/*
+ * The actual guts of printf
+ * (for libc internal use only)
+ */
+int __vprintf(void (*sendfunc)(void *clientdata, const char *, size_t len),
+	      void *clientdata,
+	      const char *fmt,
+	      __va_list ap);
+
+/* Printf calls for user programs */
+int printf(const char *fmt, ...);
+int vprintf(const char *fmt, __va_list ap);
+int snprintf(char *buf, size_t len, const char *fmt, ...);
+int vsnprintf(char *buf, size_t len, const char *fmt, __va_list ap);
+
+/* Print the argument string and then a newline. Returns 0 or -1 on error. */
+int puts(const char *);
+
+/* Like puts, but without the newline. Returns #chars written. */
+/* Nonstandard C, hence the __. */
+int __puts(const char *);
+
+/* Writes one character. Returns it. */
+int putchar(int);
+
+/* Reads one character (0-255) or returns EOF on error. */
+int getchar(void);
+
+#endif /* _STDIO_H_ */
diff --git a/os161-1.10/include/stdlib.h b/os161-1.10/include/stdlib.h
new file mode 100644
index 0000000..7c5bbbc
--- /dev/null
+++ b/os161-1.10/include/stdlib.h
@@ -0,0 +1,40 @@
+#ifndef _STDLIB_H_
+#define _STDLIB_H_
+
+#include <sys/types.h>
+
+/*
+ * Ascii to integer - turn a string holding a number into a number.
+ */
+int atoi(const char *);
+
+/*
+ * Standard routine to bail out of a program in a severe error condition.
+ */
+void abort(void);
+
+/*
+ * Routine to exit cleanly.
+ * (This does libc cleanup before calling the _exit system call.)
+ */
+void exit(int code);
+
+/*
+ * Run a command. Returns its exit status as it comes back from waitpid().
+ */
+int system(const char *command);
+
+/*
+ * Pseudo-random number generator.
+ */
+#define RAND_MAX  0x7fffffff
+long random(void);
+void srandom(unsigned long seed);
+
+/*
+ * Memory allocation functions.
+ */
+void *malloc(size_t size);
+void free(void *ptr);
+
+#endif /* _STDLIB_H_ */
diff --git a/os161-1.10/include/string.h b/os161-1.10/include/string.h
new file mode 100644
index 0000000..26847da
--- /dev/null
+++ b/os161-1.10/include/string.h
@@ -0,0 +1,33 @@
+#ifndef _STRING_H_
+#define _STRING_H_
+
+#include <sys/types.h>
+
+/*
+ * Standard C string functions.
+ */
+char *strcat(char *, const char *);
+char *strcpy(char *, const char *);
+char *strchr(const char *, int);
+char *strrchr(const char *, int);
+int strcmp(const char *, const char *);
+size_t strlen(const char *);
+char *strtok_r(char *, const char *, char **);
+char *strtok(char *, const char *);
+
+void *memset(void *, int c, size_t);
+void *memcpy(void *, const void *, size_t);
+void *memmove(void *, const void *, size_t);
+
+/*
+ * POSIX string functions.
+ */
+const char *strerror(int errcode);
+
+/*
+ * BSD string functions.
+ */
+void bzero(void *, size_t);
+
+
+#endif /* _STRING_H_ */
diff --git a/os161-1.10/include/sys/ioctl.h b/os161-1.10/include/sys/ioctl.h
new file mode 100644
index 0000000..fd4a86e
--- /dev/null
+++ b/os161-1.10/include/sys/ioctl.h
@@ -0,0 +1,2 @@
+/* This file is for UNIX compat. In OS/161, everything's in <unistd.h> */
+#include <unistd.h>
diff --git a/os161-1.10/include/sys/reboot.h b/os161-1.10/include/sys/reboot.h
new file mode 100644
index 0000000..fd4a86e
--- /dev/null
+++ b/os161-1.10/include/sys/reboot.h
@@ -0,0 +1,2 @@
+/* This file is for UNIX compat. In OS/161, everything's in <unistd.h> */
+#include <unistd.h>
diff --git a/os161-1.10/include/sys/stat.h b/os161-1.10/include/sys/stat.h
new file mode 100644
index 0000000..6eafcf3
--- /dev/null
+++ b/os161-1.10/include/sys/stat.h
@@ -0,0 +1,28 @@
+#ifndef _SYS_STAT_H_
+#define _SYS_STAT_H_
+
+/*
+ * Get struct stat and all the #defines from the kernel
+ */
+#include <kern/stat.h>
+
+/*
+ * stat is the same as fstat, only on a file that isn't already
+ * open. lstat is the same as stat, only if the name passed names a
+ * symlink, information about the symlink is returned rather than
+ * information about the file it points to. You don't need to
+ * implement lstat unless you're implementing symbolic links.
+ */
+int fstat(int filehandle, struct stat *buf);
+int stat(const char *path, struct stat *buf);
+int lstat(const char *path, struct stat *buf);
+
+/* 
+ * The second argument to mkdir is the mode for the new directory.
+ * Unless you're implementing security and permissions, you can
+ * (and should) ignore it. See notes in unistd.h.
+ */
+int mkdir(const char *dirname, int ignore);
+
+
+#endif /* _SYS_STAT_H_ */
diff --git a/os161-1.10/include/sys/types.h b/os161-1.10/include/sys/types.h
new file mode 100644
index 0000000..921e76c
--- /dev/null
+++ b/os161-1.10/include/sys/types.h
@@ -0,0 +1,20 @@
+#ifndef _SYS_TYPES_H_
+#define _SYS_TYPES_H_
+
+/*
+ * This header file is supposed to define standard system types,
+ * stuff like size_t and pid_t, as well as define a few other
+ * standard symbols like NULL.
+ *
+ * There are no such types that are user-level only, so we just
+ * get the definitions that the kernel exports.
+ *
+ * <machine/types.h> gets us the machine-dependent types from the
+ * kernel, and <kern/types.h> gets us the machine-independent types
+ * from the kernel.
+ */
+
+#include <machine/types.h>
+#include <kern/types.h>
+
+#endif /* _SYS_TYPES_H_ */
diff --git a/os161-1.10/include/sys/wait.h b/os161-1.10/include/sys/wait.h
new file mode 100644
index 0000000..fd4a86e
--- /dev/null
+++ b/os161-1.10/include/sys/wait.h
@@ -0,0 +1,2 @@
+/* This file is for UNIX compat. In OS/161, everything's in <unistd.h> */
+#include <unistd.h>
diff --git a/os161-1.10/include/time.h b/os161-1.10/include/time.h
new file mode 100644
index 0000000..fd4a86e
--- /dev/null
+++ b/os161-1.10/include/time.h
@@ -0,0 +1,2 @@
+/* This file is for UNIX compat. In OS/161, everything's in <unistd.h> */
+#include <unistd.h>
diff --git a/os161-1.10/include/unistd.h b/os161-1.10/include/unistd.h
new file mode 100644
index 0000000..ceb81bb
--- /dev/null
+++ b/os161-1.10/include/unistd.h
@@ -0,0 +1,133 @@
+#ifndef _UNISTD_H_
+#define _UNISTD_H_
+
+#include <sys/types.h>
+
+/*
+ * Get the various constants (flags, codes, etc.) for calls from
+ * kernel includes. This way user-level code doesn't need to know
+ * about the kern/ headers.
+ */
+#include <kern/unistd.h>
+#include <kern/ioctl.h>
+
+
+/*
+ * Prototypes for OS/161 system calls.
+ *
+ * Note that the following system calls are prototyped in other
+ * header files, as follows:
+ *
+ *     stat:     sys/stat.h
+ *     fstat:    sys/stat.h
+ *     lstat:    sys/stat.h
+ *     mkdir:    sys/stat.h
+ *
+ * If this were standard Unix, more prototypes would go in other
+ * header files as well, as follows:
+ * 
+ *     waitpid:  sys/wait.h
+ *     open:     fcntl.h or sys/fcntl.h
+ *     reboot:   sys/reboot.h
+ *     ioctl:    sys/ioctl.h
+ *     remove:   stdio.h
+ *     rename:   stdio.h
+ *     time:     time.h
+ *
+ * Also note that the prototypes for open() and mkdir() contain, for
+ * compatibility with Unix, an extra argument that is not meaningful
+ * in OS/161. This is the "mode" (file permissions) for a newly created
+ * object. (With open, if no file is created, this is ignored, and the
+ * call prototype is gimmicked so it doesn't have to be passed either.)
+ * 
+ * You should ignore these arguments in the OS/161 kernel unless you're
+ * implementing security and file permissions. 
+ *
+ * If you are implementing security and file permissions and using a 
+ * model different from Unix so that you need different arguments to
+ * these calls, you may make appropriate changes, or define new syscalls
+ * with different names and take the old ones out, or whatever. 
+ *
+ * As a general rule of thumb, however, while you can make as many new
+ * syscalls of your own as you like, you shouldn't change the
+ * definitions of the ones that are already here. They've been written
+ * to be pretty much compatible with Unix, and the teaching staff has
+ * test code that expects them to behave in particular ways.
+ *
+ * Of course, if you want to redesign the user/kernel API and make a
+ * lot of work for yourself, feel free, just contact the teaching
+ * staff beforehand. :-)
+ *
+ * The categories (required/recommended/optional) are guesses - check
+ * the text of the various assignments for an authoritative list.
+ */
+
+
+/*
+ * NOTE NOTE NOTE NOTE NOTE
+ *
+ * This file is *not* shared with the kernel, even though in a sense
+ * the kernel needs to know about these prototypes. This is because,
+ * due to error handling concerns, the in-kernel versions of these
+ * functions will usually have slightly different signatures.
+ */
+
+
+#ifdef __GNUC__
+/* GCC gets into a snit if _exit isn't declared to not return */
+#define __DEAD __attribute__((__noreturn__))
+#else
+#define __DEAD
+#endif
+
+/* Required. */
+__DEAD void _exit(int code);
+int execv(const char *prog, char *const *args);
+pid_t fork(void);
+int waitpid(pid_t pid, int *returncode, int flags);
+/* 
+ * Open actually takes either two or three args: the optional third
+ * arg is the file mode used for creation. Unless you're implementing
+ * security and permissions, you can ignore it.
+ */
+int open(const char *filename, int flags, ...);
+int read(int filehandle, void *buf, size_t size);
+int write(int filehandle, const void *buf, size_t size);
+int close(int filehandle);
+int reboot(int code);
+int sync(void);
+/* mkdir - see sys/stat.h */
+int rmdir(const char *dirname);
+
+/* Recommended. */
+int getpid(void);
+int ioctl(int filehandle, int code, void *buf);
+int lseek(int filehandle, off_t pos, int code);
+int fsync(int filehandle);
+int ftruncate(int filehandle, off_t size);
+int remove(const char *filename);
+int rename(const char *oldfile, const char *newfile);
+int link(const char *oldfile, const char *newfile);
+/* fstat - see sys/stat.h */
+int chdir(const char *path);
+
+/* Optional. */
+void *sbrk(int change);
+int getdirentry(int filehandle, char *buf, size_t buflen);
+int symlink(const char *target, const char *linkname);
+int readlink(const char *path, char *buf, size_t buflen);
+int dup2(int filehandle, int newhandle);
+int pipe(int filehandles[2]);
+time_t __time(time_t *seconds, unsigned long *nanoseconds);
+int __getcwd(char *buf, size_t buflen);
+/* stat - see sys/stat.h */
+/* lstat - see sys/stat.h */
+
+/*
+ * These are not themselves system calls, but wrapper routines in libc.
+ */
+
+char *getcwd(char *buf, size_t buflen);		/* calls __getcwd */
+time_t time(time_t *seconds);			/* calls __time */
+
+#endif /* _UNISTD_H_ */
diff --git a/os161-1.10/kern/Makefile b/os161-1.10/kern/Makefile
new file mode 100644
index 0000000..c2ae30b
--- /dev/null
+++ b/os161-1.10/kern/Makefile
@@ -0,0 +1,74 @@
+# Toplevel makefile for OS/161 kernel source.
+# Note: actual kernels are not compiled here; they are compiled in 
+# compile/FOO where FOO is a kernel configuration name.
+#
+
+include ../defs.mk
+
+#
+# We don't actually do anything from here except install includes.
+# Kernels get built in one or more subdirectories of compile/.
+#
+# (Actually, some stuff is done on clean below.)
+#
+all tags depend clean install: ;
+
+#
+# Directories in the system runtime tree that include files get
+# installed into.
+#
+INCDIR=$(OSTREE)/include
+KINCDIR=$(OSTREE)/include/kern
+MDINCDIR=$(OSTREE)/include/$(PLATFORM)
+
+#
+# Machine-dependent headers that we export to userland. Other header
+# files in arch/$(PLATFORM)/include are not exported.
+#
+MDHEADERS=asmdefs.h setjmp.h types.h
+
+#
+# Install kernel headers into system.
+#
+# We install everything in include/kern in $(OSTREE)/include/kern.
+# We install only $(MDHEADERS) in $(OSTREE)/include/$(PLATFORM).
+# We create $(OSTREE)/include/machine to point to 
+# $(OSTREE)/include/$(PLATFORM).
+#
+includes:
+	[ -d $(KINCDIR) ] || mkdir -p $(KINCDIR)
+	[ -d $(MDINCDIR) ] || mkdir -p $(MDINCDIR)
+	rm -f $(INCDIR)/machine
+	ln -s $(PLATFORM) $(INCDIR)/machine
+
+	@echo "Installing kernel includes..."
+	@(cd include/kern && for h in *.h; do \
+		if diff $$h $(KINCDIR)/$$h >/dev/null 2>&1; then \
+			true; \
+		else \
+			echo "Installing $$h"; \
+			cp $$h $(KINCDIR)/$$h; \
+		fi; \
+	 done)
+	@echo "Installing machine-dependent includes for $(PLATFORM)..."
+	@(cd arch/$(PLATFORM)/include && for h in $(MDHEADERS); do \
+		if diff $$h $(MDINCDIR)/$$h >/dev/null 2>&1; then \
+			true; \
+		else \
+			echo "Installing $$h"; \
+			cp $$h $(MDINCDIR)/$$h; \
+		fi; \
+	 done)
+
+#
+# Delete all emacs backups in the kernel source when "clean" is invoked.
+#
+clean: cleanhere
+cleanhere:
+	find . -name '*~' -print | xargs rm -f
+
+#
+# This tells make that the listed rules are not files so it
+# (hopefully) won't become confused if files by those names appear.
+#
+.PHONY: all tags depend clean cleanhere install includes
diff --git a/os161-1.10/kern/arch/mips/conf/Makefile.mips b/os161-1.10/kern/arch/mips/conf/Makefile.mips
new file mode 100644
index 0000000..0c5a655
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/conf/Makefile.mips
@@ -0,0 +1,192 @@
+#
+# Makefile.mips
+#
+# OS/161 kernel makefile base for the MIPS r2000/r3000.
+#
+# The actual makefiles used are copies of this file - if you want to edit,
+# edit kern/arch/mips/conf/Makefile.mips and rerun config.
+#
+
+
+#
+# Filename for the kernel.
+#
+KERNEL=kernel
+
+#
+# Get the defs that were dumped out from the kernel config tool.
+# This defines:
+#	S		Path for top of kernel source tree
+#	ARCH		Architecture ("mips")
+#	DEBUGFLAGS	-O2 or -g
+#	CONFNAME	The name of the kernel config, e.g., ASST1
+#
+include defs.mk
+
+#
+# Get the tree-wide defs.
+# This defines (that we use):
+#	OSTREE		Path for top of installed system tree
+#	CC		C compiler
+#	KCFLAGS		C compiler flags for kernel
+#	LD		Linker
+#	KLDFLAGS	Linker flags for kernel
+#	SIZE		Object file size tool
+#
+include $S/../defs.mk
+
+#
+# Adjust defs for building the kernel.
+#
+# The LOAD_ADDRESS is the virtual address where the kernel will be loaded
+# into memory. This is in the direct-mapped cached segment of the MIPS
+# address space. -Ttext is the linker option for setting it.
+#
+# -T provides the linker with a "linker script". This is a piece of
+# obscure mumble that tells the linker how to put together the output
+# program. The only reason we need it is that the linker breaks if you
+# try to use -Ttext and its default built-in linker script at the same
+# time.
+#
+# -nostdinc prevents including header files other than our own, and 
+# -nostdlib prevents linking against any standard libraries. Because
+# the kernel has to be a completely standalone program, this is important.
+#
+# -ffreestanding tells gcc this is not an ordinary program, so it will
+# make fewer unwise assumptions about standard library functions.
+#
+# We define _KERNEL so certain source files that are shared between the
+# kernel and userland (like strcpy.c) can tell the difference so they know
+# which header files to use.
+#
+# -G 0 tells the assembler and linker not to reference global variables
+# via the "global pointer" (MIPS gp register) because we don't support 
+# handling the gp register.
+#
+LOAD_ADDRESS=0x80001000
+INCLUDES=-nostdinc -I$S/include -I$S/dev -I. 
+CFLAGS=$(KCFLAGS) $(DEBUGFLAGS) $(INCLUDES) -ffreestanding -D_KERNEL -G 0
+LDFLAGS=$(KLDFLAGS) -nostdlib \
+	-Ttext $(LOAD_ADDRESS) -T $S/arch/mips/conf/ldscript \
+	-G 0
+
+#
+# Rules for compiling various kinds of source files, by suffix.
+# (There's nothing magical about these names and make.)
+#
+# We don't actually use C++ in OS/161, although, with some fiddling,
+# you might be able to. But you must turn off exceptions and RTTI in
+# order to do so (the implementations of these in gcc are completely 
+# unsuitable for kernels.)
+#
+COMPILE.cc=$(CC) $(CFLAGS) -fno-rtti -fno-exceptions -c
+COMPILE.c=$(CC) $(CFLAGS) -c
+COMPILE.l=false   # redefine when needed 
+COMPILE.y=false   # redefine when needed 
+COMPILE.S=$(CC) $(CFLAGS) -c
+
+#
+# This should expand to all the header files in the kernel so they can
+# be fed to tags.
+#
+TAGS_HEADERS=$S/include/*.h $S/include/kern/*.h $S/arch/$(ARCH)/include/*.h
+
+#
+# Default make rule: build the kernel.
+#
+all: $(KERNEL)
+
+#
+# Here's how we link the kernel. 
+#
+# vers.c/.o is generated on every build. It contains a numeric serial
+# number incremented every time newvers.sh is run.  These values are
+# printed out by newvers.sh and are also displayed at boot time. This
+# makes it possible to tell at a glance whether you're actually
+# running the same kernel you just compiled.
+#
+# The version number is kept in the file called "version" in the build
+# directory.
+#
+# By immemorial tradition, "size" is run on the kernel after it's linked.
+#
+$(KERNEL):
+	$S/conf/newvers.sh $(CONFNAME)
+	$(COMPILE.c) vers.c
+	$(LD) $(LDFLAGS) $(OBJS) vers.o -o $(KERNEL)
+	$(SIZE) $(KERNEL)
+
+#
+# Use the -M argument to gcc to get it to output dependency information.
+# Note that we use -M, which includes deps for #include <...> files,
+# rather than -MM, which doesn't. This is because we are the operating
+# system: the #include <...> files are part of our project - in fact, in
+# the kernel they're the kernel's own include files - and they will be
+# changing!
+#
+depend:
+	$(CC) $(CFLAGS) -M $(SRCS) > depend.mk
+
+#
+# Remove everything generated during the compile.
+# (To remove absolutely everything automatically generated, you can just
+# blow away the whole compile directory.)
+#
+clean:
+	rm -f *.o *.a tags $(KERNEL)
+
+#
+# Rerun config for this configuration.
+#
+reconfig:
+	(cd ../../conf && ./config $(CONFNAME))
+
+#
+# [ -d $(OSTREE) ] succeeds if $(OSTREE) is a directory.
+# (See test(1).) Thus, if $(OSTREE) doesn't exist, it will be created.
+#
+
+# The kernel gets installed at the top of the installed system tree.
+# Since with OS/161 it's relatively likely that you'll be working with
+# several configurations at once, it gets installed under the name of
+# this config, and a symbolic link with the "real" name is set up to
+# point to the last kernel installed.
+#
+install:
+	[ -d $(OSTREE) ] || mkdir $(OSTREE)
+	cp $(KERNEL) $(OSTREE)/$(KERNEL)-$(CONFNAME)
+	-rm -f $(OSTREE)/$(KERNEL)
+	ln -s $(KERNEL)-$(CONFNAME) $(OSTREE)/$(KERNEL)
+
+#
+# Run tags on all the sources and header files. This is probably not
+# the most useful way to do this and needs attention. (XXX)
+#
+tags:
+	ctags -wtd $(SRCS) $(TAGS_HEADERS)
+
+#
+# This tells make that these rules are not files so it (hopefully)
+# won't become confused if files by those names appear.
+#
+.PHONY: all depend clean install tags reconfig
+
+#
+# Get the list of source files from where it was generated by the 
+# kernel config tool.
+#
+# This sets SRCS and OBJS, and also defines a rule for compiling each
+# source file.
+#
+include files.mk
+
+# Get dependency information.
+include depend.mk
+
+#
+# Tell make that the kernel depends on the object files listed in $(OBJS).
+# This (unlike the link commands that also use $(OBJS) above) must come
+# after the include of files.mk, because of the way make reads its input
+# and evaluates variables.
+#
+$(KERNEL): $(OBJS)
diff --git a/os161-1.10/kern/arch/mips/conf/conf.arch b/os161-1.10/kern/arch/mips/conf/conf.arch
new file mode 100644
index 0000000..ca2a23f
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/conf/conf.arch
@@ -0,0 +1,39 @@
+
+#
+# The machine dependent sources for MIPS.
+#
+
+file        arch/mips/mips/cache_mips1.S	# MIPS RAM cache handling
+file        arch/mips/mips/exception.S		# Exception entry points
+file        arch/mips/mips/lamebus_mips.c	# MD code for LAMEbus
+file        arch/mips/mips/interrupt.c		# Interrupt handler
+file        arch/mips/mips/pcb.c		# MD thread code
+file        arch/mips/mips/ram.c		# Physical memory accounting
+file        arch/mips/mips/spl.c		# Interrupt management
+file        arch/mips/mips/start.S		# Kernel bootup
+file        arch/mips/mips/switch.S		# Thread context switch
+file        arch/mips/mips/syscall.c		# System call handler 
+file        arch/mips/mips/threadstart.S	# Entry code for new threads
+file        arch/mips/mips/trap.c		# Trap (exception) handler
+file        arch/mips/mips/tlb_mips1.S		# TLB handling routines
+
+file        ../lib/libc/mips-setjmp.S		# setjmp/longjmp
+
+#
+# This is included here rather than in conf.kern because
+# it may not be suitable for all architectures.
+#
+file        lib/copyinout.c			# copyin/out et al.
+
+#
+# For the early assignments, we supply a very stupid MIPS-only skeleton
+# of a VM system. It is just barely capable of running a single userlevel
+# program as long as that program's not very large.
+#
+defoption   dumbvm
+optfile     dumbvm  arch/mips/mips/dumbvm.c
+
+#
+# Get the files and options for LAMEbus devices.
+#
+include dev/lamebus/conf.lamebus
diff --git a/os161-1.10/kern/arch/mips/conf/ldscript b/os161-1.10/kern/arch/mips/conf/ldscript
new file mode 100644
index 0000000..b8afe1b
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/conf/ldscript
@@ -0,0 +1,44 @@
+/*
+ * This is a pile of crap that tells the linker how to link the kernel,
+ * because it's too stupid to be able to work it out on its own.
+ */
+ENTRY(__start)
+
+SECTIONS
+{
+	/*
+	 * Read-only loaded sections.
+	 */
+	.text : { *(.text) }	/* code */
+	_etext = .;		/* linker-provided symbol for end of code */
+
+	.rodata : { *(.rodata) }	/* read-only data */	
+	.reginfo : { *(.reginfo) }	/* MIPS register usage blather */
+
+	/* don't need this, can't write-protect text */
+	/* . = . + 0x1000; */
+
+	/*
+	 * Read-write loaded sections.
+	 */
+	
+	.data : { *(.data) }	/* initialized data */
+	.bss : { *(.bss) }	/* cleared-to-zero data */
+	_end = .;		/* linker-provided symbol for end of program */
+
+	/*
+	 * Debug info
+	 */
+
+	/* stabs debug sections */
+	.stab 0:		{ *(.stab) }
+	.stabstr 0:		{ *(.stabstr) }
+
+	/* DWARF debug sections */
+	.debug 0:		{ *(.debug) }
+	.debug_srcinfo 0:	{ *(.debug_srcinfo) }
+	.debug_aranges 0:	{ *(.debug_aranges) }
+	.debug_pubnames 0:	{ *(.debug_pubnames) }
+	.debug_sfnames 0:	{ *(.debug_sfnames) }
+	.line 0:		{ *(.line) }
+}
diff --git a/os161-1.10/kern/arch/mips/include/asmdefs.h b/os161-1.10/kern/arch/mips/include/asmdefs.h
new file mode 100644
index 0000000..f44e9b3
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/asmdefs.h
@@ -0,0 +1,65 @@
+/*
+ * Macros for register numbers for MIPS r2k/r3k.
+ */
+#ifndef _MIPS_ASMDEFS_H_
+#define _MIPS_ASMDEFS_H_
+
+/*
+ * General registers
+ */
+#define z0  $0     /* always zero register */
+#define AT  $1     /* assembler temp register */
+#define v0  $2     /* value 0 */
+#define v1  $3     /* value 1 */
+#define a0  $4     /* argument 0 */
+#define a1  $5     /* argument 1 */
+#define a2  $6     /* argument 2 */
+#define a3  $7     /* argument 3 */
+#define t0  $8     /* temporary (caller-save) 0 */
+#define t1  $9     /* temporary (caller-save) 1 */
+#define t2  $10    /* temporary (caller-save) 2 */
+#define t3  $11    /* temporary (caller-save) 3 */
+#define t4  $12    /* temporary (caller-save) 4 */
+#define t5  $13    /* temporary (caller-save) 5 */
+#define t6  $14    /* temporary (caller-save) 6 */
+#define t7  $15    /* temporary (caller-save) 7 */
+#define s0  $16    /* saved (callee-save) 0 */
+#define s1  $17    /* saved (callee-save) 1 */
+#define s2  $18    /* saved (callee-save) 2 */
+#define s3  $19    /* saved (callee-save) 3 */
+#define s4  $20    /* saved (callee-save) 4 */
+#define s5  $21    /* saved (callee-save) 5 */
+#define s6  $22    /* saved (callee-save) 6 */
+#define s7  $23    /* saved (callee-save) 7 */
+#define t8  $24    /* temporary (caller-save) 8 */
+#define t9  $25    /* temporary (caller-save) 9 */
+#define k0  $26    /* kernel temporary 0 */
+#define k1  $27    /* kernel temporary 1 */
+#define gp  $28    /* global pointer */
+#define sp  $29    /* stack pointer */
+#define s8  $30    /* saved 8 = frame pointer */
+#define ra  $31    /* return address */
+
+/* Coprocessor 0 (system processor) registers */
+#define c0_index    $0		/* TLB entry index register */
+#define c0_random   $1		/* TLB random slot register */
+#define c0_entrylo  $2		/* TLB entry contents (low-order half) */
+/*      c0_entrylo0 $2 */	/* MIPS r4k+ only */
+/*      c0_entrylo1 $3 */	/* MIPS r4k+ only */
+#define c0_context  $4		/* some precomputed pagetable stuff (ignore) */
+/*	c0_pagemask $5 */	/* MIPS r4k+ only */
+/*	c0_wired    $6 */	/* MIPS r4k+ only */
+#define c0_vaddr    $8		/* virtual addr of failing memory access */
+/*	c0_count    $9 */	/* MIPS r4k+ only */
+#define c0_entryhi  $10		/* TLB entry contents (high-order half) */
+/*	c0_compare  $11 */	/* MIPS r4k+ only */
+#define c0_status   $12		/* processor status register */
+#define c0_cause    $13		/* exception cause register */
+#define c0_epc      $14		/* exception PC register */
+#define c0_prid     $15		/* processor ID register */
+/*	c0_config   $16 */	/* MIPS r4k+ only */
+/*	c0_lladdr   $17 */	/* MIPS r4k+ only */
+/*	c0_watchlo  $18 */	/* MIPS r4k+ only */
+/*	c0_watchhi  $19 */	/* MIPS r4k+ only */
+
+#endif /* _MIPS_ASMDEFS_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/bus.h b/os161-1.10/kern/arch/mips/include/bus.h
new file mode 100644
index 0000000..6e0ded2
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/bus.h
@@ -0,0 +1,32 @@
+#ifndef _MIPS_BUS_H_
+#define _MIPS_BUS_H_
+
+/*
+ * Generic bus interface file.
+ *
+ * The only bus we support for MIPS is LAMEbus.
+ * This would need to be a bit more complicated if that weren't the case.
+ */
+
+#include <machine/vm.h>		/* for MIPS_KSEG1 */
+#include <lamebus/lamebus.h>	/* for LAMEbus definitions */
+
+#define bus_write_register(bus, slot, offset, val) \
+    lamebus_write_register(bus, slot, offset, val)
+
+#define bus_read_register(bus, slot, offset) \
+    lamebus_read_register(bus, slot, offset)
+
+#define bus_map_area(bus, slot, offset) \
+    lamebus_map_area(bus, slot, offset)
+
+/*
+ * Machine-dependent LAMEbus definitions
+ */
+
+/* Base address of the LAMEbus mapping area */
+#define LB_BASEADDR  (MIPS_KSEG1 + 0x1fe00000)
+
+void mips_lamebus_interrupt(void);
+
+#endif /* _MIPS_BUS_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/pcb.h b/os161-1.10/kern/arch/mips/include/pcb.h
new file mode 100644
index 0000000..923ac3f
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/pcb.h
@@ -0,0 +1,103 @@
+/*
+ * Process Control Block: machine-dependent part of thread
+ */
+
+#ifndef _MACHINE_PCB_H_
+#define _MACHINE_PCB_H_
+
+#include <machine/setjmp.h>
+
+/* Size of kernel stacks (bytes) */
+#define STACK_SIZE  4096
+
+/* Mask for extracting the stack base address of a kernel stack pointer */
+#define STACK_MASK  0xfffff000
+
+/* Macro to test if two addresses are on the same kernel stack */
+#define SAME_STACK(p1,p2)	(((p1)&STACK_MASK)==((p2)&STACK_MASK))
+
+/* Function pointer type for pcb_badfaultfunc: void, returning void */
+typedef void (*pcb_faultfunc)(void);
+
+/*
+ * Note: pcb_kstack and pcb_ininterrupt are saved values of the
+ * globals "curkstack" and "in_interrupt", respectively. Thus, when a
+ * thread is presently running they should not be used - the globals
+ * should be used instead.
+ *
+ * Said variables are globals because they're used in assembly code
+ * and it's much easier to access globals in assembly than to try to
+ * setting up a mechanism for converting C structure offsets to
+ * symbols that the assembler can make use of. Obviously, the latter
+ * is *possible*, and structure accesses are in fact done that way in
+ * BSD.
+ *
+ * Note that pcb_switchstack MUST BE THE FIRST THING IN THE PCB or
+ * switch.S will have a coronary.
+ */
+struct pcb {
+	u_int32_t pcb_switchstack;  // stack saved during context switch
+	u_int32_t pcb_kstack;	    // stack to load on entry to kernel
+	u_int32_t pcb_ininterrupt;  // are we in an interrupt handler?
+
+	pcb_faultfunc pcb_badfaultfunc; // recovery for fatal kernel traps
+	jmp_buf pcb_copyjmp;            // jump area used by copyin/out etc.
+};
+
+
+/*
+ * Machine-dependent thread functions used by the machine-independent
+ * thread code.
+ */
+
+/* Initialize the pcb of the first (bootup) thread */
+void md_initpcb0(struct pcb *);
+
+/*
+ * Initialize the pcb of a newly created thread. The newly created
+ * thread, when it first runs, should call mi_threadstart, to which
+ * data1, data2, and func are arguments.
+ */
+void md_initpcb(struct pcb *, char *stack, void *data1, unsigned long data2,
+		void (*func)(void *, unsigned long));
+
+/*
+ * Enter user mode. Does not return.
+ *
+ * Performs the necessary initialization so that the user program will
+ * get the arguments supplied in argc/argv (note that argv must be a
+ * user-level address), and begin executing at the specified entry
+ * point. The stack pointer is initialized from the stackptr
+ * argument. Note that passing argc/argv may use additional stack
+ * space on some other platforms (but not mips).
+ */
+void md_usermode(int argc, userptr_t argv, u_int32_t stackptr, 
+		 u_int32_t entrypoint);
+
+/*
+ * The various ways to shut down the system. (These are very low-level
+ * and should generally not be called directly - md_poweroff, for
+ * instance, unceremoniously turns the power off without doing
+ * anything else.)
+ */
+void md_poweroff(void);
+void md_reboot(void);
+void md_halt(void);
+void md_panic(void);
+
+/*
+ * Various MIPS-specific functions.
+ */
+
+/* general interrupt handler */
+void mips_interrupt(u_int32_t cause_register);
+
+/* system call dispatcher */
+struct trapframe;
+void mips_syscall(struct trapframe *tf);
+
+/* function to look up the size of physical RAM (returns count in bytes) */
+u_int32_t mips_ramsize(void);
+
+
+#endif /* _MACHINE_PCB_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/setjmp.h b/os161-1.10/kern/arch/mips/include/setjmp.h
new file mode 100644
index 0000000..1cda28c
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/setjmp.h
@@ -0,0 +1,13 @@
+#ifndef _MIPS_SETJMP_H_
+#define _MIPS_SETJMP_H_
+
+/*
+ * Must save: s0-s8, sp, ra (11 registers)
+ * Don't change __JB_REGS without adjusting mips_setjmp.S accordingly.
+ */
+#define __JB_REGS  11
+
+/* A jmp_buf is an array of __JB_REGS registers */
+typedef u_int32_t jmp_buf[__JB_REGS];
+
+#endif /* _MIPS_SETJMP_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/specialreg.h b/os161-1.10/kern/arch/mips/include/specialreg.h
new file mode 100644
index 0000000..216fe3a
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/specialreg.h
@@ -0,0 +1,36 @@
+#ifndef _MIPS_SPECIALREG_H_
+#define _MIPS_SPECIALREG_H_
+
+/*
+ * Mode bits in c0_status
+ */
+#define CST_IEc      0x00000001	/* current: interrupt enable */
+#define CST_KUc      0x00000002	/* current: user mode */
+#define CST_IEp      0x00000004	/* previous: interrupt enable */
+#define CST_KUp      0x00000008	/* previous: user mode */
+#define CST_IEo      0x00000010	/* old: interrupt enable */
+#define CST_KUo      0x00000020	/* old: user mode */
+#define CST_MODEMASK 0x0000003f	/* mask for the above */
+#define CST_IRQMASK  0x0000ff00	/* mask for the individual irq enable bits */
+#define CST_BEV      0x00400000	/* bootstrap exception vectors flag */
+
+/*
+ * Fields of the c0_cause register 
+ */
+#define CCA_UTLB   0x00000001   /* true if UTLB exception (set by our asm) */
+#define CCA_CODE   0x0000003c   /* EX_foo in trapframe.h */
+#define CCA_IRQS   0x0000ff00   /* Currently pending interrupts */
+#define CCA_COPN   0x30000000   /* Coprocessor number for EX_CPU */
+#define CCA_JD     0x80000000   /* True if exception happened in jump delay */
+
+#define CCA_CODESHIFT   2       /* shift for CCA_CODE field */
+
+/*
+ * Fields of the c0_index register
+ */
+#define CIN_P      0x80000000   /* nonzero -> TLB probe found nothing */
+#define CIN_INDEX  0x00003f00   /* 6-bit index into TLB */
+
+#define CIN_INDEXSHIFT  8       /* shift for CIN_INDEX field */
+
+#endif /* _MIPS_SPECIALREG_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/spl.h b/os161-1.10/kern/arch/mips/include/spl.h
new file mode 100644
index 0000000..ddb6575
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/spl.h
@@ -0,0 +1,67 @@
+#ifndef _MACHINE_SPL_H_
+#define _MACHINE_SPL_H_
+
+/*
+ * Machine-independent interface to interrupt enable/disable.
+ *
+ * "spl" stands for "set priority level", and was originally the name of
+ * a VAX assembler instruction.
+ *
+ * The idea is that one can block less important interrupts while
+ * processing them, but still allow more urgent interrupts to interrupt
+ * that processing.
+ *
+ * Ordinarily there would be a whole bunch of defined spl levels and
+ * functions for setting them - spltty(), splbio(), etc., etc. But we
+ * don't support interrupt priorities in OS/161, so there are only
+ * three:
+ *
+ *      splhigh()    sets spl to the highest value, disabling all interrupts.
+ *      spl0()       sets spl to 0, enabling all interrupts.
+ *      splx(s)      sets spl to S, enabling whatever state S represents.
+ *
+ * All three return the old interrupt state. Thus, these are commonly used
+ * as follows:
+ *
+ *      int s = splhigh();
+ *      [ code ]
+ *      splx(s);
+ *
+ * curspl holds the current spl level.
+ *
+ * in_interrupt is set to 1 if execution is presently occurring in an
+ * interrupt handler. (This means that the *current* thread's normal
+ * context of execution is presently stopped in the middle of doing
+ * something else, which makes all kinds of things unsafe to do.)
+ *
+ * cpu_idle() sits around until it thinks something interesting may
+ * have happened, such as an interrupt. Then it returns. It may be
+ * wrong (in fact, at present, it is almost always wrong), so it
+ * should be called in a loop that checks some other condition.
+ * cpu_idle may be called (and in fact should be called) with
+ * interrupts off - it turns them on temporarily inside itself.
+ *
+ * cpu_halt() stops the cpu permanently (until the external reset is
+ * pushed), preferably in a low-power idle state. Looping calling
+ * cpu_idle() is not good enough, because cpu_idle() accepts
+ * interrupts.
+ */
+
+extern int curspl;
+extern int in_interrupt;
+
+int splhigh(void);
+int spl0(void);
+int splx(int);
+
+void cpu_idle(void);
+void cpu_halt(void);
+
+/*
+ * Integer spl level to use for "high".
+ * This is traditionally 15. 
+ */
+#define SPL_HIGH   15
+
+
+#endif /* _MACHINE_SPL_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/switchframe.h b/os161-1.10/kern/arch/mips/include/switchframe.h
new file mode 100644
index 0000000..b7f6280
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/switchframe.h
@@ -0,0 +1,24 @@
+#ifndef _MIPS_SWITCHFRAME_H_
+#define _MIPS_SWITCHFRAME_H_
+
+/*
+ * Structure describing what is saved on the stack during a context switch.
+ *
+ * This must agree with the code in switch.S.
+ */
+
+struct switchframe {
+	u_int32_t sf_s0;
+	u_int32_t sf_s1;
+	u_int32_t sf_s2;
+	u_int32_t sf_s3;
+	u_int32_t sf_s4;
+	u_int32_t sf_s5;
+	u_int32_t sf_s6;
+	u_int32_t sf_s7;
+	u_int32_t sf_s8;
+	u_int32_t sf_gp;
+	u_int32_t sf_ra;
+};
+
+#endif /* _MIPS_SWITCHFRAME_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/tlb.h b/os161-1.10/kern/arch/mips/include/tlb.h
new file mode 100644
index 0000000..6b8dd6f
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/tlb.h
@@ -0,0 +1,76 @@
+#ifndef _MACHINE_TLB_H_
+#define _MACHINE_TLB_H_
+
+/*
+ * MIPS-specific TLB access functions.
+ *
+ *   TLB_Random: write the TLB entry specified by ENTRYHI and ENTRYLO
+ *        into a "random" TLB slot chosen by the processor.
+ *
+ *        IMPORTANT NOTE: never write more than one TLB entry with the
+ *        same virtual page field.
+ *
+ *   TLB_Write: same as TLB_Random, but you choose the slot.
+ *
+ *   TLB_Read: read a TLB entry out of the TLB into ENTRYHI and ENTRYLO.
+ *        INDEX specifies which one to get.
+ *
+ *   TLB_Probe: look for an entry matching the virtual page in ENTRYHI.
+ *        Returns the index, or a negative number if no matching entry
+ *        was found. ENTRYLO is not actually used, but must be set; 0
+ *        should be passed.
+ *
+ *        IMPORTANT NOTE: An entry may be matching even if the valid bit 
+ *        is not set. To completely invalidate the TLB, load it with
+ *        translations for addresses in one of the unmapped address
+ *        ranges - these will never be matched.
+ */
+
+void TLB_Random(u_int32_t entryhi, u_int32_t entrylo);
+void TLB_Write(u_int32_t entryhi, u_int32_t entrylo, u_int32_t index);
+void TLB_Read(u_int32_t *entryhi, u_int32_t *entrylo, u_int32_t index);
+int TLB_Probe(u_int32_t entryhi, u_int32_t entrylo);
+
+/*
+ * TLB entry fields.
+ *
+ * Note that the MIPS has support for a 6-bit address space ID. In the
+ * interests of simplicity, we don't use it. The fields related to it
+ * (TLBLO_GLOBAL and TLBHI_PID) can be left always zero, as can the
+ * bits that aren't assigned a meaning.
+ *
+ * The TLBLO_DIRTY bit is actually a write privilege bit - it is not
+ * ever set by the processor. If you set it, writes are permitted. If
+ * you don't set it, you'll get a "TLB Modify" exception when a write
+ * is attempted.
+ *
+ * There is probably no reason in the course of CS161 to use TLBLO_NOCACHE.
+ */
+
+/* Fields in the high-order word */
+#define TLBHI_VPAGE   0xfffff000
+/*      TLBHI_PID     0x00000fc0 */
+
+/* Fields in the low-order word */
+#define TLBLO_PPAGE   0xfffff000
+#define TLBLO_NOCACHE 0x00000800
+#define TLBLO_DIRTY   0x00000400
+#define TLBLO_VALID   0x00000200
+/*      TLBLO_GLOBAL  0x00000100 */
+
+/*
+ * Values for completely invalid TLB entries. The TLB entry index should
+ * be passed to TLBHI_INVALID; this prevents loading the same invalid
+ * entry into multiple TLB slots.
+ */
+#define TLBHI_INVALID(entryno) ((0x80000+(entryno))<<12)
+#define TLBLO_INVALID()        (0)
+
+/*
+ * Number of TLB entries in the processor.
+ */
+
+#define NUM_TLB  64
+
+
+#endif /* _MACHINE_TLB_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/trapframe.h b/os161-1.10/kern/arch/mips/include/trapframe.h
new file mode 100644
index 0000000..bb48591
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/trapframe.h
@@ -0,0 +1,77 @@
+#ifndef _MIPS_TRAPFRAME_H_
+#define _MIPS_TRAPFRAME_H_
+
+/*
+ * Structure describing what is saved on the stack during entry to
+ * the exception handler.
+ *
+ * This must agree with the code in exception.S.
+ */
+
+struct trapframe {
+	u_int32_t tf_vaddr;	/* coprocessor 0 vaddr register */
+	u_int32_t tf_status;	/* coprocessor 0 status register */
+	u_int32_t tf_cause;	/* coprocessor 0 cause register */
+	u_int32_t tf_lo;
+	u_int32_t tf_hi;
+	u_int32_t tf_ra;	/* Saved register 31 */
+	u_int32_t tf_at;	/* Saved register 1 (AT) */
+	u_int32_t tf_v0;	/* Saved register 2 (v0) */
+	u_int32_t tf_v1;	/* etc. */
+	u_int32_t tf_a0;
+	u_int32_t tf_a1;
+	u_int32_t tf_a2;
+	u_int32_t tf_a3;
+	u_int32_t tf_t0;
+	u_int32_t tf_t1;
+	u_int32_t tf_t2;
+	u_int32_t tf_t3;
+	u_int32_t tf_t4;
+	u_int32_t tf_t5;
+	u_int32_t tf_t6;
+	u_int32_t tf_t7;
+	u_int32_t tf_s0;
+	u_int32_t tf_s1;
+	u_int32_t tf_s2;
+	u_int32_t tf_s3;
+	u_int32_t tf_s4;
+	u_int32_t tf_s5;
+	u_int32_t tf_s6;
+	u_int32_t tf_s7;
+	u_int32_t tf_t8;
+	u_int32_t tf_t9;
+	u_int32_t tf_k0;	/* dummy (see exception.S comments) */
+	u_int32_t tf_k1;	/* dummy */
+	u_int32_t tf_gp;
+	u_int32_t tf_sp;
+	u_int32_t tf_s8;
+	u_int32_t tf_epc;	/* coprocessor 0 epc register */
+};
+
+/*
+ * MIPS exception codes.
+ */
+#define EX_IRQ    0    /* Interrupt */
+#define EX_MOD    1    /* TLB Modify (write to read-only page) */
+#define EX_TLBL   2    /* TLB miss on load */
+#define EX_TLBS   3    /* TLB miss on store */
+#define EX_ADEL   4    /* Address error on load */
+#define EX_ADES   5    /* Address error on store */
+#define EX_IBE    6    /* Bus error on instruction fetch */
+#define EX_DBE    7    /* Bus error on data load *or* store */
+#define EX_SYS    8    /* Syscall */
+#define EX_BP     9    /* Breakpoint */
+#define EX_RI     10   /* Reserved (illegal) instruction */
+#define EX_CPU    11   /* Coprocessor unusable */
+#define EX_OVF    12   /* Arithmetic overflow */
+
+/*
+ * Trapframe-related functions.
+ *
+ * The trapframe must be on the thread's own stack or bad things will
+ * happen.
+ */
+void mips_usermode(struct trapframe *tf);
+void md_forkentry(struct trapframe *tf);
+
+#endif /* _MIPS_TRAPFRAME_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/types.h b/os161-1.10/kern/arch/mips/include/types.h
new file mode 100644
index 0000000..91e6464
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/types.h
@@ -0,0 +1,68 @@
+#ifndef _MIPS_TYPES_H_
+#define _MIPS_TYPES_H_
+
+/*
+ * Basic integer types, and some related definitions, for MIPS.
+ * This file is made visible to userland.
+ *
+ * Note: while we define int64_t and u_int64_t, actually using them
+ * will in some cases cause odd link errors. This has to do with the
+ * way gcc implements 64-bit arithmetic on 32-bit processors. When you
+ * build gcc, it creates a library called libgcc.a that contains,
+ * among other things, implementations of the functions gcc expects to
+ * be able to call for doing 64-bit arithmetic. Unfortunately, you
+ * don't really want to use the standard libgcc.a in a kernel, and
+ * because of the circumstances with the compiler and toolchain in
+ * cs161 it's awkward to use libgcc.a in userlevel programs too, so we
+ * just don't support it. So don't use 64-bit integers unless you're
+ * prepared to cope with these issues yourself.
+ */
+
+typedef char      int8_t;		/* 8-bit signed integer */
+typedef short     int16_t;		/* 16-bit signed integer */
+typedef int       int32_t;		/* 32-bit signed integer */
+typedef long long int64_t;		/* 64-bit signed integer */
+
+typedef unsigned char      u_int8_t;	/* 8-bit unsigned integer */
+typedef unsigned short     u_int16_t;	/* 16-bit unsigned integer */
+typedef unsigned int       u_int32_t;	/* 32-bit unsigned integer */
+typedef unsigned long long u_int64_t;	/* 64-bit unsigned integer */
+
+/*
+ * Since we're a 32-bit platform, size_t can correctly be either
+ * unsigned int or unsigned long. However, if we don't define it to
+ * the same one gcc is using, gcc will get upset. If you switch
+ * compilers and see otherwise unexplicable type errors involving
+ * size_t, try changing this.
+ */
+#if 1
+typedef unsigned size_t;		/* Size of a memory region */
+#else
+typedef unsigned long size_t;		/* Size of a memory region */
+#endif
+
+typedef long intptr_t;			/* Signed pointer-sized integer */
+typedef unsigned long uintptr_t;	/* Unsigned pointer-sized integer */
+
+/*
+ * Number of bits per byte.
+ */
+
+#define CHAR_BIT  8
+
+/*
+ * Null pointer.
+ */
+
+#undef NULL
+#define NULL ((void *)0)
+
+/*
+ * Endianness. While the MIPS can be either big-endian (mipseb) or
+ * little-endian (mipsel), at least for now we only do mipseb.
+ */
+
+#undef _LITTLE_ENDIAN
+#define _BIG_ENDIAN
+
+#endif /* _MIPS_TYPES_H_ */
diff --git a/os161-1.10/kern/arch/mips/include/vm.h b/os161-1.10/kern/arch/mips/include/vm.h
new file mode 100644
index 0000000..8d4fca2
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/include/vm.h
@@ -0,0 +1,82 @@
+#ifndef _MIPS_VM_H_
+#define _MIPS_VM_H_
+
+/*
+ * Machine-dependent VM system definitions.
+ */
+
+#define PAGE_SIZE  4096		/* size of VM page */
+#define PAGE_FRAME 0xfffff000	/* mask for getting page number from addr */
+
+
+typedef u_int32_t paddr_t;   /* type for a physical address */
+typedef u_int32_t vaddr_t;   /* type for a virtual address */
+
+/*
+ * MIPS hardwired memory layout:
+ *    0xc0000000 - 0xffffffff   kseg2 (kernel, tlb-mapped)
+ *    0xa0000000 - 0xbfffffff   kseg1 (kernel, unmapped, uncached)
+ *    0x80000000 - 0x9fffffff   kseg0 (kernel, unmapped, cached)
+ *    0x00000000 - 0x7fffffff   kuseg (user, tlb-mapped)
+ */
+
+#define MIPS_KUSEG  0x00000000
+#define MIPS_KSEG0  0x80000000
+#define MIPS_KSEG1  0xa0000000
+#define MIPS_KSEG2  0xc0000000
+
+/* 
+ * The first 512 megs of physical space can be addressed in both kseg0 and
+ * kseg1. We use kseg0 for the kernel. This macro returns the kernel virtual
+ * address of a given physical address within that range. (We assume we're
+ * not using systems with more physical space than that anyway.)
+ *
+ * N.B. If you, say, call a function that returns a paddr or 0 on error,
+ * check the paddr for being 0 *before* you use this macro. While paddr 0
+ * is not legal for memory allocation or memory management (it holds 
+ * exception handler code) when converted to a vaddr it's *not* NULL, *is*
+ * a valid address, and will make a *huge* mess if you scribble on it.
+ */
+#define PADDR_TO_KVADDR(paddr) ((paddr)+MIPS_KSEG0)
+
+/*
+ * The top of user space. (Actually, the address immediately above the
+ * last valid user address.)
+ */
+#define USERTOP     MIPS_KSEG0
+
+/*
+ * The starting value for the stack pointer at user level.  Because
+ * the stack is subtract-then-store, this can start as the next
+ * address after the stack area.
+ *
+ * We put the stack at the very top of user virtual memory because it
+ * grows downwards.
+ */
+#define USERSTACK   USERTOP
+
+/*
+ * Interface to the low-level module that looks after the amount of
+ * physical memory we have.
+ *
+ * ram_getsize returns the lowest valid physical address, and one past
+ * the highest valid physical address. (Both are page-aligned.) This
+ * is the memory that is available for use during operation, and
+ * excludes the memory the kernel is loaded into and memory that is
+ * grabbed in the very early stages of bootup.
+ *
+ * ram_stealmem can be used before ram_getsize is called to allocate
+ * memory that cannot be freed later. This is intended for use early
+ * in bootup before VM initialization is complete.
+ */
+
+void ram_bootstrap(void);
+paddr_t ram_stealmem(unsigned long npages);
+void ram_getsize(paddr_t *lo, paddr_t *hi);
+
+/*
+ * The ELF executable type for this platform.
+ */
+#define EM_MACHINE  EM_MIPS
+
+#endif /* _MIPS_VM_H_ */
diff --git a/os161-1.10/kern/arch/mips/mips/cache_mips1.S b/os161-1.10/kern/arch/mips/mips/cache_mips1.S
new file mode 100644
index 0000000..b4d3de5
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/cache_mips1.S
@@ -0,0 +1,23 @@
+#include <machine/asmdefs.h>
+
+   /*
+    * The actual mechanism for flushing the caches on MIPS is nasty.
+    * Here, we take advantage of the fact that we know we are running
+    * on the System/161 simulator, which doesn't have caches, and
+    * treat cache flushing as a no-op.
+    *
+    * Should you ever attempt to run on a real MIPS, you will need to
+    * implement these functions properly.
+    */
+
+   .text
+   .set noreorder
+
+   .globl mips_flushicache
+   .type mips_flushicache,@function
+   .ent mips_flushicache
+mips_flushicache:
+   j ra
+   nop
+   .end mips_flushicache
+
diff --git a/os161-1.10/kern/arch/mips/mips/dumbvm.c b/os161-1.10/kern/arch/mips/mips/dumbvm.c
new file mode 100644
index 0000000..10638bf
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/dumbvm.c
@@ -0,0 +1,315 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <thread.h>
+#include <curthread.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <machine/spl.h>
+#include <machine/tlb.h>
+
+/*
+ * Dumb MIPS-only "VM system" that is intended to only be just barely
+ * enough to struggle off the ground. You should replace all of this
+ * code while doing the VM assignment. In fact, starting in that
+ * assignment, this file is not included in your kernel!
+ */
+
+/* under dumbvm, always have 48k of user stack */
+#define DUMBVM_STACKPAGES    12
+
+void
+vm_bootstrap(void)
+{
+	/* Do nothing. */
+}
+
+static
+paddr_t
+getppages(unsigned long npages)
+{
+	int spl;
+	paddr_t addr;
+
+	spl = splhigh();
+
+	addr = ram_stealmem(npages);
+	
+	splx(spl);
+	return addr;
+}
+
+/* Allocate/free some kernel-space virtual pages */
+vaddr_t 
+alloc_kpages(int npages)
+{
+	paddr_t pa;
+	pa = getppages(npages);
+	if (pa==0) {
+		return 0;
+	}
+	return PADDR_TO_KVADDR(pa);
+}
+
+void 
+free_kpages(vaddr_t addr)
+{
+	/* nothing */
+
+	(void)addr;
+}
+
+int
+vm_fault(int faulttype, vaddr_t faultaddress)
+{
+	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+	paddr_t paddr;
+	int i;
+	u_int32_t ehi, elo;
+	struct addrspace *as;
+	int spl;
+
+	spl = splhigh();
+
+	faultaddress &= PAGE_FRAME;
+
+	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+
+	switch (faulttype) {
+	    case VM_FAULT_READONLY:
+		/* We always create pages read-write, so we can't get this */
+		panic("dumbvm: got VM_FAULT_READONLY\n");
+	    case VM_FAULT_READ:
+	    case VM_FAULT_WRITE:
+		break;
+	    default:
+		splx(spl);
+		return EINVAL;
+	}
+
+	as = curthread->t_vmspace;
+	if (as == NULL) {
+		/*
+		 * No address space set up. This is probably a kernel
+		 * fault early in boot. Return EFAULT so as to panic
+		 * instead of getting into an infinite faulting loop.
+		 */
+		return EFAULT;
+	}
+
+	/* Assert that the address space has been set up properly. */
+	assert(as->as_vbase1 != 0);
+	assert(as->as_pbase1 != 0);
+	assert(as->as_npages1 != 0);
+	assert(as->as_vbase2 != 0);
+	assert(as->as_pbase2 != 0);
+	assert(as->as_npages2 != 0);
+	assert(as->as_stackpbase != 0);
+	assert((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+	assert((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+	assert((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+	assert((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+	assert((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+
+	vbase1 = as->as_vbase1;
+	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+	vbase2 = as->as_vbase2;
+	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+	stacktop = USERSTACK;
+
+	if (faultaddress >= vbase1 && faultaddress < vtop1) {
+		paddr = (faultaddress - vbase1) + as->as_pbase1;
+	}
+	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+		paddr = (faultaddress - vbase2) + as->as_pbase2;
+	}
+	else if (faultaddress >= stackbase && faultaddress < stacktop) {
+		paddr = (faultaddress - stackbase) + as->as_stackpbase;
+	}
+	else {
+		splx(spl);
+		return EFAULT;
+	}
+
+	/* make sure it's page-aligned */
+	assert((paddr & PAGE_FRAME)==paddr);
+
+	for (i=0; i<NUM_TLB; i++) {
+		TLB_Read(&ehi, &elo, i);
+		if (elo & TLBLO_VALID) {
+			continue;
+		}
+		ehi = faultaddress;
+		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+		TLB_Write(ehi, elo, i);
+		splx(spl);
+		return 0;
+	}
+
+	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+	splx(spl);
+	return EFAULT;
+}
+
+struct addrspace *
+as_create(void)
+{
+	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+	if (as==NULL) {
+		return NULL;
+	}
+
+	as->as_vbase1 = 0;
+	as->as_pbase1 = 0;
+	as->as_npages1 = 0;
+	as->as_vbase2 = 0;
+	as->as_pbase2 = 0;
+	as->as_npages2 = 0;
+	as->as_stackpbase = 0;
+
+	return as;
+}
+
+void
+as_destroy(struct addrspace *as)
+{
+	kfree(as);
+}
+
+void
+as_activate(struct addrspace *as)
+{
+	int i, spl;
+
+	(void)as;
+
+	spl = splhigh();
+
+	for (i=0; i<NUM_TLB; i++) {
+		TLB_Write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+	}
+
+	splx(spl);
+}
+
+int
+as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+		 int readable, int writeable, int executable)
+{
+	size_t npages; 
+
+	/* Align the region. First, the base... */
+	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+	vaddr &= PAGE_FRAME;
+
+	/* ...and now the length. */
+	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+	npages = sz / PAGE_SIZE;
+
+	/* We don't use these - all pages are read-write */
+	(void)readable;
+	(void)writeable;
+	(void)executable;
+
+	if (as->as_vbase1 == 0) {
+		as->as_vbase1 = vaddr;
+		as->as_npages1 = npages;
+		return 0;
+	}
+
+	if (as->as_vbase2 == 0) {
+		as->as_vbase2 = vaddr;
+		as->as_npages2 = npages;
+		return 0;
+	}
+
+	/*
+	 * Support for more than two regions is not available.
+	 */
+	kprintf("dumbvm: Warning: too many regions\n");
+	return EUNIMP;
+}
+
+int
+as_prepare_load(struct addrspace *as)
+{
+	assert(as->as_pbase1 == 0);
+	assert(as->as_pbase2 == 0);
+	assert(as->as_stackpbase == 0);
+
+	as->as_pbase1 = getppages(as->as_npages1);
+	if (as->as_pbase1 == 0) {
+		return ENOMEM;
+	}
+
+	as->as_pbase2 = getppages(as->as_npages2);
+	if (as->as_pbase2 == 0) {
+		return ENOMEM;
+	}
+
+	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+	if (as->as_stackpbase == 0) {
+		return ENOMEM;
+	}
+
+	return 0;
+}
+
+int
+as_complete_load(struct addrspace *as)
+{
+	(void)as;
+	return 0;
+}
+
+int
+as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+{
+	assert(as->as_stackpbase != 0);
+
+	*stackptr = USERSTACK;
+	return 0;
+}
+
+int
+as_copy(struct addrspace *old, struct addrspace **ret)
+{
+	struct addrspace *new;
+
+	new = as_create();
+	if (new==NULL) {
+		return ENOMEM;
+	}
+
+	new->as_vbase1 = old->as_vbase1;
+	new->as_npages1 = old->as_npages1;
+	new->as_vbase2 = old->as_vbase2;
+	new->as_npages2 = old->as_npages2;
+
+	if (as_prepare_load(new)) {
+		as_destroy(new);
+		return ENOMEM;
+	}
+
+	assert(new->as_pbase1 != 0);
+	assert(new->as_pbase2 != 0);
+	assert(new->as_stackpbase != 0);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
+		old->as_npages1*PAGE_SIZE);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
+		old->as_npages2*PAGE_SIZE);
+
+	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+		DUMBVM_STACKPAGES*PAGE_SIZE);
+	
+	*ret = new;
+	return 0;
+}
diff --git a/os161-1.10/kern/arch/mips/mips/exception.S b/os161-1.10/kern/arch/mips/mips/exception.S
new file mode 100644
index 0000000..2db73a9
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/exception.S
@@ -0,0 +1,305 @@
+/*
+ * Entry points for exceptions
+ */
+   
+#include <machine/asmdefs.h>
+#include <machine/specialreg.h>
+
+   /* 
+    * Do not allow the assembler to use $1 (at), because we need to be
+    * able to save it.
+    */
+   .set noat
+   .set noreorder
+
+/****************************************************/
+/*                                                  */
+/* UTLB exception handler                           */
+/*                                                  */
+/* This code is copied to address 0x80000000, where */ 
+/* the MIPS processor automatically invokes it.     */
+/* To avoid colliding with the other exception code,*/
+/* it must not exceed 128 bytes (32 instructions).  */
+/*                                                  */
+/****************************************************/
+ 
+   .text
+   .globl utlb_exception
+   .type utlb_exception,@function
+   .ent utlb_exception
+utlb_exception:
+   move k1, sp			/* Save previous stack pointer in k1 */
+   mfc0 k0, c0_status		/* Get status register */
+   andi k0, k0, CST_KUp		/* Check the we-were-in-user-mode bit */
+   beq	k0, $0, 1f		/* If clear, from kernel, already have stack */
+   nop				/* delay slot */
+   
+   /* Coming from user mode - load kernel stack into sp */
+   la k0, curkstack		/* get address of "curkstack" */
+   lw sp, 0(k0)			/* get its value */
+   nop				/* delay slot for the load */
+  
+1:
+   mfc0 k0, c0_cause		/* Now, load the exception cause */
+   ori k0, k0, 1		/* Set bit 0 to mark it as utlb exception */
+   j common_exception		/* Skip to common code */
+   nop				/* delay slot */
+   .globl utlb_exception_end
+utlb_exception_end:
+   .end utlb_exception
+
+/****************************************************/
+/*                                                  */
+/* General exception handler                        */
+/*                                                  */
+/* This code is copied to address 0x80000080, where */ 
+/* the MIPS processor automatically invokes it.     */
+/*                                                  */
+/****************************************************/
+      
+   .text
+   .globl exception
+   .type exception,@function
+   .ent exception
+exception:
+   move k1, sp			/* Save previous stack pointer in k1 */
+   mfc0 k0, c0_status		/* Get status register */
+   andi k0, k0, CST_KUp		/* Check the we-were-in-user-mode bit */
+   beq	k0, $0, 1f		/* If clear, from kernel, already have stack */
+   nop				/* delay slot */
+   
+   /* Coming from user mode - load kernel stack into sp */
+   la k0, curkstack		/* get address of "curkstack" */
+   lw sp, 0(k0)			/* get its value */
+   nop				/* delay slot for the load */
+  
+1:
+   mfc0 k0, c0_cause		/* Now, load the exception cause. */
+   j common_exception		/* Skip to common code */
+   nop				/* delay slot */
+
+   .globl exception_end
+exception_end:
+   .end exception
+
+   /* This keeps gdb from conflating common_exception and exception_end */
+   nop				/* padding */
+
+
+/****************************************************/
+/*                                                  */
+/* Common exception code                            */
+/*                                                  */
+/****************************************************/
+   
+   .text
+   .type common_exception,@function
+   .ent common_exception
+common_exception:	
+
+   /*
+    * At this point:
+    *      Interrupts are off. (The processor did this for us.)
+    *      k0 contains the exception cause value.
+    *      k1 contains the old stack pointer.
+    *      sp points into the kernel stack.
+    *      All other registers are untouched.
+    */
+   
+   /*
+    * Allocate stack space for 37 words to hold the trap frame,
+    * plus four more words for a minimal argument block.
+    */
+   addi sp, sp, -164
+
+   /* 
+    * Save general registers.
+    * We exclude k0/k1, which the kernel is free to clobber (and which
+    * we already have clobbered), and $0, whose value is fixed.
+    *
+    * The order here must match mips/include/trapframe.h.
+    *
+    * gdb disassembles this code to try to figure out what registers
+    * are where, and it isn't very bright. So in order to make gdb be
+    * able to trace the stack back through here, we play some silly
+    * games.
+    *
+    * In particular:
+    *    (1) We store the return address register into the epc slot,
+    *        which makes gdb think it's the return address slot. Then
+    *        we store the real epc value over that.
+    *    (2) We store the current sp into the sp slot, which makes gdb
+    *        think it's the stack pointer slot. Then we store the real
+    *        value.
+    *    (3) gdb also assumes that saved registers in a function are
+    *        saved in order. This is why we put epc where it is, and
+    *        handle the real value of ra afterwards.
+    *    (4) Because gdb will think we're saving k0 and k1, we need to
+    *        leave slots for them in the trap frame, even though the
+    *        stuff we save there is useless.
+    */
+   sw ra, 160(sp)	/* dummy for gdb */
+   sw s8, 156(sp)	/* save s8 */
+   sw sp, 152(sp)	/* dummy for gdb */
+   sw gp, 148(sp)	/* save gp */
+   sw k1, 144(sp)	/* dummy for gdb */
+   sw k0, 140(sp)	/* dummy for gdb */
+
+   sw k1, 152(sp)	/* real saved sp */
+   nop			/* delay slot for store */
+   
+   mfc0 k1, c0_epc	/* Copr.0 reg 13 == PC for exception */
+   sw k1, 160(sp)	/* real saved PC */
+
+   sw t9, 136(sp)
+   sw t8, 132(sp)
+   sw s7, 128(sp)
+   sw s6, 124(sp)
+   sw s5, 120(sp)
+   sw s4, 116(sp)
+   sw s3, 112(sp)
+   sw s2, 108(sp)
+   sw s1, 104(sp)
+   sw s0, 100(sp)
+   sw t7, 96(sp)
+   sw t6, 92(sp)
+   sw t5, 88(sp)
+   sw t4, 84(sp)
+   sw t3, 80(sp)
+   sw t2, 76(sp)
+   sw t1, 72(sp)
+   sw t0, 68(sp)
+   sw a3, 64(sp)
+   sw a2, 60(sp)
+   sw a1, 56(sp)
+   sw a0, 52(sp)
+   sw v1, 48(sp)
+   sw v0, 44(sp)
+   sw AT, 40(sp)
+
+   sw ra, 36(sp)
+
+   /*
+    * Save special registers.
+    */
+   mfhi t0
+   mflo t1
+   sw t0, 32(sp)
+   sw t1, 28(sp)
+
+   /*
+    * Save remaining exception context information.
+    */
+
+   sw   k0, 24(sp)               /* k0 was loaded with cause earlier */
+   mfc0 t1, c0_status            /* Copr.0 reg 11 == status */
+   sw   t1, 20(sp)
+   mfc0 t2, c0_vaddr             /* Copr.0 reg 8 == faulting vaddr */
+   sw   t2, 16(sp)
+
+   /*
+    * Pretend to save $0 for gdb's benefit.
+    */
+   sw $0, 12(sp)
+   
+   /*
+    * Prepare to call mips_trap(struct trapframe *)
+    */
+
+   addiu a0, sp, 16             /* set argument */
+   jal mips_trap		/* call it */
+   nop				/* delay slot */
+
+   /* Something must be here or gdb doesn't find the stack frame. */
+   nop
+   
+   /*
+    * Now restore stuff and return from the exception.
+    * Interrupts should be off.
+    */
+exception_return:
+
+   /*     16(sp)		   no need to restore tf_vaddr */
+   lw t0, 20(sp)		/* load status register value into t0 */
+   nop				/* load delay slot */
+   mtc0 t0, c0_status		/* store it back to coprocessor 0 */
+   /*     24(sp)		   no need to restore tf_cause */
+
+   /* restore special registers */
+   lw t1, 28(sp)
+   lw t0, 32(sp)
+   mtlo t1
+   mthi t0
+
+   /* load the general registers */
+   lw ra, 36(sp)
+
+   lw AT, 40(sp)
+   lw v0, 44(sp)
+   lw v1, 48(sp)
+   lw a0, 52(sp)
+   lw a1, 56(sp)
+   lw a2, 60(sp)
+   lw a3, 64(sp)
+   lw t0, 68(sp)
+   lw t1, 72(sp)
+   lw t2, 76(sp)
+   lw t3, 80(sp)
+   lw t4, 84(sp)
+   lw t5, 88(sp)
+   lw t6, 92(sp)
+   lw t7, 96(sp)
+   lw s0, 100(sp)
+   lw s1, 104(sp)
+   lw s2, 108(sp)
+   lw s3, 112(sp)
+   lw s4, 116(sp)
+   lw s5, 120(sp)
+   lw s6, 124(sp)
+   lw s7, 128(sp)
+   lw t8, 132(sp)
+   lw t9, 136(sp)
+
+   /*     140(sp)		   "saved" k0 was dummy garbage anyway */
+   /*     144(sp)		   "saved" k1 was dummy garbage anyway */
+
+   lw gp, 148(sp)		/* restore gp */
+   /*     152(sp)		   stack pointer - below */
+   lw s8, 156(sp)		/* restore s8 */
+   lw k0, 160(sp)		/* fetch exception return PC into k0 */
+
+   lw sp, 152(sp)		/* fetch saved sp (must be last) */
+   
+   /* done */
+   jr k0			/* jump back */
+   rfe				/* in delay slot */
+   .end common_exception 
+
+/****************************************************/
+/*                                                  */
+/* Code to enter user mode for the first time       */
+/*                                                  */
+/* This must be called from md_usermode.            */
+/* Interrupts should be off.                        */
+/*                                                  */
+/****************************************************/
+
+   .text
+   .globl asm_usermode
+   .type asm_usermode,@function
+   .ent asm_usermode
+asm_usermode:
+   /*
+    * a0 is the address of a trapframe to use for exception "return".
+    * It's allocated on our stack.
+    *
+    * Move it to the stack pointer - we don't need the actual stack
+    * position any more. (When we come back from usermode, curkstack
+    * will be used to reinitialize our stack pointer.)
+    *
+    * Then just jump to the exception return code above.
+    */
+
+   j exception_return
+   addiu sp, a0, -16		/* in delay slot */
+   .end asm_usermode
diff --git a/os161-1.10/kern/arch/mips/mips/interrupt.c b/os161-1.10/kern/arch/mips/mips/interrupt.c
new file mode 100644
index 0000000..805c566
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/interrupt.c
@@ -0,0 +1,38 @@
+#include <types.h>
+#include <lib.h>
+#include <machine/bus.h>
+#include <machine/spl.h>
+#include <machine/pcb.h>
+
+/* Global that signals if we're presently in an interrupt handler. */
+int in_interrupt;
+
+/* 
+ * General interrupt handler for mips.
+ * "cause" is the contents of the c0_cause register.
+ */
+
+#define LAMEBUS_IRQ_BIT  0x00000400
+#define LAMEBUS_NMI_BIT  0x00000800
+
+void
+mips_interrupt(u_int32_t cause)
+{
+	int old_in = in_interrupt;
+	in_interrupt = 1;
+
+	/* interrupts should be off */
+	assert(curspl>0);
+
+	if (cause & LAMEBUS_IRQ_BIT) {
+		mips_lamebus_interrupt();
+	}
+	else if (cause & LAMEBUS_NMI_BIT) {
+		panic("Received NMI\n");
+	}
+	else {
+		panic("Unknown interrupt; cause register is %08x\n", cause);
+	}
+
+	in_interrupt = old_in;
+}
diff --git a/os161-1.10/kern/arch/mips/mips/lamebus_mips.c b/os161-1.10/kern/arch/mips/mips/lamebus_mips.c
new file mode 100644
index 0000000..0830c13
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/lamebus_mips.c
@@ -0,0 +1,157 @@
+#include <types.h>
+#include <kern/unistd.h>
+#include <lib.h>
+#include <synch.h>
+#include <machine/spl.h>
+#include <machine/pcb.h>
+#include <dev.h>
+#include <machine/bus.h>
+#include <lamebus/lamebus.h>
+#include "autoconf.h"
+
+/* LAMEbus data for the system (we have only one LAMEbus per system) */
+static struct lamebus_softc *lamebus;
+
+void
+machdep_dev_bootstrap(void)
+{
+	/* Interrupts should be off (and have been off since startup) */
+	assert(curspl>0);
+
+	/* Initialize the system LAMEbus data */
+	lamebus = lamebus_init();
+
+	/*
+	 * Print the device name for the main bus.
+	 */
+	kprintf("lamebus0 (system main bus)\n");
+
+	/*
+	 * Now we can take interrupts without croaking, so turn them on.
+	 * Some device probes might require being able to get interrupts.
+	 */
+
+	spl0();
+
+	/*
+	 * Now probe all the devices attached to the bus.
+	 * (This amounts to all devices.)
+	 */
+	autoconf_lamebus(lamebus, 0);
+}
+
+/*
+ * Function to generate the memory address (in the uncached segment)
+ * for the specified offset into the specified slot's region of the
+ * LAMEbus.
+ */
+void *
+lamebus_map_area(struct lamebus_softc *bus, int slot, u_int32_t offset)
+{
+	u_int32_t address;
+
+	(void)bus;   // not needed
+
+	assert(slot>=0 && slot<LB_NSLOTS);
+
+	address = LB_BASEADDR + slot*LB_SLOT_SIZE + offset;
+	return (void *)address;
+}
+
+/*
+ * Read a 32-bit register from a LAMEbus device.
+ */
+u_int32_t
+lamebus_read_register(struct lamebus_softc *bus, int slot, u_int32_t offset)
+{
+	u_int32_t *ptr = lamebus_map_area(bus, slot, offset);
+
+	return *ptr;
+}
+
+/*
+ * Write a 32-bit register of a LAMEbus device.
+ */
+void
+lamebus_write_register(struct lamebus_softc *bus, int slot,
+		       u_int32_t offset, u_int32_t val)
+{
+	u_int32_t *ptr = lamebus_map_area(bus, slot, offset);
+
+	*ptr = val;
+}
+
+
+/*
+ * Power off the system.
+ */
+void
+md_poweroff(void)
+{
+	/*
+	 *
+	 * Note that lamebus_write_register() doesn't actually access
+	 * the bus argument, so this will still work if we get here
+	 * before the bus is initialized.
+	 */
+	lamebus_poweroff(lamebus);
+}
+
+/*
+ * Reboot the system.
+ */
+void
+md_reboot(void)
+{
+	/*
+	 * The MIPS doesn't appear to have any on-chip reset.
+	 * LAMEbus doesn't have a reset control, so we just
+	 * power off instead of rebooting. This would not be
+	 * so great in a real system, but it's fine for what
+	 * we're doing.
+	 */
+	kprintf("Cannot reboot - powering off instead, sorry.\n");
+	md_poweroff();
+}
+
+/*
+ * Halt the system.
+ * On some systems, this would return to the boot monitor. But we don't
+ * have one.
+ */
+void
+md_halt(void)
+{
+	cpu_halt();
+}
+
+/*
+ * Called to reset the system from panic().
+ *
+ * By the time we get here, the system may well be sufficiently hosed
+ * as to panic recursively if we do much of anything. So just power off.
+ */
+void
+md_panic(void)
+{
+	md_poweroff();
+}
+
+/*
+ * Function to get the size of installed physical RAM from the LAMEbus
+ * controller.
+ */
+u_int32_t
+mips_ramsize(void)
+{
+	return lamebus_ramsize();
+}
+
+/*
+ * Interrupt dispatcher.
+ */
+void
+mips_lamebus_interrupt(void)
+{
+	lamebus_interrupt(lamebus);
+}
diff --git a/os161-1.10/kern/arch/mips/mips/pcb.c b/os161-1.10/kern/arch/mips/mips/pcb.c
new file mode 100644
index 0000000..e87daeb
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/pcb.c
@@ -0,0 +1,142 @@
+#include <types.h>
+#include <lib.h>
+#include <machine/pcb.h>
+#include <machine/spl.h>   // for in_interrupt
+#include <machine/switchframe.h>
+#include <thread.h>
+
+/* in switch.S */
+extern void mips_switch(struct pcb *old, struct pcb *nu);
+
+/* in threadstart.S */
+extern void mips_threadstart(/* arguments are in unusual registers */);
+
+u_int32_t curkstack;	/* curthread's kernel stack, for use on kernel entry */
+
+/*
+ * Function to initialize the pcb of the first (bootup) thread, which
+ * is the thread that is presently running.
+ *
+ * Initialize pcb_badfaultfunc to NULL.
+ *
+ * We don't need to do anything else, since pcb_switchstack is always
+ * overwritten at switch time anyway, and pcb_kstack is set at switch
+ * time from the global curkstack, which was set by start.S.
+ *
+ * Nonetheless, set everything to workable values, just to be safe.
+ */
+void
+md_initpcb0(struct pcb *pcb)
+{
+	pcb->pcb_switchstack = 0;
+	pcb->pcb_kstack = curkstack;
+	pcb->pcb_ininterrupt = 0;
+
+	pcb->pcb_badfaultfunc = NULL;
+}
+
+/*
+ * Function to initialize the pcb of a new thread, which is *not*
+ * the one that is currently running.
+ *
+ * The new thread should, when it is run the first time, end up calling
+ * mi_threadstart(data1, data2, func).
+ *
+ * We arrange for this by creating a phony switchframe for mips_switch()
+ * to switch to. The only trouble is that the switchframe doesn't include
+ * the argument registers a0-a3. So we store the arguments in the s* 
+ * registers, and use a bit of asm (mips_threadstart) to move them and
+ * then jump to mi_threadstart.
+ */
+void 
+md_initpcb(struct pcb *pcb, char *stack, 
+	   void *data1, unsigned long data2, 
+	   void (*func)(void *, unsigned long))
+{
+	/*
+	 * MIPS stacks grow down. What we get passed is just a hunk of
+	 * memory. So get the other end of it.
+	 */
+	u_int32_t stacktop = ((u_int32_t)stack) + STACK_SIZE;
+
+	/*
+	 * Set up a switchframe on the top of the stack, and point to it.
+	 */
+	struct switchframe *sf = ((struct switchframe *) stacktop) - 1;
+
+	/*
+	 * pcb_badfaultfunc should start NULL.
+	 *
+	 * pcb_kstack should be what the stack pointer should be on 
+	 * entry to the kernel, that is, the end with higher addresses.
+	 *
+	 * pcb_switchstack should be the address of the switchframe.
+	 */
+	pcb->pcb_badfaultfunc = NULL;
+	pcb->pcb_kstack = stacktop;
+	pcb->pcb_switchstack = (u_int32_t) sf;
+	pcb->pcb_ininterrupt = 0;
+
+	/*
+	 * Zero out the switchframe.
+	 */
+	bzero(sf, sizeof(*sf));
+
+	/*
+	 * Now set the important parts: pass through the three arguments,
+	 * and set the return address register to the place we want 
+	 * execution to begin.
+	 *
+	 * Thus, when mips_switch does its "j ra", it will actually jump
+	 * to mips_threadstart, which will move the arguments and jump to
+	 * mi_threadstart().
+	 *
+	 * Note that this means that when we call mips_switch() in
+	 * md_switch(), we may not come back out the same way in the
+	 * next thread. (Though we will come back out the same way
+	 * when we later come back to the same thread again.)
+	 *
+	 * This means that code at the bottom of md_switch, and
+	 * mi_switch as well, may be reached fewer times than the top
+	 * of md_switch. Thus, code should not be put there without
+	 * exercising some caution.
+	 */
+	sf->sf_s0 = (u_int32_t)data1;
+	sf->sf_s1 = (u_int32_t)data2;
+	sf->sf_s2 = (u_int32_t)func;
+	sf->sf_ra = (u_int32_t)mips_threadstart;
+}
+
+/*
+ * Machine-dependent entry point for thread context switch.
+ *
+ * We save some globals (note: the MI code takes care of curthread)
+ * whose values are really meant to be per-thread, and then call the
+ * assembly switch function to do the real work.
+ */
+void
+md_switch(struct pcb *old, struct pcb *nu)
+{
+	if (old==nu) {
+		return;
+	}
+	/*
+	 * Note: we don't need to switch curspl, because splhigh()
+	 * should always be in effect when we get here and when we
+	 * leave here.
+	 */
+
+	old->pcb_kstack = curkstack;
+	old->pcb_ininterrupt = in_interrupt;
+
+	curkstack = nu->pcb_kstack;
+	in_interrupt = nu->pcb_ininterrupt;
+
+	mips_switch(old, nu);
+
+	/*
+	 * Because new threads don't come back this way, and because
+	 * the values of old and nu are not what one would necessarily
+	 * expect after mips_switch, code should not be put here.
+	 */
+}
diff --git a/os161-1.10/kern/arch/mips/mips/ram.c b/os161-1.10/kern/arch/mips/mips/ram.c
new file mode 100644
index 0000000..efdea06
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/ram.c
@@ -0,0 +1,90 @@
+#include <types.h>
+#include <lib.h>
+#include <vm.h>
+#include <machine/pcb.h>  /* for mips_ramsize */
+
+u_int32_t firstfree;   /* first free virtual address; set by start.S */
+
+static u_int32_t firstpaddr;  /* address of first free physical page */
+static u_int32_t lastpaddr;   /* one past end of last free physical page */
+
+/*
+ * Called very early in system boot to figure out how much physical
+ * RAM is available.
+ */
+void
+ram_bootstrap(void)
+{
+	u_int32_t ramsize;
+	
+	/* Get size of RAM. */
+	ramsize = mips_ramsize();
+
+	/*
+	 * This is the same as the last physical address, as long as
+	 * we have less than 508 megabytes of memory. If we had more,
+	 * various annoying properties of the MIPS architecture would
+	 * force the RAM to be discontiguous. This is not a case we 
+	 * are going to worry about.
+	 */
+	if (ramsize > 508*1024*1024) {
+		ramsize = 508*1024*1024;
+	}
+
+	lastpaddr = ramsize;
+
+	/* 
+	 * Get first free virtual address from where start.S saved it.
+	 * Convert to physical address.
+	 */
+	firstpaddr = firstfree - MIPS_KSEG0;
+
+	kprintf("Cpu is MIPS r2000/r3000\n");
+	kprintf("%uk physical memory available\n", 
+		(lastpaddr-firstpaddr)/1024);
+}
+
+/*
+ * This function is for allocating physical memory prior to VM
+ * initialization.
+ *
+ * The pages it hands back will not be reported to the VM system when
+ * the VM system calls ram_getsize(). If it's desired to free up these
+ * pages later on after bootup is complete, some mechanism for adding
+ * them to the VM system's page management must be implemented.
+ *
+ * Note: while the error return value of 0 is a legal physical address,
+ * it's not a legal *allocatable* physical address, because it's the
+ * page with the exception handlers on it.
+ *
+ * This function should not be called once the VM system is initialized, 
+ * so it is not synchronized.
+ */
+paddr_t
+ram_stealmem(unsigned long npages)
+{
+	u_int32_t size = npages * PAGE_SIZE;
+	u_int32_t paddr;
+
+	if (firstpaddr + size > lastpaddr) {
+		return 0;
+	}
+
+	paddr = firstpaddr;
+	firstpaddr += size;
+
+	return paddr;
+}
+
+/*
+ * This function is intended to be called by the VM system when it
+ * initializes in order to find out what memory it has available to
+ * manage.
+ */
+void
+ram_getsize(u_int32_t *lo, u_int32_t *hi)
+{
+	*lo = firstpaddr;
+	*hi = lastpaddr;
+	firstpaddr = lastpaddr = 0;
+}
diff --git a/os161-1.10/kern/arch/mips/mips/spl.c b/os161-1.10/kern/arch/mips/mips/spl.c
new file mode 100644
index 0000000..4da846a
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/spl.c
@@ -0,0 +1,173 @@
+#include <types.h>
+#include <lib.h>
+#include <machine/spl.h>
+#include <machine/specialreg.h>
+
+/*
+ * Actual interrupt on/off functions.
+ *
+ * While the mips actually has on-chip interrupt priority masking, in
+ * the interests of simplicity, we don't use it. Instead we use
+ * coprocessor 0 register 12 (the system coprocessor "status"
+ * register) bit 0, IEc, which is the global interrupt enable flag.
+ * (IEc stands for interrupt-enable-current.)
+ *
+ * We use gcc inline assembly clauses to get at the status register.
+ */
+
+#define get_status(x) __asm volatile("mfc0 %0,$12" : "=r" (x))
+#define set_status(x) __asm volatile("mtc0 %0,$12" :: "r" (x))
+
+static
+inline
+void
+interrupts_on(void)
+{
+	u_int32_t x;
+	get_status(x);
+	x |= CST_IEc;
+	set_status(x);
+}
+
+static
+inline
+void
+interrupts_off(void)
+{
+	u_int32_t x;
+	get_status(x);
+	x &= ~(u_int32_t) CST_IEc;
+	set_status(x);
+}
+
+static
+inline
+void
+interrupts_onoff(void)
+{
+	u_int32_t x, xon, xoff;
+	get_status(x);
+	xon = x | CST_IEc;
+	xoff = x & ~(u_int32_t) CST_IEc;
+	set_status(xon);
+	set_status(xoff);
+}
+
+/*
+ * spl manipulation.
+ *
+ * See arch/mips/include/spl.h for more information about what this is all
+ * for.
+ */
+
+/* System starts out with interrupts off. */
+int curspl = SPL_HIGH;
+
+/* Set the spl level. */
+int
+splx(int newspl)
+{
+	int oldspl;
+	
+	/*
+	 * We don't need to synchronize access to curspl, even if our
+	 * accesses to it aren't atomic. If an interrupt occurs while
+	 * we're accessing it, the interrupt will change the value,
+	 * but the interrupt will set the value back the way it was
+	 * before it finishes. (And that happens with interrupts
+	 * disabled.) So we'll complete our half-finished operation
+	 * without noticing. 
+	 *
+	 * And other threads can't interfere, because they'd have to
+	 * run, and that would require an interrupt to occur first,
+	 * and that interrupt would preserve the value of curspl we're
+	 * working with.
+	 *
+	 * This would not be true if we were on a multiprocessor
+	 * system, but we aren't, and the concept of a single curspl
+	 * on a multiprocessor isn't especially valid anyway.
+	 */
+
+
+	/*
+	 * Note: always explicitly set the interrupt state, to 
+	 * minimize the consequences if we slip up accounting for
+	 * interrupts being turned off by exceptions.
+	 */
+	if (newspl>0) {
+		interrupts_off();
+	}
+	else if (newspl==0) {
+		interrupts_on();
+	}
+
+	oldspl = curspl;
+	curspl = newspl;
+
+	return oldspl;
+}
+
+/* Set spl level to "high". */
+int 
+splhigh(void)
+{
+	return splx(SPL_HIGH);
+}
+
+int
+spl0(void)
+{
+	return splx(0);
+}
+
+/*
+ * Idle the processor until something happens.
+ */
+
+void 
+cpu_idle(void)
+{
+	assert(curspl>0);
+	/* 
+	 * mips r2k/r3k has no idle instruction.
+	 *
+	 * However, to avoid completely overloading the computing cluster,
+	 * we appropriate the WAIT instruction from later MIPS revisions.
+	 * This goes into powersave mode until an interrupt is trying to 
+	 * occur.
+	 *
+	 * Then switch interrupts on and off again, so we actually take
+	 * the interrupt.
+	 *
+	 * Note that the precise behavior of this instruction in the
+	 * System/161 simulator is partly guesswork, thanks to the
+	 * specification being inadequate. So this code may well not
+	 * work on a real mips r4k, never mind an r2k/r3k.
+	 *
+	 * Note that the assembler knows that "wait" is not a valid
+	 * r2000/r3000 instruction and won't let us use it. Emit the
+	 * bit pattern for the wait instruction as a long instead.
+	 */
+
+	/* __asm volatile("wait"); */
+	__asm volatile(".long 0x42000020");
+
+	interrupts_onoff();
+}
+
+/*
+ * Halt the CPU permanently.
+ */
+void
+cpu_halt(void)
+{
+	/*
+	 * See notes in cpu_idle.
+	 */
+
+	interrupts_off();
+	while (1) {
+		/* __asm volatile("wait"); */
+		__asm volatile(".long 0x42000020");
+	}
+}
diff --git a/os161-1.10/kern/arch/mips/mips/start.S b/os161-1.10/kern/arch/mips/mips/start.S
new file mode 100644
index 0000000..2d3119c
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/start.S
@@ -0,0 +1,180 @@
+#include <machine/asmdefs.h>
+#include <machine/specialreg.h>
+
+   .set noreorder
+   
+   .text
+   .globl __start
+   .type __start,@function
+   .ent __start
+__start:
+
+   /*
+    * Stack frame. We save the return address register, even though
+    * it contains nothing useful. This is for gdb's benefit when it
+    * comes disassembling. We also need 16 bytes for making a call,
+    * so the total frame size is 20.
+    *
+    * Note that the frame here must match the frame we set up below
+    * when we switch off the bootup stack. Otherwise, gdb gets very
+    * confused.
+    */
+   .frame sp, 20, $0	/* 16-byte sp-relative frame; return addr on stack */
+   .mask 0x80000000, -4	/* register 31 (ra) saved at (sp+20)-4 */
+   addiu sp, sp, -20
+   sw ra, 16(sp)
+   
+   /*
+    * The System/161 loader sets up a boot stack for us at the top
+    * of physical memory, and passes us a single string argument.
+    * The string lives on the very top of the stack. We get its
+    * address in a0.
+    *
+    * The kernel loads at virtual address 0x80001000, which is
+    * physical address 0x00001000. The page immediately below this
+    * is reserved for the exception vector code. 
+    *
+    * The symbol _end is generated by the linker. It's the address of
+    * the end of the kernel. It's not a variable; the *value* of _end
+    * itself is this address.
+    *
+    * We set up the memory map like this:
+    *
+    *         top of memory
+    *                         free memory
+    *         P + 0x1000
+    *                         first thread's stack (1 page)
+    *         P
+    *                         wasted space (< 1 page)
+    *                         copy of the boot string
+    *         _end          
+    *                         kernel
+    *         0x80001000
+    *                         exception handlers
+    *         0x80000000
+    *
+    * where P is the next whole page after copying the argument string.
+    */
+
+   la s0, _end		/* stash _end in a saved register */
+   
+   move a1, a0		/* move bootstring to the second argument */
+   move a0, s0		/* make _end the first argument */
+   jal strcpy		/* call strcpy(_end, bootstring) */
+   nop			/* delay slot */
+
+   move a0, s0		/* make _end the first argument again */
+   jal strlen		/* call strlen(_end) */
+   nop
+
+   add t0, s0, v0	/* add in the length of the string */
+   addi t0, t0, 1	/* and the null terminator */
+   
+   
+   addi t0, t0, 4095	/* round up to next page boundary */
+   li   t1, 0xfffff000
+   and  t0, t0, t1
+
+   addi t0, t0, 4096	/* add one page to hold the stack */
+
+   move sp, t0		/* start the kernel stack for the first thread here */
+   sw t0, curkstack	/* which is also what we want our exceptions to use */
+
+   sw t0, firstfree	/* remember the first free page for later */
+
+   /*
+    * At this point, s0 contains the boot argument string, and no other
+    * registers contain anything interesting (except the stack pointer).
+    */
+
+   /*
+    * Now set up a stack frame on the real kernel stack: a dummy saved
+    * return address and four argument slots for making function calls.
+    * (This needs to match the stack frame set up at the top of the
+    * function, or the debugger gets confused.)
+    */
+   addiu sp, sp, -20
+   sw $0, 16(sp)
+
+   /*
+    * Now, copy the exception handler code onto the first page of memory.
+    */
+
+   li a0, 0x80000000
+   la a1, utlb_exception
+   la a2, utlb_exception_end
+   sub a2, a2, a1
+   jal memmove
+   nop
+
+   li a0, 0x80000080
+   la a1, exception
+   la a2, exception_end
+   sub a2, a2, a1
+   jal memmove
+   nop
+
+   /*
+    * Flush the instruction cache to make sure the above changes show
+    * through to instruction fetch.
+    */
+   jal mips_flushicache
+   nop
+
+   /*
+    * Initialize the TLB.
+    */
+   jal TLB_Reset
+   nop
+
+   /*
+    * Set up the status register.
+    *
+    * The MIPS has six hardware interrupt lines and two software interrupts.
+    * These are individually maskable in the status register. However, we
+    * don't use this feature (for simplicity) - we only use the master 
+    * interrupt enable/disable flag in bit 0. So enable all of those bits
+    * now and forget about them.
+    *
+    * The BEV bit in the status register, if set, causes the processor to
+    * jump to a different set of hardwired exception handling addresses.
+    * This is so that the kernel's exception handling code can be loaded
+    * into RAM and that the boot ROM's exception handling code can be ROM.
+    * This flag is normally set at boot time, and we need to be sure to
+    * clear it.
+    *
+    * The KUo/IEo/KUp/IEp/KUc/IEc bits should all start at zero.
+    *
+    * We also want all the other random control bits (mostly for cache
+    * stuff) set to zero.
+    *
+    * Thus, the actual value we write is CST_IRQMASK.
+    */
+   
+   li  t0, CST_IRQMASK		/* get value */
+   mtc0 t0, c0_status		/* set status register */
+
+   
+   /*
+    * We're all set up!
+    * Fetch the copy of the bootstring as the argument, and call main.
+    */
+   jal kmain
+   move a0, s0			/* in delay slot */
+
+
+   /*
+    * kmain shouldn't return. panic.
+    * Loop back just in case panic returns.
+    */
+1:
+   la  a0, panicstr
+   jal panic
+   nop				/* delay slot */
+   j 1b
+   nop				/* delay slot */
+   .end __start
+
+   .rdata
+panicstr:
+   .asciz "kmain returned\n"
diff --git a/os161-1.10/kern/arch/mips/mips/switch.S b/os161-1.10/kern/arch/mips/mips/switch.S
new file mode 100644
index 0000000..340521b
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/switch.S
@@ -0,0 +1,64 @@
+#include <machine/asmdefs.h>
+  
+   .text
+   .set noreorder
+  
+   .globl mips_switch
+   .type mips_switch,@function
+   .ent mips_switch
+mips_switch:
+   /*
+    * a0 contains a pointer to the old thread's struct pcb.
+    * a1 contains a pointer to the new thread's struct pcb.
+    *
+    * The only thing we touch in the pcb is the first word, which
+    * we save the stack pointer in. The other registers get saved
+    * on the stack, namely:
+    *
+    *      s0-s8
+    *      gp, ra
+    *
+    * The order must match arch/mips/include/switchframe.h.
+    */
+
+   /* Allocate stack space for saving 11 registers. 11*4 = 44 */
+   addi sp, sp, -44
+
+   /* Save the registers */
+   sw	ra, 40(sp)
+   sw	gp, 36(sp)
+   sw	s8, 32(sp)
+   sw	s7, 28(sp)
+   sw	s6, 24(sp)
+   sw	s5, 20(sp)
+   sw	s4, 16(sp)
+   sw	s3, 12(sp)
+   sw	s2, 8(sp)
+   sw	s1, 4(sp)
+   sw	s0, 0(sp)
+
+   /* Store the old stack pointer in the old pcb */
+   sw	sp, 0(a0)
+
+   /* Get the new stack pointer from the new pcb */
+   lw	sp, 0(a1)
+   nop		 /* delay slot for load */
+
+   /* Now, restore the registers */
+   lw	s0, 0(sp)
+   lw	s1, 4(sp)
+   lw	s2, 8(sp)
+   lw	s3, 12(sp)
+   lw	s4, 16(sp)
+   lw	s5, 20(sp)
+   lw	s6, 24(sp)
+   lw	s7, 28(sp)
+   lw	s8, 32(sp)
+   lw	gp, 36(sp)
+   lw	ra, 40(sp)
+   nop			/* delay slot for load */
+
+   /* and return. */
+   j ra
+   addi	sp, sp, 44	/* in delay slot */
+   .end mips_switch
diff --git a/os161-1.10/kern/arch/mips/mips/syscall.c b/os161-1.10/kern/arch/mips/mips/syscall.c
new file mode 100644
index 0000000..60e431d
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/syscall.c
@@ -0,0 +1,121 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <machine/pcb.h>
+#include <machine/spl.h>
+#include <machine/trapframe.h>
+#include <kern/callno.h>
+#include <syscall.h>
+
+
+/*
+ * System call handler.
+ *
+ * A pointer to the trapframe created during exception entry (in
+ * exception.S) is passed in.
+ *
+ * The calling conventions for syscalls are as follows: Like ordinary
+ * function calls, the first 4 32-bit arguments are passed in the 4
+ * argument registers a0-a3. In addition, the system call number is
+ * passed in the v0 register.
+ *
+ * On successful return, the return value is passed back in the v0
+ * register, like an ordinary function call, and the a3 register is
+ * also set to 0 to indicate success.
+ *
+ * On an error return, the error code is passed back in the v0
+ * register, and the a3 register is set to 1 to indicate failure.
+ * (Userlevel code takes care of storing the error code in errno and
+ * returning the value -1 from the actual userlevel syscall function.
+ * See src/lib/libc/syscalls.S and related files.)
+ *
+ * Upon syscall return the program counter stored in the trapframe
+ * must be incremented by one instruction; otherwise the exception
+ * return code will restart the "syscall" instruction and the system
+ * call will repeat forever.
+ *
+ * Since none of the OS/161 system calls have more than 4 arguments,
+ * there should be no need to fetch additional arguments from the
+ * user-level stack.
+ *
+ * Watch out: if you make system calls that have 64-bit quantities as
+ * arguments, they will get passed in pairs of registers, and not
+ * necessarily in the way you expect. We recommend you don't do it.
+ * (In fact, we recommend you don't use 64-bit quantities at all. See
+ * arch/mips/include/types.h.)
+ */
+
+void
+mips_syscall(struct trapframe *tf)
+{
+	int callno;
+	int32_t retval;
+	int err;
+
+	assert(curspl==0);
+
+	callno = tf->tf_v0;
+
+	/*
+	 * Initialize retval to 0. Many of the system calls don't
+	 * really return a value, just 0 for success and -1 on
+	 * error. Since retval is the value returned on success,
+	 * initialize it to 0 by default; thus it's not necessary to
+	 * deal with it except for calls that return other values, 
+	 * like write.
+	 */
+
+	retval = 0;
+
+	switch (callno) {
+	    case SYS_reboot:
+		err = sys_reboot(tf->tf_a0);
+		break;
+
+	    /* Add stuff here */
+ 
+	    default:
+		kprintf("Unknown syscall %d\n", callno);
+		err = ENOSYS;
+		break;
+	}
+
+
+	if (err) {
+		/*
+		 * Return the error code. This gets converted at
+		 * userlevel to a return value of -1 and the error
+		 * code in errno.
+		 */
+		tf->tf_v0 = err;
+		tf->tf_a3 = 1;      /* signal an error */
+	}
+	else {
+		/* Success. */
+		tf->tf_v0 = retval;
+		tf->tf_a3 = 0;      /* signal no error */
+	}
+	
+	/*
+	 * Now, advance the program counter, to avoid restarting
+	 * the syscall over and over again.
+	 */
+	
+	tf->tf_epc += 4;
+
+	/* Make sure the syscall code didn't forget to lower spl */
+	assert(curspl==0);
+}
+
+void
+md_forkentry(struct trapframe *tf)
+{
+	/*
+	 * This function is provided as a reminder. You need to write
+	 * both it and the code that calls it.
+	 *
+	 * Thus, you can trash it and do things another way if you prefer.
+	 */
+
+	(void)tf;
+}
diff --git a/os161-1.10/kern/arch/mips/mips/threadstart.S b/os161-1.10/kern/arch/mips/mips/threadstart.S
new file mode 100644
index 0000000..4150896
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/threadstart.S
@@ -0,0 +1,35 @@
+#include <machine/asmdefs.h>
+  
+   .text
+   .set noreorder
+
+   .globl mips_threadstart
+   .type mips_threadstart,@function
+   .ent mips_threadstart
+mips_threadstart:
+
+   /*
+    * This code doesn't take normal arguments. It's reached when
+    * mips_switch switches to a new thread. mips_switch does "j ra";
+    * ra gets preloaded in md_initpcb to come here.
+    *
+    * Our arguments are in callee-save registers, as follows:
+    *
+    *   s0   data1
+    *   s1   data2
+    *   s2   func
+    *
+    * We need to rearrange these so as to call the normal C function
+    * mi_threadstart(void *data1, unsigned long data2, void (*func)(...)).
+    */
+
+   addiu sp, sp, -16	/* make our stack frame */
+   
+   move ra, $0		/* clear return addr so we're top of the call stack */
+
+   move a0, s0		/* load arguments and call */
+   move a1, s1
+   j mi_threadstart
+   move a2, s2		/* (in delay slot) */
+
+   .end mips_threadstart
diff --git a/os161-1.10/kern/arch/mips/mips/tlb_mips1.S b/os161-1.10/kern/arch/mips/mips/tlb_mips1.S
new file mode 100644
index 0000000..d7fe244
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/tlb_mips1.S
@@ -0,0 +1,125 @@
+#include <machine/asmdefs.h>
+#include <machine/specialreg.h>
+
+   .text
+   .set noreorder
+
+   /*
+    * TLB_Random: use the "tlbwr" instruction to write a TLB entry
+    * into a (very pseudo-) random slot in the TLB.
+    */
+   .globl TLB_Random
+   .type TLB_Random,@function
+   .ent TLB_Random
+TLB_Random:
+   mtc0 a0, c0_entryhi	/* store the passed entry into the */
+   mtc0 a1, c0_entrylo	/*   tlb entry registers */
+   tlbwr		/* do it */
+   j ra
+   nop
+   .end TLB_Random
+
+   /*
+    * TLB_Write: use the "tlbwi" instruction to write a TLB entry
+    * into a selected slot in the TLB.
+    */
+   .text   
+   .globl TLB_Write
+   .type TLB_Write,@function
+   .ent TLB_Write
+TLB_Write:
+   mtc0 a0, c0_entryhi	/* store the passed entry into the */
+   mtc0 a1, c0_entrylo	/*   tlb entry registers */
+   sll  t0, a2, CIN_INDEXSHIFT  /* shift the passed index into place */
+   mtc0 t0, c0_index	/* store the shifted index into the index register */
+   tlbwi		/* do it */
+   j ra
+   nop
+   .end TLB_Write
+
+   /*
+    * TLB_Read: use the "tlbr" instruction to read a TLB entry
+    * from a selected slot in the TLB.
+    */
+   .text
+   .globl TLB_Read
+   .type TLB_Read,@function
+   .ent TLB_Read
+TLB_Read:
+   sll  t0, a2, CIN_INDEXSHIFT  /* shift the passed index into place */
+   mtc0 t0, c0_index	/* store the shifted index into the index register */
+   tlbr			/* do it */
+   mfc0 t0, c0_entryhi	/* get the tlb entry out of the */
+   mfc0 t1, c0_entrylo	/*   tlb entry registers */
+   sw t0, 0(a0)		/* store through the */
+   sw t1, 0(a1)		/*   passed pointers */
+   j ra
+   nop
+   .end TLB_Read
+
+   /*
+    * TLB_Probe: use the "tlbp" instruction to find the index in the
+    * TLB of a TLB entry matching the relevant parts of the one supplied.
+    */
+   .text
+   .globl TLB_Probe
+   .type TLB_Probe,@function
+   .ent TLB_Probe
+TLB_Probe:
+   mtc0 a0, c0_entryhi	/* store the passed entry into the */
+   mtc0 a1, c0_entrylo	/*   tlb entry registers */
+   tlbp			/* do it */
+   mfc0 t0, c0_index	/* fetch the index back in t0 */
+
+   /*
+    * If the high bit (CIN_P) of c0_index is set, the probe failed.
+    * The high bit is not set <--> c0_index (now in t0) >= 0.
+    */
+
+   bgez t0, 1f		/* did probe succeed? if so, skip forward */
+   nop			/* delay slot */
+   addi v0, z0, -1	/* set return value to -1 to indicate failure */
+   j ra			/* done */
+   nop			/* delay slot */
+
+1:
+   /* succeeded - get the index field from the index register value */
+   andi t1, t0, CIN_INDEX       /* mask off the field */
+   j ra				/* done */
+   sra  v0, t1, CIN_INDEXSHIFT  /* shift it (in delay slot) */
+   .end TLB_Probe
+
+
+   /*
+    * TLB_Reset
+    *
+    * Initialize the TLB. At processor startup, the TLB state is completely
+    * undefined. So be sure to avoid creating any duplicates. Also make sure
+    * that the initialization entries don't duplicate the INVALID entries
+    * defined in tlb.h. (This way you can write the invalid entries in
+    * without having to use tlbp to find out if they're going to cause dups.)
+    *
+    * This function is not defined in tlb.h because it's only called from
+    * start.S.
+    */
+   .text
+   .globl TLB_Reset
+   .type TLB_Reset,@function
+   .ent TLB_Reset
+TLB_Reset:
+   li t0, 0			/* t0 <- tlb index number (shifted) */
+   li t1, 0x81000000		/* t1 <- tlb reset vaddr */
+1:
+   mtc0 $0, c0_entrylo 		/* set up proposed tlb entry for reset */
+   mtc0 t1, c0_entryhi
+   tlbp				/* check if it already exists */
+   mfc0 t2, c0_index
+   bgez t2, 1b			/* if it does, loop back */
+   addiu t1, t1, 0x1000		/* next vaddr (in delay slot) */
+   mtc0 t0, c0_index		/* doesn't exist, set index to write to */
+   addiu t0, t0, 0x100		/* next tlb index (shifted) */
+   bne t0, 0x4000, 1b		/* if it's not the last tlb index, loop */
+   tlbwi			/* write tlb entry (in delay slot) */
+   j ra				/* done */
+   nop				/* delay slot */	
+   .end TLB_Reset
diff --git a/os161-1.10/kern/arch/mips/mips/trap.c b/os161-1.10/kern/arch/mips/mips/trap.c
new file mode 100644
index 0000000..30fca6f
--- /dev/null
+++ b/os161-1.10/kern/arch/mips/mips/trap.c
@@ -0,0 +1,293 @@
+#include <types.h>
+#include <lib.h>
+#include <machine/trapframe.h>
+#include <machine/specialreg.h>
+#include <machine/pcb.h>
+#include <machine/spl.h>
+#include <vm.h>
+#include <thread.h>
+#include <curthread.h>
+
+extern u_int32_t curkstack;
+
+/* in exception.S */
+extern void asm_usermode(struct trapframe *tf);
+
+/* Names for trap codes */
+#define NTRAPCODES 13
+static const char *const trapcodenames[NTRAPCODES] = {
+	"Interrupt",
+	"TLB modify trap",
+	"TLB miss on load",
+	"TLB miss on store",
+	"Address error on load",
+	"Address error on store",
+	"Bus error on code",
+	"Bus error on data",
+	"System call",
+	"Break instruction",
+	"Illegal instruction",
+	"Coprocessor unusable",
+	"Arithmetic overflow",
+};
+
+/*
+ * Function called when user-level code hits a fatal fault.
+ */
+static
+void
+kill_curthread(u_int32_t epc, unsigned code, u_int32_t vaddr)
+{
+	assert(code<NTRAPCODES);
+	kprintf("Fatal user mode trap %u (%s, epc 0x%x, vaddr 0x%x)\n",
+		code, trapcodenames[code], epc, vaddr);
+
+	/*
+	 * You will probably want to change this.
+	 */
+	panic("I don't know how to handle this\n");
+}
+
+/*
+ * General trap (exception) handling function for mips.
+ * This is called by the assembly-language exception handler once
+ * the trapframe has been set up.
+ */
+void
+mips_trap(struct trapframe *tf)
+{
+	u_int32_t code, isutlb, iskern;
+	int savespl;
+
+	/* The trap frame is supposed to be 37 registers long. */
+	assert(sizeof(struct trapframe)==(37*4));
+
+	/* Save the value of curspl, which belongs to the old context. */
+	savespl = curspl;
+
+	/* Right now, interrupts should be off. */
+	curspl = SPL_HIGH;
+
+	/*
+	 * Extract the exception code info from the register fields.
+	 */
+	code = (tf->tf_cause & CCA_CODE) >> CCA_CODESHIFT;
+	isutlb = (tf->tf_cause & CCA_UTLB);
+	iskern = (tf->tf_status & CST_KUp)==0;
+
+	assert(code<NTRAPCODES);
+
+	/* Make sure we haven't run off our stack */
+	if (curthread != NULL && curthread->t_stack != NULL) {
+		assert((vaddr_t)tf > (vaddr_t)curthread->t_stack);
+		assert((vaddr_t)tf < (vaddr_t)(curthread->t_stack+STACK_SIZE));
+	}
+
+	/* Interrupt? Call the interrupt handler and return. */
+	if (code == EX_IRQ) {
+		mips_interrupt(tf->tf_cause);
+		goto done;
+	}
+
+	/*
+	 * While we're in the kernel, and not actually handling an
+	 * interrupt, leave spl where it was in the previous context,
+	 * which is probably low (interrupts on).
+	 */
+	splx(savespl);
+
+	/* Syscall? Call the syscall handler and return. */
+	if (code == EX_SYS) {
+		/* Interrupts should have been on while in user mode. */
+		assert(curspl==0);
+
+		DEBUG(DB_SYSCALL, "syscall: #%d, args %x %x %x %x\n", 
+		      tf->tf_v0, tf->tf_a0, tf->tf_a1, tf->tf_a2, tf->tf_a3);
+
+		mips_syscall(tf);
+		goto done;
+	}
+
+	/*
+	 * Ok, it wasn't any of the really easy cases.
+	 * Call vm_fault on the TLB exceptions.
+	 * Panic on the bus error exceptions.
+	 */
+	switch (code) {
+	case EX_MOD:
+		if (vm_fault(VM_FAULT_READONLY, tf->tf_vaddr)==0) {
+			goto done;
+		}
+		break;
+	case EX_TLBL:
+		if (vm_fault(VM_FAULT_READ, tf->tf_vaddr)==0) {
+			goto done;
+		}
+		break;
+	case EX_TLBS:
+		if (vm_fault(VM_FAULT_WRITE, tf->tf_vaddr)==0) {
+			goto done;
+		}
+		break;
+	case EX_IBE:
+	case EX_DBE:
+		/*
+		 * This means you loaded invalid TLB entries, or 
+		 * touched invalid parts of the direct-mapped 
+		 * segments. These are serious kernel errors, so
+		 * panic.
+		 * 
+		 * The MIPS won't even tell you what invalid address
+		 * caused the bus error.
+		 */
+		panic("Bus error exception, PC=0x%x\n", tf->tf_epc);
+		break;
+	}
+
+	/*
+	 * If we get to this point, it's a fatal fault - either it's
+	 * one of the other exceptions, like illegal instruction, or
+	 * it was a page fault we couldn't handle.
+	 */
+
+	if (!iskern) {
+		/*
+		 * Fatal fault in user mode.
+		 * Kill the current user process.
+		 */
+		kill_curthread(tf->tf_epc, code, tf->tf_vaddr);
+		goto done;
+	}
+
+	/*
+	 * Fatal fault in kernel mode.
+	 *
+	 * If pcb_badfaultfunc is set, we do not panic; badfaultfunc is
+	 * set by copyin/copyout and related functions to signify that
+	 * the addresses they're accessing are userlevel-supplied and
+	 * not trustable. What we actually want to do is resume
+	 * execution at the function pointed to by badfaultfunc. That's 
+	 * going to be "copyfail" (see copyinout.c), which longjmps 
+	 * back to copyin/copyout or wherever and returns EFAULT.
+	 *
+	 * Note that we do not just *call* this function, because that
+	 * won't necessarily do anything. We want the control flow
+	 * that is currently executing in copyin (or whichever), and
+	 * is stopped while we process the exception, to *teleport* to
+	 * copyerr.
+	 *
+	 * This is accomplished by changing tf->tf_epc and returning
+	 * from the exception handler.
+	 */
+
+	if (curthread != NULL && curthread->t_pcb.pcb_badfaultfunc != NULL) {
+		tf->tf_epc = (vaddr_t) curthread->t_pcb.pcb_badfaultfunc;
+		goto done;
+	}
+
+	/*
+	 * Really fatal kernel-mode fault.
+	 */
+
+	kprintf("panic: Fatal exception %u (%s) in kernel mode\n", code,
+		trapcodenames[code]);
+	kprintf("panic: EPC 0x%x, exception vaddr 0x%x\n", 
+		tf->tf_epc, tf->tf_vaddr);
+
+	panic("I can't handle this... I think I'll just die now...\n");
+
+ done:
+	/* Make sure interrupts are off */
+	splhigh();
+
+	/*
+	 * Restore previous context's curspl value.
+	 *
+	 * The previous context's actual interrupt status flag will
+	 * be restored by the RFE instruction at the end of trap return.
+	 */
+	curspl = savespl;
+
+	/*
+	 * This assertion will fail if either
+	 *   (1) curkstack is corrupted, or
+	 *   (2) the trap frame is somehow on the wrong kernel stack.
+	 *
+	 * If curkstack is corrupted, the next trap back to the kernel
+	 * will (most likely) hang the system, so it's better to find
+	 * out now.
+	 */
+	assert(SAME_STACK(curkstack-1, (vaddr_t)tf));
+}
+
+/*
+ * Functions for entering user mode.
+ *
+ * This should not be used by threads returning from traps - they
+ * should just return from mips_trap(). It should be used by threads
+ * entering user mode for the first time - whether the child thread in
+ * a fork(), or into a brand-new address space after exec(), or when
+ * starting the first userlevel program.
+ *
+ * mips_usermode is the common code. It should not be called outside
+ * the mips port.
+ *
+ * md_usermode is meant for use in exec and equivalent.
+ * md_forkentry, in syscall.c, is meant for use in fork.
+ */
+void
+mips_usermode(struct trapframe *tf)
+{
+
+	/*
+	 * Interrupts should be off within the kernel while entering
+	 * usermode. However, while in usermode, interrupts should be
+	 * on. To interact properly with the spl-handling logic above,
+	 * we call splhigh() to disable interrupts, but set curspl
+	 * explicitly to 0.
+	 */
+	splhigh();
+	curspl = 0;
+
+	/*
+	 * This assertion will fail if either
+	 *   (1) curkstack is corrupted, or
+	 *   (2) the trap frame is not on our own kernel stack.
+	 *
+	 * If curkstack is corrupted, the next trap back to the kernel
+	 * will (most likely) hang the system, so it's better to find
+	 * out now.
+	 *
+	 * It's necessary for the trap frame used here to be on the
+	 * current thread's own stack. It cannot correctly be on either
+	 * another thread's stack or in the kernel heap. (Why?)
+	 */
+	assert(SAME_STACK(curkstack-1, (vaddr_t)tf));
+
+	/*
+	 * This actually does it. See exception.S.
+	 */
+	asm_usermode(tf);
+}
+
+/*
+ * md_usermode: go to user mode after loading an executable.
+ *
+ * Works by creating an ersatz trapframe and jumping into the middle
+ * of the exception return code.
+ */
+void
+md_usermode(int argc, userptr_t argv, vaddr_t stack, vaddr_t entry)
+{
+	struct trapframe tf;
+
+	bzero(&tf, sizeof(tf));
+
+	tf.tf_status = CST_IRQMASK | CST_IEp | CST_KUp;
+	tf.tf_epc = entry;
+	tf.tf_a0 = argc;
+	tf.tf_a1 = (vaddr_t)argv;
+	tf.tf_sp = stack;
+
+	mips_usermode(&tf);
+}
diff --git a/os161-1.10/kern/asst1/catlock.c b/os161-1.10/kern/asst1/catlock.c
new file mode 100644
index 0000000..cd3ae6b
--- /dev/null
+++ b/os161-1.10/kern/asst1/catlock.c
@@ -0,0 +1,198 @@
+/*
+ * catlock.c
+ *
+ * 30-1-2003 : GWA : Stub functions created for CS161 Asst1.
+ *
+ * NB: Please use LOCKS/CV'S to solve the cat syncronization problem in 
+ * this file.
+ */
+
+
+/*
+ * 
+ * Includes
+ *
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <test.h>
+#include <thread.h>
+
+
+/*
+ * 
+ * Constants
+ *
+ */
+
+/*
+ * Number of food bowls.
+ */
+
+#define NFOODBOWLS 2
+
+/*
+ * Number of cats.
+ */
+
+#define NCATS 6
+
+/*
+ * Number of mice.
+ */
+
+#define NMICE 2
+
+
+/*
+ * 
+ * Function Definitions
+ * 
+ */
+
+
+/*
+ * catlock()
+ *
+ * Arguments:
+ *      void * unusedpointer: currently unused.
+ *      unsigned long catnumber: holds the cat identifier from 0 to NCATS -
+ *      1.
+ *
+ * Returns:
+ *      nothing.
+ *
+ * Notes:
+ *      Write and comment this function using locks/cv's.
+ *
+ */
+
+static
+void
+catlock(void * unusedpointer, 
+        unsigned long catnumber)
+{
+        /*
+         * Avoid unused variable warnings.
+         */
+
+        (void) unusedpointer;
+        (void) catnumber;
+}
+	
+
+/*
+ * mouselock()
+ *
+ * Arguments:
+ *      void * unusedpointer: currently unused.
+ *      unsigned long mousenumber: holds the mouse identifier from 0 to 
+ *              NMICE - 1.
+ *
+ * Returns:
+ *      nothing.
+ *
+ * Notes:
+ *      Write and comment this function using locks/cv's.
+ *
+ */
+
+static
+void
+mouselock(void * unusedpointer,
+          unsigned long mousenumber)
+{
+        /*
+         * Avoid unused variable warnings.
+         */
+        
+        (void) unusedpointer;
+        (void) mousenumber;
+}
+
+
+/*
+ * catmouselock()
+ *
+ * Arguments:
+ *      int nargs: unused.
+ *      char ** args: unused.
+ *
+ * Returns:
+ *      0 on success.
+ *
+ * Notes:
+ *      Driver code to start up catlock() and mouselock() threads.  Change
+ *      this code as necessary for your solution.
+ */
+
+int
+catmouselock(int nargs,
+             char ** args)
+{
+        int index, error;
+   
+        /*
+         * Avoid unused variable warnings.
+         */
+
+        (void) nargs;
+        (void) args;
+   
+        /*
+         * Start NCATS catlock() threads.
+         */
+
+        for (index = 0; index < NCATS; index++) {
+           
+                error = thread_fork("catlock thread", 
+                                    NULL, 
+                                    index, 
+                                    catlock, 
+                                    NULL
+                                    );
+                
+                /*
+                 * panic() on error.
+                 */
+
+                if (error) {
+                 
+                        panic("catlock: thread_fork failed: %s\n", 
+                              strerror(error)
+                              );
+                }
+        }
+
+        /*
+         * Start NMICE mouselock() threads.
+         */
+
+        for (index = 0; index < NMICE; index++) {
+   
+                error = thread_fork("mouselock thread", 
+                                    NULL, 
+                                    index, 
+                                    mouselock, 
+                                    NULL
+                                    );
+      
+                /*
+                 * panic() on error.
+                 */
+
+                if (error) {
+         
+                        panic("mouselock: thread_fork failed: %s\n", 
+                              strerror(error)
+                              );
+                }
+        }
+
+        return 0;
+}
+
+/*
+ * End of catlock.c
+ */
diff --git a/os161-1.10/kern/asst1/catsem.c b/os161-1.10/kern/asst1/catsem.c
new file mode 100644
index 0000000..dcb257b
--- /dev/null
+++ b/os161-1.10/kern/asst1/catsem.c
@@ -0,0 +1,198 @@
+/*
+ * catsem.c
+ *
+ * 30-1-2003 : GWA : Stub functions created for CS161 Asst1.
+ *
+ * NB: Please use SEMAPHORES to solve the cat syncronization problem in 
+ * this file.
+ */
+
+
+/*
+ * 
+ * Includes
+ *
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <test.h>
+#include <thread.h>
+
+
+/*
+ * 
+ * Constants
+ *
+ */
+
+/*
+ * Number of food bowls.
+ */
+
+#define NFOODBOWLS 2
+
+/*
+ * Number of cats.
+ */
+
+#define NCATS 6
+
+/*
+ * Number of mice.
+ */
+
+#define NMICE 2
+
+
+/*
+ * 
+ * Function Definitions
+ * 
+ */
+
+
+/*
+ * catsem()
+ *
+ * Arguments:
+ *      void * unusedpointer: currently unused.
+ *      unsigned long catnumber: holds the cat identifier from 0 to NCATS - 1.
+ *
+ * Returns:
+ *      nothing.
+ *
+ * Notes:
+ *      Write and comment this function using semaphores.
+ *
+ */
+
+static
+void
+catsem(void * unusedpointer, 
+       unsigned long catnumber)
+{
+        /*
+         * Avoid unused variable warnings.
+         */
+
+        (void) unusedpointer;
+        (void) catnumber;
+}
+        
+
+/*
+ * mousesem()
+ *
+ * Arguments:
+ *      void * unusedpointer: currently unused.
+ *      unsigned long mousenumber: holds the mouse identifier from 0 to 
+ *              NMICE - 1.
+ *
+ * Returns:
+ *      nothing.
+ *
+ * Notes:
+ *      Write and comment this function using semaphores.
+ *
+ */
+
+static
+void
+mousesem(void * unusedpointer, 
+         unsigned long mousenumber)
+{
+        /*
+         * Avoid unused variable warnings.
+         */
+
+        (void) unusedpointer;
+        (void) mousenumber;
+}
+
+
+/*
+ * catmousesem()
+ *
+ * Arguments:
+ *      int nargs: unused.
+ *      char ** args: unused.
+ *
+ * Returns:
+ *      0 on success.
+ *
+ * Notes:
+ *      Driver code to start up catsem() and mousesem() threads.  Change this 
+ *      code as necessary for your solution.
+ */
+
+int
+catmousesem(int nargs,
+            char ** args)
+{
+        int index, error;
+   
+        /*
+         * Avoid unused variable warnings.
+         */
+
+        (void) nargs;
+        (void) args;
+   
+        /*
+         * Start NCATS catsem() threads.
+         */
+
+        for (index = 0; index < NCATS; index++) {
+           
+                error = thread_fork("catsem Thread", 
+                                    NULL, 
+                                    index, 
+                                    catsem, 
+                                    NULL
+                                    );
+                
+                /*
+                 * panic() on error.
+                 */
+
+                if (error) {
+                 
+                        panic("catsem: thread_fork failed: %s\n", 
+                              strerror(error)
+                              );
+                }
+        }
+        
+        /*
+         * Start NMICE mousesem() threads.
+         */
+
+        for (index = 0; index < NMICE; index++) {
+   
+                error = thread_fork("mousesem Thread", 
+                                    NULL, 
+                                    index, 
+                                    mousesem, 
+                                    NULL
+                                    );
+                
+                /*
+                 * panic() on error.
+                 */
+
+                if (error) {
+         
+                        panic("mousesem: thread_fork failed: %s\n", 
+                              strerror(error)
+                              );
+                }
+        }
+
+        return 0;
+}
+
+
+/*
+ * End of catsem.c
+ */
diff --git a/os161-1.10/kern/asst1/stoplight.c b/os161-1.10/kern/asst1/stoplight.c
new file mode 100644
index 0000000..7caf4e4
--- /dev/null
+++ b/os161-1.10/kern/asst1/stoplight.c
@@ -0,0 +1,235 @@
+/* 
+ * stoplight.c
+ *
+ * 31-1-2003 : GWA : Stub functions created for CS161 Asst1.
+ *
+ * NB: You can use any synchronization primitives available to solve
+ * the stoplight problem in this file.
+ */
+
+
+/*
+ * 
+ * Includes
+ *
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <test.h>
+#include <thread.h>
+
+
+/*
+ *
+ * Constants
+ *
+ */
+
+/*
+ * Number of cars created.
+ */
+
+#define NCARS 20
+
+
+/*
+ *
+ * Function Definitions
+ *
+ */
+
+
+/*
+ * gostraight()
+ *
+ * Arguments:
+ *      unsigned long cardirection: the direction from which the car
+ *              approaches the intersection.
+ *      unsigned long carnumber: the car id number for printing purposes.
+ *
+ * Returns:
+ *      nothing.
+ *
+ * Notes:
+ *      This function should implement passing straight through the
+ *      intersection from any direction.
+ *      Write and comment this function.
+ */
+
+static
+void
+gostraight(unsigned long cardirection,
+           unsigned long carnumber)
+{
+        /*
+         * Avoid unused variable warnings.
+         */
+        
+        (void) cardirection;
+        (void) carnumber;
+}
+
+
+/*
+ * turnleft()
+ *
+ * Arguments:
+ *      unsigned long cardirection: the direction from which the car
+ *              approaches the intersection.
+ *      unsigned long carnumber: the car id number for printing purposes.
+ *
+ * Returns:
+ *      nothing.
+ *
+ * Notes:
+ *      This function should implement making a left turn through the 
+ *      intersection from any direction.
+ *      Write and comment this function.
+ */
+
+static
+void
+turnleft(unsigned long cardirection,
+         unsigned long carnumber)
+{
+        /*
+         * Avoid unused variable warnings.
+         */
+
+        (void) cardirection;
+        (void) carnumber;
+}
+
+
+/*
+ * turnright()
+ *
+ * Arguments:
+ *      unsigned long cardirection: the direction from which the car
+ *              approaches the intersection.
+ *      unsigned long carnumber: the car id number for printing purposes.
+ *
+ * Returns:
+ *      nothing.
+ *
+ * Notes:
+ *      This function should implement making a right turn through the 
+ *      intersection from any direction.
+ *      Write and comment this function.
+ */
+
+static
+void
+turnright(unsigned long cardirection,
+          unsigned long carnumber)
+{
+        /*
+         * Avoid unused variable warnings.
+         */
+
+        (void) cardirection;
+        (void) carnumber;
+}
+
+
+/*
+ * approachintersection()
+ *
+ * Arguments: 
+ *      void * unusedpointer: currently unused.
+ *      unsigned long carnumber: holds car id number.
+ *
+ * Returns:
+ *      nothing.
+ *
+ * Notes:
+ *      Change this function as necessary to implement your solution. These
+ *      threads are created by createcars().  Each one must choose a direction
+ *      randomly, approach the intersection, choose a turn randomly, and then
+ *      complete that turn.  The code to choose a direction randomly is
+ *      provided, the rest is left to you to implement.  Making a turn
+ *      or going straight should be done by calling one of the functions
+ *      above.
+ */
+ 
+static
+void
+approachintersection(void * unusedpointer,
+                     unsigned long carnumber)
+{
+        int cardirection;
+
+        /*
+         * Avoid unused variable and function warnings.
+         */
+
+        (void) unusedpointer;
+        (void) carnumber;
+	(void) gostraight;
+	(void) turnleft;
+	(void) turnright;
+
+        /*
+         * cardirection is set randomly.
+         */
+
+        cardirection = random() % 4;
+}
+
+
+/*
+ * createcars()
+ *
+ * Arguments:
+ *      int nargs: unused.
+ *      char ** args: unused.
+ *
+ * Returns:
+ *      0 on success.
+ *
+ * Notes:
+ *      Driver code to start up the approachintersection() threads.  You are
+ *      free to modiy this code as necessary for your solution.
+ */
+
+int
+createcars(int nargs,
+           char ** args)
+{
+        int index, error;
+
+        /*
+         * Avoid unused variable warnings.
+         */
+
+        (void) nargs;
+        (void) args;
+
+        /*
+         * Start NCARS approachintersection() threads.
+         */
+
+        for (index = 0; index < NCARS; index++) {
+
+                error = thread_fork("approachintersection thread",
+                                    NULL,
+                                    index,
+                                    approachintersection,
+                                    NULL
+                                    );
+
+                /*
+                 * panic() on error.
+                 */
+
+                if (error) {
+                        
+                        panic("approachintersection: thread_fork failed: %s\n",
+                              strerror(error)
+                              );
+                }
+        }
+
+        return 0;
+}
diff --git a/os161-1.10/kern/compile/.cvsignore b/os161-1.10/kern/compile/.cvsignore
new file mode 100644
index 0000000..010ddd2
--- /dev/null
+++ b/os161-1.10/kern/compile/.cvsignore
@@ -0,0 +1 @@
+[A-Z]*
diff --git a/os161-1.10/kern/conf/ASST0 b/os161-1.10/kern/conf/ASST0
new file mode 100644
index 0000000..069ec8d
--- /dev/null
+++ b/os161-1.10/kern/conf/ASST0
@@ -0,0 +1,35 @@
+# Kernel config file for assignment 0.
+
+arch mips			# use MIPS r2000/r3000
+include conf/conf.kern		# get definitions of available options
+
+debug				# Compile with debug info.
+
+#
+# Device drivers for hardware.
+#
+device lamebus0			# System/161 main bus
+device emu* at lamebus*		# Emulator passthrough filesystem
+device ltrace* at lamebus*	# trace161 trace control device
+device ltimer* at lamebus*	# Timer device
+device lrandom* at lamebus*	# Random device
+device lhd* at lamebus*		# Disk device
+device lser* at lamebus*	# Serial port
+#device lscreen* at lamebus*	# Text screen (not supported yet)
+#device lnet* at lamebus*	# Network interface (not supported yet)
+device beep0 at ltimer*		# Abstract beep handler device
+device con0 at lser*		# Abstract console on serial port
+#device con0 at lscreen*	# Abstract console on screen (not supported)
+device rtclock0 at ltimer*	# Abstract realtime clock
+device random0 at lrandom*	# Abstract randomness device
+
+device pseudorand0		# Software random generator
+device random0 at pseudorand0	# Abstract randomness device
+
+#options net			# Network stack (not supported)
+
+options sfs			# Always use the file system
+#options netfs			# Not until assignment 5 (if you choose it)
+
+options dumbvm			# Chewing gum and baling wire for asst 1&2.
+#options synchprobs		# The synchronization problems for assignment 1
diff --git a/os161-1.10/kern/conf/ASST1 b/os161-1.10/kern/conf/ASST1
new file mode 100644
index 0000000..1331dc1
--- /dev/null
+++ b/os161-1.10/kern/conf/ASST1
@@ -0,0 +1,35 @@
+# Kernel config file for assignment 1.
+
+arch mips			# use MIPS r2000/r3000
+include conf/conf.kern		# get definitions of available options
+
+debug				# Compile with debug info.
+
+#
+# Device drivers for hardware.
+#
+device lamebus0			# System/161 main bus
+device emu* at lamebus*		# Emulator passthrough filesystem
+device ltrace* at lamebus*	# trace161 trace control device
+device ltimer* at lamebus*	# Timer device
+device lrandom* at lamebus*	# Random device
+device lhd* at lamebus*		# Disk device
+device lser* at lamebus*	# Serial port
+#device lscreen* at lamebus*	# Text screen (not supported yet)
+#device lnet* at lamebus*	# Network interface (not supported yet)
+device beep0 at ltimer*		# Abstract beep handler device
+device con0 at lser*		# Abstract console on serial port
+#device con0 at lscreen*	# Abstract console on screen (not supported)
+device rtclock0 at ltimer*	# Abstract realtime clock
+device random0 at lrandom*	# Abstract randomness device
+
+device pseudorand0		# Software random generator
+device random0 at pseudorand0	# Abstract randomness device
+
+#options net			# Network stack (not supported)
+
+options sfs			# Always use the file system
+#options netfs			# Not until assignment 5 (if you choose it)
+
+options dumbvm			# Chewing gum and baling wire for asst 1&2.
+options synchprobs		# The synchronization problems for assignment 1
diff --git a/os161-1.10/kern/conf/ASST2 b/os161-1.10/kern/conf/ASST2
new file mode 100644
index 0000000..5822a13
--- /dev/null
+++ b/os161-1.10/kern/conf/ASST2
@@ -0,0 +1,35 @@
+# Kernel config file for assignment 2.
+
+arch mips			# use MIPS r2000/r3000
+include conf/conf.kern		# get definitions of available options
+
+debug				# Compile with debug info.
+
+#
+# Device drivers for hardware.
+#
+device lamebus0			# System/161 main bus
+device emu* at lamebus*		# Emulator passthrough filesystem
+device ltrace* at lamebus*	# trace161 trace control device
+device ltimer* at lamebus*	# Timer device
+device lrandom* at lamebus*	# Random device
+device lhd* at lamebus*		# Disk device
+device lser* at lamebus*	# Serial port
+#device lscreen* at lamebus*	# Text screen (not supported yet)
+#device lnet* at lamebus*	# Network interface (not supported yet)
+device beep0 at ltimer*		# Abstract beep handler device
+device con0 at lser*		# Abstract console on serial port
+#device con0 at lscreen*	# Abstract console on screen (not supported)
+device rtclock0 at ltimer*	# Abstract realtime clock
+device random0 at lrandom*	# Abstract randomness device
+
+device pseudorand0		# Software random generator
+device random0 at pseudorand0	# Abstract randomness device
+
+#options net			# Network stack (not supported)
+
+options sfs			# Always use the file system
+#options netfs			# Not until assignment 5 (if you choose it)
+
+options dumbvm			# Chewing gum and baling wire for asst 1&2.
+#options synchprobs		# No longer needed/wanted after asst. 1
diff --git a/os161-1.10/kern/conf/ASST2-OPT b/os161-1.10/kern/conf/ASST2-OPT
new file mode 100644
index 0000000..3371491
--- /dev/null
+++ b/os161-1.10/kern/conf/ASST2-OPT
@@ -0,0 +1,36 @@
+# Kernel config file for assignment 2.
+# This config builds with optimization for performance testing.
+
+arch mips			# use MIPS r2000/r3000
+include conf/conf.kern		# get definitions of available options
+
+#debug				# Optimizing compile (no debug).
+
+#
+# Device drivers for hardware.
+#
+device lamebus0			# System/161 main bus
+device emu* at lamebus*		# Emulator passthrough filesystem
+device ltrace* at lamebus*	# trace161 trace control device
+device ltimer* at lamebus*	# Timer device
+device lrandom* at lamebus*	# Random device
+device lhd* at lamebus*		# Disk device
+device lser* at lamebus*	# Serial port
+#device lscreen* at lamebus*	# Text screen (not supported yet)
+#device lnet* at lamebus*	# Network interface (not supported yet)
+device beep0 at ltimer*		# Abstract beep handler device
+device con0 at lser*		# Abstract console on serial port
+#device con0 at lscreen*	# Abstract console on screen (not supported)
+device rtclock0 at ltimer*	# Abstract realtime clock
+device random0 at lrandom*	# Abstract randomness device
+
+device pseudorand0		# Software random generator
+device random0 at pseudorand0	# Abstract randomness device
+
+#options net			# Network stack (not supported)
+
+options sfs			# Always use the file system
+#options netfs			# Not until assignment 5 (if you choose it)
+
+options dumbvm			# Chewing gum and baling wire for asst 1&2.
+#options synchprobs		# No longer needed/wanted after asst. 1
diff --git a/os161-1.10/kern/conf/ASST3 b/os161-1.10/kern/conf/ASST3
new file mode 100644
index 0000000..da280ed
--- /dev/null
+++ b/os161-1.10/kern/conf/ASST3
@@ -0,0 +1,35 @@
+# Kernel config file for assignment 3.
+
+arch mips			# use MIPS r2000/r3000
+include conf/conf.kern		# get definitions of available options
+
+debug				# Compile with debug info.
+
+#
+# Device drivers for hardware.
+#
+device lamebus0			# System/161 main bus
+device emu* at lamebus*		# Emulator passthrough filesystem
+device ltrace* at lamebus*	# trace161 trace control device
+device ltimer* at lamebus*	# Timer device
+device lrandom* at lamebus*	# Random device
+device lhd* at lamebus*		# Disk device
+device lser* at lamebus*	# Serial port
+#device lscreen* at lamebus*	# Text screen (not supported yet)
+#device lnet* at lamebus*	# Network interface (not supported yet)
+device beep0 at ltimer*		# Abstract beep handler device
+device con0 at lser*		# Abstract console on serial port
+#device con0 at lscreen*	# Abstract console on screen (not supported)
+device rtclock0 at ltimer*	# Abstract realtime clock
+device random0 at lrandom*	# Abstract randomness device
+
+device pseudorand0		# Software random generator
+device random0 at pseudorand0	# Abstract randomness device
+
+#options net			# Network stack (not supported)
+
+options sfs			# Always use the file system
+#options netfs			# Not until assignment 5 (if you choose it)
+
+#options dumbvm			# Use your own VM system now.
+#options synchprobs		# No longer needed/wanted after asst. 1
diff --git a/os161-1.10/kern/conf/ASST4 b/os161-1.10/kern/conf/ASST4
new file mode 100644
index 0000000..bf9713d
--- /dev/null
+++ b/os161-1.10/kern/conf/ASST4
@@ -0,0 +1,35 @@
+# Kernel config file for assignment 4.
+
+arch mips			# use MIPS r2000/r3000
+include conf/conf.kern		# get definitions of available options
+
+debug				# Compile with debug info.
+
+#
+# Device drivers for hardware.
+#
+device lamebus0			# System/161 main bus
+device emu* at lamebus*		# Emulator passthrough filesystem
+device ltrace* at lamebus*	# trace161 trace control device
+device ltimer* at lamebus*	# Timer device
+device lrandom* at lamebus*	# Random device
+device lhd* at lamebus*		# Disk device
+device lser* at lamebus*	# Serial port
+#device lscreen* at lamebus*	# Text screen (not supported yet)
+#device lnet* at lamebus*	# Network interface (not supported yet)
+device beep0 at ltimer*		# Abstract beep handler device
+device con0 at lser*		# Abstract console on serial port
+#device con0 at lscreen*	# Abstract console on screen (not supported)
+device rtclock0 at ltimer*	# Abstract realtime clock
+device random0 at lrandom*	# Abstract randomness device
+
+device pseudorand0		# Software random generator
+device random0 at pseudorand0	# Abstract randomness device
+
+#options net			# Network stack (not supported)
+
+options sfs			# Always use the file system
+#options netfs			# Not until assignment 5 (if you choose it)
+
+#options dumbvm			# Use your own VM system now.
+#options synchprobs		# No longer needed/wanted after asst. 1
diff --git a/os161-1.10/kern/conf/ASST5 b/os161-1.10/kern/conf/ASST5
new file mode 100644
index 0000000..55b8527
--- /dev/null
+++ b/os161-1.10/kern/conf/ASST5
@@ -0,0 +1,38 @@
+# Kernel config file for assignment 5.
+#
+# As shipped, this is the same as the assignment 4 config.
+# Change it as necessary for the project you're doing.
+
+arch mips			# use MIPS r2000/r3000
+include conf/conf.kern		# get definitions of available options
+
+debug				# Compile with debug info.
+
+#
+# Device drivers for hardware.
+#
+device lamebus0			# System/161 main bus
+device emu* at lamebus*		# Emulator passthrough filesystem
+device ltrace* at lamebus*	# trace161 trace control device
+device ltimer* at lamebus*	# Timer device
+device lrandom* at lamebus*	# Random device
+device lhd* at lamebus*		# Disk device
+device lser* at lamebus*	# Serial port
+#device lscreen* at lamebus*	# Text screen (not supported yet)
+#device lnet* at lamebus*	# Network interface (not supported yet)
+device beep0 at ltimer*		# Abstract beep handler device
+device con0 at lser*		# Abstract console on serial port
+#device con0 at lscreen*	# Abstract console on screen (not supported)
+device rtclock0 at ltimer*	# Abstract realtime clock
+device random0 at lrandom*	# Abstract randomness device
+
+device pseudorand0		# Software random generator
+device random0 at pseudorand0	# Abstract randomness device
+
+#options net			# Network stack (not supported)
+
+options sfs			# Always use the file system
+#options netfs			# Not until assignment 5 (if you choose it)
+
+#options dumbvm			# Use your own VM system now.
+#options synchprobs		# No longer needed/wanted after asst. 1
diff --git a/os161-1.10/kern/conf/conf.kern b/os161-1.10/kern/conf/conf.kern
new file mode 100644
index 0000000..7d7d9c9
--- /dev/null
+++ b/os161-1.10/kern/conf/conf.kern
@@ -0,0 +1,453 @@
+#
+# Machine-independent kernel config definitions.
+#
+# The idea is that the files, options, and facilities in the system
+# are declared by conf.kern and the various files it includes. Then
+# a kernel config (such as ASST1) is used to select options and 
+# facilities for a particular kernel build.
+#
+# To add new files to the system, you need to edit this file (or
+# others like it) and rerun the config script.
+#
+# Note: when running the config script, be sure to be in the
+# right directory (the same one this file is in) and run it as
+# "./config", not just "config" - in the latter case you will
+# probably get the host system's kernel config utility, which
+# will likely make a mess and produce mysterious error messages.
+#
+# The documentation for the syntax of these files follows.
+#
+
+############################################################
+#
+# Kernel config file syntax:
+#
+# The syntax for specifying the processor architecture to use is:
+#
+#    arch archname
+#
+#       This must come before anything else in the kernel config.
+#
+#
+# The syntax for including the system definition is:
+#
+#    include conf.kern
+#
+#       This should come second, after the architecture. This is
+#       because the system must be defined before you can do much
+#       else useful.
+#
+#       You can also include other files using the same syntax.
+#
+#
+# The syntax for turning on a kernel compile option is:
+#
+#    options optname
+#
+#       A previous "defoption" must have been seen first. See below
+#       for more information.
+#
+#       The act of compiling with debug info is (has to be) handled
+#       specially, and is just "debug" without the "options".
+#
+#
+# The syntax for turning on a device driver is:
+#
+#    device foo%
+#    device foo% at bar%
+#
+#       where the % is either a number or a star, which is treated as
+#       a wildcard. The first line enables a device foo that is not
+#       supposed to be "attached" to anything. The second line enables
+#       a device foo that is attached to a device bar. For more 
+#       information about what this means, see below.
+#
+#
+############################################################
+#
+# Kernel definition file syntax:
+#
+# Note: All source file names are relative to the top directory of the
+# kernel source, that is, src/kern.
+# 
+# The syntax for adding a regular source file is:
+#
+#    file sourcefile.c
+#
+#       Such a file is always included automatically in every kernel.
+#
+#
+# The syntax for defining optional source files is:
+#
+#    defoption optname
+#    optfile optname sourcefile.c
+#    optofffile optname sourcefile.c
+#
+#       "defoption" declares the name of a kernel option. These are
+#       then turned on by including "options optname" in a
+#       kernel config.
+#
+#       Source files added with optfile are compiled in if the option
+#       specified is enabled. Source files added with optofffile are
+#       compiled in if the option specified is not enabled.
+#
+#       Additionally, a file "opt-optname.h" is created in the compile
+#       directory, which defines a C preprocessor symbol OPT_OPTNAME.
+#       This symbol is #defined to either 0 or 1 in the logical way.
+#       Thus, you can have small bits of code that are enabled or
+#       disabled by particular options by writing constructs like
+#
+#            #include "opt-foo.h"
+#            #if OPT_FOO
+#               code();
+#            #else
+#               other_code();
+#            #endif
+#
+#       *** Be sure to use #if and not #ifdef - you want the value
+#           of the symbol.
+#       *** Be sure to remember to include the header file for the
+#           option - if you don't, cpp will silently assume it is 0,
+#           which can be quite frustrating.
+#
+#       The defoption must be seen before any optional file 
+#       declarations that use it.
+#
+#
+# The syntax for defining device drivers is:
+#
+#    defdevice devname                  sourcefile.c
+#    defattach devname% otherdevname%   sourcefile.c
+#    pseudoattach devname%
+#
+#       Declare a device driver and its "attachment(s)". (The device
+#       driver can then be selectively included or not included in any
+#       particular kernel by using the "device" statement in the
+#       kernel config file.)
+#
+#       The specified source files are only compiled if the device
+#       is enabled.
+#
+#       The % is either a specific number N, meaning "only the Nth
+#       such device can be attached this way", or a star (*), meaning
+#       "any such device can be attached this way".
+#
+#       In OS/161, device drivers are conceptually organized into
+#       trees. This mimics the organization of real hardware, where
+#       several expansion cards are plugged into one bus and there
+#       might be several devices on each expansion card and so forth.
+#
+#       There can be any number of these trees. However, devices at
+#       the root of each tree must be able to probe and "find"
+#       themselves completely on their own. This generally means that
+#       they are either all software with no hardware, or they are the
+#       system main bus which is located in a machine-dependent way.
+#
+#       Software-only devices are known as "pseudo-devices". These
+#       are "attached" with the pseudoattach directive; functions
+#       of the form
+#
+#           pseudoattach_devname
+#
+#       are called from autoconf.c to create instances as requested.
+#       These calls are made from the function pseudoconfig(), which
+#       should be called from dev/init.c after hardware device 
+#       initialization completes. The pseudoattach functions should
+#       perform all setup and initialization necessary. (No
+#       config_devname function will be called.)
+#
+#       Devices with attachments are automatically probed and 
+#       configured from code in autoconf.c. This file is generated
+#       by the config script. It contains functions called
+#       "autoconf_devname", for each device. These functions call
+#       other functions, which are supplied by device drivers,
+#       which have the following hardwired names:
+#
+#           attach_devname1_to_devname2
+#
+#                 A "devname2" device has been found and configured;
+#                 this function attempts to probe the devname2 for
+#                 a "devname1" device. Returns NULL if nothing was
+#                 found.
+#
+#           config_devname
+#
+#                 A "devname" device has been found. This function
+#                 can then perform initialization that's shared
+#                 among all the possible things it can be attached
+#                 to.
+#
+#       The idea is that there can be multiple attachments for
+#       the same device to different underlying devices. In the
+#       real world this can be used to great effect when you have,
+#       for instance, the same ethernet chipset used on both PCI
+#       and ISA cards - the chipset behaves the same way in both
+#       cases, but the probe and attach logic is very different.
+#
+#       The attach_foo_to_bar functions are put in the files
+#       specified with defattach; the config_foo function (and
+#       generally the rest of the driver for the foo device) is
+#       put in the file specified with defdevice.
+#
+#       One selects particular attachments when including the device
+#       in the kernel. A top-level device with no attachments should
+#       be included with this syntax:
+#
+#              device bar
+#
+#       A pseudo-device should be included with this syntax:
+#
+#              device bar0
+#
+#       To make use of device foo, which can be found attached to
+#       device bar, one of the following syntaxes is used:
+#
+#              device foo* at bar*
+#              device foo* at bar0
+#              device foo0 at bar*
+#              device foo0 at bar0
+#
+#       depending on to what extent you want to configure only a
+#       specific device number.
+#
+#       It sometimes matters what order things are handled in; probes
+#       occur more or less in the order things appear in the config,
+#       as constrained by the tree structure of the available devices.
+#
+#       Note that OS/161 does not make extensive use of this 
+#       functionality, and the device driver architecture outlined 
+#       here is overkill for such a limited environment as System/161.
+#       However, it's similar to the way real systems are organized.
+#
+#
+# The syntax for including other config/definition files is:
+#
+#    include filename
+#    archinclude arch-filename
+#
+#       In the first form, the filename is relative to the top of
+#       the kernel source tree.
+#
+#       In the second form, the arch-filename is relative to the
+#       top directory of the architecture-specific area for the
+#       selected architecture.
+#
+#       Thus, if the architecture is "mips", 
+#          include conf/conf.foo     includes src/kern/conf/conf.foo
+#          archinclude conf/conf.bar includes src/kern/arch/mips/conf/conf.bar
+#
+#
+############################################################
+
+
+########################################
+#                                      #
+# Generic machine-independent devices. #
+#                                      #
+########################################
+
+#
+# These are abstract system services we expect the system hardware to
+# provide: beeping, system console I/O, and time of day clock.
+#
+# These come before the archinclude so that the hardware device
+# definitions, which are included from there, can define attachments
+# for them.
+# 
+
+defdevice       beep			dev/generic/beep.c
+defdevice	con			dev/generic/console.c
+defdevice       rtclock                 dev/generic/rtclock.c
+defdevice       random                  dev/generic/random.c
+
+#
+# Random number generator for when there's no hardware random device.
+# Use "pseudoattach" because it's an all-software ("pseudo-") device.
+# (It's also a pseudo-random generator, but the two uses of pseudo are
+# unrelated.)
+#
+
+defdevice	pseudorand		dev/generic/pseudorand.c
+pseudoattach    pseudorand
+defattach	random0 pseudorand0	dev/generic/pseudorand_att.c
+
+########################################
+#                                      #
+#        Machine-dependent stuff       #
+#                                      #
+########################################
+
+#
+# Get the definitions for whatever the architecture is from 
+# conf.arch in the architecture's conf directory.
+#
+# This will declare a bunch of machine-dependent source files and also
+# declare all the hardware devices (since what sorts of hardware we
+# expect to find is machine-dependent.)
+# 
+
+archinclude   conf/conf.arch
+
+########################################
+#                                      #
+#            Support code              #
+#                                      #
+########################################
+
+#
+# Kernel utility code
+# 
+
+file      lib/array.c
+file      lib/bitmap.c
+file      lib/queue.c
+file      lib/kheap.c
+file      lib/kprintf.c
+file      lib/kgets.c
+file      lib/misc.c
+
+#
+# Standard C functions
+# 
+# For most of these, we take the source files from our libc.  Note
+# that those files have to have been hacked a bit to support this.
+#
+
+file      lib/ntoh.c
+file      ../lib/libc/__printf.c
+file      ../lib/libc/snprintf.c
+file      ../lib/libc/atoi.c
+file      ../lib/libc/bzero.c
+file      ../lib/libc/memcpy.c
+file      ../lib/libc/memmove.c
+file      ../lib/libc/strcat.c
+file      ../lib/libc/strchr.c
+file      ../lib/libc/strcmp.c
+file      ../lib/libc/strcpy.c
+file      ../lib/libc/strlen.c
+file      ../lib/libc/strrchr.c
+file      ../lib/libc/strtok_r.c
+
+########################################
+#                                      #
+#       Core kernel source files       #
+#                                      #
+########################################
+
+#
+# Device framework support
+#
+
+file      dev/init.c
+
+#
+# VFS layer
+#
+
+file      fs/vfs/device.c
+file      fs/vfs/vfscwd.c
+file      fs/vfs/vfslist.c
+file      fs/vfs/vfslookup.c
+file      fs/vfs/vfspath.c
+file      fs/vfs/vnode.c
+
+#
+# VFS devices
+#
+
+file      fs/vfs/devnull.c
+
+#
+# Thread system
+#
+
+file      thread/hardclock.c
+file      thread/synch.c
+file      thread/scheduler.c
+file      thread/thread.c
+
+#
+# Main/toplevel stuff
+#
+
+file      main/main.c
+file      main/menu.c
+
+#
+# User-level programming/system call support
+# (you will probably want to add stuff here while doing the basic system
+# calls assignment)
+#
+
+file      userprog/loadelf.c
+file      userprog/runprogram.c
+file      userprog/uio.c
+
+#
+# Virtual memory system
+# (you will probably want to add stuff here while doing the VM assignment)
+#
+
+optofffile dumbvm   vm/addrspace.c
+
+#
+# Network
+# (nothing here yet)
+#
+
+defoption  net
+#optfile   net    net/net.c
+
+########################################
+#                                      #
+#             Filesystems              #
+#                                      #
+########################################
+
+#
+# sfs (the small/simple filesystem)
+#
+
+defoption sfs
+optfile   sfs    fs/sfs/sfs_fs.c
+optfile   sfs    fs/sfs/sfs_io.c
+optfile   sfs    fs/sfs/sfs_vnode.c
+
+#
+# netfs (the networked filesystem - you might write this as one assignment)
+#
+defoption netfs
+#optfile  netfs     fs/netfs/netfs_fs.c   # or whatever
+
+#
+# Note that "emufs" is completely contained in the "emu" device.
+#
+
+
+########################################
+#                                      #
+#    Asst1 synchronization problems    #
+#                                      #
+########################################
+
+defoption synchprobs
+optfile   synchprobs  asst1/catlock.c
+optfile   synchprobs  asst1/catsem.c
+optfile   synchprobs  asst1/stoplight.c
+
+
+########################################
+#                                      #
+#              Test code               #
+#                                      #
+########################################
+
+file		test/arraytest.c
+file		test/bitmaptest.c
+file		test/queuetest.c
+file		test/threadtest.c
+file		test/tt3.c
+file		test/synchtest.c
+file		test/malloctest.c
+file		test/fstest.c
+optfile net	test/nettest.c
diff --git a/os161-1.10/kern/conf/config b/os161-1.10/kern/conf/config
new file mode 100755
index 0000000..9166e65
--- /dev/null
+++ b/os161-1.10/kern/conf/config
@@ -0,0 +1,1004 @@
+#!/bin/sh
+#
+# Kernel config script for OS/161.
+#
+# Usage: ./config conf-name
+#
+#    WARNING! IF YOU JUST RUN "config" INSTEAD OF "./config" YOU WILL
+#    PROBABLY GET THE HOST SYSTEM'S KERNEL CONFIG INSTEAD OF THIS ONE,
+#    WHICH WILL CAUSE WEIRD THINGS TO HAPPEN. DON'T DO IT.
+#
+#
+# Recognized directives:
+#
+#    file <filename>          use source file
+#    debug                    turn on debug info
+#    defoption <sym>          define an option
+#    optfile <sym> <file>     if option <sym> is enabled, use file <file>
+#    optofffile <sym> <file>  if option <sym> is disabled, use file <file>
+#    defdevice <dev> <file>   define a device
+#    defattach <dev> <bus> <file> 
+#                             define an attachment for a device to a bus
+#    pseudoattach <dev>       define a pseudo-attachment for a device
+#
+#    arch <arch>              select architecture
+#    options <sym>            enable an option
+#    device <dev> [at <bus>]  enable a particular device [on a particular bus]
+#
+#    include <filename>       get additional directives from another file
+#    archinclude <filename>   get machine-dependent directives
+#
+# Filenames are relative to the top of the kernel tree, except for
+# the archinclude directive, whose filenames are relative to the 
+# top subdirectory for the architecture set with the arch directive.
+#
+# The comment character is '#'. 
+#
+# The idea is that the first group of directives is used to set up a
+# static description of all possible configurations for each supported
+# architecture. Then a kernel config file uses the second group of
+# directives to specify a particular configuration. Then this script
+# is used to first check that the configuration is one of the possible
+# ones, and then to set up the compile directory, makefiles, and 
+# associated material necessary to actually build that configuration.
+#
+# Further documentation is at the top of conf.kern.
+#
+
+
+#
+# Make sure we're in the right place.
+#
+if [ ! -d ../userprog ]; then
+	echo "$0: Run me from src/kern/conf"
+	exit 1
+fi
+
+########################################
+#
+# 1. Get configuration name and config file.
+#
+
+CONFNAME=$1
+if [ "x$CONFNAME" = x ]; then
+    echo "Usage: $0 CONFIG-NAME"
+    exit 1
+fi
+
+FOO=`echo $CONFNAME | tr -d 'a-zA-Z0-9_-'`
+if [ "x$FOO" != x ]; then
+    echo "Illegal configuration name $CONFNAME"
+    exit 1
+fi
+
+if [ ! -f $CONFNAME ]; then
+    echo "$0: $CONFNAME not found"
+    exit 1
+fi
+echo "Configuration $CONFNAME"
+
+COMPILEDIR="../compile/$CONFNAME"
+
+########################################
+#
+# 2. Process includes.
+#    Also strip comments.
+#    Simultaneously, do a basic syntax check.
+#    As a side effect this also checks to make sure "arch" occurs exactly once.
+#
+#    For an introduction to awk, see 
+#        http://www.hcs.harvard.edu/~dholland/computers/awk.html
+#
+
+CONFTMP=.conftmp
+
+rm -f $CONFTMP
+
+echo "$CONFNAME" $CONFTMP | awk '
+    BEGIN {
+	#
+	# Initialize list of directives and required numbers of words for each.
+	#
+	nfields["arch"] = 2;
+	nfields["include"] = 2;
+	nfields["archinclude"] = 2;
+	nfields["file"] = 2;
+	nfields["debug"] = 1;
+	nfields["defoption"] = 2;
+	nfields["optfile"] = 3;
+	nfields["optofffile"] = 3;
+	nfields["defdevice"] = 3;
+	nfields["defattach"] = 4;
+	nfields["pseudoattach"] = 2;
+	nfields["options"] = 2;
+	nfields["device"] = 4;   # actually 2 or 4, handled specially
+    }
+
+    function setarch(fn, lineno, newarch) {
+	#
+	# Set the architecture. Only allowed once.
+	#
+	if (arch) {
+	    printf "%s: %d: arch: arch already set to %s\n", fn, lineno, arch;
+	    exit(1);
+	}
+	arch = newarch;
+    }
+
+    function doinclude(file,     lineno) {
+	#
+	# Include a file.
+	#
+	# lineno is a local.
+	#
+	# Read lines and hand them off recursively to processline().
+	#
+	lineno = 1;
+	while (getline < file) {
+	    if (ERRNO) {
+		printf "%s: %s\n", file, ERRNO;
+		exit(1);
+	    }
+	    processline(file, lineno);
+	    lineno++;
+	}
+    }
+
+    function processline(filename, lineno) {
+	#
+	# Handle a single config line.
+	#
+
+	# Strip comments.
+	sub("#.*", "", $0);
+
+	# Ignore blank lines.
+	if (NF==0) return;
+
+	# Syntax check: reject unknown directives
+	if (!nfields[$1]) {
+	    printf "%s: %d: Unknown directive %s\n", filename, lineno, $1;
+	    exit(1);
+	}
+
+	# Syntax check: require correct # of args.
+	if ($1=="device") {
+	    # special case - device directive can have 2 or 4 words
+	    if ((NF!=2 && NF!=4) || (NF==4 && $3!="at")) {
+		printf "%s: %d: %s: Invalid arguments\n", filename, lineno, $1;
+		exit(1);
+	    }
+	}
+	else if (nfields[$1]!=NF) {
+	    printf "%s: %d: %s: Invalid arguments\n", filename, lineno, $1;
+	    exit(1);
+	}
+
+	# Now actually process the directives we need at this stage - which
+	# are only "arch", "include", and "archinclude". Handle includes;
+	# but pass through "arch" for further later use.
+
+	if ($1 == "arch") {
+		setarch(filename, lineno, $2);
+		print >> outfile;
+	}
+	else if ($1 == "include") {
+		doinclude("../" $2);
+	}
+	else if ($1 == "archinclude") {
+		if (!arch) {
+		    printf "%s: %d: architecture not set\n", filename, lineno;
+		    exit(1);
+		}
+		doinclude("../arch/" arch "/" $2);
+	}
+	else {
+		print >> outfile;
+	}
+    }
+
+    #
+    # Code called for lines input on stdin.
+    # There is only one - the one generated above with echo, which
+    # gives us the names of the input and output files to use.
+    #
+    {
+	outfile = $2;
+	doinclude($1);
+    }
+' || exit 1
+
+########################################
+#
+# 3. Create compile dir.
+#
+
+if [ ! -d "$COMPILEDIR" ]; then
+    mkdir $COMPILEDIR
+fi
+
+: >> $COMPILEDIR/depend.mk
+
+echo -n 'Generating files...'
+
+########################################
+#
+# 4. Process device attachments into $CONFTMP.attach.
+#    Also add device/attachment files to $CONFTMP.files.
+#
+
+rm -f $CONFTMP.files
+rm -f $CONFTMP.attach
+
+awk < $CONFTMP '
+
+    #
+    # Function to grab the "0" off "le0" or the "*" off "wd*".
+    #
+    function getunit(invalmsg, d,       u, tmp) {
+	u = d;
+	sub("^[a-zA-Z_]*", "", u);
+
+	if (u!="*") {
+	    tmp = u;
+	    sub("[0-9]*", "", tmp);
+	    if (tmp!="") {
+		printf "\n%s: Invalid device/unit specification\n", invalmsg;
+		exit(1);
+	    }
+	}
+
+	return u;
+    }
+
+    #
+    # Function to grab the "le" off "le0" or the "wd" off "wd*".
+    #
+    function getbase(invalmsg, d,       base) {
+	base = d;
+	sub("[\\*0-9]*$", "", base);
+
+	if (!use[base]) {
+	    printf "\n%s: No such device\n", invalmsg;
+	    exit(1);
+	}
+
+	return base;
+    }
+
+    #
+    # Routine invoked for "defdevice" directive lines.
+    #
+    $1=="defdevice" {
+	dev = $2;
+	file = $3;
+
+	# Check for illegal characters in device name
+	# (must be legal C symbol, and at this point must not have unit number)
+	tmp = dev;
+	sub("[a-zA-Z_]*", "", tmp);
+	if (tmp!="") {
+	    printf "\ndefdevice %s: Illegal device name\n", dev;
+	    exit(1);
+	}
+
+	# Device must not have been already defined.
+	if (use[dev]) {
+	    printf "\ndefdevice %s: %s already exists\n", dev, dev;
+	    exit(1);
+	}
+
+	# Note that it exists, but is not in use, and remember the 
+	# source file for later.
+	use[dev] = "no";
+	files[dev] = file;
+    }
+
+    #
+    # Routine called for "defattach" directive lines.
+    #
+    $1=="defattach" {
+	dev = $2;
+	bus = $3;
+	file = $4;
+
+	# Even though we do not use basebus, busunit, or devunit, 
+	# call the routines to compute them, because they check the
+	# syntax.
+
+	devmsg = "defattach: device " dev;
+	devunit = getunit(devmsg, dev);
+	basedev = getbase(devmsg, dev);
+
+	busmsg = "defattach: bus " bus;
+	busunit = getunit(busmsg, bus);
+	basebus = getbase(busmsg, bus);
+
+	if (pseudo[basedev]) {
+	    printf "\n%s: Already declared pseudoattach\n", devmsg;
+	    exit(1);
+	}
+
+	# The attachment is the pair of bus and device.
+	# We remember the specific names, including the unit numbers.
+	# This is because "le* at sbus*" is different from "le0 at sbus0"
+	# - the former allows le0 to be at sbus1, allows le1, etc.
+
+	attachment = bus "." dev;
+	attach[attachment] = "no";
+	files[attachment] = file;
+
+	# Remember that attachments are defined for this device. If
+	# attachments are defined, when the device is turned on later
+	# an attachment must be specified. 
+	attachable[basedev] = 1;
+    }
+
+    #
+    # Routine called for "pseudoattach" directive lines.
+    #
+    $1=="pseudoattach" {
+	dev = $2;
+
+	devmsg = "pseudoattach: device " dev;
+	devunit = getunit(devmsg, dev);
+	basedev = getbase(devmsg, dev);
+
+	if (attachable[basedev]) {
+	    printf "\n%s: Attachments already declared\n", devmsg;
+	    exit(1);
+	}
+
+	# Remember that this device is a pseudo-device.
+	pseudo[basedev] = 1;
+    }
+
+    #
+    # Helper function for the "device" code.
+    #
+    function tryattach(combo) {
+	if (!attachok && attach[combo]) {
+	    # This attachment is defined. Note to compile it in, and report
+	    # success.
+	    attach[combo] = "yes";
+	    attachok = 1;
+	}
+    }
+
+    #
+    # Routine called for "device" directive lines.
+    #
+    $1=="device" {
+	dev = $2;
+	if (NF==4) {
+	    devmsg = "device: " dev " at " $4;
+	}
+	else {
+	    devmsg = "device: device " dev;
+	}
+	devunit = getunit(devmsg, dev);
+	basedev = getbase(devmsg, dev);
+	gendev = basedev "*";
+
+	if (NF==4) {
+	    #
+	    # The longer form, with an attachment ("bus").
+	    #
+	    bus = $4;
+	    busmsg = "device: " dev " at " bus ": " bus;
+	    busunit = getunit(busmsg, bus);
+	    basebus = getbase(busmsg, bus);
+	    genbus = basebus "*";
+
+	    if (use[basebus]!="yes") {
+		printf "\ndevice: bus %s: Bus device is not enabled\n", bus;
+		exit(1);
+	    }
+
+	    # If the line was "le0 at sbus0", we try to attach it using
+	    # the following attachments:
+	    #    First, the exact thing that was requested:
+	    #         sbus0.le0   (le0 at sbus0)
+	    #    Second, for any such device on that bus:
+	    #         sbus*.le0   (le0 at sbus*)
+	    #    Third, for that device on any such bus:
+	    #         sbus0.le*   (le* at sbus0)
+	    #    Fourth, for any such device on any such bus:
+	    #         sbus*.le*   (le* at sbus*)
+	    #
+	    # If the line was "le* at sbus0", some of these will be
+	    # redundant, but that is ok.
+
+	    attachok = 0;
+	    tryattach(bus "." dev);
+	    tryattach(bus "." gendev);
+	    tryattach(genbus "." dev);
+	    tryattach(genbus "." gendev);
+	    if (!attachok) {
+		# No matching attachment found.
+		printf "\ndevice: %s at %s: Undefined attachment\n", dev, bus;
+		exit(1);
+	    }
+
+	    devattach = sprintf("%s %s", basedev, devunit);
+	    baseattach = sprintf("%s %s", basebus, busunit);
+	    printf "attach %s at %s\n", devattach, baseattach >> attachfile;
+	}
+	else {
+	    # No bus specified to attach the device to (really, to find the
+	    # device attached on.) This is only legal if no attachments
+	    # at all were defined for the device, which is the case if the
+	    # device is in fact not attached to anything else (like the main
+	    # system bus, or a device like /dev/null that has no hardware.)
+
+
+	    # The opposite check to this is not required in the
+	    # preceding section because no attachment can be found if
+	    # attachable[basedev] is false.
+
+	    if (attachable[basedev]) {
+		printf "\ndevice %s: attachment required\n", dev;
+		exit(1);
+	    }
+
+	    if (pseudo[basedev]) {
+		if (devunit=="*") {
+		    printf "\n%s: May not use wildcard units here\n", devmsg;
+		    exit(1);
+		}
+		printf "pseudo %s %s\n", basedev, devunit >> attachfile;
+	    }
+	    else {
+		printf "noattach %s\n", basedev >> attachfile;
+	    }
+	}
+
+	use[basedev] = "yes";
+    }
+
+    #
+    # Routine invoked when we have seen all the input.
+    #
+    END {
+	# Print out the source filenames for the devices and attachments
+	# we are using.
+
+	for (dev in use) {
+	    if (use[dev]=="yes") {
+		printf "%s\n", files[dev] >> filelistfile;
+	    }
+	}
+	for (att in attach) {
+	    if (attach[att]=="yes") {
+		printf "%s\n", files[att] >> filelistfile;
+	    }
+	}
+    }
+
+' "attachfile=$CONFTMP.attach" "filelistfile=$CONFTMP.files" || exit 1
+
+########################################
+#
+# 5. Process options.
+#
+
+awk < $CONFTMP '
+
+    #
+    # Routine for a defoption line.
+    #
+    $1=="defoption" {
+	opt = $2;
+	options[opt] = "no";
+    }
+
+    #
+    # Routine for an optfile line.
+    #
+    $1=="optfile" {
+	opt = $2;
+	file = $3;
+
+	if (!options[$2]) {
+	    printf "\noptfile %s %s: No such option %s\n", opt, file, opt;
+	    exit(1);
+	}
+
+	controllers[file] = opt;
+    }
+
+    #
+    # Routine for an optofffile line.
+    #
+    $1=="optofffile" {
+	opt = $2;
+	file = $3;
+
+	if (!options[$2]) {
+	    printf "\noptofffile %s %s: No such option %s\n", opt, file, opt;
+	    exit(1);
+	}
+
+	offcontrollers[file] = opt;
+    }
+
+    #
+    # Routine for an options line.
+    #
+    $1=="options" {
+	opt = $2;
+
+	if (!options[$2]) {
+	    printf "\noptions %s: No such option\n", opt;
+	    exit(1);
+	}
+
+	options[$2] = "yes";
+    }
+
+    #
+    # Routine invoked when we have seen everything.
+    #
+    END {
+	#
+	# First, add any files to the list of sources we are building.
+	#
+	for (file in controllers) {
+	    if (options[controllers[file]]=="yes") {
+		printf "%s\n", file >> filelistfile;
+	    }
+	}
+	for (file in offcontrollers) {
+	    if (options[offcontrollers[file]]=="no") {
+		printf "%s\n", file >> filelistfile;
+	    }
+	}
+	close(filelistfile);
+
+	#
+	# Now, generate the .h file for every option
+	# (both the ones that are on and the ones that are off)
+	#
+	for (opt in options) {
+	    realfile = compiledir "/opt-" opt ".h";
+	    file = realfile ".new";
+	    sym = toupper(opt);
+	    printf "/* Automatically generated; do not edit */\n" > file;
+	    printf "#ifndef _OPT_%s_H_\n", sym >> file;
+	    printf "#define _OPT_%s_H_\n", sym >> file;
+	    val = options[opt]=="yes" ? 1 : 0;
+	    printf "#define OPT_%s %d\n", sym, val >> file;
+	    printf "#endif /* _OPT_%s_H_ */\n", sym >> file;
+	    close(file);
+	}
+    }
+
+' "compiledir=$COMPILEDIR" "filelistfile=$CONFTMP.files" || exit 1
+
+# Avoid changing the actual headers if they aren't different, so as to
+# reduce unnecessary recompiles.
+
+(
+    cd $COMPILEDIR
+    for NF in opt-*.h.new; do
+	OF=`echo $NF | sed 's/\.new$//'`
+	if diff $OF $NF >/dev/null 2>&1; then
+	    rm -f $NF      # unchanged
+	else
+	    mv -f $NF $OF  # it changed
+	fi
+    done
+)
+
+echo -n ' opt-*.h'
+
+########################################
+#
+# 6. Add in the unconditional files.
+#
+
+awk < $CONFTMP '
+    $1=="file" {
+	printf "%s\n", $2 >> filelistfile;
+    }
+' "filelistfile=$CONFTMP.files" || exit 1
+
+#
+# autoconf.c (which we generate further down) is always compiled in but
+# is not in the list yet. Note that the path to it is where we are about
+# to put it: it lives in the build directory, because it's part of a 
+# particular build.
+#
+echo "compile/$CONFNAME/autoconf.c" >> $CONFTMP.files
+
+########################################
+#
+# 7. We now have the compile file list.
+#    Generate files.mk.
+#
+
+#
+# Validate list first.
+#
+# We allow C++ files, because the makefile rules we generate are
+# sufficient to compile them. However, some low-level kernel hacking
+# will be needed to actually use C++ in OS/161.
+#
+# We do not allow lex and yacc files, because the $(COMPILE.ext) model
+# of make rules we're generating won't really work right for
+# them. However, you don't want to use lex and yacc in the kernel
+# anyway.
+#
+
+awk < $CONFTMP.files '
+    /\.cc$/ { next; }
+    /\.cpp$/ { next; }
+    /\.C$/ { next; }
+    /\.c$/ { next; }
+    #/\.l$/ { next; }   # will require some makefile hacking to make work
+    #/\.y$/ { next; }   # will require some makefile hacking to make work
+    /\.S$/ { next; }
+    /\.o$/ { next; }
+    { 
+	printf "\n%s: Unrecognized source file type\n", $1;
+	exit(1);
+    }
+' || exit 1;
+
+#
+# Do it.
+# Generate a make rule for each file.
+#
+
+awk < $CONFTMP.files '
+    BEGIN {
+	printf "# Automatically generated by config; do not edit\n";
+    }
+
+    {
+	file = $1;
+
+	# get basename
+	basename = $1;
+	sub(".*/", "", basename);
+
+	# get extension
+	ext = basename;
+	sub(".*\\.", "", ext);
+	sub("\\.[^\\.]*$", "", basename);
+
+	# If an .o, presumably a special compile rule for it will be 
+	# hand-entered in the Makefile somewhere.
+	if (ext!="o") {
+	    # Handle all C++ files with $(COMPILE.cc)
+	    if (ext==".C" || ext==".cpp") {
+		ext = ".cc";
+	    }
+
+	    printf "%s.o: ${S}/%s\n", basename, file;
+	    printf "\t${COMPILE.%s} ${S}/%s\n", ext, file;
+	    printf "SRCS+=${S}/%s\n", file;
+	}
+	printf "OBJS+=%s.o\n\n", basename;
+    }
+' > $COMPILEDIR/files.mk
+
+rm -f $CONFTMP.files
+
+echo -n ' files.mk'
+
+########################################
+#
+# 8. Generate defs.mk
+#
+
+awk < $CONFTMP '
+    # Default: optimize.
+    BEGIN { debugflags="-O2"; }
+    $1=="arch" { arch = $2; }
+    $1=="debug" { 
+	debugflags="-g";
+    }
+
+    END {
+	printf "# Automatically generated by config; do not edit\n";
+	printf "S=../..\n";
+	printf "ARCH=%s\n", arch;
+	printf "DEBUGFLAGS=%s\n", debugflags;
+	printf "CONFNAME=%s\n", confname;
+    }
+' "confname=$CONFNAME" > $COMPILEDIR/defs.mk || exit 1
+
+echo -n ' defs.mk'
+
+########################################
+#
+# 9. Generate Makefile
+#    (basically, copy it from the right arch dir)
+#
+
+ARCH=`awk < $CONFTMP '$1=="arch" { print $2; }'`
+MKSRC="arch/$ARCH/conf/Makefile.$ARCH"
+
+(
+    echo "# Automatically generated by config."
+    echo "# Edit $MKSRC instead, and rerun config."
+    echo "#"
+    echo
+    cat ../$MKSRC || exit 1
+) > $COMPILEDIR/Makefile || exit 1
+
+echo -n ' Makefile'
+
+########################################
+#
+# 10. Create/update "machine" symlink
+#     (points to the machine-dependent include files)
+#
+
+rm -f $COMPILEDIR/machine
+ln -s ../../arch/$ARCH/include $COMPILEDIR/machine
+
+
+########################################
+#
+# 11. Process attachment list.
+#     Generate autoconf.[ch].
+#
+
+ACHREAL=$COMPILEDIR/autoconf.h
+ACH=$COMPILEDIR/autoconf.h.new
+ACC=$COMPILEDIR/autoconf.c
+
+echo '/* Automatically generated; do not edit */' > $ACH
+echo '/* Automatically generated; do not edit */' > $ACC
+
+echo '#ifndef _AUTOCONF_H_' >> $ACH
+echo '#define _AUTOCONF_H_' >> $ACH
+
+#
+# first, declare struct foo_softc for all devices foo.
+#
+
+echo >> $ACH
+awk < $CONFTMP.attach '{ printf "struct %s_softc;\n", $2 }' >> $ACH
+
+#
+# second, declare the autoconf_foo functions for unattached devices.
+#
+# The autoconf_foo functions for attached devices are file-static 
+# in autoconf.c.
+#
+
+echo >> $ACH
+awk < $CONFTMP.attach '$1=="noattach" { print $2 }' | sort -u | awk '
+    {
+	printf "void autoconf_%s(struct %s_softc *dev, int unit);\n", $1, $1;
+    }
+' >> $ACH
+
+#
+# third, declare the attach functions.
+#
+
+echo >> $ACH
+awk < $CONFTMP.attach '
+    $1=="attach" {
+	dev = $2;
+	bus = $5;
+	f = sprintf("struct %s_softc *attach_%s_to_%s", dev, dev, bus);
+	printf "%s(int devunit, struct %s_softc *bus);\n", f, bus;
+    }
+    $1=="pseudo" {
+	dev = $2;
+	printf "struct %s_softc *pseudoattach_%s(int devunit);\n", dev, dev;
+    }
+' >> $ACH
+
+#
+# fourth, declare the config functions.
+#
+
+echo >> $ACH
+awk < $CONFTMP.attach '
+    $1=="attach" {
+	dev = $2;
+	printf "int config_%s(struct %s_softc *dev, int unit);\n", dev, dev;
+    }
+' >> $ACH
+
+#
+# Declare pseudoconfig()
+#
+echo >> $ACH
+echo 'void pseudoconfig(void);' >> $ACH
+echo >> $ACH
+
+#
+# Done with the header file.
+#
+echo '#endif /* _AUTOCONF_H_ */' >> $ACH
+
+#
+# Avoid changing the actual autoconf.h if it's not different, so as to
+# reduce unnecessary recompiles.
+#
+
+if diff $ACHREAL $ACH >/dev/null 2>&1; then
+    rm -f $ACH            # unchanged
+else
+    mv -f $ACH $ACHREAL   # it changed
+fi
+
+echo -n ' autoconf.h'
+
+#
+# now, autoconf.c
+#
+
+echo '#include <types.h>' >> $ACC
+echo '#include <lib.h>' >> $ACC
+echo '#include "autoconf.h"' >> $ACC
+
+#
+# first, declare the static autoconf_foo functions and the nextunit_foo vars
+#
+echo >> $ACC
+awk < $CONFTMP.attach '$1=="attach" || $1=="pseudo" { print $2 }' | sort -u |\
+  awk '
+    { 
+	printf "static void autoconf_%s(struct %s_softc *, int);\n", $1, $1;
+    }
+' >> $ACC
+awk < $CONFTMP.attach '$1=="attach" { print $2 }' | sort -u | awk '
+    { 
+	printf "static int nextunit_%s;\n", $1;
+    }
+' >> $ACC
+echo >> $ACC
+
+#
+# Now generate the tryattach_ functions.
+#
+
+awk < $CONFTMP.attach '
+    $1=="attach" {
+	dev = $2;
+	bus = $5;
+	printf "static\n";
+	printf "int\n";
+	printf "tryattach_%s_to_%s", dev, bus;
+	printf "(int devunit, struct %s_softc *bus, int busunit)\n", bus;
+	printf "{\n";
+	printf "\tstruct %s_softc *dev;\n", dev;
+	printf "\tint result;\n", dev;
+	printf "\n";
+	printf "\tdev = attach_%s_to_%s(devunit, bus);\n", dev, bus;
+	printf "\tif (dev==NULL) {\n";
+	printf "\t\treturn -1;\n";
+	printf "\t}\n";
+	printf "\tkprintf(\"%s%%d at %s%%d\", devunit, busunit);\n", dev, bus;
+	printf "\tresult = config_%s(dev, devunit);\n", dev;
+	printf "\tif (result != 0) {\n";
+	printf "\t\tkprintf(\": %%s\\n\", strerror(result));\n";
+		# Note: we leak the device softc instead of trying 
+		# to clean it up.
+	printf "\t\t/* should really clean up dev */\n";
+	printf "\t\treturn result;\n";
+	printf "\t}\n";
+	printf "\tkprintf(\"\\n\");\n";
+	printf "\tnextunit_%s = devunit+1;\n", dev;
+	printf "\tautoconf_%s(dev, devunit);\n", dev;
+	printf "\treturn 0;\n";
+	printf "}\n";
+	printf "\n";
+    }
+' >> $ACC
+echo >> $ACC
+
+
+#
+# Now comes the tricky part, actually writing those autoconf
+# functions.  We need one for every device. In each one, there needs
+# to be a probe section for each line in $CONFTMP.attach in which that
+# device appears on the *right hand* (bus) side.
+#
+
+awk < $CONFTMP.attach '
+    BEGIN { nlines=0; npseudo=0; }
+    $1=="attach" {
+	devs[nlines] = $2;
+	devunits[nlines] = $3;
+	buses[nlines] = $5;
+	busunits[nlines] = $6;
+	alldevs[$2] = 1;
+	nlines++;
+    }
+    $1=="noattach" {
+	alldevs[$2] = 0;
+    }
+    $1=="pseudo" {
+	alldevs[$2] = 0;
+	pseudodevs[npseudo] = $2;
+	pseudounits[npseudo] = $3;
+	npseudo++;
+    }
+
+    function genprobe(dev, devunit, bus, busunit) {
+
+	tryfunc = sprintf("tryattach_%s_to_%s", dev, bus);
+	    
+	if (busunit!="*") {
+	    printf "\tif (busunit==%d) {\n", busunit;
+	}
+	else {
+	    printf "\t{\n";
+	}
+
+	if (devunit!="*") {
+	    printf "\t\tif (nextunit_%s <= %d) {\n", dev, devunit;
+	    printf "\t\t\t%s(%d, bus, busunit);\n", tryfunc, devunit;
+	    printf "\t\t}\n";
+	}
+	else {
+	    printf "\t\tint result, devunit=nextunit_%s;\n", dev;
+	    printf "\t\tdo {\n";
+	    printf "\t\t\tresult = %s(devunit, bus, busunit);\n", tryfunc;
+	    printf "\t\t\tdevunit++;\n";
+	    printf "\t\t} while (result==0);\n";
+	}
+
+	printf "\t}\n";
+    }
+
+    END {
+	for (bus in alldevs) {
+	    softc = sprintf("struct %s_softc", bus);
+
+	    if (alldevs[bus]) printf "static\n";
+	    printf "void\n";
+	    printf "autoconf_%s(%s *bus, int busunit)\n", bus, softc;
+	    printf "{\n";
+	    printf "\t(void)bus; (void)busunit;\n";
+
+	    for (i=0; i<nlines; i++) {
+		if (buses[i]==bus) {
+		    genprobe(devs[i], devunits[i], buses[i], busunits[i]);
+		}
+	    }
+
+	    printf "}\n\n";
+	}
+
+	printf "void\n";
+	printf "pseudoconfig(void)\n";
+	printf "{\n";
+	for (i=0; i<npseudo; i++) {
+	    dev = pseudodevs[i];
+	    unit = pseudounits[i];
+	    printf "\t{\n";
+	    printf "\t\tstruct %s_softc *s;\n", dev;
+	    printf "\t\t\n";
+	    printf "\t\ts = pseudoattach_%s(%s);\n", dev, unit;
+	    printf "\t\tif (s!=NULL) {\n";
+	    printf "\t\t\tkprintf(\"%s%d (virtual)\\n\");\n", dev, unit;
+	    printf "\t\t\tautoconf_%s(s, %s);\n", dev, unit;
+	    printf "\t\t}\n";
+	    printf "\t}\n";
+	}
+	printf "}\n\n";
+    }
+' >> $ACC
+
+echo -n ' autoconf.c'
+
+rm -f $CONFTMP $CONFTMP.attach
+
+########################################
+#
+# Done.
+#
+
+echo
+echo "Configuration in ../compile/$CONFNAME done"
+echo "Remember to make depend"
diff --git a/os161-1.10/kern/conf/newvers.sh b/os161-1.10/kern/conf/newvers.sh
new file mode 100755
index 0000000..1e7b009
--- /dev/null
+++ b/os161-1.10/kern/conf/newvers.sh
@@ -0,0 +1,44 @@
+#!/bin/sh
+#
+# newvers.sh - increment build number in current directory (a build directory)
+#              and emit vers.c.
+#              The build number is kept in the file "version".
+#
+# Usage: newvers.sh CONFIGNAME
+
+if [ ! -f autoconf.c ]; then
+    #
+    # If there's no file autoconf.c, we are in the wrong place.
+    #
+    echo "$0: Not in a build directory"
+    exit 1
+fi
+
+if [ "x$1" = x ]; then
+    echo "Usage: %0 CONFIGNAME"
+    exit 1
+fi
+
+CONFIG="$1"
+
+#
+# Get and increment the version number
+#
+
+VERS=`cat version 2>/dev/null || echo 0`
+VERS=`expr $VERS + 1`
+echo "$VERS" > version
+
+#
+# Write vers.c
+#
+
+echo '/* This file is automatically generated. Edits will be lost.*/' > vers.c
+echo "const int buildversion = $VERS;" >> vers.c
+echo 'const char buildconfig[] = "'"$CONFIG"'";' >> vers.c
+
+#
+# Announce it in the hopes that it'll still be visible when the build
+# finishes.
+#
+echo "*** This is $CONFIG build "'#'"$VERS ***"
diff --git a/os161-1.10/kern/dev/generic/beep.c b/os161-1.10/kern/dev/generic/beep.c
new file mode 100644
index 0000000..bf81295
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/beep.c
@@ -0,0 +1,42 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <generic/beep.h>
+#include "autoconf.h"
+
+/*
+ * Machine-independent generic beep "device".
+ *
+ * Basically, all we do is remember something that can be used for
+ * beeping, and provide the beep() function to the rest of the kernel.
+ *
+ * The kernel config mechanism can be used to explicitly choose which
+ * of the available beeping devices to use, if more than one is
+ * available.
+ */
+
+static struct beep_softc *the_beep = NULL;
+
+int
+config_beep(struct beep_softc *bs, int unit)
+{
+	/* We use only the first beep device. */
+	if (unit!=0) {
+		return ENODEV;
+	}
+
+	assert(the_beep==NULL);
+	the_beep = bs;
+	return 0;
+}
+
+void
+beep(void)
+{
+	if (the_beep!=NULL) {
+		the_beep->bs_beep(the_beep->bs_devdata);
+	}
+	else {
+		kprintf("beep: Warning: no beep device\n");
+	}
+}
diff --git a/os161-1.10/kern/dev/generic/beep.h b/os161-1.10/kern/dev/generic/beep.h
new file mode 100644
index 0000000..d334dcf
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/beep.h
@@ -0,0 +1,14 @@
+#ifndef _GENERIC_BEEP_H_
+#define _GENERIC_BEEP_H_
+
+/*
+ * The device info for the generic MI beep device - a function
+ * to call and a context pointer for it.
+ */
+
+struct beep_softc {
+	void *bs_devdata;
+	void (*bs_beep)(void *devdata);
+};
+
+#endif /* _GENERIC_BEEP_H_ */
diff --git a/os161-1.10/kern/dev/generic/console.c b/os161-1.10/kern/dev/generic/console.c
new file mode 100644
index 0000000..0044547
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/console.c
@@ -0,0 +1,353 @@
+/*
+ * Machine (and hardware) independent console driver.
+ *
+ * We expose a simple interface to the rest of the kernel: "putch" to
+ * print a character, "getch" to read one.
+ *
+ * As long as the device we're connected to does, we allow printing in
+ * an interrupt handler or with interrupts off (by polling),
+ * transparently to the caller. Note that getch by polling is not
+ * supported, although such support could be added without undue
+ * difficulty.
+ *
+ * Note that nothing happens until we have a device to write to. A
+ * buffer of size DELAYBUFSIZE is used to hold output that is
+ * generated before this point. This means that (1) using kprintf for
+ * debugging problems that occur early in initialization is awkward,
+ * and (2) if the system crashes before we find a console, no output
+ * at all may appear.
+ *
+ * Note that we have no input buffering; characters typed too rapidly
+ * will be lost.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <machine/spl.h>
+#include <synch.h>
+#include <generic/console.h>
+#include <dev.h>
+#include <vfs.h>
+#include <uio.h>
+#include "autoconf.h"
+
+/*
+ * The console device.
+ */
+static struct con_softc *the_console = NULL;
+
+/*
+ * Lock so user I/Os are atomic.
+ * We use two locks so readers waiting for input don't lock out writers.
+ */
+static struct lock *con_userlock_read = NULL;
+static struct lock *con_userlock_write = NULL;
+
+//////////////////////////////////////////////////
+
+/*
+ * This is for accumulating characters printed before the
+ * console is set up. Upon console setup they are dumped 
+ * to the actual console; thenceforth this space is unused.
+ */
+#define DELAYBUFSIZE  1024
+static char delayed_outbuf[DELAYBUFSIZE];
+static size_t delayed_outbuf_pos=0;
+
+static
+void
+putch_delayed(int ch)
+{
+	/*
+	 * No synchronization needed: called only during system startup
+	 * by main thread.
+	 */
+
+	assert(delayed_outbuf_pos < sizeof(delayed_outbuf));
+	delayed_outbuf[delayed_outbuf_pos++] = ch;
+}
+
+static
+void
+flush_delay_buf(void)
+{
+	size_t i;
+	for (i=0; i<delayed_outbuf_pos; i++) {
+		putch(delayed_outbuf[i]);
+	}
+	delayed_outbuf_pos = 0;
+}
+
+//////////////////////////////////////////////////
+
+/*
+ * Print a character, using polling instead of interrupts to wait for
+ * I/O completion.
+ */
+static
+void
+putch_polled(struct con_softc *cs, int ch)
+{
+	cs->cs_sendpolled(cs->cs_devdata, ch);
+}
+
+//////////////////////////////////////////////////
+
+/*
+ * Print a character, using interrupts to wait for I/O completion.
+ */
+
+static
+void
+putch_intr(struct con_softc *cs, int ch)
+{
+	P(cs->cs_wsem);
+	cs->cs_send(cs->cs_devdata, ch);
+}
+
+/*
+ * Read a character, using interrupts to wait for I/O completion.
+ */
+
+static
+int
+getch_intr(struct con_softc *cs)
+{
+	P(cs->cs_rsem);
+	return cs->cs_gotchar;
+}
+
+/*
+ * Called from underlying device when a read-ready interrupt occurs.
+ */
+void
+con_input(void *vcs, int ch)
+{
+	struct con_softc *cs = vcs;
+
+	cs->cs_gotchar = ch;
+	V(cs->cs_rsem);
+}
+
+/*
+ * Called from underlying device when a write-done interrupt occurs.
+ */
+void
+con_start(void *vcs)
+{
+	struct con_softc *cs = vcs;
+
+	V(cs->cs_wsem);
+}
+
+//////////////////////////////////////////////////
+
+/*
+ * Exported interface.
+ * 
+ * Warning: putch must work even in an interrupt handler or with
+ * interrupts disabled, and before the console is probed. getch need
+ * not, and does not.
+ */
+
+void
+putch(int ch)
+{
+	struct con_softc *cs = the_console;
+
+	if (cs==NULL) {
+		putch_delayed(ch);
+	}
+	else if (in_interrupt || curspl>0) {
+		putch_polled(cs, ch);
+	}
+	else {
+		putch_intr(cs, ch);
+	}
+}
+
+int
+getch(void)
+{
+	struct con_softc *cs = the_console;
+	assert(cs!=NULL);
+	assert(!in_interrupt && curspl==0);
+
+	return getch_intr(cs);
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * VFS interface functions
+ */
+
+static
+int
+con_open(struct device *dev, int openflags)
+{
+	(void)dev;
+	(void)openflags;
+	return 0;
+}
+
+static
+int
+con_close(struct device *dev)
+{
+	(void)dev;
+	return 0;
+}
+
+static
+int
+con_io(struct device *dev, struct uio *uio)
+{
+	int result;
+	char ch;
+	struct lock *lk;
+
+	(void)dev;  // unused
+
+	if (uio->uio_rw==UIO_READ) {
+		lk = con_userlock_read;
+	}
+	else {
+		lk = con_userlock_write;
+	}
+
+	assert(lk != NULL);
+	lock_acquire(lk);
+
+	while (uio->uio_resid > 0) {
+		if (uio->uio_rw==UIO_READ) {
+			ch = getch();
+			if (ch=='\r') {
+				ch = '\n';
+			}
+			result = uiomove(&ch, 1, uio);
+			if (result) {
+				lock_release(lk);
+				return result;
+			}
+			if (ch=='\n') {
+				break;
+			}
+		}
+		else {
+			result = uiomove(&ch, 1, uio);
+			if (result) {
+				lock_release(lk);
+				return result;
+			}
+			if (ch=='\n') {
+				putch('\r');
+			}
+			putch(ch);
+		}
+	}
+	lock_release(lk);
+	return 0;
+}
+
+static
+int
+con_ioctl(struct device *dev, int op, userptr_t data)
+{
+	/* No ioctls. */
+	(void)dev;
+	(void)op;
+	(void)data;
+	return EINVAL;
+}
+
+static
+int
+attach_console_to_vfs(struct con_softc *cs)
+{
+	struct device *dev;
+	int result;
+
+	dev = kmalloc(sizeof(*dev));
+	if (dev==NULL) {
+		return ENOMEM;
+	}
+
+	dev->d_open = con_open;
+	dev->d_close = con_close;
+	dev->d_io = con_io;
+	dev->d_ioctl = con_ioctl;
+	dev->d_blocks = 0;
+	dev->d_blocksize = 1;
+	dev->d_data = cs;
+
+	result = vfs_adddev("con", dev, 0);
+	if (result) {
+		kfree(dev);
+		return result;
+	}
+
+	return 0;
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Config routine called by autoconf.c after we are attached to something.
+ */
+
+int
+config_con(struct con_softc *cs, int unit)
+{
+	struct semaphore *rsem, *wsem;
+	struct lock *rlk, *wlk;
+
+	/*
+	 * Only allow one system console.
+	 * Further devices that could be the system console are ignored.
+	 *
+	 * Do not hardwire the console to be "con1" instead of "con0",
+	 * or these asserts will go off.
+	 */
+	if (unit>0) {
+		assert(the_console!=NULL);
+		return ENODEV;
+	}
+	assert(the_console==NULL);
+
+	rsem = sem_create("console read", 0);
+	if (rsem == NULL) {
+		return ENOMEM;
+	}
+	wsem = sem_create("console write", 1);
+	if (wsem == NULL) {
+		sem_destroy(rsem);
+		return ENOMEM;
+	}
+	rlk = lock_create("console-lock-read");
+	if (rlk == NULL) {
+		sem_destroy(rsem);
+		sem_destroy(wsem);
+		return ENOMEM;
+	}
+	wlk = lock_create("console-lock-write");
+	if (wlk == NULL) {
+		lock_destroy(rlk);
+		sem_destroy(rsem);
+		sem_destroy(wsem);
+		return ENOMEM;
+	}
+
+	cs->cs_rsem = rsem; 
+	cs->cs_wsem = wsem; 
+	cs->cs_gotchar = 0;
+
+	the_console = cs;
+	con_userlock_read = rlk;
+	con_userlock_write = wlk;
+
+	flush_delay_buf();
+
+	return attach_console_to_vfs(cs);
+}
diff --git a/os161-1.10/kern/dev/generic/console.h b/os161-1.10/kern/dev/generic/console.h
new file mode 100644
index 0000000..620d931
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/console.h
@@ -0,0 +1,35 @@
+#ifndef _GENERIC_CONSOLE_H_
+#define _GENERIC_CONSOLE_H_
+
+/*
+ * Device data for the hardware-independent system console.
+ *
+ * devdata, send, and sendpolled are provided by the underlying
+ * device, and are to be initialized by the attach routine.
+ */
+
+struct con_softc {
+	/* initialized by attach routine */
+	void *cs_devdata;
+	void (*cs_send)(void *devdata, int ch);
+	void (*cs_sendpolled)(void *devdata, int ch);
+
+	/* initialized by config routine */
+	struct semaphore *cs_rsem;
+	struct semaphore *cs_wsem;
+	int cs_gotchar;
+};
+
+/*
+ * Functions called by lower-level drivers
+ */
+void con_input(/*struct con_softc*/ void *cs, int ch);
+void con_start(/*struct con_softc*/ void *cs);
+
+/*
+ * Functions called by higher-level code
+ *
+ * putch/getch - see <lib.h>
+ */
+
+#endif /* _GENERIC_CONSOLE_H_ */
diff --git a/os161-1.10/kern/dev/generic/pseudorand.c b/os161-1.10/kern/dev/generic/pseudorand.c
new file mode 100644
index 0000000..44002ca
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/pseudorand.c
@@ -0,0 +1,110 @@
+/*
+ * Simple pseudorandom generator.
+ *
+ * This is from the article "Random Number Generators: Good Ones are
+ * Hard to Find", by S.K. Park and K.W. Miller in the October 1988
+ * CACM.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <uio.h>
+#include <generic/pseudorand.h>
+#include "autoconf.h"
+
+#define MULTIPLIER    16807
+#define MODULUS       0x7fffffff
+#define K1            127773		/* MODULUS / MULTIPLIER */
+#define K2            2836		/* MODULUS % MULTIPLIER */
+
+u_int32_t
+pseudorand_random(void *devdata)
+{
+	struct pseudorand_softc *ps = devdata;
+	int32_t hi, lo, tmp;
+
+	hi = ps->ps_seed / K1;
+	lo = ps->ps_seed % K1;
+	tmp = MULTIPLIER * lo - K2 * hi;
+	if (tmp <= 0) {
+		tmp += MODULUS;
+	}
+	ps->ps_seed = tmp;
+
+	/*
+	 * The seed ranges from 1 through MODULUS-1. 
+	 * Return values 0 through MODULUS-2.
+	 */
+	return ps->ps_seed - 1;
+}
+
+u_int32_t
+pseudorand_randmax(void *devdata)
+{
+	(void)devdata;
+
+	/* RAND_MAX should be the largest integer we can return. */
+	return MODULUS - 2;
+}
+
+struct pseudorand_softc *
+pseudoattach_pseudorand(int unit)
+{
+	struct pseudorand_softc *ps = kmalloc(sizeof(struct pseudorand_softc));
+	if (ps==NULL) {
+		return NULL;
+	}
+
+	(void) unit; // unnecessary
+
+	/*
+	 * It would be nice if there were a good way to pick the random
+	 * seed. (Note: it must be between 1 and MODULUS-1 inclusive; 
+	 * do not make it 0.)
+	 */
+
+	ps->ps_seed = 305824;
+
+	return ps;
+}
+
+/*
+ * Access through VFS ("random:").
+ *
+ * Since the generator doesn't return 32 actual random bits, do
+ * 24 at a time.
+ */
+
+int
+pseudorand_read(void *devdata, struct uio *uio)
+{
+	u_int32_t val;
+	u_int8_t bytes[3];
+	int result;
+
+	while (uio->uio_resid > 0) {
+		val = pseudorand_random(devdata);
+
+		/*
+		 * Since the maximum value is MODULUS-2, or 0x7ffffffd,
+		 * and the generator distributes evenly among the numbers
+		 * it returns, it does not actually give us quite random
+		 * bits. All of the bits will be very slightly biased.
+		 * There's no easy fix for this, so we'll just ignore it.
+		 * The strongest effect will be on the outermost bits
+		 * (I think - feel free to tell me I'm wrong), so, since
+		 * we need to select 24 of the 31 bits anyway, pick the
+		 * inside ones.
+		 */
+		bytes[0] = (val & 0x00000ff0) >> 4;
+		bytes[1] = (val & 0x000ff000) >> 12;
+		bytes[2] = (val & 0x0ff00000) >> 20;
+
+		result = uiomove(bytes, sizeof(bytes), uio);
+		if (result) {
+			return result;
+		}
+	}
+
+	return 0;
+}
diff --git a/os161-1.10/kern/dev/generic/pseudorand.h b/os161-1.10/kern/dev/generic/pseudorand.h
new file mode 100644
index 0000000..dcbc91b
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/pseudorand.h
@@ -0,0 +1,14 @@
+#ifndef _GENERIC_PSEUDORAND_H_
+#define _GENERIC_PSEUDORAND_H_
+
+struct uio;
+
+struct pseudorand_softc {
+	u_int32_t ps_seed;
+};
+
+u_int32_t pseudorand_random(/*struct pseudorand_softc*/ void *devdata);
+u_int32_t pseudorand_randmax(/*struct pseudorand_softc*/ void *devdata);
+int pseudorand_read(/*struct pseudorand_softc*/ void *, struct uio *);
+
+#endif /* _GENERIC_PSEUDORAND_H_ */
diff --git a/os161-1.10/kern/dev/generic/pseudorand_att.c b/os161-1.10/kern/dev/generic/pseudorand_att.c
new file mode 100644
index 0000000..fd48ddc
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/pseudorand_att.c
@@ -0,0 +1,28 @@
+/*
+ * Attachment code for having the generic random device use the
+ * pseudo-random device.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <generic/random.h>
+#include <generic/pseudorand.h>
+#include "autoconf.h"
+
+struct random_softc *
+attach_random_to_pseudorand(int randomno, struct pseudorand_softc *ls)
+{
+	struct random_softc *rs = kmalloc(sizeof(struct random_softc));
+	if (rs==NULL) {
+		return NULL;
+	}
+
+	(void)randomno;  // unused
+
+	rs->rs_devdata = ls;
+	rs->rs_random = pseudorand_random;
+	rs->rs_randmax = pseudorand_randmax;
+	rs->rs_read = pseudorand_read;
+
+	return rs;
+}
diff --git a/os161-1.10/kern/dev/generic/random.c b/os161-1.10/kern/dev/generic/random.c
new file mode 100644
index 0000000..24db480
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/random.c
@@ -0,0 +1,137 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/unistd.h>
+#include <lib.h>
+#include <uio.h>
+#include <vfs.h>
+#include <generic/random.h>
+#include "autoconf.h"
+
+/*
+ * Machine-independent generic randomness device.
+ *
+ * Remembers something that's a random source, and provides random()
+ * and randmax() to the rest of the kernel.
+ *
+ * The kernel config mechanism can be used to explicitly choose which
+ * of the available random sources to use, if more than one is
+ * available.
+ */
+
+static struct random_softc *the_random = NULL;
+
+/*
+ * VFS device functions.
+ * open: allow reading only.
+ */
+static
+int
+randopen(struct device *dev, int openflags)
+{
+	(void)dev;
+
+	if (openflags != O_RDONLY) {
+		return EIO;
+	}
+
+	return 0;
+}
+
+/*
+ * VFS close function.
+ */
+static
+int
+randclose(struct device *dev)
+{
+	(void)dev;
+	return 0;
+}
+
+/*
+ * VFS I/O function. Hand off to implementation.
+ */
+static
+int
+randio(struct device *dev, struct uio *uio)
+{
+	struct random_softc *rs = dev->d_data;
+
+	if (uio->uio_rw != UIO_READ) {
+		return EIO;
+	}
+
+	return rs->rs_read(rs->rs_devdata, uio);
+}
+
+/*
+ * VFS ioctl function.
+ */
+static
+int
+randioctl(struct device *dev, int op, userptr_t data)
+{
+	/*
+	 * We don't support any ioctls.
+	 */
+	(void)dev;
+	(void)op;
+	(void)data;
+	return EIOCTL;
+}
+
+/*
+ * Config function.
+ */
+int
+config_random(struct random_softc *rs, int unit)
+{
+	int result;
+
+	/* We use only the first random device. */
+	if (unit!=0) {
+		return ENODEV;
+	}
+
+	assert(the_random==NULL);
+	the_random = rs;
+
+	rs->rs_dev.d_open = randopen;
+	rs->rs_dev.d_close = randclose;
+	rs->rs_dev.d_io = randio;
+	rs->rs_dev.d_ioctl = randioctl;
+	rs->rs_dev.d_blocks = 0;
+	rs->rs_dev.d_blocksize = 1;
+	rs->rs_dev.d_data = rs;
+
+	/* Add the VFS device structure to the VFS device list. */
+	result = vfs_adddev("random", &rs->rs_dev, 0);
+	if (result) {
+		return result;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Random number functions exported to the rest of the kernel.
+ */
+
+u_int32_t
+random(void)
+{
+	if (the_random==NULL) {
+		panic("No random device\n");
+	}
+	return the_random->rs_random(the_random->rs_devdata);
+}
+
+u_int32_t
+randmax(void)
+{
+	if (the_random==NULL) {
+		panic("No random device\n");
+	}
+	return the_random->rs_randmax(the_random->rs_devdata);
+}
diff --git a/os161-1.10/kern/dev/generic/random.h b/os161-1.10/kern/dev/generic/random.h
new file mode 100644
index 0000000..05f5984
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/random.h
@@ -0,0 +1,17 @@
+#ifndef _GENERIC_RANDOM_H_
+#define _GENERIC_RANDOM_H_
+
+#include <dev.h>
+struct uio;
+
+struct random_softc {
+	/* Initialized by lower-level attach routine */
+	void *rs_devdata;
+	u_int32_t (*rs_random)(void *devdata);
+	u_int32_t (*rs_randmax)(void *devdata);
+	int (*rs_read)(void *devdata, struct uio *uio);
+
+	struct device rs_dev;
+};
+
+#endif /* _GENERIC_RANDOM_H_ */
diff --git a/os161-1.10/kern/dev/generic/rtclock.c b/os161-1.10/kern/dev/generic/rtclock.c
new file mode 100644
index 0000000..4e855c3
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/rtclock.c
@@ -0,0 +1,41 @@
+/*
+ * Machine-independent generic clock "device".
+ *
+ * Basically, all we do is remember something that can be used for
+ * handling requests for the current time, and provide the gettime()
+ * function to the rest of the kernel.
+ *
+ * The kernel config mechanism can be used to explicitly choose which
+ * of the available clocks to use, if more than one is available.
+ *
+ * The system will panic if gettime() is called and there is no clock.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <clock.h>
+#include <generic/rtclock.h>
+#include "autoconf.h"
+
+static struct rtclock_softc *the_clock = NULL;
+
+int
+config_rtclock(struct rtclock_softc *rtc, int unit)
+{
+	/* We use only the first clock device. */
+	if (unit!=0) {
+		return ENODEV;
+	}
+
+	assert(the_clock==NULL);
+	the_clock = rtc;
+	return 0;
+}
+
+void
+gettime(time_t *secs, u_int32_t *nsecs)
+{
+	assert(the_clock!=NULL);
+	the_clock->rtc_gettime(the_clock->rtc_devdata, secs, nsecs);
+}
diff --git a/os161-1.10/kern/dev/generic/rtclock.h b/os161-1.10/kern/dev/generic/rtclock.h
new file mode 100644
index 0000000..8a6a4fe
--- /dev/null
+++ b/os161-1.10/kern/dev/generic/rtclock.h
@@ -0,0 +1,14 @@
+#ifndef _GENERIC_RTCLOCK_H_
+#define _GENERIC_RTCLOCK_H_
+
+/*
+ * The device info for the generic MI clock device - a function
+ * to call and a context pointer for it.
+ */
+
+struct rtclock_softc {
+	void *rtc_devdata;
+	void (*rtc_gettime)(void *devdata, time_t *secs, u_int32_t *nsecs);
+};
+
+#endif /* _GENERIC_RTCLOCK_H_ */
diff --git a/os161-1.10/kern/dev/init.c b/os161-1.10/kern/dev/init.c
new file mode 100644
index 0000000..2691897
--- /dev/null
+++ b/os161-1.10/kern/dev/init.c
@@ -0,0 +1,33 @@
+#include <types.h>
+#include <lib.h>
+#include <machine/spl.h>
+#include <dev.h>
+#include "autoconf.h"  // for pseudoconfig
+
+/*
+ * Machine-independent device initialization (and cleanup)
+ *
+ * This is called as early in boot as possible, because until it's
+ * called, console I/O doesn't print.
+ *
+ * machdep_dev_bootstrap() calls the autoconf stuff for the main
+ * system bus, which does all the device probes.
+ */
+
+void
+dev_bootstrap(void)
+{
+	/* Interrupts should be off. */
+	assert(curspl>0);
+
+	kprintf("Device probe...\n");
+	machdep_dev_bootstrap();
+
+	/* Interrupts should now have come on. */
+	assert(curspl==0);
+	
+	/* Now initialize pseudo-devices */
+	pseudoconfig();
+
+	kprintf("\n");
+}
diff --git a/os161-1.10/kern/dev/lamebus/beep_ltimer.c b/os161-1.10/kern/dev/lamebus/beep_ltimer.c
new file mode 100644
index 0000000..b5f8bd2
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/beep_ltimer.c
@@ -0,0 +1,26 @@
+/*
+ * Attachment code for having the generic beep device use the LAMEbus
+ * ltimer device for beeping.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <generic/beep.h>
+#include <lamebus/ltimer.h>
+#include "autoconf.h"
+
+struct beep_softc *
+attach_beep_to_ltimer(int beepno, struct ltimer_softc *ls)
+{
+	struct beep_softc *bs = kmalloc(sizeof(struct beep_softc));
+	if (bs==NULL) {
+		return NULL;
+	}
+
+	(void)beepno;  // unused
+
+	bs->bs_devdata = ls;
+	bs->bs_beep = ltimer_beep;
+
+	return bs;
+}
diff --git a/os161-1.10/kern/dev/lamebus/con_lscreen.c b/os161-1.10/kern/dev/lamebus/con_lscreen.c
new file mode 100644
index 0000000..ac6b91d
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/con_lscreen.c
@@ -0,0 +1,30 @@
+/*
+ * Attachment code for having the generic console device use the LAMEbus
+ * screen device.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <generic/console.h>
+#include <lamebus/lscreen.h>
+#include "autoconf.h"
+
+struct con_softc *
+attach_con_to_lscreen(int consno, struct lscreen_softc *ls)
+{
+	struct con_softc *cs = kmalloc(sizeof(struct con_softc));
+	if (cs==NULL) {
+		return NULL;
+	}
+
+	cs->cs_devdata = ls;
+	cs->cs_send = lscreen_write;
+	cs->cs_sendpolled = lscreen_write;
+
+	ls->ls_devdata = cs;
+	ls->ls_start = con_start;
+	ls->ls_input = con_input;
+
+	return cs;
+}
+
diff --git a/os161-1.10/kern/dev/lamebus/con_lser.c b/os161-1.10/kern/dev/lamebus/con_lser.c
new file mode 100644
index 0000000..0ab9bff
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/con_lser.c
@@ -0,0 +1,32 @@
+/*
+ * Attachment code for having the generic console device use the LAMEbus
+ * serial device.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <generic/console.h>
+#include <lamebus/lser.h>
+#include "autoconf.h"
+
+struct con_softc *
+attach_con_to_lser(int consno, struct lser_softc *ls)
+{
+	struct con_softc *cs = kmalloc(sizeof(struct con_softc));
+	if (cs==NULL) {
+		return NULL;
+	}
+
+	(void)consno;  // unused
+
+	cs->cs_devdata = ls;
+	cs->cs_send = lser_write;
+	cs->cs_sendpolled = lser_writepolled;
+
+	ls->ls_devdata = cs;
+	ls->ls_start = con_start;
+	ls->ls_input = con_input;
+
+	return cs;
+}
+
diff --git a/os161-1.10/kern/dev/lamebus/conf.lamebus b/os161-1.10/kern/dev/lamebus/conf.lamebus
new file mode 100644
index 0000000..53adce5
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/conf.lamebus
@@ -0,0 +1,57 @@
+#
+# Kernel config definitions for LAMEbus devices.
+#
+# See conf/conf.kern for more information.
+#
+
+# System main bus.
+defdevice	lamebus			dev/lamebus/lamebus.c
+
+# Timer.
+defdevice	ltimer			dev/lamebus/ltimer.c
+defattach	ltimer* lamebus*	dev/lamebus/ltimer_att.c
+
+# Random.
+defdevice	lrandom			dev/lamebus/lrandom.c
+defattach	lrandom* lamebus*	dev/lamebus/lrandom_att.c
+
+# Disk.
+defdevice	lhd			dev/lamebus/lhd.c
+defattach	lhd* lamebus*		dev/lamebus/lhd_att.c
+
+# Serial port.
+defdevice	lser			dev/lamebus/lser.c
+defattach	lser* lamebus*		dev/lamebus/lser_att.c
+
+# Text screen.
+defdevice	lscreen			dev/lamebus/lscreen.c
+defattach	lscreen* lamebus*	dev/lamebus/lscreen_att.c
+
+# Network interface.
+defdevice	lnet			dev/lamebus/lnet.c
+defattach	lnet* lamebus*		dev/lamebus/lnet_att.c
+
+# Trace control device.
+defdevice	ltrace			dev/lamebus/ltrace.c
+defattach	ltrace* lamebus*	dev/lamebus/ltrace_att.c
+
+# Emulator passthrough filesystem.
+defdevice	emu			dev/lamebus/emu.c
+defattach	emu* lamebus*		dev/lamebus/emu_att.c
+
+#
+# Attachments to generic interface devices
+#
+
+# Consoles.
+defattach	con0 lser*		dev/lamebus/con_lser.c
+defattach	con0 lscreen*		dev/lamebus/con_lscreen.c
+
+# Beeper.
+defattach	beep* ltimer*		dev/lamebus/beep_ltimer.c
+
+# Clock.
+defattach       rtclock* ltimer*        dev/lamebus/rtclock_ltimer.c
+
+# Random.
+defattach	random0 lrandom*	dev/lamebus/random_lrandom.c
diff --git a/os161-1.10/kern/dev/lamebus/emu.c b/os161-1.10/kern/dev/lamebus/emu.c
new file mode 100644
index 0000000..60fe063
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/emu.c
@@ -0,0 +1,1111 @@
+/*
+ * Emulator passthrough filesystem.
+ *
+ * The idea is that this appears as a filesystem in the VFS layer, and
+ * passes VFS operations through a somewhat complicated "hardware"
+ * interface to some simulated "hardware" in System/161 that accesses
+ * the filesystem System/161 is running in.
+ *
+ * This makes it unnecessary to copy the system files to the simulated
+ * disk, although we recommend doing so and trying running without this
+ * device as part of testing your filesystem.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/unistd.h>
+#include <kern/stat.h>
+#include <lib.h>
+#include <synch.h>
+#include <array.h>
+#include <uio.h>
+#include <vfs.h>
+#include <emufs.h>
+#include <lamebus/emu.h>
+#include <machine/bus.h>
+#include "autoconf.h"
+
+/* Register offsets */
+#define REG_HANDLE    0
+#define REG_OFFSET    4
+#define REG_IOLEN     8
+#define REG_OPER      12
+#define REG_RESULT    16
+
+/* I/O buffer offset */
+#define EMU_BUFFER    32768
+
+/* Operation codes for REG_OPER */
+#define EMU_OP_OPEN          1
+#define EMU_OP_CREATE        2
+#define EMU_OP_EXCLCREATE    3
+#define EMU_OP_CLOSE         4
+#define EMU_OP_READ          5
+#define EMU_OP_READDIR       6
+#define EMU_OP_WRITE         7
+#define EMU_OP_GETSIZE       8
+#define EMU_OP_TRUNC         9
+
+/* Result codes for REG_RESULT */
+#define EMU_RES_SUCCESS      1
+#define EMU_RES_BADHANDLE    2
+#define EMU_RES_BADOP        3
+#define EMU_RES_BADPATH      4
+#define EMU_RES_BADSIZE      5
+#define EMU_RES_EXISTS       6
+#define EMU_RES_ISDIR        7
+#define EMU_RES_MEDIA        8
+#define EMU_RES_NOHANDLES    9
+#define EMU_RES_NOSPACE      10
+#define EMU_RES_NOTDIR       11
+#define EMU_RES_UNKNOWN      12
+#define EMU_RES_UNSUPP       13
+
+////////////////////////////////////////////////////////////
+//
+// Hardware ops
+//
+
+/*
+ * Shortcut for reading a register
+ */
+static
+inline
+u_int32_t
+emu_rreg(struct emu_softc *sc, u_int32_t reg)
+{
+	return bus_read_register(sc->e_busdata, sc->e_buspos, reg);
+}
+
+/*
+ * Shortcut for writing a register
+ */
+static
+inline
+void
+emu_wreg(struct emu_softc *sc, u_int32_t reg, u_int32_t val)
+{
+	bus_write_register(sc->e_busdata, sc->e_buspos, reg, val);
+}
+
+/*
+ * Called by the underlying bus code when an interrupt happens
+ */
+void
+emu_irq(void *dev)
+{
+	struct emu_softc *sc = dev;
+
+	sc->e_result = emu_rreg(sc, REG_RESULT);
+	emu_wreg(sc, REG_RESULT, 0);
+
+	V(sc->e_sem);
+}
+
+/*
+ * Convert the error codes reported by the "hardware" to errnos.
+ * Or, on cases that indicate a programming error in emu.c, panic.
+ */
+static
+u_int32_t
+translate_err(struct emu_softc *sc, u_int32_t code)
+{
+	switch (code) {
+	    case EMU_RES_SUCCESS: return 0;
+	    case EMU_RES_BADHANDLE: 
+	    case EMU_RES_BADOP: 
+	    case EMU_RES_BADSIZE: 
+		panic("emu%d: got fatal result code %d\n", sc->e_unit, code);
+	    case EMU_RES_BADPATH: return ENOENT;
+	    case EMU_RES_EXISTS: return EEXIST;
+	    case EMU_RES_ISDIR: return EISDIR;
+	    case EMU_RES_MEDIA: return EIO;
+	    case EMU_RES_NOHANDLES: return ENFILE;
+	    case EMU_RES_NOSPACE: return ENOSPC;
+	    case EMU_RES_NOTDIR: return ENOTDIR;
+	    case EMU_RES_UNKNOWN: return EIO;
+	    case EMU_RES_UNSUPP: return EUNIMP;
+	}
+	kprintf("emu%d: Unknown result code %d\n", sc->e_unit, code);
+	return EAGAIN;
+}
+
+/*
+ * Wait for an operation to complete, and return an errno for the result.
+ */
+static
+int
+emu_waitdone(struct emu_softc *sc)
+{
+	P(sc->e_sem);
+	return translate_err(sc, sc->e_result);
+}
+
+/*
+ * Common file open routine (for both VOP_LOOKUP and VOP_CREATE).  Not
+ * for VOP_OPEN. At the hardware level, we need to "open" files in
+ * order to look at them, so by the time VOP_OPEN is called the
+ * files are already open.
+ */
+static
+int
+emu_open(struct emu_softc *sc, u_int32_t handle, const char *name,
+	 int create, int excl, u_int32_t *newhandle, int *newisdir)
+{
+	u_int32_t op;
+	int result;
+
+	if (strlen(name)+1 > EMU_MAXIO) {
+		return ENAMETOOLONG;
+	}
+
+	if (create && excl) {
+		op = EMU_OP_EXCLCREATE;
+	}
+	else if (create) {
+		op = EMU_OP_CREATE;
+	}
+	else {
+		op = EMU_OP_OPEN;
+	}
+
+	lock_acquire(sc->e_lock);
+
+	strcpy(sc->e_iobuf, name);
+	emu_wreg(sc, REG_IOLEN, strlen(name));
+	emu_wreg(sc, REG_HANDLE, handle);
+	emu_wreg(sc, REG_OPER, op);
+	result = emu_waitdone(sc);
+
+	if (result==0) {
+		*newhandle = emu_rreg(sc, REG_HANDLE);
+		*newisdir = emu_rreg(sc, REG_IOLEN)>0;
+	}
+
+	lock_release(sc->e_lock);
+	return result;
+}
+
+/*
+ * Routine for closing a file we opened at the hardware level.
+ * This is not necessarily called at VOP_CLOSE time; it's called
+ * at VOP_RECLAIM time.
+ */
+static
+int
+emu_close(struct emu_softc *sc, u_int32_t handle)
+{
+	int result;
+	int mine;
+	int retries=0;
+
+	mine = lock_do_i_hold(sc->e_lock);
+	if (!mine) {
+		lock_acquire(sc->e_lock);
+	}
+
+	while (1) {
+		/* Retry operation up to 10 times */
+
+		emu_wreg(sc, REG_HANDLE, handle);
+		emu_wreg(sc, REG_OPER, EMU_OP_CLOSE);
+		result = emu_waitdone(sc);
+
+		if (result==EIO && retries < 10) {
+			kprintf("emu%d: I/O error on close, retrying\n", 
+				sc->e_unit);
+			retries++;
+			continue;
+		}
+		break;
+	}
+
+	if (!mine) {
+		lock_release(sc->e_lock);
+	}
+	return result;
+}
+
+/*
+ * Common code for read and readdir.
+ */
+static
+int
+emu_doread(struct emu_softc *sc, u_int32_t handle, u_int32_t len,
+	   u_int32_t op, struct uio *uio)
+{
+	int result;
+
+	assert(uio->uio_rw == UIO_READ);
+
+	lock_acquire(sc->e_lock);
+
+	emu_wreg(sc, REG_HANDLE, handle);
+	emu_wreg(sc, REG_IOLEN, len);
+	emu_wreg(sc, REG_OFFSET, uio->uio_offset);
+	emu_wreg(sc, REG_OPER, op);
+	result = emu_waitdone(sc);
+	if (result) {
+		goto out;
+	}
+	
+	result = uiomove(sc->e_iobuf, emu_rreg(sc, REG_IOLEN), uio);
+
+	uio->uio_offset = emu_rreg(sc, REG_OFFSET);
+
+ out:
+	lock_release(sc->e_lock);
+	return result;
+}
+
+/*
+ * Read from a hardware-level file handle.
+ */
+static
+int
+emu_read(struct emu_softc *sc, u_int32_t handle, u_int32_t len,
+	 struct uio *uio)
+{
+	return emu_doread(sc, handle, len, EMU_OP_READ, uio);
+}
+
+/*
+ * Read a directory entry from a hardware-level file handle.
+ */
+static
+int
+emu_readdir(struct emu_softc *sc, u_int32_t handle, u_int32_t len,
+	    struct uio *uio)
+{
+	return emu_doread(sc, handle, len, EMU_OP_READDIR, uio);
+}
+
+/*
+ * Write to a hardware-level file handle.
+ */
+static
+int
+emu_write(struct emu_softc *sc, u_int32_t handle, u_int32_t len,
+	  struct uio *uio)
+{
+	int result;
+
+	assert(uio->uio_rw == UIO_WRITE);
+
+	lock_acquire(sc->e_lock);
+
+	emu_wreg(sc, REG_HANDLE, handle);
+	emu_wreg(sc, REG_IOLEN, len);
+	emu_wreg(sc, REG_OFFSET, uio->uio_offset);
+
+	result = uiomove(sc->e_iobuf, len, uio);
+	if (result) {
+		goto out;
+	}
+
+	emu_wreg(sc, REG_OPER, EMU_OP_WRITE);
+	result = emu_waitdone(sc);
+
+ out:
+	lock_release(sc->e_lock);
+	return result;
+}
+
+/*
+ * Get the file size associated with a hardware-level file handle.
+ */
+static
+int
+emu_getsize(struct emu_softc *sc, u_int32_t handle, off_t *retval)
+{
+	int result;
+
+	lock_acquire(sc->e_lock);
+
+	emu_wreg(sc, REG_HANDLE, handle);
+	emu_wreg(sc, REG_OPER, EMU_OP_GETSIZE);
+	result = emu_waitdone(sc);
+	if (result==0) {
+		*retval = emu_rreg(sc, REG_IOLEN);
+	}
+
+	lock_release(sc->e_lock);
+	return result;
+}
+
+/*
+ * Truncate a hardware-level file handle.
+ */
+static
+int
+emu_trunc(struct emu_softc *sc, u_int32_t handle, off_t len)
+{
+	int result;
+
+	lock_acquire(sc->e_lock);
+
+	emu_wreg(sc, REG_HANDLE, handle);
+	emu_wreg(sc, REG_IOLEN, len);
+	emu_wreg(sc, REG_OPER, EMU_OP_TRUNC);
+	result = emu_waitdone(sc);
+
+	lock_release(sc->e_lock);
+	return result;
+}
+
+//
+////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////
+//
+// vnode functions 
+//
+
+// at bottom of this section
+
+static int emufs_loadvnode(struct emufs_fs *ef, u_int32_t handle, int isdir,
+			   struct emufs_vnode **ret);
+
+/*
+ * VOP_OPEN on files
+ */
+static
+int
+emufs_open(struct vnode *v, int openflags)
+{
+	/*
+	 * At this level we do not need to handle O_CREAT, O_EXCL, or O_TRUNC.
+	 * We *would* need to handle O_APPEND, but we don't support it.
+	 *
+	 * Any of O_RDONLY, O_WRONLY, and O_RDWR are valid, so we don't need
+	 * to check that either.
+	 */
+
+	if (openflags & O_APPEND) {
+		return EUNIMP;
+	}
+
+	(void)v;
+
+	return 0;
+}
+
+/*
+ * VOP_OPEN on directories
+ */
+static
+int
+emufs_opendir(struct vnode *v, int openflags)
+{
+	switch (openflags & O_ACCMODE) {
+	    case O_RDONLY:
+		break;
+	    case O_WRONLY:
+	    case O_RDWR:
+	    default:
+		return EISDIR;
+	}
+	if (openflags & O_APPEND) {
+		return EISDIR;
+	}
+
+	(void)v;
+	return 0;
+}
+
+/*
+ * VOP_CLOSE
+ */
+static
+int
+emufs_close(struct vnode *v)
+{
+	(void)v;
+	return 0;
+}
+
+/*
+ * VOP_RECLAIM
+ *
+ * Reclaim should make an effort to returning errors other than EBUSY.
+ */
+static
+int
+emufs_reclaim(struct vnode *v)
+{
+	struct emufs_vnode *ev = v->vn_data;
+	struct emufs_fs *ef = v->vn_fs->fs_data;
+	int ix, i, num, result;
+
+	lock_acquire(ef->ef_emu->e_lock);
+	lock_acquire(ev->ev_v.vn_countlock);
+
+	if (ev->ev_v.vn_refcount != 1) {
+		lock_release(ev->ev_v.vn_countlock);
+		lock_release(ef->ef_emu->e_lock);
+		return EBUSY;
+	}
+
+	/*
+	 * Since we hold e_lock and are the last ref, nobody can increment
+	 * the refcount, so we can release vn_countlock.
+	 */
+	lock_release(ev->ev_v.vn_countlock);
+
+	/* emu_close retries on I/O error */
+	result = emu_close(ev->ev_emu, ev->ev_handle);
+	if (result) {
+		lock_release(ef->ef_emu->e_lock);
+		return result;
+	}
+
+	ix = -1;
+	num = array_getnum(ef->ef_vnodes);
+	for (i=0; i<num; i++) {
+		struct emufs_vnode *evx = array_getguy(ef->ef_vnodes, i);
+		if (evx==ev) {
+			ix = i;
+			break;
+		}
+	}
+	if (ix<0) {
+		panic("emu%d: reclaim vnode %u not in vnode pool\n",
+		      ef->ef_emu->e_unit, ev->ev_handle);
+	}
+	array_remove(ef->ef_vnodes, ix);
+
+	lock_release(ef->ef_emu->e_lock);
+
+	VOP_KILL(&ev->ev_v);
+
+	kfree(ev);
+	return 0;
+}
+
+/*
+ * VOP_READ
+ */
+static
+int
+emufs_read(struct vnode *v, struct uio *uio)
+{
+	struct emufs_vnode *ev = v->vn_data;
+	u_int32_t amt;
+	size_t oldresid;
+	int result;
+
+	assert(uio->uio_rw==UIO_READ);
+
+	while (uio->uio_resid > 0) {
+		amt = uio->uio_resid;
+		if (amt > EMU_MAXIO) {
+			amt = EMU_MAXIO;
+		}
+
+		oldresid = uio->uio_resid;
+
+		result = emu_read(ev->ev_emu, ev->ev_handle, amt, uio);
+		if (result) {
+			return result;
+		}
+		
+		if (uio->uio_resid == oldresid) {
+			/* nothing read - EOF */
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * VOP_READDIR
+ */
+static
+int
+emufs_getdirentry(struct vnode *v, struct uio *uio)
+{
+	struct emufs_vnode *ev = v->vn_data;
+	u_int32_t amt;
+
+	assert(uio->uio_rw==UIO_READ);
+
+	amt = uio->uio_resid;
+	if (amt > EMU_MAXIO) {
+		amt = EMU_MAXIO;
+	}
+
+	return emu_readdir(ev->ev_emu, ev->ev_handle, amt, uio);
+}
+
+/*
+ * VOP_WRITE
+ */
+static
+int
+emufs_write(struct vnode *v, struct uio *uio)
+{
+	struct emufs_vnode *ev = v->vn_data;
+	u_int32_t amt;
+	size_t oldresid;
+	int result;
+
+	assert(uio->uio_rw==UIO_WRITE);
+
+	while (uio->uio_resid > 0) {
+		amt = uio->uio_resid;
+		if (amt > EMU_MAXIO) {
+			amt = EMU_MAXIO;
+		}
+
+		oldresid = uio->uio_resid;
+
+		result = emu_write(ev->ev_emu, ev->ev_handle, amt, uio);
+		if (result) {
+			return result;
+		}
+
+		if (uio->uio_resid == oldresid) {
+			/* nothing written...? */
+			break;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * VOP_IOCTL
+ */
+static
+int
+emufs_ioctl(struct vnode *v, int op, userptr_t data)
+{
+	/*
+	 * No ioctls.
+	 */
+
+	(void)v;
+	(void)op;
+	(void)data;
+
+	return EINVAL;
+}
+
+/*
+ * VOP_STAT
+ */
+static
+int
+emufs_stat(struct vnode *v, struct stat *statbuf)
+{
+	struct emufs_vnode *ev = v->vn_data;
+	int result;
+
+	bzero(statbuf, sizeof(struct stat));
+
+	result = VOP_GETTYPE(v, &statbuf->st_mode);
+	if (result) {
+		return result;
+	}
+
+	statbuf->st_nlink = 1;  /* might be a lie, but doesn't matter much */
+
+	result = emu_getsize(ev->ev_emu, ev->ev_handle, &statbuf->st_size);
+	if (result) {
+		return result;
+	}
+
+	statbuf->st_blocks = 0;  /* almost certainly a lie */
+
+	return 0;
+}
+
+/*
+ * VOP_GETTYPE for files
+ */
+static
+int
+emufs_file_gettype(struct vnode *v, int *result)
+{
+	(void)v;
+	*result = S_IFREG;
+	return 0;
+}
+
+/*
+ * VOP_GETTYPE for directories
+ */
+static
+int
+emufs_dir_gettype(struct vnode *v, int *result)
+{
+	(void)v;
+	*result = S_IFDIR;
+	return 0;
+}
+
+/*
+ * VOP_TRYSEEK
+ */
+static
+int
+emufs_tryseek(struct vnode *v, off_t pos)
+{
+	if (pos<0) {
+		return EINVAL;
+	}
+
+	/* Allow anything else */
+	(void)v;
+
+	return 0;
+}
+
+/*
+ * VOP_FSYNC
+ */
+static
+int
+emufs_fsync(struct vnode *v)
+{
+	(void)v;
+	return 0;
+}
+
+/*
+ * VOP_TRUNCATE
+ */
+static
+int
+emufs_truncate(struct vnode *v, off_t len)
+{
+	struct emufs_vnode *ev = v->vn_data;
+	return emu_trunc(ev->ev_emu, ev->ev_handle, len);
+}
+
+/*
+ * VOP_CREAT
+ */
+static
+int
+emufs_creat(struct vnode *dir, const char *name, int excl, struct vnode **ret)
+{
+	struct emufs_vnode *ev = dir->vn_data;
+	struct emufs_fs *ef = dir->vn_fs->fs_data;
+	struct emufs_vnode *newguy;
+	u_int32_t handle;
+	int result;
+	int isdir;
+
+	result = emu_open(ev->ev_emu, ev->ev_handle, name, 1, excl, 
+			  &handle, &isdir);
+	if (result) {
+		return result;
+	}
+
+	result = emufs_loadvnode(ef, handle, isdir, &newguy);
+	if (result) {
+		emu_close(ev->ev_emu, handle);
+		return result;
+	}
+
+	*ret = &newguy->ev_v;
+	return 0;
+}
+
+/*
+ * VOP_LOOKUP
+ */
+static
+int
+emufs_lookup(struct vnode *dir, char *pathname, struct vnode **ret)
+{
+	struct emufs_vnode *ev = dir->vn_data;
+	struct emufs_fs *ef = dir->vn_fs->fs_data;
+	struct emufs_vnode *newguy;
+	u_int32_t handle;
+	int result;
+	int isdir;
+
+	result = emu_open(ev->ev_emu, ev->ev_handle, pathname, 0, 0,
+			  &handle, &isdir);
+	if (result) {
+		return result;
+	}
+
+	result = emufs_loadvnode(ef, handle, isdir, &newguy);
+	if (result) {
+		emu_close(ev->ev_emu, handle);
+		return result;
+	}
+
+	*ret = &newguy->ev_v;
+	return 0;
+}
+
+/*
+ * VOP_LOOKPARENT
+ */
+static
+int
+emufs_lookparent(struct vnode *dir, char *pathname, struct vnode **ret,
+		 char *buf, size_t len)
+{
+	char *s;
+
+	s = strrchr(pathname, '/');
+	if (s==NULL) {
+		/* just a last component, no directory part */
+		if (strlen(pathname)+1 > len) {
+			return ENAMETOOLONG;
+		}
+		VOP_INCREF(dir);
+		*ret = dir;
+		strcpy(buf, pathname);
+		return 0;
+	}
+
+	*s = 0;
+	s++;
+	if (strlen(s)+1 > len) {
+		return ENAMETOOLONG;
+	}
+	strcpy(buf, s);
+
+	return emufs_lookup(dir, pathname, ret);
+}
+
+/*
+ * VOP_NAMEFILE
+ */
+static
+int
+emufs_namefile(struct vnode *v, struct uio *uio)
+{
+	struct emufs_vnode *ev = v->vn_data;
+	struct emufs_fs *ef = v->vn_fs->fs_data;
+
+	if (ev == ef->ef_root) {
+		/*
+		 * Root directory - name is empty string
+		 */
+		return 0;
+	}
+
+	(void)uio;
+	
+	return EUNIMP;
+}
+
+//////////////////////////////
+
+/*
+ * Generic routines to return specific errors
+ */
+
+static
+int
+emufs_notdir(void)
+{
+	return ENOTDIR;
+}
+
+static
+int
+emufs_isdir(void)
+{
+	return EISDIR;
+}
+
+static
+int
+emufs_unimp(void)
+{
+	return EUNIMP;
+}
+
+/*
+ * Casting through void * prevents warnings.
+ * All of the vnode ops return int, and it's ok to cast functions that
+ * take args to functions that take no args.
+ */
+#define ISDIR ((void *)emufs_isdir)
+#define NOTDIR ((void *)emufs_notdir)
+#define UNIMP ((void *)emufs_unimp)
+
+/*
+ * Function table for emufs files.
+ */
+static const struct vnode_ops emufs_fileops = {
+	VOP_MAGIC,	/* mark this a valid vnode ops table */
+
+	emufs_open,
+	emufs_close,
+	emufs_reclaim,
+
+	emufs_read,
+	NOTDIR,  /* readlink */
+	NOTDIR,  /* getdirentry */
+	emufs_write,
+	emufs_ioctl,
+	emufs_stat,
+	emufs_file_gettype,
+	emufs_tryseek,
+	emufs_fsync,
+	UNIMP,   /* mmap */
+	emufs_truncate,
+	NOTDIR,  /* namefile */
+
+	NOTDIR,  /* creat */
+	NOTDIR,  /* symlink */
+	NOTDIR,  /* mkdir */
+	NOTDIR,  /* link */
+	NOTDIR,  /* remove */
+	NOTDIR,  /* rmdir */
+	NOTDIR,  /* rename */
+
+	NOTDIR,  /* lookup */
+	NOTDIR,  /* lookparent */
+};
+
+/*
+ * Function table for emufs directories.
+ */
+static const struct vnode_ops emufs_dirops = {
+	VOP_MAGIC,	/* mark this a valid vnode ops table */
+
+	emufs_opendir,
+	emufs_close,
+	emufs_reclaim,
+
+	ISDIR,   /* read */
+	ISDIR,   /* readlink */
+	emufs_getdirentry,
+	ISDIR,   /* write */
+	emufs_ioctl,
+	emufs_stat,
+	emufs_dir_gettype,
+	UNIMP,   /* tryseek */
+	ISDIR,   /* fsync */
+	ISDIR,   /* mmap */
+	ISDIR,   /* truncate */
+	emufs_namefile,
+
+	emufs_creat,
+	UNIMP,   /* symlink */
+	UNIMP,   /* mkdir */
+	UNIMP,   /* link */
+	UNIMP,   /* remove */
+	UNIMP,   /* rmdir */
+	UNIMP,   /* rename */
+
+	emufs_lookup,
+	emufs_lookparent,
+};
+
+/*
+ * Function to load a vnode into memory.
+ */
+static
+int
+emufs_loadvnode(struct emufs_fs *ef, u_int32_t handle, int isdir,
+		struct emufs_vnode **ret)
+{
+	struct emufs_vnode *ev;
+	int i, num, result;
+
+	lock_acquire(ef->ef_emu->e_lock);
+
+	num = array_getnum(ef->ef_vnodes);
+	for (i=0; i<num; i++) {
+		ev = array_getguy(ef->ef_vnodes, i);
+		if (ev->ev_handle==handle) {
+			/* Found */
+
+			VOP_INCREF(&ev->ev_v);
+
+			lock_release(ef->ef_emu->e_lock);
+			*ret = ev;
+			return 0;
+		}
+	}
+
+	/* Didn't have one; create it */
+
+	ev = kmalloc(sizeof(struct emufs_vnode));
+	if (ev==NULL) {
+		lock_release(ef->ef_emu->e_lock);
+		return ENOMEM;
+	}
+
+	ev->ev_emu = ef->ef_emu;
+	ev->ev_handle = handle;
+
+	result = VOP_INIT(&ev->ev_v, isdir ? &emufs_dirops : &emufs_fileops,
+			   &ef->ef_fs, ev);
+	if (result) {
+		lock_release(ef->ef_emu->e_lock);
+		kfree(ev);
+		return result;
+	}
+
+	result = array_add(ef->ef_vnodes, ev);
+	if (result) {
+		lock_release(ef->ef_emu->e_lock);
+		/* note: VOP_KILL undoes VOP_INIT - it does not kfree */
+		VOP_KILL(&ev->ev_v);
+		kfree(ev);
+		return result;
+	}
+
+	lock_release(ef->ef_emu->e_lock);
+
+	*ret = ev;
+	return 0;
+}
+
+//
+////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////
+//
+// filesystem functions 
+//
+
+/*
+ * FSOP_SYNC
+ */
+static
+int
+emufs_sync(struct fs *fs)
+{
+	(void)fs;
+	return 0;
+}
+
+/*
+ * FSOP_GETVOLNAME
+ */
+static
+const char *
+emufs_getvolname(struct fs *fs)
+{
+	/* We don't have a volume name beyond the device name */
+	(void)fs;
+	return NULL;
+}
+
+/*
+ * FSOP_GETROOT
+ */
+static
+struct vnode *
+emufs_getroot(struct fs *fs)
+{
+	struct emufs_fs *ef;
+
+	assert(fs!=NULL);
+
+	ef = fs->fs_data;
+
+	assert(ef!=NULL);
+	assert(ef->ef_root!=NULL);
+
+	VOP_INCREF(&ef->ef_root->ev_v);
+	return &ef->ef_root->ev_v;
+}
+
+/*
+ * FSOP_UNMOUNT
+ */
+static
+int
+emufs_unmount(struct fs *fs)
+{
+	/* Always prohibit unmount, as we're not really "mounted" */
+	(void)fs;
+	return EBUSY;
+}
+
+/*
+ * Routine for "mounting" an emufs - we're not really mounted in the
+ * sense that the VFS understands that term, because we're not
+ * connected to a block device.
+ *
+ * Basically, we just add ourselves to the name list in the VFS layer.
+ */
+static
+int
+emufs_addtovfs(struct emu_softc *sc, const char *devname)
+{
+	struct emufs_fs *ef;
+	int result;
+
+	ef = kmalloc(sizeof(struct emufs_fs));
+	if (ef==NULL) {
+		return ENOMEM;
+	}
+
+	ef->ef_fs.fs_sync = emufs_sync;
+	ef->ef_fs.fs_getvolname = emufs_getvolname;
+	ef->ef_fs.fs_getroot = emufs_getroot;
+	ef->ef_fs.fs_unmount = emufs_unmount;
+	ef->ef_fs.fs_data = ef;
+
+	ef->ef_emu = sc;
+	ef->ef_root = NULL;
+	ef->ef_vnodes = array_create();
+	if (ef->ef_vnodes == NULL) {
+		kfree(ef);
+		return ENOMEM;
+	}
+
+	result = emufs_loadvnode(ef, EMU_ROOTHANDLE, 1, &ef->ef_root);
+	if (result) {
+		kfree(ef);
+		return result;
+	}
+
+	assert(ef->ef_root!=NULL);
+
+	result = vfs_addfs(devname, &ef->ef_fs);
+	if (result) {
+		VOP_DECREF(&ef->ef_root->ev_v);
+		kfree(ef);
+	}
+	return result;
+}
+
+//
+////////////////////////////////////////////////////////////
+
+/*
+ * Config routine called by autoconf stuff.
+ *
+ * Initialize our data, then add ourselves to the VFS layer.
+ *
+ * Note that the config_*() functions are expected not to fail,
+ * so we don't.
+ */
+int
+config_emu(struct emu_softc *sc, int emuno)
+{
+	char name[32];
+
+	sc->e_lock = lock_create("emufs-lock");
+	if (sc->e_lock == NULL) {
+		return ENOMEM;
+	}
+	sc->e_sem = sem_create("emufs-sem", 0);
+	if (sc->e_sem == NULL) {
+		lock_destroy(sc->e_lock);
+		sc->e_lock = NULL;
+		return ENOMEM;
+	}
+	sc->e_iobuf = bus_map_area(sc->e_busdata, sc->e_buspos, EMU_BUFFER);
+
+	snprintf(name, sizeof(name), "emu%d", emuno);
+
+	return emufs_addtovfs(sc, name);
+}
diff --git a/os161-1.10/kern/dev/lamebus/emu.h b/os161-1.10/kern/dev/lamebus/emu.h
new file mode 100644
index 0000000..95cb33b
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/emu.h
@@ -0,0 +1,31 @@
+#ifndef _LAMEBUS_EMU_H_
+#define _LAMEBUS_EMU_H_
+
+#define EMU_MAXIO       16384
+#define EMU_ROOTHANDLE  0
+
+/*
+ * The per-device data used by the emufs device driver.
+ * (Note that this is only a small portion of its actual data;
+ * all the filesystem stuff goes elsewhere.
+ */
+
+struct emu_softc {
+	/* Initialized by lower-level attach code */
+	void *e_busdata;
+	u_int32_t e_buspos;
+	int e_unit;
+
+	/* Initialized by config_emu() */
+	struct lock *e_lock;
+	struct semaphore *e_sem;
+	void *e_iobuf;
+
+	/* Written by the interrupt handler */
+	u_int32_t e_result;
+};
+
+/* Functions called by lower-level drivers */
+void emu_irq(/*struct emu_softc*/ void *);
+
+#endif /* _LAMEBUS_EMU_H_ */
diff --git a/os161-1.10/kern/dev/lamebus/emu_att.c b/os161-1.10/kern/dev/lamebus/emu_att.c
new file mode 100644
index 0000000..05acef3
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/emu_att.c
@@ -0,0 +1,39 @@
+/*
+ * Code for probe/attach of the emu device to lamebus.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <lamebus/lamebus.h>
+#include <lamebus/emu.h>
+#include "autoconf.h"
+
+/* Lowest revision we support */
+#define LOW_VERSION   1
+/* Highest revision we support */
+#define HIGH_VERSION  1
+
+struct emu_softc *
+attach_emu_to_lamebus(int emuno, struct lamebus_softc *sc)
+{
+	struct emu_softc *es;
+	int slot = lamebus_probe(sc, LB_VENDOR_CS161, LBCS161_EMUFS,
+				 LOW_VERSION, HIGH_VERSION);
+	if (slot < 0) {
+		return NULL;
+	}
+
+	es = kmalloc(sizeof(struct emu_softc));
+	if (es==NULL) {
+		return NULL;
+	}
+
+	es->e_busdata = sc;
+	es->e_buspos = slot;
+	es->e_unit = emuno;
+
+	lamebus_mark(sc, slot);
+	lamebus_attach_interrupt(sc, slot, es, emu_irq);
+
+	return es;
+}
diff --git a/os161-1.10/kern/dev/lamebus/lamebus.c b/os161-1.10/kern/dev/lamebus/lamebus.c
new file mode 100644
index 0000000..7c195df
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lamebus.c
@@ -0,0 +1,434 @@
+/*
+ * Machine-independent LAMEbus code.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <machine/spl.h>
+#include <lamebus/lamebus.h>
+
+/* Register offsets within each config region */
+#define CFGREG_VID   0    /* Vendor ID */
+#define CFGREG_DID   4    /* Device ID */
+#define CFGREG_DRL   8    /* Device Revision Level */
+
+/* LAMEbus controller private registers (offsets within its config region) */
+#define CTLREG_RAMSZ    0x200
+#define CTLREG_IRQS     0x204
+#define CTLREG_PWR      0x208
+
+
+/*
+ * Read a config register for the given slot.
+ */
+static
+inline
+u_int32_t
+read_cfg_register(struct lamebus_softc *lb, int slot, u_int32_t offset)
+{
+	/* Note that lb might be NULL on some platforms in some contexts. */
+	offset += LB_CONFIG_SIZE*slot;
+	return lamebus_read_register(lb, LB_CONTROLLER_SLOT, offset);
+}
+
+/*
+ * Write a config register for a given slot.
+ */
+static
+inline
+void
+write_cfg_register(struct lamebus_softc *lb, int slot, u_int32_t offset,
+		   u_int32_t val)
+{
+	offset += LB_CONFIG_SIZE*slot;
+	lamebus_write_register(lb, LB_CONTROLLER_SLOT, offset, val);
+}
+
+/*
+ * Read one of the bus controller's registers.
+ */
+static
+inline
+u_int32_t
+read_ctl_register(struct lamebus_softc *lb, u_int32_t offset)
+{
+	/* Note that lb might be NULL on some platforms in some contexts. */
+	return read_cfg_register(lb, LB_CONTROLLER_SLOT, offset);
+}
+
+/*
+ * Write one of the bus controller's registers.
+ */
+static
+inline
+void
+write_ctl_register(struct lamebus_softc *lb, u_int32_t offset, u_int32_t val)
+{
+	write_cfg_register(lb, LB_CONTROLLER_SLOT, offset, val);
+}
+
+/*
+ * Probe function.
+ *
+ * Given a LAMEbus, look for a device that's not already been marked
+ * in use, has the specified IDs, and has a device revision level in
+ * the specified range (which is inclusive on both ends.)
+ *
+ * Returns the slot number found (0-31) or -1 if nothing suitable was
+ * found.
+ */
+
+int
+lamebus_probe(struct lamebus_softc *sc,
+	      u_int32_t vendorid, u_int32_t deviceid,
+	      u_int32_t lowver, u_int32_t highver)
+{
+	int slot;
+	u_int32_t val;
+	int spl;
+
+	/*
+	 * Because the slot information in sc is used when dispatching
+	 * interrupts, disable interrupts while working with it.
+	 */
+
+	spl = splhigh();
+
+	for (slot=0; slot<LB_NSLOTS; slot++) {
+		if (sc->ls_slotsinuse & (1<<slot)) {
+			/* Slot already in use; skip */
+			continue;
+		}
+
+		val = read_cfg_register(sc, slot, CFGREG_VID);
+		if (val!=vendorid) {
+			/* Wrong vendor id */
+			continue;
+		}
+
+		val = read_cfg_register(sc, slot, CFGREG_DID);
+		if (val != deviceid) {
+			/* Wrong device id */
+			continue;
+		}
+
+		val = read_cfg_register(sc, slot, CFGREG_DRL);
+		if (val < lowver || val > highver) {
+			/* Unsupported device revision */
+			continue;
+		}
+
+		/* Found something */
+
+		splx(spl);
+		return slot;
+	}
+
+	/* Found nothing */
+
+	splx(spl);
+	return -1;
+}
+
+/*
+ * Mark that a slot is in use.
+ * This prevents the probe routine from returning the same device over
+ * and over again.
+ */
+void
+lamebus_mark(struct lamebus_softc *sc, int slot)
+{
+	int spl;
+
+	u_int32_t mask = ((u_int32_t)1) << slot;
+	assert(slot>=0 && slot < LB_NSLOTS);
+
+	spl = splhigh();
+
+	if ((sc->ls_slotsinuse & mask)!=0) {
+		panic("lamebus_mark: slot %d already in use\n", slot);
+	}
+
+	sc->ls_slotsinuse |= mask;
+
+	splx(spl);
+}
+
+/*
+ * Mark that a slot is no longer in use.
+ */
+void
+lamebus_unmark(struct lamebus_softc *sc, int slot)
+{
+	int spl;
+
+	u_int32_t mask = ((u_int32_t)1) << slot;
+	assert(slot>=0 && slot < LB_NSLOTS);
+
+	spl = splhigh();
+
+	if ((sc->ls_slotsinuse & mask)==0) {
+		panic("lamebus_mark: slot %d not marked in use\n", slot);
+	}
+
+	sc->ls_slotsinuse &= ~mask;
+
+	splx(spl);
+}
+
+/*
+ * Register a function (and a device context pointer) to be called
+ * when a particular slot signals an interrupt.
+ */
+void
+lamebus_attach_interrupt(struct lamebus_softc *sc, int slot,
+			 void *devdata,
+			 void (*irqfunc)(void *devdata))
+{
+	int spl;
+
+	u_int32_t mask = ((u_int32_t)1) << slot;
+	assert(slot>=0 && slot < LB_NSLOTS);
+
+	spl = splhigh();
+
+	if ((sc->ls_slotsinuse & mask)==0) {
+		panic("lamebus_attach_interrupt: slot %d not marked in use\n",
+		      slot);
+	}
+
+	assert(sc->ls_devdata[slot]==NULL);
+	assert(sc->ls_irqfuncs[slot]==NULL);
+
+	sc->ls_devdata[slot] = devdata;
+	sc->ls_irqfuncs[slot] = irqfunc;
+	
+	splx(spl);
+}
+
+/*
+ * Unregister a function that was being called when a particular slot
+ * signaled an interrupt.
+ */
+void
+lamebus_detach_interrupt(struct lamebus_softc *sc, int slot)
+{
+	int spl;
+
+	u_int32_t mask = ((u_int32_t)1) << slot;
+	assert(slot>=0 && slot < LB_NSLOTS);
+
+	spl = splhigh();
+
+	if ((sc->ls_slotsinuse & mask)==0) {
+		panic("lamebus_detach_interrupt: slot %d not marked in use\n",
+		      slot);
+	}
+
+	assert(sc->ls_irqfuncs[slot]!=NULL);
+
+	sc->ls_devdata[slot] = NULL;
+	sc->ls_irqfuncs[slot] = NULL;
+	
+	splx(spl);
+}
+
+
+/*
+ * LAMEbus interrupt handling function. (Machine-independent!)
+ */
+void
+lamebus_interrupt(struct lamebus_softc *lamebus)
+{
+	/*
+	 * Note that despite the fact that "spl" stands for "set
+	 * priority level", we don't actually support interrupt
+	 * priorities. When an interrupt happens, we look through the
+	 * slots to find the first interrupting device and call its
+	 * interrupt routine, no matter what that device is.
+	 *
+	 * Note that the entire LAMEbus uses only one on-cpu interrupt line. 
+	 * Thus, we do not use any on-cpu interrupt priority system either.
+	 */
+
+	int slot;
+	u_int32_t mask;
+	u_int32_t irqs;
+
+	/* For keeping track of how many bogus things happen in a row. */
+	static int duds=0;
+	int duds_this_time=0;
+
+	/* spl had better be raised. */
+	assert(curspl>0);
+
+	/* and we better have a valid bus instance. */
+	assert(lamebus!=NULL);
+
+	/*
+	 * Read the LAMEbus controller register that tells us which
+	 * slots are asserting an interrupt condition.
+	 */
+	irqs = read_ctl_register(lamebus, CTLREG_IRQS);
+
+	if (irqs==0) {
+		/*
+		 * Huh? None of them? Must be a glitch.
+		 */
+		kprintf("lamebus: stray interrupt\n");
+		duds++;
+		duds_this_time++;
+
+		/*
+		 * We could just return now, but instead we'll
+		 * continue ahead. Because irqs==0, nothing in the
+		 * loop will execute, and passing through it gets us
+		 * to the code that checks how many duds we've
+		 * seen. This is important, because we just might get
+		 * a stray interrupt that latches itself on. If that
+		 * happens, we're pretty much toast, but it's better
+		 * to panic and hopefully reset the system than to
+		 * loop forever printing "stray interrupt".
+		 */
+		return;
+	}
+
+	/*
+	 * Go through the bits in the value we got back to see which
+	 * ones are set.
+	 */
+
+	for (mask=1, slot=0; slot<LB_NSLOTS; mask<<=1, slot++) {
+		if ((irqs & mask)==0) {
+			/* Nope. */
+			continue;
+		}
+
+		/*
+		 * This slot is signalling an interrupt.
+		 */
+			
+		if ((lamebus->ls_slotsinuse & mask)==0) {
+			/*
+			 * No device driver is using this slot.
+			 */
+			duds++;
+			duds_this_time++;
+			continue;
+		}
+
+		if (lamebus->ls_irqfuncs[slot]==NULL) {
+			/*
+			 * The device driver hasn't installed an interrupt
+			 * handler.
+			 */
+			duds++;
+			duds_this_time++;
+			continue;
+		}
+
+		/*
+		 * Call the interrupt handler.
+		 * Note that interrupts are off here so it's ok to access
+		 * the global lamebus structure.
+		 */
+		lamebus->ls_irqfuncs[slot](lamebus->ls_devdata[slot]);
+
+		/*
+		 * Reload the mask of pending IRQs - if we just called
+		 * hardclock, it might have changed under us.
+		 */
+
+		irqs = read_ctl_register(lamebus, CTLREG_IRQS);
+	}
+
+
+	/*
+	 * If we get interrupts for a slot with no driver or no
+	 * interrupt handler, it's fairly serious. Because LAMEbus
+	 * uses level-triggered interrupts, if we don't shut off the
+	 * condition, we'll keep getting interrupted continuously and
+	 * the system will make no progress. But we don't know how to
+	 * do that if there's no driver or no interrupt handler.
+	 *
+	 * So, if we get too many dud interrupts, panic, since it's 
+	 * better to panic and reset than to hang.
+	 *
+	 * If we get through here without seeing any duds this time,
+	 * the condition, whatever it was, has gone away. It might be
+	 * some stupid device we don't have a driver for, or it might
+	 * have been an electrical transient. In any case, warn and
+	 * clear the dud count.
+	 */
+
+	if (duds_this_time==0 && duds>0) {
+		kprintf("lamebus: %d dud interrupts\n", duds);
+		duds = 0;
+	}
+
+	if (duds > 10000) {
+		panic("lamebus: too many (%d) dud interrupts\n", duds);
+	}
+}
+
+/*
+ * Have the bus controller power the system off.
+ */
+void
+lamebus_poweroff(struct lamebus_softc *lamebus)
+{
+	/*
+	 * Write 0 to the power register to shut the system off.
+	 */
+
+	splhigh();
+	write_ctl_register(lamebus, CTLREG_PWR, 0);
+
+	/* The power doesn't go off instantly... halt the cpu. */
+	cpu_halt();
+}
+
+/*
+ * Ask the bus controller how much memory we have.
+ */
+u_int32_t
+lamebus_ramsize(void)
+{
+	/*
+	 * Note that this has to work before bus initialization.
+	 * On machines where lamebus_read_register doesn't work
+	 * before bus initialization, this function can't be used
+	 * for initial RAM size lookup.
+	 */
+
+	return read_ctl_register(NULL, CTLREG_RAMSZ);
+}
+
+/*
+ * Initial setup.
+ * Should be called from machdep_dev_bootstrap().
+ */
+struct lamebus_softc *
+lamebus_init(void)
+{
+	struct lamebus_softc *lamebus;
+	int i;
+
+	/* Allocate space for lamebus data */
+	lamebus = kmalloc(sizeof(struct lamebus_softc));
+	if (lamebus==NULL) {
+		panic("lamebus_init: Out of memory\n");
+	}
+
+	/*
+	 * Initialize the LAMEbus data structure.
+	 */
+	lamebus->ls_slotsinuse = 1 << LB_CONTROLLER_SLOT;
+
+	for (i=0; i<LB_NSLOTS; i++) {
+		lamebus->ls_devdata[i] = NULL;
+		lamebus->ls_irqfuncs[i] = NULL;
+	}
+
+	return lamebus;
+}
diff --git a/os161-1.10/kern/dev/lamebus/lamebus.h b/os161-1.10/kern/dev/lamebus/lamebus.h
new file mode 100644
index 0000000..710f60f
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lamebus.h
@@ -0,0 +1,114 @@
+#ifndef _LAMEBUS_H_
+#define _LAMEBUS_H_
+
+/*
+ * Machine-independent LAMEbus definitions.
+ */
+
+
+/* Vendors */
+#define LB_VENDOR_CS161      1
+
+/* CS161 devices */
+#define LBCS161_BUSCTL       1
+#define LBCS161_TIMER        2
+#define LBCS161_DISK         3
+#define LBCS161_SERIAL       4
+#define LBCS161_SCREEN       5
+#define LBCS161_NET          6
+#define LBCS161_EMUFS        7
+#define LBCS161_TRACE        8
+#define LBCS161_RANDOM       9
+
+/* LAMEbus controller always goes in slot 31 */
+#define LB_CONTROLLER_SLOT   31
+
+/* Number of slots */
+#define LB_NSLOTS            32
+
+/* LAMEbus controller per-slot config space */
+#define LB_CONFIG_SIZE       1024
+
+/* LAMEbus mapping size per slot */
+#define LB_SLOT_SIZE         65536
+
+/* Pointer to kind of function called on interrupt */
+typedef void (*lb_irqfunc)(void *devdata);
+
+/*
+ * Driver data
+ */
+struct lamebus_softc {
+	/* Accessed from interrupts; synchronized via spl */ 
+	u_int32_t    ls_slotsinuse;
+	void        *ls_devdata[LB_NSLOTS];
+	lb_irqfunc   ls_irqfuncs[LB_NSLOTS];
+};
+
+/*
+ * Allocate and set up a lamebus_softc for the system.
+ */
+struct lamebus_softc *lamebus_init(void);
+
+/*
+ * Look for a not-in-use slot containing a device whose vendor and device 
+ * ids match those provided, and whose version is in the range between
+ * lowver and highver, inclusive.
+ *
+ * Returns a slot number (0-31) or -1 if no such device is found.
+ */
+int lamebus_probe(struct lamebus_softc *, 
+		  u_int32_t vendorid, u_int32_t deviceid, 
+		  u_int32_t lowver, u_int32_t highver);
+
+/*
+ * Mark a slot in-use (that is, has a device driver attached to it),
+ * or unmark it. It is a fatal error to mark a slot that is already 
+ * in use, or unmark a slot that is not in use.
+ */
+void lamebus_mark(struct lamebus_softc *, int slot);
+void lamebus_unmark(struct lamebus_softc *, int slot);
+
+/*
+ * Attach to an interrupt.
+ */
+void lamebus_attach_interrupt(struct lamebus_softc *, int slot,
+			      void *devdata, 
+			      void (*irqfunc)(void *devdata));
+/*
+ * Detach from interrupt.
+ */
+void lamebus_detach_interrupt(struct lamebus_softc *, int slot);
+
+/*
+ * Function to call to handle a LAMEbus interrupt.
+ */
+void lamebus_interrupt(struct lamebus_softc *);
+
+/*
+ * Have the LAMEbus controller power the system off.
+ */
+void lamebus_poweroff(struct lamebus_softc *);
+
+/*
+ * Ask the bus controller how much memory we have.
+ */
+u_int32_t lamebus_ramsize(void);
+
+/*
+ * Read/write 32-bit register at offset OFFSET within slot SLOT.
+ * (Machine dependent.)
+ */
+u_int32_t lamebus_read_register(struct lamebus_softc *, int slot,
+				u_int32_t offset);
+void lamebus_write_register(struct lamebus_softc *, int slot,
+			    u_int32_t offset, u_int32_t val);
+
+/*
+ * Map a buffer that starts at offset OFFSET within slot SLOT.
+ */
+void *lamebus_map_area(struct lamebus_softc *, int slot,
+		       u_int32_t offset);
+
+
+#endif /* _LAMEBUS_H_ */
diff --git a/os161-1.10/kern/dev/lamebus/lhd.c b/os161-1.10/kern/dev/lamebus/lhd.c
new file mode 100644
index 0000000..d3cb515
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lhd.c
@@ -0,0 +1,287 @@
+/*
+ * LAMEbus hard disk (lhd) driver.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <kern/errno.h>
+#include <machine/bus.h>
+#include <uio.h>
+#include <vfs.h>
+#include <lamebus/lhd.h>
+#include "autoconf.h"
+
+/* Registers (offsets within slot) */
+#define LHD_REG_NSECT   0   /* Number of sectors */
+#define LHD_REG_STAT    4   /* Status */
+#define LHD_REG_SECT    8   /* Sector for I/O */
+#define LHD_REG_RPM     12  /* Disk rotation speed (revs per minute) */
+
+/* Status codes */
+#define LHD_IDLE        0   /* Device idle */
+#define LHD_WORKING     1   /* Operation in progress */
+#define LHD_OK          4   /* Operation succeeded */
+#define LHD_INVSECT     12  /* Invalid sector requested */
+#define LHD_MEDIA       20  /* Media error */
+#define LHD_ISWRITE     2   /* OR with above: I/O is a write */
+#define LHD_STATEMASK   0x1d  /* mask for masking out LHD_ISWRITE */
+
+/* Buffer (offset within slot)  */
+#define LHD_BUFFER      32768
+
+/*
+ * Shortcut for reading a register.
+ */
+static
+inline
+u_int32_t lhd_rdreg(struct lhd_softc *lh, u_int32_t reg)
+{
+	return bus_read_register(lh->lh_busdata, lh->lh_buspos, reg);
+}
+
+/*
+ * Shortcut for writing a register.
+ */
+static
+inline
+void lhd_wreg(struct lhd_softc *lh, u_int32_t reg, u_int32_t val)
+{
+	bus_write_register(lh->lh_busdata, lh->lh_buspos, reg, val);
+}
+
+/*
+ * Convert a result code from the hardware to an errno value.
+ */
+static
+int lhd_code_to_errno(struct lhd_softc *lh, int code)
+{
+	switch (code & LHD_STATEMASK) {
+	    case LHD_OK: return 0;
+	    case LHD_INVSECT: return EINVAL;
+	    case LHD_MEDIA: return EIO;
+	}
+	kprintf("lhd%d: Unknown result code %d\n", lh->lh_unit, code);
+	return EAGAIN;
+}
+
+/*
+ * Record that an I/O has completed: save the result and poke the
+ * completion semaphore.
+ */
+static
+void
+lhd_iodone(struct lhd_softc *lh, int err)
+{
+	lh->lh_result = err;
+	V(lh->lh_done);
+}
+
+/*
+ * Interrupt handler for lhd.
+ * Read the status register; if an operation finished, clear the status
+ * register and report completion.
+ */
+void
+lhd_irq(void *vlh)
+{
+	struct lhd_softc *lh = vlh;
+	u_int32_t val;
+	
+	val = lhd_rdreg(lh, LHD_REG_STAT);
+
+	switch (val & LHD_STATEMASK) {
+	    case LHD_IDLE:
+	    case LHD_WORKING:
+		break;
+	    case LHD_OK:
+	    case LHD_INVSECT:
+	    case LHD_MEDIA:
+		lhd_wreg(lh, LHD_REG_STAT, 0);
+		lhd_iodone(lh, lhd_code_to_errno(lh, val));
+		break;
+	}
+}
+
+/*
+ * Function called when we are open()'d.
+ */
+static
+int
+lhd_open(struct device *d, int openflags)
+{
+	/*
+	 * Don't need to do anything.
+	 */
+	(void)d;
+	(void)openflags;
+
+	return 0;
+}
+
+/*
+ * Function called when we are close()'d.
+ */
+static
+int
+lhd_close(struct device *d)
+{
+	/*
+	 * Don't need to do anything.
+	 */
+	(void)d;
+
+	return 0;
+}
+
+/*
+ * Function for handling ioctls.
+ */
+static
+int
+lhd_ioctl(struct device *d, int op, userptr_t data)
+{
+	/*
+	 * We don't support any ioctls.
+	 */
+	(void)d;
+	(void)op;
+	(void)data;
+	return EIOCTL;
+}
+
+#if 0
+/*
+ * Reset the device.
+ * This could be used, for instance, on timeout, if you implement suitable
+ * facilities.
+ */
+static
+void
+lhd_reset(struct lhd_softc *lh)
+{
+	lhd_wreg(lh, LHD_REG_STAT, 0);
+}
+#endif
+
+/*
+ * I/O function (for both reads and writes)
+ */
+static
+int
+lhd_io(struct device *d, struct uio *uio)
+{
+	struct lhd_softc *lh = d->d_data;
+
+	u_int32_t sector = uio->uio_offset / LHD_SECTSIZE;
+	u_int32_t sectoff = uio->uio_offset % LHD_SECTSIZE;
+	u_int32_t len = uio->uio_resid / LHD_SECTSIZE;
+	u_int32_t lenoff = uio->uio_resid % LHD_SECTSIZE;
+	u_int32_t i;
+	u_int32_t statval = LHD_WORKING;
+	int result;
+
+	/* Don't allow I/O that isn't sector-aligned. */
+	if (sectoff != 0 || lenoff != 0) {
+		return EINVAL;
+	}
+
+	/* Don't allow I/O past the end of the disk. */
+	if (sector+len > lh->lh_dev.d_blocks) {
+		return EINVAL;
+	}
+
+	/* Set up the value to write into the status register. */
+	if (uio->uio_rw==UIO_WRITE) {
+		statval |= LHD_ISWRITE;
+	}
+
+	/* Loop over all the sectors we were asked to do. */
+	for (i=0; i<len; i++) {
+
+		/* Wait until nobody else is using the device. */
+		P(lh->lh_clear);
+
+		/*
+		 * Are we writing? If so, transfer the data to the
+		 * on-card buffer.
+		 */
+		if (uio->uio_rw == UIO_WRITE) {
+			result = uiomove(lh->lh_buf, LHD_SECTSIZE, uio);
+			if (result) {
+				V(lh->lh_clear);
+				return result;
+			}
+		}
+
+		/* Tell it what sector we want... */
+		lhd_wreg(lh, LHD_REG_SECT, sector+i);
+
+		/* and start the operation. */
+		lhd_wreg(lh, LHD_REG_STAT, statval);
+
+		/* Now wait until the interrupt handler tells us we're done. */
+		P(lh->lh_done);
+
+		/* Get the result value saved by the interrupt handler. */
+		result = lh->lh_result;
+
+		/*
+		 * Are we reading? If so, and if we succeeded,
+		 * transfer the data out of the on-card buffer.
+		 */
+		if (result==0 && uio->uio_rw==UIO_READ) {
+			result = uiomove(lh->lh_buf, LHD_SECTSIZE, uio);
+		}
+
+		/* Tell another thread it's cleared to go ahead. */
+		V(lh->lh_clear);
+
+		/* If we failed, return the error. */
+		if (result) {
+			return result;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Setup routine called by autoconf.c when an lhd is found.
+ */
+int
+config_lhd(struct lhd_softc *lh, int lhdno)
+{
+	char name[32];
+
+	/* Figure out what our name is. */
+	snprintf(name, sizeof(name), "lhd%d", lhdno);
+
+	/* Get a pointer to the on-chip buffer. */
+	lh->lh_buf = bus_map_area(lh->lh_busdata, lh->lh_buspos, LHD_BUFFER);
+
+	/* Create the semaphores. */
+	lh->lh_clear = sem_create("lhd-clear", 1);
+	if (lh->lh_clear == NULL) {
+		return ENOMEM;
+	}
+	lh->lh_done = sem_create("lhd-done", 0);
+	if (lh->lh_done == NULL) {
+		sem_destroy(lh->lh_clear);
+		lh->lh_clear = NULL;
+		return ENOMEM;
+	}
+
+	/* Set up the VFS device structure. */
+	lh->lh_dev.d_open = lhd_open;
+	lh->lh_dev.d_close = lhd_close;
+	lh->lh_dev.d_io = lhd_io;
+	lh->lh_dev.d_ioctl = lhd_ioctl;
+	lh->lh_dev.d_blocks = bus_read_register(lh->lh_busdata, lh->lh_buspos,
+						LHD_REG_NSECT);
+	lh->lh_dev.d_blocksize = LHD_SECTSIZE;
+	lh->lh_dev.d_data = lh;
+
+	/* Add the VFS device structure to the VFS device list. */
+	return vfs_adddev(name, &lh->lh_dev, 1);
+}
diff --git a/os161-1.10/kern/dev/lamebus/lhd.h b/os161-1.10/kern/dev/lamebus/lhd.h
new file mode 100644
index 0000000..4c17491
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lhd.h
@@ -0,0 +1,35 @@
+#ifndef _LAMEBUS_LHD_H_
+#define _LAMEBUS_LHD_H_
+
+#include <dev.h>
+
+/*
+ * Our sector size
+ */
+#define LHD_SECTSIZE  512
+
+/*
+ * Hardware device data associated with lhd (LAMEbus hard disk)
+ */
+struct lhd_softc {
+	/* Initialized by lower-level attach code */
+	void *lh_busdata;		/* The bus we're on */ 
+	u_int32_t lh_buspos;		/* Our slot on that bus */
+	int lh_unit;			/* What number lhd we are */
+
+	/*
+	 * Initialized by config_lhd 
+	 */
+
+	void *lh_buf;			/* Pointer to on-card I/O buffer */
+	int lh_result;			/* Result from I/O operation */
+	struct semaphore *lh_clear;	/* Synchronization */
+	struct semaphore *lh_done;
+
+	struct device lh_dev;		/* VFS device structure */
+};
+
+/* Functions called by lower-level drivers */
+void lhd_irq(/*struct lhd_softc*/ void *);	/* Interrupt handler */
+
+#endif /* _LAMEBUS_LHD_H_ */
diff --git a/os161-1.10/kern/dev/lamebus/lhd_att.c b/os161-1.10/kern/dev/lamebus/lhd_att.c
new file mode 100644
index 0000000..97bf308
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lhd_att.c
@@ -0,0 +1,42 @@
+/*
+ * Code for probe/attach of lhd to LAMEbus.
+ */
+#include <types.h>
+#include <lib.h>
+#include <lamebus/lamebus.h>
+#include <lamebus/lhd.h>
+#include "autoconf.h"
+
+/* Lowest revision we support */
+#define LOW_VERSION   2
+/* Highest revision we support */
+#define HIGH_VERSION  2
+
+struct lhd_softc *
+attach_lhd_to_lamebus(int lhdno, struct lamebus_softc *sc)
+{
+	struct lhd_softc *lh;
+	int slot = lamebus_probe(sc, LB_VENDOR_CS161, LBCS161_DISK,
+				 LOW_VERSION, HIGH_VERSION);
+	if (slot < 0) {
+		/* None found */
+		return NULL;
+	}
+
+	lh = kmalloc(sizeof(struct lhd_softc));
+	if (lh==NULL) {
+		/* Out of memory */
+		return NULL;
+	}
+
+	/* Record what the lhd is attached to */
+	lh->lh_busdata = sc;
+	lh->lh_buspos = slot;
+	lh->lh_unit = lhdno;
+
+	/* Mark the slot in use and collect interrupts */
+	lamebus_mark(sc, slot);
+	lamebus_attach_interrupt(sc, slot, lh, lhd_irq);
+
+	return lh;
+}
diff --git a/os161-1.10/kern/dev/lamebus/lnet.c b/os161-1.10/kern/dev/lamebus/lnet.c
new file mode 100644
index 0000000..b8cf0e1
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lnet.c
@@ -0,0 +1,16 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include "autoconf.h"
+
+int
+config_lnet(struct lnet_softc *sc, int lnetno)
+{
+	(void)sc;
+	
+	kprintf("lnet%d: No network support in system\n", lnetno);
+
+	return ENODEV;
+}
+
+
diff --git a/os161-1.10/kern/dev/lamebus/lnet_att.c b/os161-1.10/kern/dev/lamebus/lnet_att.c
new file mode 100644
index 0000000..1b7d0f0
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lnet_att.c
@@ -0,0 +1,23 @@
+#include <types.h>
+#include <lib.h>
+#include <lamebus/lamebus.h>
+#include "autoconf.h"
+
+/* Lowest revision we support */
+#define LOW_VERSION   1
+/* Highest revision we support */
+#define HIGH_VERSION  1
+
+struct lnet_softc *
+attach_lnet_to_lamebus(int lnetno, struct lamebus_softc *sc)
+{
+	int slot = lamebus_probe(sc, LB_VENDOR_CS161, LBCS161_NET,
+				 LOW_VERSION, HIGH_VERSION);
+	if (slot < 0) {
+		return NULL;
+	}
+
+	kprintf("lnet%d: No network support in system\n", lnetno);
+
+	return NULL;
+}
diff --git a/os161-1.10/kern/dev/lamebus/lrandom.c b/os161-1.10/kern/dev/lamebus/lrandom.c
new file mode 100644
index 0000000..ff26020
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lrandom.c
@@ -0,0 +1,59 @@
+/*
+ * Driver for LAMEbus random generator card
+ */
+#include <types.h>
+#include <lib.h>
+#include <uio.h>
+#include <machine/bus.h>
+#include <lamebus/lrandom.h>
+#include "autoconf.h"
+
+/* Registers (offsets within slot) */
+#define LR_REG_RAND   0     /* random register */
+
+/* Constants */
+#define LR_RANDMAX  0xffffffff
+
+int
+config_lrandom(struct lrandom_softc *lr, int lrandomno)
+{
+	(void)lrandomno;
+	(void)lr;
+	return 0;
+}
+
+u_int32_t
+lrandom_random(void *devdata)
+{
+	struct lrandom_softc *lr = devdata;
+	return bus_read_register(lr->lr_bus, lr->lr_buspos, LR_REG_RAND);
+}
+
+u_int32_t
+lrandom_randmax(void *devdata)
+{
+	(void)devdata;
+	return LR_RANDMAX;
+}
+
+int
+lrandom_read(void *devdata, struct uio *uio)
+{
+	struct lrandom_softc *lr = devdata;
+	int result;
+	union {
+		u_int32_t val;
+		char buf[sizeof(u_int32_t)];
+	} u;
+
+	while (uio->uio_resid > 0) {
+		u.val = bus_read_register(lr->lr_bus, lr->lr_buspos, 
+					  LR_REG_RAND);
+		result = uiomove(u.buf, sizeof(u.buf), uio);
+		if (result) {
+			return result;
+		}
+	}
+	
+	return 0;
+}
diff --git a/os161-1.10/kern/dev/lamebus/lrandom.h b/os161-1.10/kern/dev/lamebus/lrandom.h
new file mode 100644
index 0000000..5991f6a
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lrandom.h
@@ -0,0 +1,17 @@
+#ifndef _LAMEBUS_LRANDOM_H_
+#define _LAMEBUS_LRANDOM_H_
+
+struct uio;
+
+struct lrandom_softc {
+	/* Initialized by lower-level attach routine */
+	void *lr_bus;
+	u_int32_t lr_buspos;
+};
+
+/* Functions called by higher-level drivers */
+u_int32_t lrandom_random(/*struct lrandom_softc*/ void *devdata);
+u_int32_t lrandom_randmax(/*struct lrandom_softc*/ void *devdata);
+int lrandom_read(/*struct lrandom_softc*/ void *, struct uio *);
+
+#endif /* _LAMEBUS_LRANDOM_H_ */
diff --git a/os161-1.10/kern/dev/lamebus/lrandom_att.c b/os161-1.10/kern/dev/lamebus/lrandom_att.c
new file mode 100644
index 0000000..63f5de9
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lrandom_att.c
@@ -0,0 +1,35 @@
+#include <types.h>
+#include <lib.h>
+#include <lamebus/lamebus.h>
+#include <lamebus/lrandom.h>
+#include "autoconf.h"
+
+/* Lowest revision we support */
+#define LOW_VERSION   1
+/* Highest revision we support */
+#define HIGH_VERSION  1
+
+struct lrandom_softc *
+attach_lrandom_to_lamebus(int lrandomno, struct lamebus_softc *sc)
+{
+	struct lrandom_softc *lr;
+	int slot = lamebus_probe(sc, LB_VENDOR_CS161, LBCS161_RANDOM,
+				 LOW_VERSION, HIGH_VERSION);
+	if (slot < 0) {
+		return NULL;
+	}
+
+	lr = kmalloc(sizeof(struct lrandom_softc));
+	if (lr==NULL) {
+		return NULL;
+	}
+
+	(void)lrandomno;  // unused
+
+	lr->lr_bus = sc;
+	lr->lr_buspos = slot;
+
+	lamebus_mark(sc, slot);
+
+	return lr;
+}
diff --git a/os161-1.10/kern/dev/lamebus/lscreen.c b/os161-1.10/kern/dev/lamebus/lscreen.c
new file mode 100644
index 0000000..b602af6
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lscreen.c
@@ -0,0 +1,184 @@
+/*
+ * Driver for full-screen console.
+ *
+ * As of this writing the full-screen console is not supported in
+ * System/161, so this driver is untested and probably broken.
+ */
+#include <types.h>
+#include <lib.h>
+#include <machine/bus.h>
+#include <machine/spl.h>
+#include <lamebus/lscreen.h>
+#include "autoconf.h"
+
+/* Registers (offsets within slot) */
+#define LSCR_REG_POSN    0   /* Cursor position */
+#define LSCR_REG_SIZE    4   /* Display size */
+#define LSCR_REG_CHAR    8   /* Character in */
+#define LSCR_REG_RIRQ    12  /* Read interrupt status */
+
+/* Bits in the IRQ registers */
+#define LSCR_IRQ_ENABLE  1
+#define LSCR_IRQ_ACTIVE  2
+
+/* Offset within slot of screen buffer */
+#define LSCR_SCREEN      32768
+
+/* Convert a 32-bit X/Y pair to X and Y coordinates. */ 
+static
+inline
+void
+splitxy(u_int32_t xy, unsigned *x, unsigned *y)
+{
+	*x = xy >> 16;
+	*y = xy & 0xffff;
+}
+
+/* Convert X and Y coordinates to a single 32-bit value. */
+static
+inline
+u_int32_t
+mergexy(unsigned x, unsigned y)
+{
+	u_int32_t val = x;
+	return (val << 16) | y;
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Interrupt handler.
+ */
+void
+lscreen_irq(void *vsc)
+{
+	struct lscreen_softc *sc = vsc;
+	u_int32_t ch, x;
+
+	assert(curspl>0);
+	x = bus_read_register(sc->ls_busdata, sc->ls_buspos, LSCR_REG_RIRQ);
+	if (x & LSCR_IRQ_ACTIVE) {
+		ch = bus_read_register(sc->ls_busdata, sc->ls_buspos,
+				       LSCR_REG_CHAR);
+		bus_write_register(sc->ls_busdata, sc->ls_buspos,
+				   LSCR_REG_RIRQ, LSCR_IRQ_ENABLE);
+
+		if (sc->ls_input) {
+			sc->ls_input(sc->ls_devdata, ch);
+		}
+	}
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Handle a newline on the screen.
+ */
+static
+void
+lscreen_newline(struct lscreen_softc *sc)
+{
+	if (sc->ls_cy >= sc->ls_height-1) {
+		/*
+		 * Scroll
+		 */
+
+		memmove(sc->ls_screen, sc->ls_screen + sc->ls_width,
+			sc->ls_width * (sc->ls_height-1));
+		bzero(sc->ls_screen + sc->ls_width * (sc->ls_height-1),
+		      sc->ls_width);
+	}
+	else {
+		sc->ls_cy++;
+	}
+	sc->ls_cx=0;
+}
+
+/*
+ * Handle a printable character being written to the screen.
+ */
+static
+void
+lscreen_char(struct lscreen_softc *sc, int ch)
+{
+	if (sc->ls_cx >= sc->ls_width) {
+		lscreen_newline(sc);
+	}
+
+	sc->ls_screen[sc->ls_cy*sc->ls_width + sc->ls_cx] = ch;
+	sc->ls_cx++;
+}
+
+/*
+ * Send a character to the screen.
+ * This should probably know about backspace and tab.
+ */
+void
+lscreen_write(void *vsc, int ch)
+{
+	struct lscreen_softc *sc = vsc;
+	int ccx, ccy;
+
+	switch (ch) {
+	    case '\n': lscreen_newline(sc); break;
+	    default: lscreen_char(sc, ch); break;
+	}
+
+	/*
+	 * ccx/ccy = corrected cursor position
+	 * (The cursor marks the next space text will appear in. But
+	 * at the very end of the line, it should not move off the edge.)
+	 */
+	ccx = sc->ls_cx;
+	ccy = sc->ls_cy;
+	if (ccx==sc->ls_width) {
+		ccx--;
+	}
+
+	/* Set the cursor position */
+	bus_write_register(sc->ls_busdata, sc->ls_buspos,
+			   LSCR_REG_POSN, mergexy(ccx, ccy));
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Setup routine called by autoconf.c when an lscreen is found.
+ */
+int
+config_lscreen(struct lscreen_softc *sc, int lscreenno)
+{
+	u_int32_t val;
+
+	(void)lscreenno;
+
+	/*
+	 * Enable interrupting.
+	 */
+
+	bus_write_register(sc->ls_busdata, sc->ls_buspos,
+			   LSCR_REG_RIRQ, LSCR_IRQ_ENABLE);
+
+	/*
+	 * Get screen size.
+	 */
+	val = bus_read_register(sc->ls_busdata, sc->ls_buspos,
+				LSCR_REG_SIZE);
+	splitxy(val, &sc->ls_width, &sc->ls_height);
+
+	/*
+	 * Get cursor position.
+	 */
+	val = bus_read_register(sc->ls_busdata, sc->ls_buspos,
+				LSCR_REG_POSN);
+	splitxy(val, &sc->ls_cx, &sc->ls_cy);
+
+	/*
+	 * Get a pointer to the memory-mapped screen area.
+	 */
+	sc->ls_screen = bus_map_area(sc->ls_busdata, sc->ls_buspos,
+				     LSCR_SCREEN);
+
+	return 0;
+}
+
diff --git a/os161-1.10/kern/dev/lamebus/lscreen.h b/os161-1.10/kern/dev/lamebus/lscreen.h
new file mode 100644
index 0000000..9629a0d
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lscreen.h
@@ -0,0 +1,29 @@
+#ifndef _LAMEBUS_LSCREEN_H_
+#define _LAMEBUS_LSCREEN_H_
+
+/*
+ * Hardware device data for memory-mapped fullscreen text console.
+ */
+struct lscreen_softc {
+	/* Initialized by config function; synchronized with spl */
+	unsigned ls_width, ls_height; // screen size
+	unsigned ls_cx, ls_cy;        // cursor position
+	char *ls_screen;              // memory-mapped screen buffer
+
+	/* Initialized by lower-level attachment function */
+	void *ls_busdata;		// bus we're on
+	u_int32_t ls_buspos;		// position on that bus
+
+	/* Initialized by higher-level attachment function */
+	void *ls_devdata;			// data and functions for
+	void (*ls_start)(void *devdata);	// upper device (perhaps
+	void (*ls_input)(void *devdata, int ch); // console)
+};
+
+/* Functions called by lower-level drivers */
+void lscreen_irq(/*struct lser_softc*/ void *sc);  // interrupt handler
+
+/* Functions called by higher-level drivers */
+void lscreen_write(/*struct lser_softc*/ void *sc, int ch); // output function
+
+#endif /* _LAMEBUS_LSCREEN_H_ */
diff --git a/os161-1.10/kern/dev/lamebus/lscreen_att.c b/os161-1.10/kern/dev/lamebus/lscreen_att.c
new file mode 100644
index 0000000..2c3fa38
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lscreen_att.c
@@ -0,0 +1,41 @@
+/*
+ * Code for probe/attach of lscreen to LAMEbus.
+ */
+#include <types.h>
+#include <lib.h>
+#include <lamebus/lamebus.h>
+#include <lamebus/lscreen.h>
+#include "autoconf.h"
+
+/* Lowest revision we support */
+#define LOW_VERSION   1
+/* Highest revision we support */
+#define HIGH_VERSION  1
+
+struct lscreen_softc *
+attach_lscreen_to_lamebus(int lscreenno, struct lamebus_softc *sc)
+{
+	struct lscreen_softc *ls;
+	int slot = lamebus_probe(sc, LB_VENDOR_CS161, LBCS161_SCREEN,
+				 LOW_VERSION, HIGH_VERSION);
+	if (slot < 0) {
+		/* Not found */
+		return NULL;
+	}
+
+	ls = kmalloc(sizeof(struct lscreen_softc));
+	if (ls==NULL) {
+		/* Out of memory */
+		return NULL;
+	}
+
+	/* Record what it's attached to */
+	ls->ls_busdata = sc;
+	ls->ls_buspos = slot;
+
+	/* Mark the slot in use and hook the interrupt */
+	lamebus_mark(sc, slot);
+	lamebus_attach_interrupt(sc, slot, ls, lscreen_irq);
+
+	return ls;
+}
diff --git a/os161-1.10/kern/dev/lamebus/lser.c b/os161-1.10/kern/dev/lamebus/lser.c
new file mode 100644
index 0000000..dc6294e
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lser.c
@@ -0,0 +1,147 @@
+#include <types.h>
+#include <lib.h>
+#include <machine/spl.h>
+#include <machine/bus.h>
+#include <lamebus/lser.h>
+#include "autoconf.h"
+
+/* Registers (offsets within slot) */
+#define LSER_REG_CHAR  0     /* Character in/out */
+#define LSER_REG_WIRQ  4     /* Write interrupt status */
+#define LSER_REG_RIRQ  8     /* Read interrupt status */
+
+/* Bits in the IRQ registers */
+#define LSER_IRQ_ENABLE  1
+#define LSER_IRQ_ACTIVE  2
+
+void
+lser_irq(void *vsc)
+{
+	struct lser_softc *sc = vsc;
+	u_int32_t x;
+	int clear_to_write=0;
+	int got_a_read=0;
+	u_int32_t ch = 0;
+
+	assert(curspl>0);
+
+	x = bus_read_register(sc->ls_busdata, sc->ls_buspos, LSER_REG_WIRQ);
+	if (x & LSER_IRQ_ACTIVE) {
+		x = LSER_IRQ_ENABLE;
+		sc->ls_wbusy = 0;
+		clear_to_write = 1;
+		bus_write_register(sc->ls_busdata, sc->ls_buspos,
+				   LSER_REG_WIRQ, x);
+	}
+
+	x = bus_read_register(sc->ls_busdata, sc->ls_buspos, LSER_REG_RIRQ);
+	if (x & LSER_IRQ_ACTIVE) {
+		x = LSER_IRQ_ENABLE;
+		ch = bus_read_register(sc->ls_busdata, sc->ls_buspos,
+				       LSER_REG_CHAR);
+		got_a_read = 1;
+		bus_write_register(sc->ls_busdata, sc->ls_buspos, 
+				   LSER_REG_RIRQ, x);
+	}
+
+	if (clear_to_write && sc->ls_start != NULL) {
+		sc->ls_start(sc->ls_devdata);
+	}
+	if (got_a_read && sc->ls_input != NULL) {
+		sc->ls_input(sc->ls_devdata, ch);
+	}
+}
+
+void
+lser_write(void *vls, int ch)
+{
+	struct lser_softc *ls = vls;
+	int spl = splhigh();
+
+	if (ls->ls_wbusy) {
+		/*
+		 * We're not clear to write.
+		 *
+		 * This should not happen. It's the job of the driver
+		 * attached to us to not write until we call
+		 * ls->ls_start.
+		 *
+		 * (Note: if we're the console, the panic will go to
+		 * lser_writepolled for printing, because spl is high;
+		 * it won't recurse.)
+		 */
+		panic("lser: Not clear to write\n");
+	}
+	ls->ls_wbusy = 1;
+
+	bus_write_register(ls->ls_busdata, ls->ls_buspos, LSER_REG_CHAR, ch);
+
+	splx(spl);
+}
+
+static
+void
+lser_spin_until_write(struct lser_softc *sc)
+{
+	u_int32_t val;
+	assert(curspl>0);
+	do {
+		val = bus_read_register(sc->ls_busdata, sc->ls_buspos,
+					LSER_REG_WIRQ);
+	}
+	while ((val & LSER_IRQ_ACTIVE)==0);
+}
+
+void
+lser_writepolled(void *vsc, int ch)
+{
+	struct lser_softc *sc = vsc;
+	int spl = splhigh();
+	int irqpending=0;
+
+	if (sc->ls_wbusy) {
+		irqpending = 1;
+		lser_spin_until_write(sc);
+		/* Clear the ready condition */
+		bus_write_register(sc->ls_busdata, sc->ls_buspos,
+				   LSER_REG_WIRQ, LSER_IRQ_ENABLE);
+	}
+
+	/* Send the character. */
+	bus_write_register(sc->ls_busdata, sc->ls_buspos, LSER_REG_CHAR, ch);
+
+	/* Wait until it's done. */
+	lser_spin_until_write(sc);
+
+	/*
+	 * If there wasn't already an IRQ pending, clear the ready condition.
+	 * But if there was, leave the ready condition, so we get to the 
+	 * interrupt handler in due course.
+	 */
+	if (!irqpending) {
+		bus_write_register(sc->ls_busdata, sc->ls_buspos,
+				   LSER_REG_WIRQ, LSER_IRQ_ENABLE);
+	}
+
+	splx(spl);
+}
+
+int
+config_lser(struct lser_softc *sc, int lserno)
+{
+	(void)lserno;
+
+	/*
+	 * Enable interrupting.
+	 */
+
+	sc->ls_wbusy = 0;
+
+	bus_write_register(sc->ls_busdata, sc->ls_buspos,
+			   LSER_REG_RIRQ, LSER_IRQ_ENABLE);
+	bus_write_register(sc->ls_busdata, sc->ls_buspos,
+			   LSER_REG_WIRQ, LSER_IRQ_ENABLE);
+
+	return 0;
+}
+
diff --git a/os161-1.10/kern/dev/lamebus/lser.h b/os161-1.10/kern/dev/lamebus/lser.h
new file mode 100644
index 0000000..99f7a93
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lser.h
@@ -0,0 +1,25 @@
+#ifndef _LAMEBUS_LSER_H_
+#define _LAMEBUS_LSER_H_
+
+struct lser_softc {
+	/* Initialized by config function; synchronized with spl */
+	volatile int ls_wbusy;     /* true if write in progress */
+
+	/* Initialized by lower-level attachment function */
+	void *ls_busdata;
+	u_int32_t ls_buspos;
+
+	/* Initialized by higher-level attachment function */
+	void *ls_devdata;
+	void (*ls_start)(void *devdata);
+	void (*ls_input)(void *devdata, int ch);
+};
+
+/* Functions called by lower-level drivers */
+void lser_irq(/*struct lser_softc*/ void *sc);
+
+/* Functions called by higher-level drivers */
+void lser_write(/*struct lser_softc*/ void *sc, int ch);
+void lser_writepolled(/*struct lser_softc*/ void *sc, int ch);
+
+#endif /* _LAMEBUS_LSER_H_ */
diff --git a/os161-1.10/kern/dev/lamebus/lser_att.c b/os161-1.10/kern/dev/lamebus/lser_att.c
new file mode 100644
index 0000000..f6a465e
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/lser_att.c
@@ -0,0 +1,36 @@
+#include <types.h>
+#include <lib.h>
+#include <lamebus/lamebus.h>
+#include <lamebus/lser.h>
+#include "autoconf.h"
+
+/* Lowest revision we support */
+#define LOW_VERSION   1
+/* Highest revision we support */
+#define HIGH_VERSION  1
+
+struct lser_softc *
+attach_lser_to_lamebus(int lserno, struct lamebus_softc *sc)
+{
+	struct lser_softc *ls;
+	int slot = lamebus_probe(sc, LB_VENDOR_CS161, LBCS161_SERIAL,
+				 LOW_VERSION, HIGH_VERSION);
+	if (slot < 0) {
+		return NULL;
+	}
+
+	ls = kmalloc(sizeof(struct lser_softc));
+	if (ls==NULL) {
+		return NULL;
+	}
+
+	(void)lserno;  // unused
+
+	ls->ls_busdata = sc;
+	ls->ls_buspos = slot;
+
+	lamebus_mark(sc, slot);
+	lamebus_attach_interrupt(sc, slot, ls, lser_irq);
+
+	return ls;
+}
diff --git a/os161-1.10/kern/dev/lamebus/ltimer.c b/os161-1.10/kern/dev/lamebus/ltimer.c
new file mode 100644
index 0000000..247a225
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/ltimer.c
@@ -0,0 +1,130 @@
+/*
+ * Driver for LAMEbus clock/timer card
+ */
+#include <types.h>
+#include <lib.h>
+#include <clock.h>
+#include <machine/bus.h>
+#include <lamebus/ltimer.h>
+#include "autoconf.h"
+
+/* Registers (offsets within slot) */
+#define LT_REG_SEC    0     /* time of day: seconds */
+#define LT_REG_NSEC   4     /* time of day: nanoseconds */
+#define LT_REG_ROE    8     /* Restart On countdown-timer Expiry flag */
+#define LT_REG_IRQ    12    /* Interrupt status register */
+#define LT_REG_COUNT  16    /* Time for countdown timer (usec) */
+#define LT_REG_SPKR   20    /* Beep control */
+
+/* Granularity of countdown timer (usec) */
+#define LT_GRANULARITY   1000000
+
+
+static int haveclock=0;
+
+/*
+ * Setup routine called by autoconf stuff when an ltimer is found.
+ */
+int
+config_ltimer(struct ltimer_softc *lt, int ltimerno)
+{
+	/*
+	 * If we don't have a timer doing hardclock yet, use this one.
+	 * (hardclock is the forced context switch code.)
+	 */
+	if (!haveclock) {
+		haveclock = 1;
+		lt->lt_hardclock = 1;
+
+		/*
+		 * Arm the timer to go off HZ times a second, and set
+		 * it to autoreload (so we don't need to pay any more
+		 * attention to it)
+		 */
+
+		bus_write_register(lt->lt_bus, lt->lt_buspos, LT_REG_ROE, 1);
+		bus_write_register(lt->lt_bus, lt->lt_buspos, LT_REG_COUNT,
+				   LT_GRANULARITY/HZ);
+
+		kprintf("\nhardclock on ltimer%d (%u hz)", ltimerno, HZ);
+	}
+	else {
+		/*
+		 * Second and subsequent timers are not used for hardclock.
+		 */
+		lt->lt_hardclock = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Interrupt handler.
+ */
+void
+ltimer_irq(void *vlt)
+{
+	struct ltimer_softc *lt = vlt;
+	u_int32_t val;
+
+	val = bus_read_register(lt->lt_bus, lt->lt_buspos, LT_REG_IRQ);
+	if (val) {
+		/*
+		 * Only call hardclock if we're responsible for hardclock.
+		 * (Any additional timer devices are unused.)
+		 */
+		if (lt->lt_hardclock) {
+			hardclock();
+		}
+	}
+}
+
+/*
+ * The timer device will beep if you write to the beep register. It
+ * doesn't matter what value you write. This function is called if
+ * the beep device is attached to this timer. 
+ */
+void
+ltimer_beep(void *vlt)
+{
+	struct ltimer_softc *lt = vlt;
+
+	bus_write_register(lt->lt_bus, lt->lt_buspos, LT_REG_SPKR, 440);
+}
+
+/*
+ * The timer device also has a realtime clock on it.
+ * This function gets called if the rtclock device is attached
+ * to this timer.
+ */
+void
+ltimer_gettime(void *vlt, time_t *secs, u_int32_t *nsecs)
+{
+	struct ltimer_softc *lt = vlt;
+	u_int32_t secs1, secs2;
+
+	/*
+	 * Read the seconds twice, on either side of the nanoseconds. 
+	 * If nsecs is small, use the *later* value of seconds, in case
+	 * the nanoseconds turned over between the time we got the earlier
+	 * value and the time we got nsecs.
+	 *
+	 * Note that the clock in the ltimer device is accurate down
+	 * to a single processor cycle, so this might actually matter
+	 * now and then.
+	 */
+
+	secs1 = bus_read_register(lt->lt_bus, lt->lt_buspos,
+				  LT_REG_SEC);
+	*nsecs = bus_read_register(lt->lt_bus, lt->lt_buspos,
+				   LT_REG_NSEC);
+	secs2 = bus_read_register(lt->lt_bus, lt->lt_buspos,
+				  LT_REG_SEC);
+
+	if (*nsecs < 5000000) {
+		*secs = secs2;
+	}
+	else {
+		*secs = secs1;
+	}
+}
diff --git a/os161-1.10/kern/dev/lamebus/ltimer.h b/os161-1.10/kern/dev/lamebus/ltimer.h
new file mode 100644
index 0000000..e5d1068
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/ltimer.h
@@ -0,0 +1,25 @@
+#ifndef _LAMEBUS_LTIMER_H_
+#define _LAMEBUS_LTIMER_H_
+
+/*
+ * Hardware device data for LAMEbus timer device
+ */
+struct ltimer_softc {
+	/* Initialized by config function */
+	int lt_hardclock;        /* true if we should call hardclock() */
+
+	/* Initialized by lower-level attach routine */
+	void *lt_bus;		/* bus we're on */
+	u_int32_t lt_buspos;	/* position (slot) on that bus */
+	
+};
+
+/* Functions called by lower-level drivers */
+void ltimer_irq(/*struct ltimer_softc*/ void *lt);  // interrupt handler
+
+/* Functions called by higher-level devices */
+void ltimer_beep(/*struct ltimer_softc*/ void *devdata);   // for beep device
+void ltimer_gettime(/*struct ltimer_softc*/ void *devdata,
+		    time_t *secs, u_int32_t *nsecs);       // for rtclock
+
+#endif /* _LAMEBUS_LTIMER_H_ */
diff --git a/os161-1.10/kern/dev/lamebus/ltimer_att.c b/os161-1.10/kern/dev/lamebus/ltimer_att.c
new file mode 100644
index 0000000..1dcff75
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/ltimer_att.c
@@ -0,0 +1,43 @@
+/*
+ * Routine for probing/attaching ltimer to LAMEbus.
+ */
+#include <types.h>
+#include <lib.h>
+#include <lamebus/lamebus.h>
+#include <lamebus/ltimer.h>
+#include "autoconf.h"
+
+/* Lowest revision we support */
+#define LOW_VERSION   1
+/* Highest revision we support */
+#define HIGH_VERSION  1
+
+struct ltimer_softc *
+attach_ltimer_to_lamebus(int ltimerno, struct lamebus_softc *sc)
+{
+	struct ltimer_softc *lt;
+	int slot = lamebus_probe(sc, LB_VENDOR_CS161, LBCS161_TIMER,
+				 LOW_VERSION, HIGH_VERSION);
+	if (slot < 0) {
+		/* No ltimer (or no additional ltimer) found */
+		return NULL;
+	}
+
+	lt = kmalloc(sizeof(struct ltimer_softc));
+	if (lt==NULL) {
+		/* out of memory */
+		return NULL;
+	}
+
+	(void)ltimerno;  // unused
+
+	/* Record what bus it's on */
+	lt->lt_bus = sc;
+	lt->lt_buspos = slot;
+
+	/* Mark the slot in use and hook that slot's interrupt */
+	lamebus_mark(sc, slot);
+	lamebus_attach_interrupt(sc, slot, lt, ltimer_irq);
+
+	return lt;
+}
diff --git a/os161-1.10/kern/dev/lamebus/ltrace.c b/os161-1.10/kern/dev/lamebus/ltrace.c
new file mode 100644
index 0000000..bfd7339
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/ltrace.c
@@ -0,0 +1,57 @@
+#include <types.h>
+#include <lib.h>
+#include <machine/bus.h>
+#include <lamebus/ltrace.h>
+#include "autoconf.h"
+
+/* Registers (offsets within slot) */
+#define LTRACE_REG_TRON    0
+#define LTRACE_REG_TROFF   4
+#define LTRACE_REG_DEBUG   8
+#define LTRACE_REG_DUMP    12
+
+static struct ltrace_softc *the_trace;
+
+void
+ltrace_on(u_int32_t code)
+{
+	if (the_trace != NULL) {
+		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
+				   LTRACE_REG_TRON, code);
+	}
+}
+
+void
+ltrace_off(u_int32_t code)
+{
+	if (the_trace != NULL) {
+		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
+				   LTRACE_REG_TROFF, code);
+	}
+}
+
+void
+ltrace_debug(u_int32_t code)
+{
+	if (the_trace != NULL) {
+		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
+				   LTRACE_REG_DEBUG, code);
+	}
+}
+
+void
+ltrace_dump(u_int32_t code)
+{
+	if (the_trace != NULL) {
+		bus_write_register(the_trace->lt_busdata, the_trace->lt_buspos,
+				   LTRACE_REG_DUMP, code);
+	}
+}
+
+int
+config_ltrace(struct ltrace_softc *sc, int ltraceno)
+{
+	(void)ltraceno;
+	the_trace = sc;
+	return 0;
+}
diff --git a/os161-1.10/kern/dev/lamebus/ltrace.h b/os161-1.10/kern/dev/lamebus/ltrace.h
new file mode 100644
index 0000000..dfb5a85
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/ltrace.h
@@ -0,0 +1,38 @@
+#ifndef _LAMEBUS_LTRACE_H_
+#define _LAMEBUS_LTRACE_H_
+
+struct ltrace_softc {
+	/* Initialized by lower-level attachment function */
+	void *lt_busdata;
+	u_int32_t lt_buspos;
+};
+
+/*
+ * Functions provided for debug hacking:
+ *   ltrace_on:    turns on the trace161 tracing flag CODE.
+ *   ltrace_off:   turns off the trace161 tracing flag CODE.
+ *   ltrace_debug: causes sys161/trace161 to print a message with CODE.
+ *   ltrace_dump:  causes trace161 to do a complete state dump, tagged CODE.
+ *
+ * The flags for ltrace_on/off are the characters used to control
+ * tracing on the trace161 command line. See the System/161 manual for
+ * more information.
+ *
+ * ltrace_debug is for printing simple indications that a certain
+ * piece of code has been reached, like one might use kprintf, except
+ * that it is less invasive than kprintf. Think of it as setting the
+ * value of a readout on the system's front panel. (In real life,
+ * since computers don't have front panels with blinking lights any
+ * more, people often use the speaker or the top left corner of the
+ * screen for this purpose.)
+ *
+ * ltrace_dump dumps the entire system state and is primarily intended
+ * for regression testing of System/161. It might or might not prove
+ * useful for debugging as well.
+ */
+void ltrace_on(u_int32_t code);
+void ltrace_off(u_int32_t code);
+void ltrace_debug(u_int32_t code);
+void ltrace_dump(u_int32_t code);
+
+#endif /* _LAMEBUS_LTRACE_H_ */
diff --git a/os161-1.10/kern/dev/lamebus/ltrace_att.c b/os161-1.10/kern/dev/lamebus/ltrace_att.c
new file mode 100644
index 0000000..cf0eb5f
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/ltrace_att.c
@@ -0,0 +1,35 @@
+#include <types.h>
+#include <lib.h>
+#include <lamebus/lamebus.h>
+#include <lamebus/ltrace.h>
+#include "autoconf.h"
+
+/* Lowest revision we support */
+#define LOW_VERSION   1
+/* Highest revision we support */
+#define HIGH_VERSION  1
+
+struct ltrace_softc *
+attach_ltrace_to_lamebus(int ltraceno, struct lamebus_softc *sc)
+{
+	struct ltrace_softc *lt;
+	int slot = lamebus_probe(sc, LB_VENDOR_CS161, LBCS161_TRACE,
+				 LOW_VERSION, HIGH_VERSION);
+	if (slot < 0) {
+		return NULL;
+	}
+
+	lt = kmalloc(sizeof(struct ltrace_softc));
+	if (lt==NULL) {
+		return NULL;
+	}
+
+	(void)ltraceno;  // unused
+
+	lt->lt_busdata = sc;
+	lt->lt_buspos = slot;
+
+	lamebus_mark(sc, slot);
+
+	return lt;
+}
diff --git a/os161-1.10/kern/dev/lamebus/random_lrandom.c b/os161-1.10/kern/dev/lamebus/random_lrandom.c
new file mode 100644
index 0000000..94a93ff
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/random_lrandom.c
@@ -0,0 +1,28 @@
+/*
+ * Attachment code for having the generic random device use the LAMEbus
+ * random device.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <generic/random.h>
+#include <lamebus/lrandom.h>
+#include "autoconf.h"
+
+struct random_softc *
+attach_random_to_lrandom(int randomno, struct lrandom_softc *ls)
+{
+	struct random_softc *rs = kmalloc(sizeof(struct random_softc));
+	if (rs==NULL) {
+		return NULL;
+	}
+
+	(void)randomno;  // unused
+
+	rs->rs_devdata = ls;
+	rs->rs_random = lrandom_random;
+	rs->rs_randmax = lrandom_randmax;
+	rs->rs_read = lrandom_read;
+
+	return rs;
+}
diff --git a/os161-1.10/kern/dev/lamebus/rtclock_ltimer.c b/os161-1.10/kern/dev/lamebus/rtclock_ltimer.c
new file mode 100644
index 0000000..996323f
--- /dev/null
+++ b/os161-1.10/kern/dev/lamebus/rtclock_ltimer.c
@@ -0,0 +1,37 @@
+/*
+ * Code for attaching the (generic) rtclock device to the LAMEbus ltimer.
+ *
+ * rtclock is a generic clock interface that gets its clock service from
+ * an actual hardware clock of some kind. (Theoretically it could also
+ * get its clock service from a clock maintained in software, as is the
+ * case on most systems. However, no such driver has been written yet.)
+ *
+ * ltimer can provide this clock service.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <generic/rtclock.h>
+#include <lamebus/ltimer.h>
+#include "autoconf.h"
+
+struct rtclock_softc *
+attach_rtclock_to_ltimer(int rtclockno, struct ltimer_softc *ls)
+{
+	/*
+	 * No need to probe; ltimer always has a clock.
+	 * Just allocate the rtclock, set our fields, and return it.
+	 */
+	struct rtclock_softc *rtc = kmalloc(sizeof(struct rtclock_softc));
+	if (rtc==NULL) {
+		/* Out of memory */
+		return NULL;
+	}
+
+	(void)rtclockno;  // unused
+
+	rtc->rtc_devdata = ls;
+	rtc->rtc_gettime = ltimer_gettime;
+
+	return rtc;
+}
diff --git a/os161-1.10/kern/fs/sfs/sfs_fs.c b/os161-1.10/kern/fs/sfs/sfs_fs.c
new file mode 100644
index 0000000..9a5bb46
--- /dev/null
+++ b/os161-1.10/kern/fs/sfs/sfs_fs.c
@@ -0,0 +1,321 @@
+/*
+ * SFS filesystem
+ *
+ * Filesystem-level interface routines.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <kern/errno.h>
+#include <array.h>
+#include <bitmap.h>
+#include <uio.h>
+#include <dev.h>
+#include <sfs.h>
+#include <vfs.h>
+
+/* Shortcuts for the size macros in kern/sfs.h */
+#define SFS_FS_BITMAPSIZE(sfs)  SFS_BITMAPSIZE((sfs)->sfs_super.sp_nblocks)
+#define SFS_FS_BITBLOCKS(sfs)   SFS_BITBLOCKS((sfs)->sfs_super.sp_nblocks)
+
+/*
+ * Routine for doing I/O (reads or writes) on the free block bitmap.
+ * We always do the whole bitmap at once; writing individual sectors
+ * might or might not be a worthwhile optimization.
+ *
+ * The free block bitmap consists of SFS_BITBLOCKS 512-byte sectors of
+ * bits, one bit for each sector on the filesystem. The number of
+ * blocks in the bitmap is thus rounded up to the nearest multiple of
+ * 512*8 = 4096. (This rounded number is SFS_BITMAPSIZE.) This means
+ * that the bitmap will (in general) contain space for some number of
+ * invalid sectors that are actually beyond the end of the disk
+ * device. This is ok. These sectors are supposed to be marked "in
+ * use" by mksfs and never get marked "free".
+ *
+ * The sectors used by the superblock and the bitmap itself are
+ * likewise marked in use by mksfs.
+ */
+
+static
+int
+sfs_mapio(struct sfs_fs *sfs, enum uio_rw rw)
+{
+	u_int32_t j, mapsize;
+	char *bitdata;
+	int result;
+
+	/* Number of blocks in the bitmap. */
+	mapsize = SFS_FS_BITBLOCKS(sfs);
+
+	/* Pointer to our bitmap data in memory. */
+	bitdata = bitmap_getdata(sfs->sfs_freemap);
+	
+	/* For each sector in the bitmap... */
+	for (j=0; j<mapsize; j++) {
+
+		/* Get a pointer to its data */
+		void *ptr = bitdata + j*SFS_BLOCKSIZE;
+
+		/* and read or write it. The bitmap starts at sector 2. */ 
+		if (rw == UIO_READ) {
+			result = sfs_rblock(sfs, ptr, SFS_MAP_LOCATION+j);
+		}
+		else {
+			result = sfs_wblock(sfs, ptr, SFS_MAP_LOCATION+j);
+		}
+
+		/* If we failed, stop. */
+		if (result) {
+			return result;
+		}
+	}
+	return 0;
+}
+
+/*
+ * Sync routine. This is what gets invoked if you do FS_SYNC on the
+ * sfs filesystem structure.
+ */
+
+static
+int
+sfs_sync(struct fs *fs)
+{
+	struct sfs_fs *sfs; 
+	int i, num, result;
+
+	/*
+	 * Get the sfs_fs from the generic abstract fs.
+	 *
+	 * Note that the abstract struct fs, which is all the VFS
+	 * layer knows about, is actually a member of struct sfs_fs.
+	 * The pointer in the struct fs points back to the top of the
+	 * struct sfs_fs - essentially the same object. This can be a
+	 * little confusing at first.
+	 *
+	 * The following diagram may help:
+	 *
+	 *     struct sfs_fs        <-------------\
+         *           :                            |
+         *           :   sfs_absfs (struct fs)    |   <------\
+         *           :      :                     |          |
+         *           :      :  various members    |          |
+         *           :      :                     |          |
+         *           :      :  fs_data  ----------/          |
+         *           :      :                             ...|...
+         *           :                                   .  VFS  .
+         *           :                                   . layer . 
+         *           :   other members                    .......
+         *           :                                    
+         *           :
+	 *
+	 * This construct is repeated with vnodes and devices and other
+	 * similar things all over the place in OS/161, so taking the
+	 * time to straighten it out in your mind is worthwhile.
+	 */
+
+	sfs = fs->fs_data;
+
+	/* Go over the array of loaded vnodes, syncing as we go. */
+	num = array_getnum(sfs->sfs_vnodes);
+	for (i=0; i<num; i++) {
+		struct sfs_vnode *sv = array_getguy(sfs->sfs_vnodes, i);
+		VOP_FSYNC(&sv->sv_v);
+	}
+
+	/* If the free block map needs to be written, write it. */
+	if (sfs->sfs_freemapdirty) {
+		result = sfs_mapio(sfs, UIO_WRITE);
+		if (result) {
+			return result;
+		}
+		sfs->sfs_freemapdirty = 0;
+	}
+
+	/* If the superblock needs to be written, write it. */
+	if (sfs->sfs_superdirty) {
+		result = sfs_wblock(sfs, &sfs->sfs_super, SFS_SB_LOCATION);
+		if (result) {
+			return result;
+		}
+		sfs->sfs_superdirty = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Routine to retrieve the volume name. Filesystems can be referred
+ * to by their volume name followed by a colon as well as the name
+ * of the device they're mounted on.
+ */
+static
+const char *
+sfs_getvolname(struct fs *fs)
+{
+	struct sfs_fs *sfs = fs->fs_data;
+	return sfs->sfs_super.sp_volname;
+}
+
+/*
+ * Unmount code.
+ *
+ * VFS calls FS_SYNC on the filesystem prior to unmounting it.
+ */
+static
+int
+sfs_unmount(struct fs *fs)
+{
+	struct sfs_fs *sfs = fs->fs_data;
+	
+	/* Do we have any files open? If so, can't unmount. */
+	if (array_getnum(sfs->sfs_vnodes)>0) {
+		return EBUSY;
+	}
+
+	/* We should have just had sfs_sync called. */
+	assert(sfs->sfs_superdirty==0);
+	assert(sfs->sfs_freemapdirty==0);
+
+	/* Once we start nuking stuff we can't fail. */
+	array_destroy(sfs->sfs_vnodes);
+	bitmap_destroy(sfs->sfs_freemap);
+	
+	/* The vfs layer takes care of the device for us */
+	(void)sfs->sfs_device;
+
+	/* Destroy the fs object */
+	kfree(sfs);
+
+	/* nothing else to do */
+	return 0;
+}
+
+/*
+ * Mount routine.
+ *
+ * The way mount works is that you call vfs_mount and pass it a
+ * filesystem-specific mount routine. This routine takes a device and
+ * hands back a pointer to an abstract filesystem.  You can also pass
+ * a void * through to the mount routine.
+ *
+ * This structure is necessitated by the fact that the VFS layer needs
+ * to update its internal device tables atomically to avoid getting
+ * two filesystems with the same name mounted at once, or two
+ * filesystems mounted on the same device at once.
+ */
+
+static
+int
+sfs_domount(void *options, struct device *dev, struct fs **ret)
+{
+	int result;
+	struct sfs_fs *sfs;
+
+	/* We don't pass any options through mount */
+	(void)options;
+
+	/*
+	 * Make sure our on-disk structures aren't messed up
+	 */
+	assert(sizeof(struct sfs_super)==SFS_BLOCKSIZE);
+	assert(sizeof(struct sfs_inode)==SFS_BLOCKSIZE);
+	assert(SFS_BLOCKSIZE % sizeof(struct sfs_dir) == 0);
+
+	/*
+	 * We can't mount on devices with the wrong sector size.
+	 *
+	 * (Note: for all intents and purposes here, "sector" and
+	 * "block" are interchangeable terms. Technically a filesystem
+	 * block may be composed of several hardware sectors, but we
+	 * don't do that in sfs.)
+	 */
+	if (dev->d_blocksize != SFS_BLOCKSIZE) {
+		return ENXIO;
+	}
+
+	/* Allocate object */
+	sfs = kmalloc(sizeof(struct sfs_fs));
+	if (sfs==NULL) {
+		return ENOMEM;
+	}
+
+	/* Allocate array */
+	sfs->sfs_vnodes = array_create();
+	if (sfs->sfs_vnodes == NULL) {
+		kfree(sfs);
+		return ENOMEM;
+	}
+
+	/* Set the device so we can use sfs_rblock() */
+	sfs->sfs_device = dev;
+
+	/* Load superblock */
+	result = sfs_rblock(sfs, &sfs->sfs_super, SFS_SB_LOCATION);
+	if (result) {
+		array_destroy(sfs->sfs_vnodes);
+		kfree(sfs);
+		return result;
+	}
+
+	/* Make some simple sanity checks */
+
+	if (sfs->sfs_super.sp_magic != SFS_MAGIC) {
+		kprintf("sfs: Wrong magic number in superblock "
+			"(0x%x, should be 0x%x)\n", 
+			sfs->sfs_super.sp_magic,
+			SFS_MAGIC);
+		array_destroy(sfs->sfs_vnodes);
+		kfree(sfs);
+		return EINVAL;
+	}
+	
+	if (sfs->sfs_super.sp_nblocks > dev->d_blocks) {
+		kprintf("sfs: warning - fs has %u blocks, device has %u\n",
+			sfs->sfs_super.sp_nblocks, dev->d_blocks);
+	}
+
+	/* Ensure null termination of the volume name */
+	sfs->sfs_super.sp_volname[sizeof(sfs->sfs_super.sp_volname)-1] = 0;
+
+	/* Load free space bitmap */
+	sfs->sfs_freemap = bitmap_create(SFS_FS_BITMAPSIZE(sfs));
+	if (sfs->sfs_freemap == NULL) {
+		array_destroy(sfs->sfs_vnodes);
+		kfree(sfs);
+		return ENOMEM;
+	}
+	result = sfs_mapio(sfs, UIO_READ);
+	if (result) {
+		bitmap_destroy(sfs->sfs_freemap);
+		array_destroy(sfs->sfs_vnodes);
+		kfree(sfs);
+		return result;
+	}
+
+	/* Set up abstract fs calls */
+	sfs->sfs_absfs.fs_sync = sfs_sync;
+	sfs->sfs_absfs.fs_getvolname = sfs_getvolname;
+	sfs->sfs_absfs.fs_getroot = sfs_getroot;
+	sfs->sfs_absfs.fs_unmount = sfs_unmount;
+	sfs->sfs_absfs.fs_data = sfs;
+
+	/* the other fields */
+	sfs->sfs_superdirty = 0;
+	sfs->sfs_freemapdirty = 0;
+
+	/* Hand back the abstract fs */
+	*ret = &sfs->sfs_absfs;
+
+	return 0;
+}
+
+/*
+ * Actual function called from high-level code to mount an sfs.
+ */
+
+int
+sfs_mount(const char *device)
+{
+	return vfs_mount(device, NULL, sfs_domount);
+}
diff --git a/os161-1.10/kern/fs/sfs/sfs_io.c b/os161-1.10/kern/fs/sfs/sfs_io.c
new file mode 100644
index 0000000..ee3c371
--- /dev/null
+++ b/os161-1.10/kern/fs/sfs/sfs_io.c
@@ -0,0 +1,71 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <uio.h>
+#include <sfs.h>
+#include <dev.h>
+
+////////////////////////////////////////////////////////////
+//
+// Basic block-level I/O routines
+//
+// Note: sfs_rblock is used to read the superblock
+// early in mount, before sfs is fully (or even mostly)
+// initialized, and so may not use anything from sfs
+// except sfs_device.
+
+int
+sfs_rwblock(struct sfs_fs *sfs, struct uio *uio)
+{
+	int result;
+	int tries=0;
+
+	DEBUG(DB_SFS, "sfs: %s %u\n", 
+	      uio->uio_rw == UIO_READ ? "read" : "write",
+	      uio->uio_offset / SFS_BLOCKSIZE);
+
+ retry:
+	result = sfs->sfs_device->d_io(sfs->sfs_device, uio);
+	if (result == EINVAL) {
+		/*
+		 * This means the sector we requested was out of range,
+		 * or the seek address we gave wasn't sector-aligned,
+		 * or a couple of other things that are our fault.
+		 */
+		panic("sfs: d_io returned EINVAL\n");
+	}
+	if (result == EIO) {
+		if (tries == 0) {
+			tries++;
+			kprintf("sfs: block %u I/O error, retrying\n",
+				uio->uio_offset / SFS_BLOCKSIZE);
+			goto retry;
+		}
+		else if (tries < 10) {
+			tries++;
+			goto retry;
+		}
+		else {
+			kprintf("sfs: block %u I/O error, giving up after "
+				"%d retries\n",
+				uio->uio_offset / SFS_BLOCKSIZE, tries);
+		}
+	}
+	return result;
+}
+
+int
+sfs_rblock(struct sfs_fs *sfs, void *data, u_int32_t block)
+{
+	struct uio ku;
+	SFSUIO(&ku, data, block, UIO_READ);
+	return sfs_rwblock(sfs, &ku);
+}
+
+int
+sfs_wblock(struct sfs_fs *sfs, void *data, u_int32_t block)
+{
+	struct uio ku;
+	SFSUIO(&ku, data, block, UIO_WRITE);
+	return sfs_rwblock(sfs, &ku);
+}
diff --git a/os161-1.10/kern/fs/sfs/sfs_vnode.c b/os161-1.10/kern/fs/sfs/sfs_vnode.c
new file mode 100644
index 0000000..ab068e9
--- /dev/null
+++ b/os161-1.10/kern/fs/sfs/sfs_vnode.c
@@ -0,0 +1,1670 @@
+/*
+ * SFS filesystem
+ *
+ * File-level (vnode) interface routines.
+ */
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <array.h>
+#include <bitmap.h>
+#include <kern/stat.h>
+#include <kern/errno.h>
+#include <kern/unistd.h>
+#include <uio.h>
+#include <dev.h>
+#include <sfs.h>
+
+/* At bottom of file */
+static int 
+sfs_loadvnode(struct sfs_fs *sfs, u_int32_t ino, int type,
+		 struct sfs_vnode **ret);
+
+////////////////////////////////////////////////////////////
+//
+// Simple stuff
+
+/* Zero out a disk block. */
+static
+int
+sfs_clearblock(struct sfs_fs *sfs, u_int32_t block)
+{
+	/* static -> automatically initialized to zero */
+	static char zeros[SFS_BLOCKSIZE];
+	return sfs_wblock(sfs, zeros, block);
+}
+
+/* Write an on-disk inode structure back out to disk. */
+static
+int
+sfs_sync_inode(struct sfs_vnode *sv)
+{
+	if (sv->sv_dirty) {
+		struct sfs_fs *sfs = sv->sv_v.vn_fs->fs_data;
+		int result = sfs_wblock(sfs, &sv->sv_i, sv->sv_ino);
+		if (result) {
+			return result;
+		}
+		sv->sv_dirty = 0;
+	}
+	return 0;
+}
+
+////////////////////////////////////////////////////////////
+//
+// Space allocation
+
+/*
+ * Allocate a block.
+ */
+static
+int
+sfs_balloc(struct sfs_fs *sfs, u_int32_t *diskblock)
+{
+	int result;
+
+	result = bitmap_alloc(sfs->sfs_freemap, diskblock);
+	if (result) {
+		return result;
+	}
+	sfs->sfs_freemapdirty = 1;
+
+	if (*diskblock >= sfs->sfs_super.sp_nblocks) {
+		panic("sfs: balloc: invalid block %u\n", *diskblock);
+	}
+
+	/* Clear block before returning it */
+	return sfs_clearblock(sfs, *diskblock);
+}
+
+/*
+ * Free a block.
+ */
+static
+void
+sfs_bfree(struct sfs_fs *sfs, u_int32_t diskblock)
+{
+	bitmap_unmark(sfs->sfs_freemap, diskblock);
+	sfs->sfs_freemapdirty = 1;
+}
+
+/*
+ * Check if a block is in use.
+ */
+static
+int
+sfs_bused(struct sfs_fs *sfs, u_int32_t diskblock)
+{
+	if (diskblock >= sfs->sfs_super.sp_nblocks) {
+		panic("sfs: sfs_bused called on out of range block %u\n", 
+		      diskblock);
+	}
+	return bitmap_isset(sfs->sfs_freemap, diskblock);
+}
+
+////////////////////////////////////////////////////////////
+//
+// Block mapping/inode maintenance
+
+/*
+ * Look up the disk block number (from 0 up to the number of blocks on
+ * the disk) given a file and the logical block number within that
+ * file. If DOALLOC is set, and no such block exists, one will be
+ * allocated.
+ */
+static
+int
+sfs_bmap(struct sfs_vnode *sv, u_int32_t fileblock, int doalloc,
+	    u_int32_t *diskblock)
+{
+	/*
+	 * I/O buffer for handling indirect blocks.
+	 *
+	 * Note: in real life (and when you've done the fs assignment)
+	 * you would get space from the disk buffer cache for this,
+	 * not use a static area.
+	 */
+	static u_int32_t idbuf[SFS_DBPERIDB];
+
+	struct sfs_fs *sfs = sv->sv_v.vn_fs->fs_data;
+	u_int32_t block;
+	u_int32_t idblock;
+	u_int32_t idnum, idoff;
+	int result;
+
+	assert(sizeof(idbuf)==SFS_BLOCKSIZE);
+
+	/*
+	 * If the block we want is one of the direct blocks...
+	 */
+	if (fileblock < SFS_NDIRECT) {
+		/*
+		 * Get the block number
+		 */
+		block = sv->sv_i.sfi_direct[fileblock];
+
+		/*
+		 * Do we need to allocate?
+		 */
+		if (block==0 && doalloc) {
+			result = sfs_balloc(sfs, &block);
+			if (result) {
+				return result;
+			}
+
+			/* Remember what we allocated; mark inode dirty */
+			sv->sv_i.sfi_direct[fileblock] = block;
+			sv->sv_dirty = 1;
+		}
+
+		/*
+		 * Hand back the block
+		 */
+		if (block != 0 && !sfs_bused(sfs, block)) {
+			panic("sfs: Data block %u (block %u of file %u) "
+			      "marked free\n", block, fileblock, sv->sv_ino);
+		}
+		*diskblock = block;
+		return 0;
+	}
+
+	/*
+	 * It's not a direct block; it must be in the indirect block.
+	 * Subtract off the number of direct blocks, so FILEBLOCK is
+	 * now the offset into the indirect block space.
+	 */
+
+	fileblock -= SFS_NDIRECT;
+
+	/* Get the indirect block number and offset w/i that indirect block */
+	idnum = fileblock / SFS_DBPERIDB;
+	idoff = fileblock % SFS_DBPERIDB;
+
+	/*
+	 * We only have one indirect block. If the offset we were asked for
+	 * is too large, we can't handle it, so fail.
+	 */
+	if (idnum > 0) {
+		return EINVAL;
+	}
+
+	/* Get the disk block number of the indirect block. */
+	idblock = sv->sv_i.sfi_indirect;
+
+	if (idblock==0 && !doalloc) {
+		/*
+		 * There's no indirect block allocated. We weren't
+		 * asked to allocate anything, so pretend the indirect
+		 * block was filled with all zeros.
+		 */
+		*diskblock = 0;
+		return 0;
+	}
+	else if (idblock==0) {
+		/*
+		 * There's no indirect block allocated, but we need to
+		 * allocate a block whose number needs to be stored in
+		 * the indirect block. Thus, we need to allocate an
+		 * indirect block.
+		 */
+		result = sfs_balloc(sfs, &idblock);
+		if (result) {
+			return result;
+		}
+
+		/* Remember the block we just allocated */
+		sv->sv_i.sfi_indirect = idblock;
+
+		/* Mark the inode dirty */
+		sv->sv_dirty = 1;
+
+		/* Clear the indirect block buffer */
+		bzero(idbuf, sizeof(idbuf));
+	}
+	else {
+		/*
+		 * We already have an indirect block allocated; load it.
+		 */
+		result = sfs_rblock(sfs, idbuf, idblock);
+		if (result) {
+			return result;
+		}
+	}
+
+	/* Get the block out of the indirect block buffer */
+	block = idbuf[idoff];
+
+	/* If there's no block there, allocate one */
+	if (block==0 && doalloc) {
+		result = sfs_balloc(sfs, &block);
+		if (result) {
+			return result;
+		}
+
+		/* Remember the block we allocated */
+		idbuf[idoff] = block;
+
+		/* The indirect block is now dirty; write it back */
+		result = sfs_wblock(sfs, idbuf, idblock);
+		if (result) {
+			return result;
+		}
+	}
+
+	/* Hand back the result and return. */
+	if (block != 0 && !sfs_bused(sfs, block)) {
+		panic("sfs: Data block %u (block %u of file %u) marked free\n",
+		      block, fileblock, sv->sv_ino);
+	}
+	*diskblock = block;
+	return 0;
+}
+
+////////////////////////////////////////////////////////////
+//
+// File-level I/O
+
+/*
+ * Do I/O to a block of a file that doesn't cover the whole block.  We
+ * need to read in the original block first, even if we're writing, so
+ * we don't clobber the portion of the block we're not intending to
+ * write over.
+ *
+ * skipstart is the number of bytes to skip past at the beginning of
+ * the sector; len is the number of bytes to actually read or write.
+ * uio is the area to do the I/O into.
+ */
+static
+int
+sfs_partialio(struct sfs_vnode *sv, struct uio *uio,
+	      u_int32_t skipstart, u_int32_t len)
+{
+	/*
+	 * I/O buffer for handling partial sectors.
+	 *
+	 * Note: in real life (and when you've done the fs assignment)
+	 * you would get space from the disk buffer cache for this,
+	 * not use a static area.
+	 */
+	static char iobuf[SFS_BLOCKSIZE];
+
+	struct sfs_fs *sfs = sv->sv_v.vn_fs->fs_data;
+	u_int32_t diskblock;
+	u_int32_t fileblock;
+	int result;
+	
+	/* Allocate missing blocks if and only if we're writing */
+	int doalloc = (uio->uio_rw==UIO_WRITE);
+
+	assert(skipstart + len <= SFS_BLOCKSIZE);
+
+	/* Compute the block offset of this block in the file */
+	fileblock = uio->uio_offset / SFS_BLOCKSIZE;
+
+	/* Get the disk block number */
+	result = sfs_bmap(sv, fileblock, doalloc, &diskblock);
+	if (result) {
+		return result;
+	}
+
+	if (diskblock == 0) {
+		/*
+		 * There was no block mapped at this point in the file.
+		 * Zero the buffer.
+		 */
+		assert(uio->uio_rw == UIO_READ);
+		bzero(iobuf, sizeof(iobuf));
+	}
+	else {
+		/*
+		 * Read the block.
+		 */
+		result = sfs_rblock(sfs, iobuf, diskblock);
+		if (result) {
+			return result;
+		}
+	}
+
+	/*
+	 * Now perform the requested operation into/out of the buffer.
+	 */
+	result = uiomove(iobuf+skipstart, len, uio);
+	if (result) {
+		return result;
+	}
+
+	/*
+	 * If it was a write, write back the modified block.
+	 */
+	if (uio->uio_rw == UIO_WRITE) {
+		result = sfs_wblock(sfs, iobuf, diskblock);
+		if (result) {
+			return result;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Do I/O (either read or write) of a single whole block.
+ */
+static
+int
+sfs_blockio(struct sfs_vnode *sv, struct uio *uio)
+{
+	struct sfs_fs *sfs = sv->sv_v.vn_fs->fs_data;
+	u_int32_t diskblock;
+	u_int32_t fileblock;
+	int result;
+	int doalloc = (uio->uio_rw==UIO_WRITE);
+	off_t saveoff;
+	off_t diskoff;
+	off_t saveres;
+	off_t diskres;
+
+	/* Get the block number within the file */
+	fileblock = uio->uio_offset / SFS_BLOCKSIZE;
+
+	/* Look up the disk block number */
+	result = sfs_bmap(sv, fileblock, doalloc, &diskblock);
+	if (result) {
+		return result;
+	}
+
+	if (diskblock == 0) {
+		/*
+		 * No block - fill with zeros.
+		 *
+		 * We must be reading, or sfs_bmap would have
+		 * allocated a block for us.
+		 */
+		assert(uio->uio_rw == UIO_READ);
+		return uiomovezeros(SFS_BLOCKSIZE, uio);
+	}
+
+	/*
+	 * Do the I/O directly to the uio region. Save the uio_offset,
+	 * and substitute one that makes sense to the device.
+	 */
+	saveoff = uio->uio_offset;
+	diskoff = diskblock * SFS_BLOCKSIZE;
+	uio->uio_offset = diskoff;
+
+	/*
+	 * Temporarily set the residue to be one block size.
+	 */
+	assert(uio->uio_resid >= SFS_BLOCKSIZE);
+	saveres = uio->uio_resid;
+	diskres = SFS_BLOCKSIZE;
+	uio->uio_resid = diskres;
+	
+	result = sfs_rwblock(sfs, uio);
+
+	/*
+	 * Now, restore the original uio_offset and uio_resid and update 
+	 * them by the amount of I/O done.
+	 */
+	uio->uio_offset = (uio->uio_offset - diskoff) + saveoff;
+	uio->uio_resid = (uio->uio_resid - diskres) + saveres;
+
+	return result;
+}
+
+/*
+ * Do I/O of a whole region of data, whether or not it's block-aligned.
+ */
+static
+int
+sfs_io(struct sfs_vnode *sv, struct uio *uio)
+{
+	u_int32_t blkoff;
+	u_int32_t nblocks, i;
+	int result = 0;
+	u_int32_t extraresid = 0;
+
+	/*
+	 * If reading, check for EOF. If we can read a partial area,
+	 * remember how much extra there was in EXTRARESID so we can
+	 * add it back to uio_resid at the end.
+	 */
+	if (uio->uio_rw == UIO_READ) {
+		off_t size = sv->sv_i.sfi_size;
+		off_t endpos = uio->uio_offset + uio->uio_resid;
+
+		if (uio->uio_offset >= size) {
+			/* At or past EOF - just return */
+			return 0;
+		}
+
+		if (endpos > size) {
+			extraresid = endpos - size;
+			assert(uio->uio_resid > extraresid);
+			uio->uio_resid -= extraresid;
+		}
+	}
+
+	/*
+	 * First, do any leading partial block.
+	 */
+	blkoff = uio->uio_offset % SFS_BLOCKSIZE;
+	if (blkoff != 0) {
+		/* Number of bytes at beginning of block to skip */
+		u_int32_t skip = blkoff;
+
+		/* Number of bytes to read/write after that point */
+		u_int32_t len = SFS_BLOCKSIZE - blkoff;
+
+		/* ...which might be less than the rest of the block */
+		if (len > uio->uio_resid) {
+			len = uio->uio_resid;
+		}
+
+		/* Call sfs_partialio() to do it. */
+		result = sfs_partialio(sv, uio, skip, len);
+		if (result) {
+			goto out;
+		}
+	}
+
+	/* If we're done, quit. */
+	if (uio->uio_resid==0) {
+		goto out;
+	}
+
+	/*
+	 * Now we should be block-aligned. Do the remaining whole blocks.
+	 */
+	assert(uio->uio_offset % SFS_BLOCKSIZE == 0);
+	nblocks = uio->uio_resid / SFS_BLOCKSIZE;
+	for (i=0; i<nblocks; i++) {
+		result = sfs_blockio(sv, uio);
+		if (result) {
+			goto out;
+		}
+	}
+
+	/*
+	 * Now do any remaining partial block at the end.
+	 */
+	assert(uio->uio_resid < SFS_BLOCKSIZE);
+
+	if (uio->uio_resid > 0) {
+		result = sfs_partialio(sv, uio, 0, uio->uio_resid);
+		if (result) {
+			goto out;
+		}
+	}
+
+ out:
+
+	/* If writing, adjust file length */
+	if (uio->uio_rw == UIO_WRITE && 
+	    uio->uio_offset > (off_t)sv->sv_i.sfi_size) {
+		sv->sv_i.sfi_size = uio->uio_offset;
+		sv->sv_dirty = 1;
+	}
+
+	/* Add in any extra amount we couldn't read because of EOF */
+	uio->uio_resid += extraresid;
+
+	/* Done */
+	return result;
+}
+
+////////////////////////////////////////////////////////////
+//
+// Directory I/O
+
+/*
+ * Read the directory entry out of slot SLOT of a directory vnode.
+ * The "slot" is the index of the directory entry, starting at 0.
+ */
+static
+int
+sfs_readdir(struct sfs_vnode *sv, struct sfs_dir *sd, int slot)
+{
+	struct uio ku;
+	off_t actualpos;
+	int result;
+
+	/* Compute the actual position in the directory to read. */
+	actualpos = slot * sizeof(struct sfs_dir);
+
+	/* Set up a uio to do the read */ 
+	mk_kuio(&ku, sd, sizeof(struct sfs_dir), actualpos, UIO_READ);
+
+	/* do it */
+	result = sfs_io(sv, &ku);
+	if (result) {
+		return result;
+	}
+
+	/* We should not hit EOF in the middle of a directory entry */
+	if (ku.uio_resid > 0) {
+		panic("sfs: readdir: Short entry (inode %u)\n", sv->sv_ino);
+	}
+
+	/* Done */
+	return 0;
+}
+
+/*
+ * Write (overwrite) the directory entry in slot SLOT of a directory
+ * vnode.
+ */
+static
+int
+sfs_writedir(struct sfs_vnode *sv, struct sfs_dir *sd, int slot)
+{
+	struct uio ku;
+	off_t actualpos;
+	int result;
+
+	/* Compute the actual position in the directory. */
+	assert(slot>=0);
+	actualpos = slot * sizeof(struct sfs_dir);
+
+	/* Set up a uio to do the write */ 
+	mk_kuio(&ku, sd, sizeof(struct sfs_dir), actualpos, UIO_WRITE);
+
+	/* do it */
+	result = sfs_io(sv, &ku);
+	if (result) {
+		return result;
+	}
+
+	/* Should not end up with a partial entry! */
+	if (ku.uio_resid > 0) {
+		panic("sfs: writedir: Short write (ino %u)\n", sv->sv_ino);
+	}
+
+	/* Done */
+	return 0;
+}
+
+/*
+ * Compute the number of entries in a directory.
+ * This actually computes the number of existing slots, and does not
+ * account for empty slots.
+ */
+static
+int
+sfs_dir_nentries(struct sfs_vnode *sv)
+{
+	off_t size;
+
+	assert(sv->sv_i.sfi_type == SFS_TYPE_DIR);
+
+	size = sv->sv_i.sfi_size;
+	if (size % sizeof(struct sfs_dir) != 0) {
+		panic("sfs: directory %u: Invalid size %u\n",
+		      sv->sv_ino, size);
+	}
+
+	return size / sizeof(struct sfs_dir);
+}
+
+/*
+ * Search a directory for a particular filename in a directory, and
+ * return its inode number, its slot, and/or the slot number of an
+ * empty directory slot if one is found.
+ */
+
+static
+int
+sfs_dir_findname(struct sfs_vnode *sv, const char *name,
+		    u_int32_t *ino, int *slot, int *emptyslot)
+{
+	struct sfs_dir tsd;
+	int found = 0;
+	int nentries = sfs_dir_nentries(sv);
+	int i, result;
+
+	/* For each slot... */
+	for (i=0; i<nentries; i++) {
+
+		/* Read the entry from that slot */
+		result = sfs_readdir(sv, &tsd, i);
+		if (result) {
+			return result;
+		}
+		if (tsd.sfd_ino == SFS_NOINO) {
+			/* Free slot - report it back if one was requested */
+			if (emptyslot != NULL) {
+				*emptyslot = i;
+			}
+		}
+		else {
+			/* Ensure null termination, just in case */
+			tsd.sfd_name[sizeof(tsd.sfd_name)-1] = 0;
+			if (!strcmp(tsd.sfd_name, name)) {
+
+				/* Each name may legally appear only once... */
+				assert(found==0);
+
+				found = 1;
+				if (slot != NULL) {
+					*slot = i;
+				}
+				if (ino != NULL) {
+					*ino = tsd.sfd_ino;
+				}
+			}
+		}
+	}
+
+	return found ? 0 : ENOENT;
+}
+
+/*
+ * Create a link in a directory to the specified inode by number, with
+ * the specified name, and optionally hand back the slot.
+ */
+static
+int
+sfs_dir_link(struct sfs_vnode *sv, const char *name, u_int32_t ino, int *slot)
+{
+	int emptyslot = -1;
+	int result;
+	struct sfs_dir sd;
+
+	/* Look up the name. We want to make sure it *doesn't* exist. */
+	result = sfs_dir_findname(sv, name, NULL, NULL, &emptyslot);
+	if (result!=0 && result!=ENOENT) {
+		return result;
+	}
+	if (result==0) {
+		return EEXIST;
+	}
+
+	if (strlen(name)+1 > sizeof(sd.sfd_name)) {
+		return ENAMETOOLONG;
+	}
+
+	/* If we didn't get an empty slot, add the entry at the end. */
+	if (emptyslot < 0) {
+		emptyslot = sfs_dir_nentries(sv);
+	}
+
+	/* Set up the entry. */
+	bzero(&sd, sizeof(sd));
+	sd.sfd_ino = ino;
+	strcpy(sd.sfd_name, name);
+
+	/* Hand back the slot, if so requested. */
+	if (slot) {
+		*slot = emptyslot;
+	}
+
+	/* Write the entry. */
+	return sfs_writedir(sv, &sd, emptyslot);
+	
+}
+
+/*
+ * Unlink a name in a directory, by slot number.
+ */
+static
+int
+sfs_dir_unlink(struct sfs_vnode *sv, int slot)
+{
+	struct sfs_dir sd;
+
+	/* Initialize a suitable directory entry... */ 
+	bzero(&sd, sizeof(sd));
+	sd.sfd_ino = SFS_NOINO;
+
+	/* ... and write it */
+	return sfs_writedir(sv, &sd, slot);
+}
+
+/*
+ * Look for a name in a directory and hand back a vnode for the
+ * file, if there is one.
+ */
+static
+int
+sfs_lookonce(struct sfs_vnode *sv, const char *name, 
+		struct sfs_vnode **ret,
+		int *slot)
+{
+	struct sfs_fs *sfs = sv->sv_v.vn_fs->fs_data;
+	u_int32_t ino;
+	int result;
+
+	result = sfs_dir_findname(sv, name, &ino, slot, NULL);
+	if (result) {
+		return result;
+	}
+
+	result = sfs_loadvnode(sfs, ino, SFS_TYPE_INVAL, ret);
+	if (result) {
+		return result;
+	}
+
+	if ((*ret)->sv_i.sfi_linkcount == 0) {
+		panic("sfs: Link count of file %u found in dir %u is 0\n",
+		      (*ret)->sv_ino, sv->sv_ino);
+	}
+
+	return 0;
+}
+
+////////////////////////////////////////////////////////////
+//
+// Object creation
+
+/*
+ * Create a new filesystem object and hand back its vnode.
+ */
+static
+int
+sfs_makeobj(struct sfs_fs *sfs, int type, struct sfs_vnode **ret)
+{
+	u_int32_t ino;
+	int result;
+
+	/*
+	 * First, get an inode. (Each inode is a block, and the inode 
+	 * number is the block number, so just get a block.)
+	 */
+
+	result = sfs_balloc(sfs, &ino);
+	if (result) {
+		return result;
+	}
+
+	/*
+	 * Now load a vnode for it.
+	 */
+
+	return sfs_loadvnode(sfs, ino, type, ret);
+}
+
+////////////////////////////////////////////////////////////
+//
+// Vnode ops
+
+/*
+ * This is called on *each* open().
+ */
+static
+int
+sfs_open(struct vnode *v, int openflags)
+{
+	/*
+	 * At this level we do not need to handle O_CREAT, O_EXCL, or O_TRUNC.
+	 * We *would* need to handle O_APPEND, but we don't support it.
+	 *
+	 * Any of O_RDONLY, O_WRONLY, and O_RDWR are valid, so we don't need
+	 * to check that either.
+	 */
+
+	if (openflags & O_APPEND) {
+		return EUNIMP;
+	}
+
+	(void)v;
+
+	return 0;
+}
+
+/*
+ * This is called on *each* open() of a directory.
+ * Directories may only be open for read.
+ */
+static
+int
+sfs_opendir(struct vnode *v, int openflags)
+{
+	switch (openflags & O_ACCMODE) {
+	    case O_RDONLY:
+		break;
+	    case O_WRONLY:
+	    case O_RDWR:
+	    default:
+		return EISDIR;
+	}
+	if (openflags & O_APPEND) {
+		return EISDIR;
+	}
+
+	(void)v;
+	return 0;
+}
+
+/*
+ * Called on the *last* close().
+ *
+ * This function should attempt to avoid returning errors, as handling
+ * them usefully is often not possible.
+ */
+static
+int
+sfs_close(struct vnode *v)
+{
+	/* Sync it. */
+	return VOP_FSYNC(v);
+}
+
+/*
+ * Called when the vnode refcount (in-memory usage count) hits zero.
+ *
+ * This function should try to avoid returning errors other than EBUSY.
+ */
+static
+int
+sfs_reclaim(struct vnode *v)
+{
+	struct sfs_vnode *sv = v->vn_data;
+	struct sfs_fs *sfs = v->vn_fs->fs_data;
+	int ix, i, num, result;
+
+	/*
+	 * Make sure someone else hasn't picked up the vnode since the
+	 * decision was made to reclaim it. (You must also synchronize
+	 * this with sfs_loadvnode.)
+	 */
+	lock_acquire(v->vn_countlock);
+	if (v->vn_refcount != 1) {
+
+		/* consume the reference VOP_DECREF gave us */
+		assert(v->vn_refcount>1);
+		v->vn_refcount--;
+
+		lock_release(v->vn_countlock);
+		return EBUSY;
+	}
+	lock_release(v->vn_countlock);
+	
+
+	/* If there are no on-disk references to the file either, erase it. */
+	if (sv->sv_i.sfi_linkcount==0) {
+		result = VOP_TRUNCATE(&sv->sv_v, 0);
+		if (result) {
+			return result;
+		}
+	}
+
+	/* Sync the inode to disk */
+	result = sfs_sync_inode(sv);
+	if (result) {
+		return result;
+	}
+
+	/* If there are no on-disk references, discard the inode */
+	if (sv->sv_i.sfi_linkcount==0) {
+		sfs_bfree(sfs, sv->sv_ino);
+	}
+
+	/* Remove the vnode structure from the table in the struct sfs_fs. */
+	ix = -1;
+	num = array_getnum(sfs->sfs_vnodes);
+	for (i=0; i<num; i++) {
+		struct sfs_vnode *sv2 = array_getguy(sfs->sfs_vnodes, i);
+		if (sv2==sv) {
+			ix = i;
+			break;
+		}
+	}
+	if (ix<0) {
+		panic("sfs: reclaim vnode %u not in vnode pool\n",
+		      sv->sv_ino);
+	}
+	array_remove(sfs->sfs_vnodes, ix);
+
+	VOP_KILL(&sv->sv_v);
+
+	/* Release the storage for the vnode structure itself. */
+	kfree(sv);
+
+	/* Done */
+	return 0;
+}
+
+/*
+ * Called for read(). sfs_io() does the work.
+ */
+static
+int
+sfs_read(struct vnode *v, struct uio *uio)
+{
+	struct sfs_vnode *sv = v->vn_data;
+	assert(uio->uio_rw==UIO_READ);
+	return sfs_io(sv, uio);
+}
+
+/*
+ * Called for write(). sfs_io() does the work.
+ */
+static
+int
+sfs_write(struct vnode *v, struct uio *uio)
+{
+	struct sfs_vnode *sv = v->vn_data;
+	assert(uio->uio_rw==UIO_WRITE);
+	return sfs_io(sv, uio);
+}
+
+/*
+ * Called for ioctl()
+ */
+static
+int
+sfs_ioctl(struct vnode *v, int op, userptr_t data)
+{
+	/*
+	 * No ioctls.
+	 */
+
+	(void)v;
+	(void)op;
+	(void)data;
+
+	return EINVAL;
+}
+
+/*
+ * Called for stat/fstat/lstat.
+ */
+static
+int
+sfs_stat(struct vnode *v, struct stat *statbuf)
+{
+	struct sfs_vnode *sv = v->vn_data;
+	int result;
+
+	/* Fill in the stat structure */
+	bzero(statbuf, sizeof(struct stat));
+
+	result = VOP_GETTYPE(v, &statbuf->st_mode);
+	if (result) {
+		return result;
+	}
+
+	statbuf->st_size = sv->sv_i.sfi_size;
+
+	/* We don't support these yet; you get to implement them */
+	statbuf->st_nlink = 0;
+	statbuf->st_blocks = 0;
+
+	return 0;
+}
+
+/*
+ * Return the type of the file (types as per kern/stat.h)
+ */
+static
+int
+sfs_gettype(struct vnode *v, int *ret)
+{
+	struct sfs_vnode *sv = v->vn_data;
+	switch (sv->sv_i.sfi_type) {
+	case SFS_TYPE_FILE:
+		*ret = S_IFREG;
+		return 0;
+	case SFS_TYPE_DIR:
+		*ret = S_IFDIR;
+		return 0;
+	}
+	panic("sfs: gettype: Invalid inode type (inode %u, type %u)\n",
+	      sv->sv_ino, sv->sv_i.sfi_type);
+	return EINVAL;
+}
+
+/*
+ * Check for legal seeks on files. Allow anything non-negative.
+ * We could conceivably, here, prohibit seeking past the maximum
+ * file size our inode structure can support, but we don't - few
+ * people ever bother to check lseek() for failure and having 
+ * read() or write() fail is sufficient.
+ */
+static
+int
+sfs_tryseek(struct vnode *v, off_t pos)
+{
+	if (pos<0) {
+		return EINVAL;
+	}
+
+	/* Allow anything else */
+	(void)v;
+
+	return 0;
+}
+
+/*
+ * Called for fsync(), and also on filesystem unmount, global sync(),
+ * and some other cases.
+ */
+static
+int
+sfs_fsync(struct vnode *v)
+{
+	struct sfs_vnode *sv = v->vn_data;
+	return sfs_sync_inode(sv);
+}
+
+/*
+ * Called for mmap().
+ */
+static
+int
+sfs_mmap(struct vnode *v   /* add stuff as needed */)
+{
+	(void)v;
+	return EUNIMP;
+}
+
+/*
+ * Called for ftruncate() and from sfs_reclaim.
+ */
+static
+int
+sfs_truncate(struct vnode *v, off_t len)
+{
+	/*
+	 * I/O buffer for handling the indirect block.
+	 *
+	 * Note: in real life (and when you've done the fs assignment)
+	 * you would get space from the disk buffer cache for this,
+	 * not use a static area.
+	 */
+	static u_int32_t idbuf[SFS_DBPERIDB];
+
+	struct sfs_vnode *sv = v->vn_data;
+	struct sfs_fs *sfs = sv->sv_v.vn_fs->fs_data;
+
+	/* Length in blocks (divide rounding up) */
+	u_int32_t blocklen = DIVROUNDUP(len, SFS_BLOCKSIZE);
+
+	u_int32_t i, j, block;
+	u_int32_t idblock, baseblock, highblock;
+	int result;
+	int hasnonzero, iddirty;
+
+	assert(sizeof(idbuf)==SFS_BLOCKSIZE);
+
+	/*
+	 * Go through the direct blocks. Discard any that are
+	 * past the limit we're truncating to.
+	 */
+	for (i=0; i<SFS_NDIRECT; i++) {
+		block = sv->sv_i.sfi_direct[i];
+		if (i >= blocklen && block != 0) {
+			sfs_bfree(sfs, block);
+			sv->sv_i.sfi_direct[i] = 0;
+			sv->sv_dirty = 1;
+		}
+	}
+
+	/* Indirect block number */
+	idblock = sv->sv_i.sfi_indirect;
+
+	/* The lowest block in the indirect block */
+	baseblock = SFS_NDIRECT;
+
+	/* The highest block in the indirect block */
+	highblock = baseblock + SFS_DBPERIDB - 1;
+
+	if (blocklen < highblock && idblock != 0) {
+		/* We're past the proposed EOF; may need to free stuff */
+
+		/* Read the indirect block */
+		result = sfs_rblock(sfs, idbuf, idblock);
+		if (result) {
+			return result;
+		}
+		
+		hasnonzero = 0;
+		iddirty = 0;
+		for (j=0; j<SFS_DBPERIDB; j++) {
+			/* Discard any blocks that are past the new EOF */
+			if (blocklen < baseblock+j && idbuf[j] != 0) {
+				sfs_bfree(sfs, idbuf[j]);
+				idbuf[j] = 0;
+				iddirty = 1;
+			}
+			/* Remember if we see any nonzero blocks in here */
+			if (idbuf[j]!=0) {
+				hasnonzero=1;
+			}
+		}
+
+		if (!hasnonzero) {
+			/* The whole indirect block is empty now; free it */
+			sfs_bfree(sfs, idblock);
+			sv->sv_i.sfi_indirect = 0;
+			sv->sv_dirty = 1;
+		}
+		else if (iddirty) {
+			/* The indirect block is dirty; write it back */
+			result = sfs_wblock(sfs, idbuf, idblock);
+			if (result) {
+				return result;
+			}
+		}
+	}
+
+	/* Set the file size */
+	sv->sv_i.sfi_size = len;
+
+	/* Mark the inode dirty */
+	sv->sv_dirty = 1;
+	
+	return 0;
+}
+
+/*
+ * Get the full pathname for a file. This only needs to work on directories.
+ * Since we don't support subdirectories, assume it's the root directory
+ * and hand back the empty string. (The VFS layer takes care of the
+ * device name, leading slash, etc.)
+ */
+static
+int
+sfs_namefile(struct vnode *vv, struct uio *uio)
+{
+	struct sfs_vnode *sv = vv->vn_data;
+	assert(sv->sv_ino == SFS_ROOT_LOCATION);
+
+	/* send back the empty string - just return */
+
+	(void)uio;
+
+	return 0;
+}
+
+/*
+ * Create a file. If EXCL is set, insist that the filename not already
+ * exist; otherwise, if it already exists, just open it.
+ */
+static
+int
+sfs_creat(struct vnode *v, const char *name, int excl, struct vnode **ret)
+{
+	struct sfs_fs *sfs = v->vn_fs->fs_data;
+	struct sfs_vnode *sv = v->vn_data;
+	struct sfs_vnode *newguy;
+	u_int32_t ino;
+	int result;
+
+	/* Look up the name */
+	result = sfs_dir_findname(sv, name, &ino, NULL, NULL);
+	if (result!=0 && result!=ENOENT) {
+		return result;
+	}
+
+	/* If it exists and we didn't want it to, fail */
+	if (result==0 && excl) {
+		return EEXIST;
+	}
+
+	if (result==0) {
+		/* We got a file; load its vnode and return */
+		result = sfs_loadvnode(sfs, ino, SFS_TYPE_INVAL, &newguy);
+		if (result) {
+			return result;
+		}
+		*ret = &newguy->sv_v;
+		return 0;
+	}
+
+	/* Didn't exist - create it */
+	result = sfs_makeobj(sfs, SFS_TYPE_FILE, &newguy);
+	if (result) {
+		return result;
+	}
+
+	/* Link it into the directory */
+	result = sfs_dir_link(sv, name, newguy->sv_ino, NULL);
+	if (result) {
+		VOP_DECREF(&newguy->sv_v);
+		return result;
+	}
+
+	/* Update the linkcount of the new file */
+	newguy->sv_i.sfi_linkcount++;
+
+	/* and consequently mark it dirty. */
+	newguy->sv_dirty = 1;
+
+	*ret = &newguy->sv_v;
+	
+	return 0;
+}
+
+/*
+ * Make a hard link to a file.
+ * The VFS layer should prevent this being called unless both
+ * vnodes are ours.
+ */
+static
+int
+sfs_link(struct vnode *dir, const char *name, struct vnode *file)
+{
+	struct sfs_vnode *sv = dir->vn_data;
+	struct sfs_vnode *f = file->vn_data;
+	int result;
+
+	assert(file->vn_fs == dir->vn_fs);
+
+	/* Just create a link */
+	result = sfs_dir_link(sv, name, f->sv_ino, NULL);
+	if (result) {
+		return result;
+	}
+
+	/* and update the link count, marking the inode dirty */
+	f->sv_i.sfi_linkcount++;
+	f->sv_dirty = 1;
+
+	return 0;
+}
+
+/*
+ * Delete a file.
+ */
+static
+int
+sfs_remove(struct vnode *dir, const char *name)
+{
+	struct sfs_vnode *sv = dir->vn_data;
+	struct sfs_vnode *victim;
+	int slot;
+	int result;
+
+	/* Look for the file and fetch a vnode for it. */
+	result = sfs_lookonce(sv, name, &victim, &slot);
+	if (result) {
+		return result;
+	}
+
+	/* Erase its directory entry. */
+	result = sfs_dir_unlink(sv, slot);
+	if (result==0) {
+		/* If we succeeded, decrement the link count. */
+		assert(victim->sv_i.sfi_linkcount > 0);
+		victim->sv_i.sfi_linkcount--;
+		victim->sv_dirty = 1;
+	}
+
+	/* Discard the reference that sfs_lookonce got us */
+	VOP_DECREF(&victim->sv_v);
+
+	return result;
+}
+
+/*
+ * Rename a file.
+ *
+ * Since we don't support subdirectories, assumes that the two
+ * directories passed are the same.
+ */
+static
+int
+sfs_rename(struct vnode *d1, const char *n1, 
+	   struct vnode *d2, const char *n2)
+{
+	struct sfs_vnode *sv = d1->vn_data;
+	struct sfs_vnode *g1;
+	int slot1, slot2;
+	int result, result2;
+
+	assert(d1==d2);
+	assert(sv->sv_ino == SFS_ROOT_LOCATION);
+
+	/* Look up the old name of the file and get its inode and slot number*/
+	result = sfs_lookonce(sv, n1, &g1, &slot1);
+	if (result) {
+		return result;
+	}
+
+	/* We don't support subdirectories */
+	assert(g1->sv_i.sfi_type == SFS_TYPE_FILE);
+
+	/*
+	 * Link it under the new name.
+	 *
+	 * We could theoretically just overwrite the original
+	 * directory entry, except that we need to check to make sure
+	 * the new name doesn't already exist; might as well use the
+	 * existing link routine.
+	 */
+	result = sfs_dir_link(sv, n2, g1->sv_ino, &slot2);
+	if (result) {
+		goto puke;
+	}
+	
+	/* Increment the link count, and mark inode dirty */
+	g1->sv_i.sfi_linkcount++;
+	g1->sv_dirty = 1;
+
+	/* Unlink the old slot */
+	result = sfs_dir_unlink(sv, slot1);
+	if (result) {
+		goto puke_harder;
+	}
+
+	/*
+	 * Decrement the link count again, and mark the inode dirty again,
+	 * in case it's been synced behind our back.
+	 */
+	assert(g1->sv_i.sfi_linkcount>0);
+	g1->sv_i.sfi_linkcount--;
+	g1->sv_dirty = 1;
+
+	/* Let go of the reference to g1 */
+	VOP_DECREF(&g1->sv_v);
+
+	return 0;
+
+ puke_harder:
+	/*
+	 * Error recovery: try to undo what we already did
+	 */
+	result2 = sfs_dir_unlink(sv, slot2);
+	if (result2) {
+		kprintf("sfs: rename: %s\n", strerror(result));
+		kprintf("sfs: rename: while cleaning up: %s\n", 
+			strerror(result2));
+		panic("sfs: rename: Cannot recover\n");
+	}
+	g1->sv_i.sfi_linkcount--;
+ puke:
+	/* Let go of the reference to g1 */
+	VOP_DECREF(&g1->sv_v);
+	return result;
+}
+
+/*
+ * lookparent returns the last path component as a string and the
+ * directory it's in as a vnode.
+ *
+ * Since we don't support subdirectories, this is very easy - 
+ * return the root dir and copy the path.
+ */
+static
+int
+sfs_lookparent(struct vnode *v, char *path, struct vnode **ret,
+		  char *buf, size_t buflen)
+{
+	struct sfs_vnode *sv = v->vn_data;
+
+	if (sv->sv_i.sfi_type != SFS_TYPE_DIR) {
+		return ENOTDIR;
+	}
+
+	if (strlen(path)+1 > buflen) {
+		return ENAMETOOLONG;
+	}
+	strcpy(buf, path);
+
+	VOP_INCREF(&sv->sv_v);
+	*ret = &sv->sv_v;
+
+	return 0;
+}
+
+/*
+ * Lookup gets a vnode for a pathname.
+ *
+ * Since we don't support subdirectories, it's easy - just look up the
+ * name.
+ */
+static
+int
+sfs_lookup(struct vnode *v, char *path, struct vnode **ret)
+{
+	struct sfs_vnode *sv = v->vn_data;
+	struct sfs_vnode *final;
+	int result;
+
+	if (sv->sv_i.sfi_type != SFS_TYPE_DIR) {
+		return ENOTDIR;
+	}
+	
+	result = sfs_lookonce(sv, path, &final, NULL);
+	if (result) {
+		return result;
+	}
+
+	*ret = &final->sv_v;
+
+	return 0;
+}
+
+//////////////////////////////////////////////////
+
+static
+int
+sfs_notdir(void)
+{
+	return ENOTDIR;
+}
+
+static
+int
+sfs_isdir(void)
+{
+	return EISDIR;
+}
+
+static
+int
+sfs_unimp(void)
+{
+	return EUNIMP;
+}
+
+/*
+ * Casting through void * prevents warnings.
+ * All of the vnode ops return int, and it's ok to cast functions that
+ * take args to functions that take no args.
+ */
+
+#define ISDIR ((void *)sfs_isdir)
+#define NOTDIR ((void *)sfs_notdir)
+#define UNIMP ((void *)sfs_unimp)
+
+/*
+ * Function table for sfs files.
+ */
+static const struct vnode_ops sfs_fileops = {
+	VOP_MAGIC,	/* mark this a valid vnode ops table */
+
+	sfs_open,
+	sfs_close,
+	sfs_reclaim,
+
+	sfs_read,
+	NOTDIR,  /* readlink */
+	NOTDIR,  /* getdirentry */
+	sfs_write,
+	sfs_ioctl,
+	sfs_stat,
+	sfs_gettype,
+	sfs_tryseek,
+	sfs_fsync,
+	sfs_mmap,
+	sfs_truncate,
+	NOTDIR,  /* namefile */
+
+	NOTDIR,  /* creat */
+	NOTDIR,  /* symlink */
+	NOTDIR,  /* mkdir */
+	NOTDIR,  /* link */
+	NOTDIR,  /* remove */
+	NOTDIR,  /* rmdir */
+	NOTDIR,  /* rename */
+
+	NOTDIR,  /* lookup */
+	NOTDIR,  /* lookparent */
+};
+
+/*
+ * Function table for the sfs directory.
+ */
+static const struct vnode_ops sfs_dirops = {
+	VOP_MAGIC,	/* mark this a valid vnode ops table */
+
+	sfs_opendir,
+	sfs_close,
+	sfs_reclaim,
+	
+	ISDIR,   /* read */
+	ISDIR,   /* readlink */
+	UNIMP,   /* getdirentry */
+	ISDIR,   /* write */
+	sfs_ioctl,
+	sfs_stat,
+	sfs_gettype,
+	UNIMP,   /* tryseek */
+	sfs_fsync,
+	ISDIR,   /* mmap */
+	ISDIR,   /* truncate */
+	sfs_namefile,
+
+	sfs_creat,
+	UNIMP,   /* symlink */
+	UNIMP,   /* mkdir */
+	sfs_link,
+	sfs_remove,
+	UNIMP,   /* rmdir */
+	sfs_rename,
+
+	sfs_lookup,
+	sfs_lookparent,
+};
+
+/*
+ * Function to load a inode into memory as a vnode, or dig up one
+ * that's already resident.
+ */
+static
+int
+sfs_loadvnode(struct sfs_fs *sfs, u_int32_t ino, int forcetype,
+		 struct sfs_vnode **ret)
+{
+	struct sfs_vnode *sv;
+	const struct vnode_ops *ops = NULL;
+	int i, num;
+	int result;
+
+	/* Look in the vnodes table */
+	num = array_getnum(sfs->sfs_vnodes);
+
+	/* Linear search. Is this too slow? You decide. */
+	for (i=0; i<num; i++) {
+		sv = array_getguy(sfs->sfs_vnodes, i);
+
+		/* Every inode in memory must be in an allocated block */
+		if (!sfs_bused(sfs, sv->sv_ino)) {
+			panic("sfs: Found inode %u in unallocated block\n",
+			      sv->sv_ino);
+		}
+
+		if (sv->sv_ino==ino) {
+			/* Found */
+
+			/* May only be set when creating new objects */
+			assert(forcetype==SFS_TYPE_INVAL);
+
+			VOP_INCREF(&sv->sv_v);
+			*ret = sv;
+			return 0;
+		}
+	}
+
+	/* Didn't have it loaded; load it */
+
+	sv = kmalloc(sizeof(struct sfs_vnode));
+	if (sv==NULL) {
+		return ENOMEM;
+	}
+
+	/* Must be in an allocated block */
+	if (!sfs_bused(sfs, ino)) {
+		panic("sfs: Tried to load inode %u from unallocated block\n",
+		      ino);
+	}
+
+	/* Read the block the inode is in */
+	result = sfs_rblock(sfs, &sv->sv_i, ino);
+	if (result) {
+		kfree(sv);
+		return result;
+	}
+
+	/* Not dirty yet */
+	sv->sv_dirty = 0;
+
+	/*
+	 * FORCETYPE is set if we're creating a new file, because the
+	 * block on disk will have been zeroed out and thus the type
+	 * recorded there will be SFS_TYPE_INVAL.
+	 */
+	if (forcetype != SFS_TYPE_INVAL) {
+		assert(sv->sv_i.sfi_type == SFS_TYPE_INVAL);
+		sv->sv_i.sfi_type = forcetype;
+		sv->sv_dirty = 1;
+	}
+
+	/*
+	 * Choose the function table based on the object type.
+	 */
+	switch (sv->sv_i.sfi_type) {
+	    case SFS_TYPE_FILE:
+		ops = &sfs_fileops;
+		break;
+	    case SFS_TYPE_DIR:
+		ops = &sfs_dirops;
+		break;
+	    default: 
+		panic("sfs: loadvnode: Invalid inode type "
+		      "(inode %u, type %u)\n",
+		      ino, sv->sv_i.sfi_type);
+	}
+
+	/* Call the common vnode initializer */
+	result = VOP_INIT(&sv->sv_v, ops, &sfs->sfs_absfs, sv);
+	if (result) {
+		kfree(sv);
+		return result;
+	}
+
+	/* Set the other fields in our vnode structure */
+	sv->sv_ino = ino;
+
+	/* Add it to our table */
+	result = array_add(sfs->sfs_vnodes, sv);
+	if (result) {
+		VOP_KILL(&sv->sv_v);
+		kfree(sv);
+		return result;
+	}
+
+	/* Hand it back */
+	*ret = sv;
+	return 0;
+}
+
+/*
+ * Get vnode for the root of the filesystem.
+ * The root vnode is always found in block 1 (SFS_ROOT_LOCATION).
+ */
+struct vnode *
+sfs_getroot(struct fs *fs)
+{
+	struct sfs_fs *sfs = fs->fs_data;
+	struct sfs_vnode *sv;
+	int result;
+
+	result = sfs_loadvnode(sfs, SFS_ROOT_LOCATION, SFS_TYPE_INVAL, &sv);
+	if (result) {
+		panic("sfs: getroot: Cannot load root vnode\n");
+	}
+
+	return &sv->sv_v;
+}
diff --git a/os161-1.10/kern/fs/vfs/device.c b/os161-1.10/kern/fs/vfs/device.c
new file mode 100644
index 0000000..869aca5
--- /dev/null
+++ b/os161-1.10/kern/fs/vfs/device.c
@@ -0,0 +1,415 @@
+/*
+ * Vnode operations for VFS devices.
+ *
+ * These hand off to the functions in the VFS device structure (see dev.h)
+ * but take care of a bunch of common tasks in a uniform fashion.
+ */
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <kern/errno.h>
+#include <kern/unistd.h>
+#include <kern/stat.h>
+#include <vnode.h>
+#include <uio.h>
+#include <dev.h>
+
+/*
+ * Called for each open().
+ *
+ * We reject O_APPEND.
+ */
+static
+int
+dev_open(struct vnode *v, int flags)
+{
+	struct device *d = v->vn_data;
+
+	if (flags & (O_CREAT | O_TRUNC | O_EXCL | O_APPEND)) {
+		return EINVAL;
+	}
+
+	return d->d_open(d, flags);
+}
+
+/*
+ * Called on the last close().
+ * Just pass through.
+ */
+static
+int
+dev_close(struct vnode *v)
+{
+	struct device *d = v->vn_data;
+	return d->d_close(d);
+}
+
+/*
+ * Called when the vnode refcount reaches zero.
+ * Do nothing; devices are permanent.
+ */
+static
+int
+dev_reclaim(struct vnode *v)
+{
+	(void)v;
+	/* nothing - device continues to exist even when not in use */
+	return 0;
+}
+
+/*
+ * Called for read. Hand off to d_io.
+ */
+static
+int
+dev_read(struct vnode *v, struct uio *uio)
+{
+	struct device *d = v->vn_data;
+	assert(uio->uio_rw == UIO_READ);
+	return d->d_io(d, uio);
+}
+
+/*
+ * Used for several functions with the same type signature that are
+ * not meaningful on devices.
+ */
+static
+int
+null_io(struct vnode *v, struct uio *uio)
+{
+	(void)v;
+	(void)uio;
+	return EINVAL;
+}
+
+/*
+ * Called for write. Hand off to d_io.
+ */
+static
+int
+dev_write(struct vnode *v, struct uio *uio)
+{
+	struct device *d = v->vn_data;
+	assert(uio->uio_rw == UIO_WRITE);
+	return d->d_io(d, uio);
+}
+
+/*
+ * Called for ioctl(). Just pass through.
+ */
+static
+int
+dev_ioctl(struct vnode *v, int op, userptr_t data)
+{
+	struct device *d = v->vn_data;
+	return d->d_ioctl(d, op, data);
+}
+
+/*
+ * Called for stat().
+ * Set the type and the size (block devices only).
+ * The link count for a device is always 1.
+ */
+static
+int
+dev_stat(struct vnode *v, struct stat *statbuf)
+{
+	struct device *d = v->vn_data;
+	int result;
+
+	bzero(statbuf, sizeof(struct stat));
+
+	result = VOP_GETTYPE(v, &statbuf->st_mode);
+	if (result) {
+		return result;
+	}
+
+	statbuf->st_nlink = 1;
+	statbuf->st_blocks = d->d_blocks;
+
+	if (d->d_blocks > 0) {
+		statbuf->st_size = d->d_blocks * d->d_blocksize;
+	}
+	else {
+		statbuf->st_size = 0;
+	}
+
+	return 0;
+}
+
+/*
+ * Return the type. A device is a "block device" if it has a known
+ * length. A device that generates data in a stream is a "character
+ * device".
+ */
+static
+int
+dev_gettype(struct vnode *v, int *ret)
+{
+	struct device *d = v->vn_data;
+	if (d->d_blocks > 0) {
+		*ret = S_IFBLK;
+	}
+	else {
+		*ret = S_IFCHR;
+	}
+	return 0;
+}
+
+/*
+ * Attempt a seek.
+ * For block devices, require block alignment.
+ * For character devices, prohibit seeking entirely.
+ */
+static
+int
+dev_tryseek(struct vnode *v, off_t pos)
+{
+	struct device *d = v->vn_data;
+	if (d->d_blocks > 0) {
+		if ((pos % d->d_blocksize)!=0) {
+			/* not block-aligned */
+			return EINVAL;
+		}
+		if (pos < 0) {
+			/* 
+			 * Nonsensical.
+			 * (note: off_t must be signed for SEEK_CUR or
+			 * SEEK_END seeks to work, so this case must
+			 * be checked.)
+			 */
+			return EINVAL;
+		}
+		if (pos / d->d_blocksize >= d->d_blocks) {
+			/* off the end */
+			return EINVAL;
+		}
+	}
+	else {
+		return ESPIPE;
+	}
+	return 0;
+}
+
+/*
+ * For fsync() - meaningless, do nothing.
+ */
+static
+int
+null_fsync(struct vnode *v)
+{
+	(void)v;
+	return 0;
+}
+
+/*
+ * For mmap. If you want this to do anything, you have to write it
+ * yourself. Some devices may not make sense to map. Others do.
+ */
+static
+int
+dev_mmap(struct vnode *v  /* add stuff as needed */)
+{
+	(void)v;
+	return EUNIMP;
+}
+
+/*
+ * For ftruncate(). 
+ */
+static
+int
+dev_truncate(struct vnode *v, off_t len)
+{
+	struct device *d = v->vn_data;
+
+	/*
+	 * Allow truncating to the object's own size, if it has one.
+	 */
+	if (d->d_blocks > 0 && (off_t)(d->d_blocks*d->d_blocksize) == len) {
+		return 0;
+	}
+
+	return EINVAL;
+}
+
+/*
+ * For namefile (which implements "pwd")
+ *
+ * This should never be reached, as it's not possible to chdir to a
+ * device vnode.
+ */
+static
+int
+dev_namefile(struct vnode *v, struct uio *uio)
+{
+	/*
+	 * The name of a device is always just "device:". The VFS
+	 * layer puts in the device name for us, so we don't need to
+	 * do anything further.
+	 */
+
+	(void)v;
+	(void)uio;
+
+	return 0;
+}
+
+/*
+ * Operations that are completely meaningless on devices.
+ */
+
+static
+int
+null_creat(struct vnode *v, const char *name, int excl, struct vnode **result)
+{
+	(void)v;
+	(void)name;
+	(void)excl;
+	(void)result;
+	return ENOTDIR;
+}
+
+static
+int
+null_symlink(struct vnode *v, const char *contents, const char *name)
+{
+	(void)v;
+	(void)contents;
+	(void)name;
+	return ENOTDIR;
+}
+
+static
+int
+null_nameop(struct vnode *v, const char *name)
+{
+	(void)v;
+	(void)name;
+	return ENOTDIR;
+}
+
+static
+int
+null_link(struct vnode *v, const char *name, struct vnode *file)
+{
+	(void)v;
+	(void)name;
+	(void)file;
+	return ENOTDIR;
+}
+
+static
+int
+null_rename(struct vnode *v, const char *n1, struct vnode *v2, const char *n2)
+{
+	(void)v;
+	(void)n1;
+	(void)v2;
+	(void)n2;
+	return ENOTDIR;
+}
+
+
+/*
+ * Name lookup.
+ *
+ * One interesting feature of device:name pathname syntax is that you can
+ * implement pathnames on arbitrary devices. For instance, if you had a
+ * serial port that actually let you control the RS232 settings (unlike
+ * the LAMEbus serial port), you might arrange things so that you could
+ * open it with pathnames like "ser:9600/n/8/1" in order to select the
+ * operating mode.
+ *
+ * However, we have no support for this in the base system.
+ */
+static
+int
+dev_lookup(struct vnode *dir, 
+	   char *pathname, struct vnode **result)
+{
+	/*
+	 * If the path was "device:", we get "". For that, return self.
+	 * Anything else is an error.
+	 * Increment the ref count of the vnode before returning it.
+	 */
+	if (strlen(pathname)>0) {
+		return ENOENT;
+	}
+	VOP_INCREF(dir);
+	*result = dir;
+	return 0;
+}
+
+static
+int
+dev_lookparent(struct vnode *dir, 
+	       char *pathname, struct vnode **result,
+	       char *namebuf, size_t buflen)
+{
+	/*
+	 * This is always an error.
+	 */
+	(void)dir;
+	(void)pathname;
+	(void)result;
+	(void)namebuf;
+	(void)buflen;
+
+	return ENOTDIR;
+}
+
+/*
+ * Function table for device vnodes.
+ */
+static const struct vnode_ops dev_vnode_ops = {
+	VOP_MAGIC,
+
+	dev_open,
+	dev_close,
+	dev_reclaim,
+	dev_read,
+	null_io,      /* readlink */
+	null_io,      /* getdirentry */
+	dev_write,
+	dev_ioctl,
+	dev_stat,
+	dev_gettype,
+	dev_tryseek,
+	null_fsync,
+	dev_mmap,
+	dev_truncate,
+	dev_namefile,
+	null_creat,
+	null_symlink,
+	null_nameop,  /* mkdir */
+	null_link,
+	null_nameop,  /* remove */
+	null_nameop,  /* rmdir */
+	null_rename,
+	dev_lookup,
+	dev_lookparent,
+};
+
+/*
+ * Function to create a vnode for a VFS device.
+ */
+struct vnode *
+dev_create_vnode(struct device *dev)
+{
+	int result;
+	struct vnode *v;
+
+	v = kmalloc(sizeof(struct vnode));
+	if (v==NULL) {
+		return NULL;
+	}
+
+	result = VOP_INIT(v, &dev_vnode_ops, NULL, dev);
+	if (result != 0) {
+		panic("While creating vnode for device: VOP_INIT: %s\n",
+		      strerror(result));
+	}
+
+	return v;
+}
diff --git a/os161-1.10/kern/fs/vfs/devnull.c b/os161-1.10/kern/fs/vfs/devnull.c
new file mode 100644
index 0000000..268479c
--- /dev/null
+++ b/os161-1.10/kern/fs/vfs/devnull.c
@@ -0,0 +1,96 @@
+/*
+ * Implementation of the null device, "null:", which generates an
+ * immediate EOF on read and throws away anything written to it.
+ */
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <vfs.h>
+#include <dev.h>
+#include <uio.h>
+
+/* For open() */
+static
+int
+nullopen(struct device *dev, int openflags)
+{
+	(void)dev;
+	(void)openflags;
+
+	return 0;
+}
+
+/* For close() */
+static
+int
+nullclose(struct device *dev)
+{
+	(void)dev;
+	return 0;
+}
+
+/* For d_io() */
+static
+int
+nullio(struct device *dev, struct uio *uio)
+{
+	/*
+	 * On write, discard everything without looking at it.
+	 * On read, do nothing, generating an immediate EOF.
+	 */
+
+	(void)dev; // unused
+
+	if (uio->uio_rw == UIO_WRITE) {
+		uio->uio_resid = 0;
+	}
+
+	return 0;
+}
+
+/* For ioctl() */
+static
+int
+nullioctl(struct device *dev, int op, userptr_t data)
+{
+	/*
+	 * No ioctls.
+	 */
+
+	(void)dev;
+	(void)op;
+	(void)data;
+
+	return EINVAL;
+}
+
+/*
+ * Function to create and attach null:
+ */
+void
+devnull_create(void)
+{
+	int result;
+	struct device *dev;
+
+	dev = kmalloc(sizeof(*dev));
+	if (dev==NULL) {
+		panic("Could not add null device: out of memory\n");
+	}
+
+	
+	dev->d_open = nullopen;
+	dev->d_close = nullclose;
+	dev->d_io = nullio;
+	dev->d_ioctl = nullioctl;
+
+	dev->d_blocks = 0;
+	dev->d_blocksize = 1;
+
+	dev->d_data = NULL;
+
+	result = vfs_adddev("null", dev, 0);
+	if (result) {
+		panic("Could not add null device: %s\n", strerror(result));
+	}
+}
diff --git a/os161-1.10/kern/fs/vfs/vfscwd.c b/os161-1.10/kern/fs/vfs/vfscwd.c
new file mode 100644
index 0000000..2b10c28
--- /dev/null
+++ b/os161-1.10/kern/fs/vfs/vfscwd.c
@@ -0,0 +1,151 @@
+/*
+ * VFS operations involving the current directory.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <kern/errno.h>
+#include <kern/stat.h>
+#include <vfs.h>
+#include <fs.h>
+#include <vnode.h>
+#include <uio.h>
+#include <thread.h>
+#include <curthread.h>
+
+/*
+ * Get current directory as a vnode.
+ * 
+ * We do not synchronize curthread->t_cwd, because it belongs exclusively
+ * to its own thread; no other threads should access it.
+ */
+int
+vfs_getcurdir(struct vnode **ret)
+{
+	int rv = 0;
+
+	if (curthread->t_cwd!=NULL) {
+		VOP_INCREF(curthread->t_cwd);
+		*ret = curthread->t_cwd;
+	}
+	else {
+		rv = ENOENT;
+	}
+
+	return rv;
+}
+
+/*
+ * Set current directory as a vnode.
+ * The passed vnode must in fact be a directory.
+ */
+int
+vfs_setcurdir(struct vnode *dir)
+{
+	struct vnode *old;
+	int vtype;
+	int result;
+
+	result = VOP_GETTYPE(dir, &vtype);
+	if (result) {
+		return result;
+	}
+	if (!S_ISDIR(vtype)) {
+		return ENOTDIR;
+	}
+
+	old = curthread->t_cwd;
+	curthread->t_cwd = dir;
+
+	if (old!=NULL) { 
+		VOP_DECREF(old);
+	}
+
+	return 0;
+}
+
+/*
+ * Set current directory to "none".
+ */
+int
+vfs_clearcurdir(void)
+{
+	struct vnode *old;
+
+	old = curthread->t_cwd;
+	curthread->t_cwd = NULL;
+
+	if (old!=NULL) { 
+		VOP_DECREF(old);
+	}
+
+	return 0;
+}
+
+/*
+ * Set current directory, as a pathname. Use vfs_lookup to translate
+ * it to a vnode.
+ */
+int
+vfs_chdir(char *path)
+{
+	struct vnode *vn;
+	int result;
+
+	result = vfs_lookup(path, &vn);
+	if (result) {
+		return result;
+	}
+	result = vfs_setcurdir(vn);
+	if (result) {
+		VOP_DECREF(vn);
+	}
+	return result;
+}
+
+/*
+ * Get current directory, as a pathname.
+ * Use VOP_NAMEFILE to get the pathname and FSOP_GETVOLNAME to get the
+ * volume name.
+ */
+int
+vfs_getcwd(struct uio *uio)
+{
+	struct vnode *cwd;
+	int result;
+	const char *name;
+	char colon=':';
+
+	assert(uio->uio_rw==UIO_READ);
+
+	result = vfs_getcurdir(&cwd);
+	if (result) {
+		return result;
+	}
+
+	/* The current dir must be a directory, and thus it is not a device. */
+	assert(cwd->vn_fs != NULL);
+
+	name = FSOP_GETVOLNAME(cwd->vn_fs);
+	if (name==NULL) {
+		name = vfs_getdevname(cwd->vn_fs);
+	}
+	assert(name != NULL);
+
+	result = uiomove((char *)name, strlen(name), uio);
+	if (result) {
+		goto out;
+	}
+	result = uiomove(&colon, 1, uio);
+	if (result) {
+		goto out;
+	}
+
+	result = VOP_NAMEFILE(cwd, uio);
+
+ out:
+
+	VOP_DECREF(cwd);
+	return result;
+}
diff --git a/os161-1.10/kern/fs/vfs/vfslist.c b/os161-1.10/kern/fs/vfs/vfslist.c
new file mode 100644
index 0000000..b127f42
--- /dev/null
+++ b/os161-1.10/kern/fs/vfs/vfslist.c
@@ -0,0 +1,589 @@
+/*
+ * VFS operations that involve the list of VFS (named) devices
+ * (the "dev" in "dev:path" syntax).
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <array.h>
+#include <kern/errno.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <fs.h>
+#include <dev.h>
+
+/*
+ * Structure for a single named device.
+ * 
+ * kd_name    - Name of device (eg, "lhd0"). Should always be set to
+ *              a valid string.
+ *
+ * kd_rawname - Name of raw device (eg, "lhd0raw"). Is non-NULL if and
+ *              only if this device can have a filesystem mounted on
+ *              it.
+ *
+ * kd_device  - Device object this name refers to. May be NULL if kd_fs
+ *              is hardwired.
+ *
+ * kd_fs      - Filesystem object mounted on, or associated with, this
+ *              device. NULL if there is no filesystem. 
+ *
+ * A filesystem can be associated with a device without having been
+ * mounted if the device was created that way. In this case,
+ * kd_rawname is NULL (prohibiting mount/unmount), and, as there is
+ * then no way to access kd_device, it will be NULL as well. This is
+ * intended for devices that are inherently filesystems, like emu0.
+ *
+ * Referencing kd_name, or the filesystem volume name, on a device
+ * with a filesystem mounted returns the root of the filesystem.
+ * Referencing kd_name on a mountable device with no filesystem
+ * returns ENXIO. Referencing kd_name on a device that is not
+ * mountable and has no filesystem, or kd_rawname on a mountable
+ * device, returns the device itself.
+ */
+
+struct knowndev {
+	char *kd_name;
+	char *kd_rawname;
+	struct device *kd_device;
+	struct vnode *kd_vnode;
+	struct fs *kd_fs;
+};
+
+static struct array *knowndevs;
+static struct lock *knowndevs_lock;
+
+/*
+ * Setup function
+ */
+void
+vfs_bootstrap(void)
+{
+	knowndevs = array_create();
+	if (knowndevs==NULL) {
+		panic("vfs: Could not create knowndevs array\n");
+	}
+	knowndevs_lock = lock_create("knowndevs");
+	if (knowndevs_lock==NULL) {
+		panic("vfs: Could not create knowndevs lock\n");
+	}
+
+	vfs_initbootfs();
+	devnull_create();
+}
+
+/*
+ * Global sync function - call FSOP_SYNC on all devices.
+ */
+int
+vfs_sync(void)
+{
+	struct knowndev *dev;
+	int i, num;
+
+	lock_acquire(knowndevs_lock);
+
+	num = array_getnum(knowndevs);
+	for (i=0; i<num; i++) {
+		dev = array_getguy(knowndevs, i);
+		if (dev->kd_fs != NULL) {
+			/*result =*/ FSOP_SYNC(dev->kd_fs);
+		}
+	}
+
+	lock_release(knowndevs_lock);
+
+	return 0;
+}
+
+/*
+ * Given a device name (lhd0, emu0, somevolname, null, etc.), hand
+ * back an appropriate vnode.
+ */
+int
+vfs_getroot(const char *devname, struct vnode **result)
+{
+	struct knowndev *kd;
+	int i, num;
+	int err=0;
+
+	lock_acquire(knowndevs_lock);
+
+	num = array_getnum(knowndevs);
+	for (i=0; i<num; i++) {
+		kd = array_getguy(knowndevs, i);
+
+		/*
+		 * If this device has a mounted filesystem, and we
+		 * just named the filesystem, or just named the
+		 * device, return the root of the filesystem.
+		 *
+		 * If it has no mounted filesystem, it's mountable,
+		 * and we just named the device, return ENXIO.
+		 */
+
+		if (kd->kd_fs!=NULL) {
+			const char *volname;
+			volname = FSOP_GETVOLNAME(kd->kd_fs);
+
+			if (!strcmp(kd->kd_name, devname) ||
+			    (volname!=NULL && !strcmp(volname, devname))) {
+				*result = FSOP_GETROOT(kd->kd_fs);
+				goto out;
+			}
+		}
+		else {
+			if (kd->kd_rawname!=NULL &&
+			    !strcmp(kd->kd_name, devname)) {
+				err = ENXIO;
+				goto out;
+			}
+		}
+
+		/*
+		 * If we named the device, and we got here, it must
+		 * have no fs and not be mountable. In this case, we
+		 * return the device itself.
+		 */
+		if (!strcmp(kd->kd_name, devname)) {
+			assert(kd->kd_fs==NULL);
+			assert(kd->kd_rawname==NULL);
+			assert(kd->kd_device != NULL);
+			VOP_INCREF(kd->kd_vnode);
+			*result = kd->kd_vnode;
+			goto out;
+		}
+
+		/*
+		 * If the device has a rawname and we just named that,
+		 * return the device itself.
+		 */
+		if (kd->kd_rawname!=NULL && !strcmp(kd->kd_rawname, devname)) {
+			assert(kd->kd_device != NULL);
+			VOP_INCREF(kd->kd_vnode);
+			*result = kd->kd_vnode;
+			goto out;
+		}
+
+		/*
+		 * If none of the above tests matched, we didn't name
+		 * any of the names of this device, so go on to the
+		 * next one. 
+		 */
+	}
+
+	/*
+	 * If we got here, the device specified by devname doesn't exist.
+	 */
+	err = ENODEV;
+
+ out:
+	lock_release(knowndevs_lock);
+
+	return err;
+}
+
+/*
+ * Given a filesystem, hand back the name of the device it's mounted on.
+ */
+const char *
+vfs_getdevname(struct fs *fs)
+{
+	struct knowndev *kd;
+	int i, num;
+
+	assert(fs != NULL);
+
+	lock_acquire(knowndevs_lock);
+
+	num = array_getnum(knowndevs);
+	for (i=0; i<num; i++) {
+		kd = array_getguy(knowndevs, i);
+
+		if (kd->kd_fs == fs) {
+			lock_release(knowndevs_lock);
+			/*
+			 * This is not a race condition: as long as the
+			 * guy calling us holds a reference to the fs,
+			 * the fs cannot go away, and the device can't
+			 * go away until the fs goes away.
+			 */
+			return kd->kd_name;
+		}
+	}
+
+	lock_release(knowndevs_lock);
+
+	return NULL;
+}
+
+/*
+ * Assemble the name for a raw device from the name for the regular device.
+ */
+static
+char *
+mkrawname(const char *name)
+{
+	char *s = kmalloc(strlen(name)+3+1);
+	if (!s) {
+		return NULL;
+	}
+	strcpy(s, name);
+	strcat(s, "raw");
+	return s;
+}
+
+
+/*
+ * Check if the two strings passed in are the same, if they're both
+ * not NULL (the latter part being significant).
+ */
+static
+inline
+int
+samestring(const char *a, const char *b)
+{
+	if (a==NULL || b==NULL) {
+		return 0;
+	}
+	return !strcmp(a, b);
+}
+
+/*
+ * Check if the first string passed is the same as any of the three others,
+ * if they're not NULL.
+ */
+static
+inline
+int
+samestring3(const char *a, const char *b, const char *c, const char *d)
+{
+	return samestring(a,b) || samestring(a,c) || samestring(a,d);
+}
+
+/*
+ * Check if any of the three names passed in already exists as a device
+ * name.
+ */
+
+static
+int
+badnames(const char *n1, const char *n2, const char *n3)
+{
+	const char *volname;
+	int i, num;
+	struct knowndev *kd;
+
+	assert(lock_do_i_hold(knowndevs_lock));
+
+	num = array_getnum(knowndevs);
+	for (i=0; i<num; i++) {
+		kd = array_getguy(knowndevs, i);
+
+		if (kd->kd_fs) {
+			volname = FSOP_GETVOLNAME(kd->kd_fs);
+			if (samestring3(volname, n1, n2, n3)) {
+				return 1;
+			}
+		}
+
+		if (samestring3(kd->kd_rawname, n1, n2, n3) ||
+		    samestring3(kd->kd_name, n1, n2, n3)) {
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Add a new device to the VFS layer's device table.
+ *
+ * If "mountable" is set, the device will be treated as one that expects
+ * to have a filesystem mounted on it, and a raw device will be created
+ * for direct access.
+ */
+static
+int
+vfs_doadd(const char *dname, int mountable, struct device *dev, struct fs *fs)
+{
+	char *name=NULL, *rawname=NULL;
+	struct knowndev *kd=NULL;
+	struct vnode *vnode=NULL;
+	const char *volname=NULL;
+	int err=0;
+
+	name = kstrdup(dname);
+	if (name==NULL) {
+		goto puke;
+	}
+	if (mountable) {
+		rawname = mkrawname(name);
+		if (rawname==NULL) {
+			goto puke;
+		}
+	}
+
+	vnode = dev_create_vnode(dev);
+	if (vnode==NULL) {
+		goto puke;
+	}
+
+	kd = kmalloc(sizeof(struct knowndev));
+	if (kd==NULL) {
+		goto puke;
+	}
+
+	kd->kd_name = name;
+	kd->kd_rawname = rawname;
+	kd->kd_device = dev;
+	kd->kd_vnode = vnode;
+	kd->kd_fs = fs;
+
+	if (fs!=NULL) {
+		volname = FSOP_GETVOLNAME(fs);
+	}
+
+	lock_acquire(knowndevs_lock);
+
+	if (!badnames(name, rawname, volname)) {
+		err = array_add(knowndevs, kd);
+	}
+	else {
+		err = EEXIST;
+	}
+
+	lock_release(knowndevs_lock);
+
+	return err;
+
+ puke:
+
+	if (name) {
+		kfree(name);
+	}
+	if (rawname) {
+		kfree(rawname);
+	}
+	if (vnode) {
+		kfree(vnode);
+	}
+	if (kd) {
+		kfree(kd);
+	}
+	
+	return ENOMEM;
+}
+
+/*
+ * Add a new device, by name. See above for the description of
+ * mountable.
+ */
+int
+vfs_adddev(const char *devname, struct device *dev, int mountable)
+{
+	return vfs_doadd(devname, mountable, dev, NULL);
+}
+
+/*
+ * Add a filesystem that does not have an underlying device.
+ * This is used for emufs, but might also be used for network
+ * filesystems and the like.
+ */
+int
+vfs_addfs(const char *devname, struct fs *fs)
+{
+	return vfs_doadd(devname, 0, NULL, fs);
+}
+
+//////////////////////////////////////////////////
+
+/*
+ * Look for a mountable device named DEVNAME.
+ * Should already hold knowndevs_lock.
+ */
+static
+int
+findmount(const char *devname, struct knowndev **result)
+{
+	struct knowndev *dev;
+	int i, num, found=0;
+
+	assert(lock_do_i_hold(knowndevs_lock));
+
+	num = array_getnum(knowndevs);
+	for (i=0; !found && i<num; i++) {
+		dev = array_getguy(knowndevs, i);
+		if (dev->kd_rawname==NULL) {
+			/* not mountable/unmountable */
+			continue;
+		}
+
+		if (!strcmp(devname, dev->kd_name)) {
+			*result = dev;
+			found = 1;
+		}
+	}
+
+	return found ? 0 : ENODEV;
+}
+
+/*
+ * Mount a filesystem. Once we've found the device, call MOUNTFUNC to
+ * set up the filesystem and hand back a struct fs. This is done with
+ * the devices table locked.
+ *
+ * The DATA argument is passed through unchanged to MOUNTFUNC.
+ */
+int
+vfs_mount(const char *devname, void *data,
+	  int (*mountfunc)(void *data, struct device *, struct fs **ret))
+{
+	const char *volname;
+	struct knowndev *kd;
+	struct fs *fs;
+	int result;
+
+	lock_acquire(knowndevs_lock);
+	
+
+	result = findmount(devname, &kd);
+	if (result) {
+		goto puke;
+	}
+
+	if (kd->kd_fs != NULL) {
+		result = EBUSY;
+		goto puke;
+	}
+	assert(kd->kd_rawname != NULL);
+	assert(kd->kd_device != NULL);
+
+	result = mountfunc(data, kd->kd_device, &fs);
+	if (result) {
+		goto puke;
+	}
+
+	assert(fs!=NULL);
+
+	kd->kd_fs = fs;
+
+	volname = FSOP_GETVOLNAME(fs);
+	kprintf("vfs: Mounted %s: on %s\n",
+		volname ? volname : kd->kd_name, kd->kd_name);
+
+	assert(result==0);
+	
+ puke:
+	lock_release(knowndevs_lock);
+	return result;
+}
+
+/*
+ * Unmount a filesystem/device by name.
+ * First calls FSOP_SYNC on the filesystem; then calls FSOP_UNMOUNT.
+ */
+int
+vfs_unmount(const char *devname)
+{
+	struct knowndev *kd;
+	int result;
+
+	lock_acquire(knowndevs_lock);
+	
+
+	result = findmount(devname, &kd);
+	if (result) {
+		goto puke;
+	}
+
+	if (kd->kd_fs == NULL) {
+		result = EINVAL;
+		goto puke;
+	}
+	assert(kd->kd_rawname != NULL);
+	assert(kd->kd_device != NULL);
+
+	result = FSOP_SYNC(kd->kd_fs);
+	if (result) {
+		goto puke;
+	}
+
+	result = FSOP_UNMOUNT(kd->kd_fs);
+	if (result) {
+		goto puke;
+	}
+
+	kprintf("vfs: Unmounted %s:\n", kd->kd_name);
+
+	/* now drop the filesystem */
+	kd->kd_fs = NULL;
+
+	assert(result==0);
+
+ puke:
+	lock_release(knowndevs_lock);
+	return result;
+}
+
+/*
+ * Global unmount function.
+ */
+int
+vfs_unmountall(void)
+{
+	struct knowndev *dev;
+	int i, num, result;
+
+	lock_acquire(knowndevs_lock);
+
+	num = array_getnum(knowndevs);
+	for (i=0; i<num; i++) {
+		dev = array_getguy(knowndevs, i);
+		if (dev->kd_rawname == NULL) {
+			/* not mountable/unmountable */
+			continue;
+		}
+		if (dev->kd_fs == NULL) {
+			/* not mounted */
+			continue;
+		}
+
+		kprintf("vfs: Unmounting %s:\n", dev->kd_name);
+
+		result = FSOP_SYNC(dev->kd_fs);
+		if (result) {
+			kprintf("vfs: Warning: sync failed for %s: %s, trying "
+				"again\n", dev->kd_name, strerror(result));
+
+			result = FSOP_SYNC(dev->kd_fs);
+			if (result) {
+				kprintf("vfs: Warning: sync failed second time"
+					" for %s: %s, giving up...\n",
+					dev->kd_name, strerror(result));
+				continue;
+			}
+		}
+
+		result = FSOP_UNMOUNT(dev->kd_fs);
+		if (result==EBUSY) {
+			kprintf("vfs: Cannot unmount %s: (busy)\n", 
+				dev->kd_name);
+			continue;
+		}
+		if (result) {
+			kprintf("vfs: Warning: unmount failed for %s:"
+				" %s, already synced, dropping...\n",
+				dev->kd_name, strerror(result));
+			continue;
+		}
+
+		/* now drop the filesystem */
+		dev->kd_fs = NULL;
+	}
+
+	lock_release(knowndevs_lock);
+
+	return 0;
+}
diff --git a/os161-1.10/kern/fs/vfs/vfslookup.c b/os161-1.10/kern/fs/vfs/vfslookup.c
new file mode 100644
index 0000000..706c3b0
--- /dev/null
+++ b/os161-1.10/kern/fs/vfs/vfslookup.c
@@ -0,0 +1,256 @@
+/*
+ * VFS operations relating to pathname translation
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/limits.h>
+#include <lib.h>
+#include <synch.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <fs.h>
+
+static struct vnode *bootfs_vnode = NULL;
+static struct lock *bootfs_lock = NULL;
+
+void
+vfs_initbootfs(void)
+{
+	bootfs_lock = lock_create("bootfs_lock");
+	if (bootfs_lock == NULL) {
+		panic("vfs: Could not create bootfs lock\n");
+	}
+}
+
+/*
+ * Helper function for actually changing bootfs_vnode.
+ */
+static
+void
+change_bootfs(struct vnode *newguy)
+{
+	struct vnode *oldguy;
+
+	lock_acquire(bootfs_lock);
+	oldguy = bootfs_vnode;
+	bootfs_vnode = newguy;
+	lock_release(bootfs_lock);
+
+	/* Do this without holding the lock so as to avoid deadlock */
+	if (oldguy != NULL) {
+		VOP_DECREF(oldguy);
+	}
+}
+
+/*
+ * Set bootfs_vnode.
+ *
+ * Bootfs_vnode is the vnode used for beginning path translation of
+ * pathnames starting with /.
+ *
+ * It is also incidentally the system's first current directory.
+ */
+int
+vfs_setbootfs(const char *fsname)
+{
+	char tmp[NAME_MAX+1];
+	char *s;
+	int result;
+	struct vnode *newguy;
+
+	snprintf(tmp, sizeof(tmp)-1, "%s", fsname);
+	s = strchr(tmp, ':');
+	if (s) {
+		/* If there's a colon, it must be at the end */
+		if (strlen(s)>0) {
+			return EINVAL;
+		}
+	}
+	else {
+		strcat(tmp, ":");
+	}
+
+	result = vfs_chdir(tmp);
+	if (result) {
+		return result;
+	}
+
+	result = vfs_getcurdir(&newguy);
+	if (result) {
+		return result;
+	}
+
+	change_bootfs(newguy);
+
+	return 0;
+}
+
+/*
+ * Clear the bootfs vnode (preparatory to system shutdown).
+ */
+void
+vfs_clearbootfs(void)
+{
+	change_bootfs(NULL);
+}
+
+
+/*
+ * Common code to pull the device name, if any, off the front of a
+ * path and choose the vnode to begin the name lookup relative to.
+ */
+
+static
+int
+getdevice(char *path, char **subpath, struct vnode **startvn)
+{
+	int slash=-1, colon=-1, i;
+	struct vnode *vn;
+	int result;
+
+	/*
+	 * Locate the first colon or slash.
+	 */
+
+	for (i=0; path[i]; i++) {
+		if (path[i]==':') {
+			colon = i;
+			break;
+		}
+		if (path[i]=='/') {
+			slash = i;
+			break;
+		}
+	}
+
+	if (colon < 0 && slash != 0) {
+		/*
+		 * No colon before a slash, so no device name
+		 * specified, and the slash isn't leading or is also
+		 * absent, so this is a relative path or just a bare
+		 * filename. Start from the current directory, and
+		 * use the whole thing as the subpath.
+		 */
+		*subpath = path;
+		return vfs_getcurdir(startvn);
+	}
+
+	if (colon>0) {
+		/* device:path - get root of device's filesystem */
+		path[colon]=0;
+		while (path[colon+1]=='/') {
+			/* device:/path - skip slash, treat as device:path */
+			colon++;
+		}
+		*subpath = &path[colon+1];
+		
+		result = vfs_getroot(path, startvn);
+		if (result) {
+			return result;
+		}
+
+		return 0;
+	}
+
+	/*
+	 * We have either /path or :path.
+	 *
+	 * /path is a path relative to the root of the "boot filesystem".
+	 * :path is a path relative to the root of the current filesystem.
+	 */
+	assert(colon==0 || slash==0);
+
+	if (path[0]=='/') {
+		lock_acquire(bootfs_lock);
+		if (bootfs_vnode==NULL) {
+			lock_release(bootfs_lock);
+			return ENOENT;
+		}
+		VOP_INCREF(bootfs_vnode);
+		*startvn = bootfs_vnode;
+		lock_release(bootfs_lock);
+	}
+	else {
+		assert(path[0]==':');
+
+		result = vfs_getcurdir(&vn);
+		if (result) {
+			return result;
+		}
+
+		/*
+		 * The current directory may not be a device, so it
+		 * must have a fs.
+		 */
+		assert(vn->vn_fs!=NULL);
+
+		*startvn = FSOP_GETROOT(vn->vn_fs);
+
+		VOP_DECREF(vn);
+	}
+
+	while (path[1]=='/') {
+		/* ///... or :/... */
+		path++;
+	}
+
+	*subpath = path+1;
+
+	return 0;
+}
+
+/*
+ * Name-to-vnode translation.
+ * (In BSD, both of these are subsumed by namei().)
+ */
+
+int
+vfs_lookparent(char *path, struct vnode **retval,
+	       char *buf, size_t buflen)
+{
+	struct vnode *startvn;
+	int result;
+
+	result = getdevice(path, &path, &startvn);
+	if (result) {
+		return result;
+	}
+
+	if (strlen(path)==0) {
+		/*
+		 * It does not make sense to use just a device name in
+		 * a context where "lookparent" is the desired
+		 * operation.
+		 */
+		result = EINVAL;
+	}
+	else {
+		result = VOP_LOOKPARENT(startvn, path, retval, buf, buflen);
+	}
+
+	VOP_DECREF(startvn);
+	return result;
+}
+
+int
+vfs_lookup(char *path, struct vnode **retval)
+{
+	struct vnode *startvn;
+	int result;
+
+	result = getdevice(path, &path, &startvn);
+	if (result) {
+		return result;
+	}
+
+	if (strlen(path)==0) {
+		*retval = startvn;
+		return 0;
+	}
+
+	result = VOP_LOOKUP(startvn, path, retval);
+
+	VOP_DECREF(startvn);
+	return result;
+}
diff --git a/os161-1.10/kern/fs/vfs/vfspath.c b/os161-1.10/kern/fs/vfs/vfspath.c
new file mode 100644
index 0000000..06e7af8
--- /dev/null
+++ b/os161-1.10/kern/fs/vfs/vfspath.c
@@ -0,0 +1,291 @@
+/*
+ * High-level VFS operations on pathnames.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/limits.h>
+#include <kern/unistd.h>
+#include <vfs.h>
+#include <vnode.h>
+#include <lib.h>
+
+
+/* Does most of the work for open(). */
+int
+vfs_open(char *path, int openflags, struct vnode **ret)
+{
+	int how;
+	int result;
+	int canwrite;
+	struct vnode *vn = NULL;
+
+	how = openflags & O_ACCMODE;
+
+	switch (how) {
+	    case O_RDONLY:
+		canwrite=0;
+		break;
+	    case O_WRONLY:
+	    case O_RDWR:
+		canwrite=1;
+		break;
+	    default:
+		return EINVAL;
+	}
+
+	if (openflags & O_CREAT) {
+		char name[NAME_MAX+1];
+		struct vnode *dir;
+		int excl = (openflags & O_EXCL)!=0;
+		
+		result = vfs_lookparent(path, &dir, name, sizeof(name));
+		if (result) {
+			return result;
+		}
+
+		result = VOP_CREAT(dir, name, excl, &vn);
+
+		VOP_DECREF(dir);
+	}
+	else {
+		result = vfs_lookup(path, &vn);
+	}
+
+	if (result) {
+		return result;
+	}
+
+	assert(vn != NULL);
+
+	result = VOP_OPEN(vn, openflags);
+	if (result) {
+		VOP_DECREF(vn);
+		return result;
+	}
+
+	VOP_INCOPEN(vn);
+	
+	if (openflags & O_TRUNC) {
+		if (canwrite==0) {
+			result = EINVAL;
+		}
+		else {
+			result = VOP_TRUNCATE(vn, 0);
+		}
+		if (result) {
+			VOP_DECOPEN(vn);
+			VOP_DECREF(vn);
+			return result;
+		}
+	}
+
+	*ret = vn;
+
+	return 0;
+}
+
+/* Does most of the work for close(). */
+void
+vfs_close(struct vnode *vn)
+{
+	/*
+	 * VOP_DECOPEN and VOP_DECREF don't return errors.
+	 *
+	 * We assume that the file system makes every reasonable
+	 * effort to not fail. If it does fail - such as on a hard I/O
+	 * error or something - vnode.c prints a warning. The reason
+	 * we don't report errors up to or above this level is that
+	 *    (1) most application software does not check for close
+	 *        failing, and more importantly
+	 *    (2) we're often called from places like process exit
+	 *        where reporting the error is impossible and
+	 *        meaningful recovery is entirely impractical.
+	 */
+
+	VOP_DECOPEN(vn);
+	VOP_DECREF(vn);
+}
+
+/* Does most of the work for remove(). */
+int
+vfs_remove(char *path)
+{
+	struct vnode *dir;
+	char name[NAME_MAX+1];
+	int result;
+	
+	result = vfs_lookparent(path, &dir, name, sizeof(name));
+	if (result) {
+		return result;
+	}
+
+	result = VOP_REMOVE(dir, name);
+	VOP_DECREF(dir);
+
+	return result;
+}
+
+/* Does most of the work for rename(). */
+int
+vfs_rename(char *oldpath, char *newpath)
+{
+	struct vnode *olddir;
+	char oldname[NAME_MAX+1];
+	struct vnode *newdir;
+	char newname[NAME_MAX+1];
+	int result;
+	
+	result = vfs_lookparent(oldpath, &olddir, oldname, sizeof(oldname));
+	if (result) {
+		return result;
+	}
+	result = vfs_lookparent(newpath, &newdir, newname, sizeof(newname));
+	if (result) {
+		VOP_DECREF(olddir);
+		return result;
+	}
+
+	if (olddir->vn_fs==NULL || newdir->vn_fs==NULL || 
+	    olddir->vn_fs != newdir->vn_fs) {
+		VOP_DECREF(newdir);
+		VOP_DECREF(olddir);
+		return EXDEV;
+	}
+
+	result = VOP_RENAME(olddir, oldname, newdir, newname);
+
+	VOP_DECREF(newdir);
+	VOP_DECREF(olddir);
+
+	return result;
+}
+
+/* Does most of the work for link(). */
+int
+vfs_link(char *oldpath, char *newpath)
+{
+	struct vnode *oldfile;
+	struct vnode *newdir;
+	char newname[NAME_MAX+1];
+	int result;
+
+	result = vfs_lookup(oldpath, &oldfile);
+	if (result) {
+		return result;
+	}
+	result = vfs_lookparent(newpath, &newdir, newname, sizeof(newname));
+	if (result) {
+		VOP_DECREF(oldfile);
+		return result;
+	}
+
+	if (oldfile->vn_fs==NULL || newdir->vn_fs==NULL ||
+	    oldfile->vn_fs != newdir->vn_fs) {
+		VOP_DECREF(newdir);
+		VOP_DECREF(oldfile);
+		return EXDEV;
+	}
+
+	result = VOP_LINK(newdir, newname, oldfile);
+
+	VOP_DECREF(newdir);
+	VOP_DECREF(oldfile);
+
+	return result;
+}
+
+/*
+ * Does most of the work for symlink().
+ *
+ * Note, however, if you're implementing symlinks, that various
+ * other parts of the VFS layer are missing crucial elements of
+ * support for symlinks.
+ */
+int
+vfs_symlink(const char *contents, char *path)
+{
+	struct vnode *newdir;
+	char newname[NAME_MAX+1];
+	int result;
+
+	result = vfs_lookparent(path, &newdir, newname, sizeof(newname));
+	if (result) {
+		return result;
+	}
+
+	result = VOP_SYMLINK(newdir, newname, contents);
+	VOP_DECREF(newdir);
+
+	return result;
+}
+
+/*
+ * Does most of the work for readlink().
+ *
+ * Note, however, if you're implementing symlinks, that various
+ * other parts of the VFS layer are missing crucial elements of
+ * support for symlinks.
+ */
+int
+vfs_readlink(char *path, struct uio *uio)
+{
+	struct vnode *vn;
+	int result;
+
+	result = vfs_lookup(path, &vn);
+	if (result) {
+		return result;
+	}
+
+	result = VOP_READLINK(vn, uio);
+
+	VOP_DECREF(vn);
+
+	return result;
+}
+
+/*
+ * Does most of the work for mkdir.
+ */
+int
+vfs_mkdir(char *path)
+{
+	struct vnode *parent;
+	char name[NAME_MAX+1];
+	int result;
+
+	result = vfs_lookparent(path, &parent, name, sizeof(name));
+	if (result) {
+		return result;
+	}
+
+	result = VOP_MKDIR(parent, name);
+
+	VOP_DECREF(parent);
+
+	return result;
+}
+
+/*
+ * Does most of the work for rmdir.
+ */
+int
+vfs_rmdir(char *path)
+{
+	struct vnode *parent;
+	char name[NAME_MAX+1];
+	int result;
+
+	result = vfs_lookparent(path, &parent, name, sizeof(name));
+	if (result) {
+		return result;
+	}
+
+	result = VOP_RMDIR(parent, name);
+
+	VOP_DECREF(parent);
+
+	return result;
+}
+
diff --git a/os161-1.10/kern/fs/vfs/vnode.c b/os161-1.10/kern/fs/vfs/vnode.c
new file mode 100644
index 0000000..02cafeb
--- /dev/null
+++ b/os161-1.10/kern/fs/vfs/vnode.c
@@ -0,0 +1,200 @@
+/*
+ * Basic vnode support functions.
+ */
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <synch.h>
+#include <vnode.h>
+
+/*
+ * Initialize an abstract vnode.
+ * Invoked by VOP_INIT.
+ */
+int
+vnode_init(struct vnode *vn, const struct vnode_ops *ops,
+	   struct fs *fs, void *fsdata)
+{
+	assert(vn!=NULL);
+	assert(ops!=NULL);
+
+	vn->vn_ops = ops;
+	vn->vn_refcount = 1;
+	vn->vn_opencount = 0;
+	vn->vn_countlock = lock_create("vnode-countlock");
+	if (vn->vn_countlock == NULL) {
+		return ENOMEM;
+	}
+	vn->vn_fs = fs;
+	vn->vn_data = fsdata;
+	return 0;
+}
+
+/*
+ * Destroy an abstract vnode.
+ * Invoked by VOP_KILL.
+ */
+void
+vnode_kill(struct vnode *vn)
+{
+	assert(vn->vn_refcount==1);
+	assert(vn->vn_opencount==0);
+	assert(vn->vn_countlock!=NULL);
+
+	lock_destroy(vn->vn_countlock);
+
+	vn->vn_ops = NULL;
+	vn->vn_refcount = 0;
+	vn->vn_opencount = 0;
+	vn->vn_countlock = NULL;
+	vn->vn_fs = NULL;
+	vn->vn_data = NULL;
+}
+
+
+/*
+ * Increment refcount.
+ * Called by VOP_INCREF.
+ */
+void
+vnode_incref(struct vnode *vn)
+{
+	assert(vn!=NULL);
+	lock_acquire(vn->vn_countlock);
+	vn->vn_refcount++;
+	lock_release(vn->vn_countlock);
+}
+
+/*
+ * Decrement refcount.
+ * Called by VOP_DECREF.
+ * Calls VOP_RECLAIM if the refcount hits zero.
+ */
+void
+vnode_decref(struct vnode *vn)
+{
+	int result, actually_do_it = 0;
+
+	assert(vn!=NULL);
+
+	lock_acquire(vn->vn_countlock);
+	assert(vn->vn_refcount>0);
+	if (vn->vn_refcount>1) {
+		vn->vn_refcount--;
+	}
+	else {
+		actually_do_it = 1;
+	}
+	lock_release(vn->vn_countlock);
+
+	if (actually_do_it) {
+		result = VOP_RECLAIM(vn);
+		if (result != 0 && result != EBUSY) {
+			// XXX: lame.
+			kprintf("vfs: Warning: VOP_RECLAIM: %s\n",
+				strerror(result));
+		}
+	}
+}
+
+/*
+ * Increment the open count.
+ * Called by VOP_INCOPEN.
+ */
+void
+vnode_incopen(struct vnode *vn)
+{
+	assert(vn!=NULL);
+	lock_acquire(vn->vn_countlock);
+	vn->vn_opencount++;
+	lock_release(vn->vn_countlock);
+}
+
+/*
+ * Decrement the open count.
+ * Called by VOP_DECOPEN.
+ */
+void
+vnode_decopen(struct vnode *vn)
+{
+	int opencount, result;
+
+	assert(vn!=NULL);
+	lock_acquire(vn->vn_countlock);
+	assert(vn->vn_opencount>0);
+	vn->vn_opencount--;
+	opencount = vn->vn_opencount;
+	lock_release(vn->vn_countlock);
+
+	if (opencount > 0) {
+		return;
+	}
+
+	result = VOP_CLOSE(vn);
+	if (result) {
+		// XXX: also lame.
+		// The FS should do what it can to make sure this code
+		// doesn't get reached...
+		kprintf("vfs: Warning: VOP_CLOSE: %s\n", strerror(result));
+	}
+}
+
+/*
+ * Check for various things being valid.
+ * Called before all VOP_* calls.
+ */
+void
+vnode_check(struct vnode *v, const char *opstr)
+{
+	if (v == NULL) {
+		panic("vnode_check: vop_%s: null vnode\n", opstr);
+	}
+	if (v == (void *)0xdeadbeef) {
+		panic("vnode_check: vop_%s: deadbeef vnode\n", opstr);
+	}
+
+	if (v->vn_ops == NULL) {
+		panic("vnode_check: vop_%s: null ops pointer\n", opstr);
+	}
+	if (v->vn_ops == (void *)0xdeadbeef) {
+		panic("vnode_check: vop_%s: deadbeef ops pointer\n", opstr);
+	}
+
+	if (v->vn_ops->vop_magic != VOP_MAGIC) {
+		panic("vnode_check: vop_%s: ops with bad magic number %lx\n", 
+		      opstr, v->vn_ops->vop_magic);
+	}
+
+	// Device vnodes have null fs pointers.
+	//if (v->vn_fs == NULL) {
+	//	panic("vnode_check: vop_%s: null fs pointer\n", opstr);
+	//}
+	if (v->vn_fs == (void *)0xdeadbeef) {
+		panic("vnode_check: vop_%s: deadbeef fs pointer\n", opstr);
+	}
+
+	lock_acquire(v->vn_countlock);
+
+	if (v->vn_refcount < 0) {
+		panic("vnode_check: vop_%s: negative refcount %d\n", opstr,
+		      v->vn_refcount);
+	}
+	else if (v->vn_refcount == 0 && strcmp(opstr, "reclaim")) {
+		panic("vnode_check: vop_%s: zero refcount\n", opstr);
+	}
+	else if (v->vn_refcount > 0x100000) {
+		kprintf("vnode_check: vop_%s: warning: large refcount %d\n", 
+			opstr, v->vn_refcount);
+	}
+
+	if (v->vn_opencount < 0) {
+		panic("vnode_check: vop_%s: negative opencount %d\n", opstr,
+		      v->vn_opencount);
+	}
+	else if (v->vn_opencount > 0x100000) {
+		kprintf("vnode_check: vop_%s: warning: large opencount %d\n", 
+			opstr, v->vn_opencount);
+	}
+
+	lock_release(v->vn_countlock);
+}
diff --git a/os161-1.10/kern/include/addrspace.h b/os161-1.10/kern/include/addrspace.h
new file mode 100644
index 0000000..6b3e4d4
--- /dev/null
+++ b/os161-1.10/kern/include/addrspace.h
@@ -0,0 +1,88 @@
+#ifndef _ADDRSPACE_H_
+#define _ADDRSPACE_H_
+
+#include <vm.h>
+#include "opt-dumbvm.h"
+
+struct vnode;
+
+/* 
+ * Address space - data structure associated with the virtual memory
+ * space of a process.
+ *
+ * You write this.
+ */
+
+struct addrspace {
+#if OPT_DUMBVM
+	vaddr_t as_vbase1;
+	paddr_t as_pbase1;
+	size_t as_npages1;
+	vaddr_t as_vbase2;
+	paddr_t as_pbase2;
+	size_t as_npages2;
+	paddr_t as_stackpbase;
+#else
+	/* Put stuff here for your VM system */
+#endif
+};
+
+/*
+ * Functions in addrspace.c:
+ *
+ *    as_create - create a new empty address space. You need to make 
+ *                sure this gets called in all the right places. You
+ *                may find you want to change the argument list. May
+ *                return NULL on out-of-memory error.
+ *
+ *    as_copy   - create a new address space that is an exact copy of
+ *                an old one. Probably calls as_create to get a new
+ *                empty address space and fill it in, but that's up to
+ *                you.
+ *
+ *    as_activate - make the specified address space the one currently
+ *                "seen" by the processor. Argument might be NULL, 
+ *		  meaning "no particular address space".
+ *
+ *    as_destroy - dispose of an address space. You may need to change
+ *                the way this works if implementing user-level threads.
+ *
+ *    as_define_region - set up a region of memory within the address
+ *                space.
+ *
+ *    as_prepare_load - this is called before actually loading from an
+ *                executable into the address space.
+ *
+ *    as_complete_load - this is called when loading from an executable
+ *                is complete.
+ *
+ *    as_define_stack - set up the stack region in the address space.
+ *                (Normally called *after* as_complete_load().) Hands
+ *                back the initial stack pointer for the new process.
+ */
+
+struct addrspace *as_create(void);
+int               as_copy(struct addrspace *src, struct addrspace **ret);
+void              as_activate(struct addrspace *);
+void              as_destroy(struct addrspace *);
+
+int               as_define_region(struct addrspace *as, 
+				   vaddr_t vaddr, size_t sz,
+				   int readable, 
+				   int writeable,
+				   int executable);
+int		  as_prepare_load(struct addrspace *as);
+int		  as_complete_load(struct addrspace *as);
+int               as_define_stack(struct addrspace *as, vaddr_t *initstackptr);
+
+/*
+ * Functions in loadelf.c
+ *    load_elf - load an ELF user program executable into the current
+ *               address space. Returns the entry point (initial PC)
+ *               in the space pointed to by ENTRYPOINT.
+ */
+
+int load_elf(struct vnode *v, vaddr_t *entrypoint);
+
+
+#endif /* _ADDRSPACE_H_ */
diff --git a/os161-1.10/kern/include/array.h b/os161-1.10/kern/include/array.h
new file mode 100644
index 0000000..0fc3bcf
--- /dev/null
+++ b/os161-1.10/kern/include/array.h
@@ -0,0 +1,43 @@
+#ifndef _ARRAY_H_
+#define _ARRAY_H_
+
+/*
+ * Resizeable array of void pointers.
+ *
+ * Functions:
+ *     array_create  - allocate a new array object. Returns NULL if out
+ *                     of memory.
+ *     array_preallocate - allocate enough space for at least NUM elements,
+ *                     without changing the visible size of the array. Can 
+ *                     be used to prevent anticipated calls to setsize from
+ *                     failing. Returns an error code.
+ *     array_getnum  - return the size of the array.
+ *     array_getguy  - return the specified element from the array.
+ *     array_setsize - alter the size of the array. If shrunk, excess 
+ *                     elements are dropped. If expanded, the new elements
+ *                     are *not* initialized. Returns an error number on
+ *                     failure.
+ *     array_setguy  - set the specified element in the array to the passed
+ *                     pointer. The element must be within range.
+ *     array_add     - add one pointer to the end of the array, increasing 
+ *                     the size. Returns an error number on failure.
+ *     array_remove  - remove one pointer from anywhere in the array. The
+ *                     portion of the array after the index is moved down,
+ *                     collapsing the resulting hole.
+ *     array_destroy - dispose of an array. If not empty, the contents are
+ *                     lost.
+ */
+
+struct array;  /* Opaque. */
+
+struct array *array_create(void);
+int           array_preallocate(struct array *, int nguys);
+int           array_getnum(struct array *);
+void         *array_getguy(struct array *, int index);
+int           array_setsize(struct array *, int nguys);
+void          array_setguy(struct array *, int index, void *ptr);
+int           array_add(struct array *, void *guy);
+void          array_remove(struct array *, int index);
+void          array_destroy(struct array *);
+
+#endif /* _ARRAY_H_ */
diff --git a/os161-1.10/kern/include/bitmap.h b/os161-1.10/kern/include/bitmap.h
new file mode 100644
index 0000000..21c8d27
--- /dev/null
+++ b/os161-1.10/kern/include/bitmap.h
@@ -0,0 +1,28 @@
+#ifndef _BITMAP_H_
+#define _BITMAP_H_
+
+/*
+ * Fixed-size array of bits. (Intended for storage management.)
+ *
+ * Functions:
+ *     bitmap_create  - allocate a new bitmap object.
+ *                      Returns NULL on error.
+ *     bitmap_getdata - return pointer to raw bit data (for I/O).
+ *     bitmap_alloc   - locate a cleared bit, set it, and return its index.
+ *     bitmap_mark    - set a clear bit by its index.
+ *     bitmap_unmark  - clear a set bit by its index.
+ *     bitmap_isset   - return whether a particular bit is set or not.
+ *     bitmap_destroy - destroy bitmap.
+ */
+
+struct bitmap;  /* Opaque. */
+
+struct bitmap *bitmap_create(u_int32_t nbits);
+void          *bitmap_getdata(struct bitmap *);
+int            bitmap_alloc(struct bitmap *, u_int32_t *index);
+void           bitmap_mark(struct bitmap *, u_int32_t index);
+void           bitmap_unmark(struct bitmap *, u_int32_t index);
+int	       bitmap_isset(struct bitmap *, u_int32_t index);
+void           bitmap_destroy(struct bitmap *);
+
+#endif /* _BITMAP_H_ */
diff --git a/os161-1.10/kern/include/clock.h b/os161-1.10/kern/include/clock.h
new file mode 100644
index 0000000..59db6f3
--- /dev/null
+++ b/os161-1.10/kern/include/clock.h
@@ -0,0 +1,31 @@
+#ifndef _CLOCK_H_
+#define _CLOCK_H_
+
+#include "opt-synchprobs.h"
+
+/*
+ * Time-related definitions.
+ *
+ * hardclock() is called from the timer interrupt HZ times a second.
+ * gettime() may be used to fetch the current time of day.
+ * getinterval() computes the time from time1 to time2.
+ */
+
+/* hardclocks per second */
+#if OPT_SYNCHPROBS
+/* Make synchronization more exciting :) */
+#define HZ  10000
+#else
+/* More realistic value */
+#define HZ  100
+#endif
+
+void hardclock(void);
+
+void gettime(time_t *seconds, u_int32_t *nanoseconds);
+
+void getinterval(time_t secs1, u_int32_t nsecs,
+		 time_t secs2, u_int32_t nsecs2,
+		 time_t *rsecs, u_int32_t *rnsecs);
+
+#endif /* _CLOCK_H_ */
diff --git a/os161-1.10/kern/include/curthread.h b/os161-1.10/kern/include/curthread.h
new file mode 100644
index 0000000..cd04470
--- /dev/null
+++ b/os161-1.10/kern/include/curthread.h
@@ -0,0 +1,15 @@
+#ifndef _CURTHREAD_H_
+#define _CURTHREAD_H_
+
+/*
+ * The current thread.
+ *
+ * This is in its own header file (instead of thread.h) to reduce the
+ * number of things that get recompiled when you change thread.h.
+ */
+
+struct thread;
+
+extern struct thread *curthread;
+
+#endif /* _CURTHREAD_H_ */
diff --git a/os161-1.10/kern/include/dev.h b/os161-1.10/kern/include/dev.h
new file mode 100644
index 0000000..2fb3743
--- /dev/null
+++ b/os161-1.10/kern/include/dev.h
@@ -0,0 +1,43 @@
+#ifndef _DEV_H_
+#define _DEV_H_
+
+struct uio;  /* in <uio.h> */
+
+/*
+ * Filesystem-namespace-accessible device.
+ * d_io is for both reads and writes; the uio indicates which should be done.
+ */
+struct device {
+	int (*d_open)(struct device *, int flags_from_open);
+	int (*d_close)(struct device *);
+	int (*d_io)(struct device *, struct uio *);
+	int (*d_ioctl)(struct device *, int op, userptr_t data);
+
+	u_int32_t d_blocks;
+	u_int32_t d_blocksize;
+
+	void *d_data;   /* device-specific data */
+};
+
+/* Create vnode for namespace-accessible device. */
+struct vnode *dev_create_vnode(struct device *dev);
+
+
+/* Builtin namespace-accessible devices. */
+void devnull_create(void);
+
+
+/*
+ * Device probe functions.
+ *
+ *      dev_bootstrap - start machine-independent device initialization.
+ *
+ * The corresponding machine-dependent function is called by the
+ * machine-independent function.
+ */
+
+void dev_bootstrap(void);
+
+void machdep_dev_bootstrap(void);
+
+#endif /* _DEV_H_ */
diff --git a/os161-1.10/kern/include/elf.h b/os161-1.10/kern/include/elf.h
new file mode 100644
index 0000000..89c74e3
--- /dev/null
+++ b/os161-1.10/kern/include/elf.h
@@ -0,0 +1,167 @@
+#ifndef _ELF_H_
+#define _ELF_H_
+
+/*
+ * Simplified ELF definitions for OS/161 and System/161.
+ *
+ * Restrictions:
+ *     32-bit only
+ *     No support for .o files or linker structures
+ *     Does not define all the random symbols a standard elf header would.
+ */
+
+
+
+/*
+ * ELF file header. This appears at the very beginning of an ELF file.
+ */
+#define	ELF_NIDENT	16
+typedef struct {
+	unsigned char	e_ident[ELF_NIDENT];   /* magic number et al. */
+	u_int16_t	e_type;                /* type of file this is */
+	u_int16_t	e_machine;             /* processor type file is for */
+	u_int32_t	e_version;             /* ELF version */
+	u_int32_t	e_entry;           /* address of program entry point */
+	u_int32_t	e_phoff;           /* location in file of phdrs */
+	u_int32_t	e_shoff;           /* ignore */
+	u_int32_t	e_flags;	   /* ignore */
+	u_int16_t	e_ehsize;          /* actual size of file header */
+	u_int16_t	e_phentsize;       /* actual size of phdr */
+	u_int16_t	e_phnum;           /* number of phdrs */
+	u_int16_t	e_shentsize;       /* ignore */
+	u_int16_t	e_shnum;           /* ignore */
+	u_int16_t	e_shstrndx;        /* ignore */
+} Elf32_Ehdr;
+
+/* Offsets for the 1-byte fields within e_ident[] */
+#define	EI_MAG0		0	/* '\177' */
+#define	EI_MAG1		1	/* 'E'    */
+#define	EI_MAG2		2	/* 'L'    */
+#define	EI_MAG3		3	/* 'F'    */
+#define	EI_CLASS	4	/* File class - always ELFCLASS32 */
+#define	EI_DATA		5	/* Data encoding - ELFDATA2LSB or ELFDATA2MSB*/
+#define	EI_VERSION	6	/* ELF version - EV_CURRENT*/
+#define	EI_OSABI	7	/* OS/syscall ABI identification */
+#define	EI_ABIVERSION	8	/* syscall ABI version */
+#define	EI_PAD		9	/* Start of padding bytes up to EI_NIDENT*/
+
+/* Values for these fields */
+
+/* For e_ident[EI_MAG0..3] */
+#define	ELFMAG0		0x7f
+#define	ELFMAG1		'E'
+#define	ELFMAG2		'L'
+#define	ELFMAG3		'F'
+
+/* For e_ident[EI_CLASS] */
+#define	ELFCLASSNONE	0	/* Invalid class */
+#define	ELFCLASS32	1	/* 32-bit objects */
+#define	ELFCLASS64	2	/* 64-bit objects */
+
+/* e_ident[EI_DATA] */
+#define	ELFDATANONE	0	/* Invalid data encoding */
+#define	ELFDATA2LSB	1	/* 2's complement values, LSB first */
+#define	ELFDATA2MSB	2	/* 2's complement values, MSB first */
+
+/* e_ident[EI_VERSION] */
+#define	EV_NONE		0	/* Invalid version */
+#define	EV_CURRENT	1	/* Current version */
+
+/* e_ident[EI_OSABI] */
+#define	ELFOSABI_SYSV		0	/* UNIX System V ABI */
+#define	ELFOSABI_HPUX		1	/* HP-UX operating system */
+#define	ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
+
+
+/*
+ * Values for e_type
+ */
+#define	ET_NONE		0	/* No file type */
+#define	ET_REL		1	/* Relocatable file */
+#define	ET_EXEC		2	/* Executable file */
+#define	ET_DYN		3	/* Shared object file */
+#define	ET_CORE		4	/* Core file */
+#define	ET_NUM		5
+
+/*
+ * Values for e_machine
+ */
+#define	EM_NONE		0	/* No machine */
+#define	EM_M32		1	/* AT&T WE 32100 */
+#define	EM_SPARC	2	/* SPARC */
+#define	EM_386		3	/* Intel 80386 */
+#define	EM_68K		4	/* Motorola 68000 */
+#define	EM_88K		5	/* Motorola 88000 */
+#define	EM_486		6	/* Intel 80486 */
+#define	EM_860		7	/* Intel 80860 */
+#define	EM_MIPS		8	/* MIPS I Architecture */
+#define	EM_S370		9	/* Amdahl UTS on System/370 */
+#define	EM_MIPS_RS3_LE	10	/* MIPS RS3000 Little-endian */
+#define	EM_RS6000	11	/* IBM RS/6000 XXX reserved */
+#define	EM_PARISC	15	/* Hewlett-Packard PA-RISC */
+#define	EM_NCUBE	16	/* NCube XXX reserved */
+#define	EM_VPP500	17	/* Fujitsu VPP500 */
+#define	EM_SPARC32PLUS	18	/* Enhanced instruction set SPARC */
+#define	EM_960		19	/* Intel 80960 */
+#define	EM_PPC		20	/* PowerPC */
+#define	EM_V800		36	/* NEC V800 */
+#define	EM_FR20		37	/* Fujitsu FR20 */
+#define	EM_RH32		38	/* TRW RH-32 */
+#define	EM_RCE		39	/* Motorola RCE */
+#define	EM_ARM		40	/* Advanced RISC Machines ARM */
+#define	EM_ALPHA	41	/* DIGITAL Alpha */
+#define	EM_SH		42	/* Hitachi Super-H */
+#define	EM_SPARCV9	43	/* SPARC Version 9 */
+#define	EM_TRICORE	44	/* Siemens Tricore */
+#define	EM_ARC		45	/* Argonaut RISC Core */
+#define	EM_H8_300	46	/* Hitachi H8/300 */
+#define	EM_H8_300H	47	/* Hitachi H8/300H */
+#define	EM_H8S		48	/* Hitachi H8S */
+#define	EM_H8_500	49	/* Hitachi H8/500 */
+#define	EM_IA_64	50	/* Intel Merced Processor */
+#define	EM_MIPS_X	51	/* Stanford MIPS-X */
+#define	EM_COLDFIRE	52	/* Motorola Coldfire */
+#define	EM_68HC12	53	/* Motorola MC68HC12 */
+#define	EM_VAX		75	/* DIGITAL VAX */
+#define	EM_ALPHA_EXP	36902	/* used by NetBSD/alpha; obsolete */
+#define	EM_NUM		36903
+
+
+/*
+ * "Program Header" - runtime segment header.
+ * There are Ehdr.e_phnum of these located at one position within the file.
+ *
+ * Note: if p_memsz > p_filesz, the leftover space should be zero-filled.
+ */
+typedef struct {
+	u_int32_t	p_type;      /* Type of segment */
+	u_int32_t	p_offset;    /* Location of data within file */
+	u_int32_t	p_vaddr;     /* Virtual address */
+	u_int32_t	p_paddr;     /* Ignore */
+	u_int32_t	p_filesz;    /* Size of data within file */
+	u_int32_t	p_memsz;     /* Size of data to be loaded into memory*/
+	u_int32_t	p_flags;     /* Flags */
+	u_int32_t	p_align;     /* Required alignment - can ignore */
+} Elf32_Phdr;
+
+/* values for p_type */
+#define	PT_NULL		0		/* Program header table entry unused */
+#define	PT_LOAD		1		/* Loadable program segment */
+#define	PT_DYNAMIC	2		/* Dynamic linking information */
+#define	PT_INTERP	3		/* Program interpreter */
+#define	PT_NOTE		4		/* Auxiliary information */
+#define	PT_SHLIB	5		/* Reserved, unspecified semantics */
+#define	PT_PHDR		6		/* Entry for header table itself */
+#define	PT_NUM		7
+#define	PT_MIPS_REGINFO	0x70000000
+
+/* values for p_flags */
+#define	PF_R		0x4	/* Segment is readable */
+#define	PF_W		0x2	/* Segment is writable */
+#define	PF_X		0x1	/* Segment is executable */
+
+
+typedef Elf32_Ehdr Elf_Ehdr;
+typedef Elf32_Phdr Elf_Phdr;
+
+#endif /* _ELF_H_ */
diff --git a/os161-1.10/kern/include/emufs.h b/os161-1.10/kern/include/emufs.h
new file mode 100644
index 0000000..acc4f5e
--- /dev/null
+++ b/os161-1.10/kern/include/emufs.h
@@ -0,0 +1,27 @@
+#ifndef _EMUFS_H_
+#define _EMUFS_H_
+
+/*
+ * Get abstract structure definitions
+ */
+#include <vnode.h>
+#include <fs.h>
+
+/*
+ * Our structures
+ */
+
+struct emufs_vnode {
+	struct vnode ev_v;		/* abstract vnode structure */
+	struct emu_softc *ev_emu;	/* device */
+	u_int32_t ev_handle;		/* file handle */
+};
+
+struct emufs_fs {
+	struct fs ef_fs;		/* abstract filesystem structure */
+	struct emu_softc *ef_emu;	/* device */
+	struct emufs_vnode *ef_root;	/* root vnode */
+	struct array *ef_vnodes;	/* table of loaded vnodes */
+};
+
+#endif /* _EMUFS_H_ */
diff --git a/os161-1.10/kern/include/fs.h b/os161-1.10/kern/include/fs.h
new file mode 100644
index 0000000..b6f46db
--- /dev/null
+++ b/os161-1.10/kern/include/fs.h
@@ -0,0 +1,51 @@
+#ifndef _FS_H_
+#define _FS_H_
+
+/*
+ * Abstract filesystem. (Or device accessible as a file.)
+ *
+ * Operations:
+ *
+ *      fs_sync       - Flush all dirty buffers to disk.
+ *      fs_getvolname - Return volume name of filesystem.
+ *      fs_getroot    - Return root vnode of filesystem.
+ *      fs_unmount    - Attempt unmount of filesystem.
+ *
+ * fs_getvolname may return NULL on filesystem types that don't
+ * support the concept of a volume name. The string returned is
+ * assumed to point into the filesystem's private storage and live
+ * until unmount time.
+ *
+ * If the volume name changes on the fly, there is no way at present
+ * to make sure such changes don't cause name conflicts. So it probably
+ * should be considered fixed.
+ *
+ * fs_getroot should increment the refcount of the vnode returned.
+ * It should not ever return NULL.
+ *
+ * If fs_unmount returns an error, the filesystem stays mounted, and
+ * consequently the struct fs instance should remain valid. On success,
+ * however, the filesystem object and all storage associated with the
+ * filesystem should have been discarded/released.
+ *
+ * fs_data is a pointer to filesystem-specific data.
+ */
+struct fs {
+	int           (*fs_sync)(struct fs *);
+	const char   *(*fs_getvolname)(struct fs *);
+	struct vnode *(*fs_getroot)(struct fs *);
+	int           (*fs_unmount)(struct fs *);
+
+	void *fs_data;
+};
+
+/*
+ * Macros to shorten the calling sequences.
+ */
+#define FSOP_SYNC(fs)        ((fs)->fs_sync(fs))
+#define FSOP_GETVOLNAME(fs)  ((fs)->fs_getvolname(fs))
+#define FSOP_GETROOT(fs)     ((fs)->fs_getroot(fs))
+#define FSOP_UNMOUNT(fs)     ((fs)->fs_unmount(fs))
+
+
+#endif /* _FS_H_ */
diff --git a/os161-1.10/kern/include/kern/callno.h b/os161-1.10/kern/include/kern/callno.h
new file mode 100644
index 0000000..37b8bae
--- /dev/null
+++ b/os161-1.10/kern/include/kern/callno.h
@@ -0,0 +1,46 @@
+#ifndef _KERN_CALLNO_H_
+#define _KERN_CALLNO_H_
+
+/*
+ * System call numbers.
+ * Caution: this file is parsed by a shell script to generate the assembly
+ * language system call stubs. Don't add weird stuff between the markers.
+ */
+
+/*CALLBEGIN*/
+#define SYS__exit        0
+#define SYS_execv        1
+#define SYS_fork         2
+#define SYS_waitpid      3
+#define SYS_open         4
+#define SYS_read         5
+#define SYS_write        6
+#define SYS_close        7
+#define SYS_reboot       8
+#define SYS_sync         9
+#define SYS_sbrk         10
+#define SYS_getpid       11
+#define SYS_ioctl        12
+#define SYS_lseek        13
+#define SYS_fsync        14
+#define SYS_ftruncate    15
+#define SYS_fstat        16
+#define SYS_remove       17
+#define SYS_rename       18
+#define SYS_link         19
+#define SYS_mkdir        20
+#define SYS_rmdir        21
+#define SYS_chdir        22
+#define SYS_getdirentry  23
+#define SYS_symlink      24
+#define SYS_readlink     25
+#define SYS_dup2         26
+#define SYS_pipe         27
+#define SYS___time       28
+#define SYS___getcwd     29
+#define SYS_stat         30
+#define SYS_lstat        31
+/*CALLEND*/
+
+
+#endif /* _KERN_CALLNO_H_ */
diff --git a/os161-1.10/kern/include/kern/errmsg.h b/os161-1.10/kern/include/kern/errmsg.h
new file mode 100644
index 0000000..179fb43
--- /dev/null
+++ b/os161-1.10/kern/include/kern/errmsg.h
@@ -0,0 +1,47 @@
+#ifndef _KERN_ERRMSG_H_
+#define _KERN_ERRMSG_H_
+
+/*
+ * Error strings.
+ * This table must agree with kern/errno.h.
+ *
+ * Note that since this actually defines sys_errlist and sys_nerrlist, it
+ * should only be included in one file. For the kernel, that file is 
+ * lib/misc.c; for userland it's lib/libc/strerror.c.
+ */
+const char *const sys_errlist[] = {
+	"Operation succeeded",        /* 0 */
+	"Invalid argument",           /* EINVAL */
+	"Bad memory address",         /* EFAULT */
+	"String too long",            /* ENAMETOOLONG */
+	"Out of memory",              /* ENOMEM */
+	"Input/output error",         /* EIO */
+	"No such file or directory",  /* ENOENT */
+	"Not a directory",            /* ENOTDIR */
+	"Is a directory",             /* EISDIR */
+	"File or object exists",      /* EEXIST */
+	"Cross-device link",          /* EXDEV */
+	"Try again later",            /* EAGAIN */
+	"Illegal seek",               /* ESPIPE */
+	"Unimplemented feature",      /* EUNIMP */
+	"Device not available",       /* ENXIO */
+	"No such device",             /* ENODEV */
+	"Device or resource busy",    /* EBUSY */
+	"Invalid/inappropriate ioctl",/* EIOCTL (ENOTTY in Unix) */
+	"Directory not empty",        /* ENOTEMPTY */
+	"Result too large",           /* ERANGE */
+	"No space left on device",    /* ENOSPC */
+	"Too many open files",        /* EMFILE */
+	"Too many open files in system",/* ENFILE */
+	"No such system call",        /* ENOSYS */
+	"File is not executable",     /* ENOEXEC */
+	"Argument list too long",     /* E2BIG */
+	"Bad file number",            /* EBADF */
+};
+
+/*
+ * Number of entries in sys_errlist.
+ */
+const int sys_nerr = sizeof(sys_errlist)/sizeof(const char *);
+
+#endif /* _KERN_ERRMSG_H_ */
diff --git a/os161-1.10/kern/include/kern/errno.h b/os161-1.10/kern/include/kern/errno.h
new file mode 100644
index 0000000..68360ce
--- /dev/null
+++ b/os161-1.10/kern/include/kern/errno.h
@@ -0,0 +1,40 @@
+#ifndef _KERN_ERRNO_H_
+#define _KERN_ERRNO_H_
+
+/*
+ * If you change this, be sure to make appropriate corresponding changes
+ * to kern/errmsg.h as well. You might also want to change the man page
+ * for errno to document the new error.
+ *
+ * Also note that this file has to work from assembler, so it should
+ * contain only symbolic constants.
+ */
+
+#define EINVAL       1      /* Invalid argument */
+#define EFAULT       2      /* Bad memory reference */
+#define ENAMETOOLONG 3      /* String too long */
+#define ENOMEM       4      /* Out of memory */
+#define EIO          5      /* Input/output error */
+#define ENOENT       6      /* No such file or directory */
+#define ENOTDIR      7      /* Not a directory */
+#define EISDIR       8      /* Is a directory */
+#define EEXIST       9      /* File exists */
+#define EXDEV        10     /* Cross-device link */
+#define EAGAIN       11     /* Try again later */
+#define ESPIPE       12     /* Illegal seek */
+#define EUNIMP       13     /* Unimplemented feature */
+#define ENXIO        14     /* Device not available */
+#define ENODEV       15     /* No such device */
+#define EBUSY        16     /* Device busy */
+#define EIOCTL       17     /* Invalid or inappropriate ioctl */
+#define ENOTEMPTY    18     /* Directory not empty */
+#define ERANGE       19     /* Result too large */
+#define ENOSPC       20     /* No space left on device */
+#define EMFILE       21     /* Too many open files */
+#define ENFILE       22     /* Too many open files in system */
+#define ENOSYS       23     /* No such system call */
+#define ENOEXEC      24     /* File is not executable */
+#define E2BIG        25     /* Argument list too long */
+#define EBADF        26     /* Bad file number */
+
+#endif /* _KERN_ERRNO_H_ */
diff --git a/os161-1.10/kern/include/kern/ioctl.h b/os161-1.10/kern/include/kern/ioctl.h
new file mode 100644
index 0000000..f94ee87
--- /dev/null
+++ b/os161-1.10/kern/include/kern/ioctl.h
@@ -0,0 +1,10 @@
+#ifndef _KERN_IOCTL_H_
+#define _KERN_IOCTL_H_
+
+/*
+ * ioctl operation codes
+ */
+
+/* (none yet) */
+
+#endif /* _KERN_IOCTL_H_*/
diff --git a/os161-1.10/kern/include/kern/limits.h b/os161-1.10/kern/include/kern/limits.h
new file mode 100644
index 0000000..480b980
--- /dev/null
+++ b/os161-1.10/kern/include/kern/limits.h
@@ -0,0 +1,11 @@
+#ifndef _KERN_LIMITS_H_
+#define _KERN_LIMITS_H_
+
+/* Longest filename (without directory) not including null terminator */
+#define NAME_MAX  255
+
+/* Longest full path name */
+#define PATH_MAX   1024
+
+
+#endif /* _KERN_LIMITS_H_ */
diff --git a/os161-1.10/kern/include/kern/sfs.h b/os161-1.10/kern/include/kern/sfs.h
new file mode 100644
index 0000000..8a16060
--- /dev/null
+++ b/os161-1.10/kern/include/kern/sfs.h
@@ -0,0 +1,62 @@
+#ifndef _KERN_SFS_H_
+#define _KERN_SFS_H_
+
+#define SFS_MAGIC         0xabadf001    /* magic number identifying us */
+#define SFS_BLOCKSIZE     512           /* size of our blocks */
+#define SFS_VOLNAME_SIZE  32            /* max length of volume name */
+#define SFS_NDIRECT       15            /* # of direct blocks in inode */
+#define SFS_DBPERIDB      128           /* # direct blks per indirect blk */
+#define SFS_NAMELEN       60            /* max length of filename */
+#define SFS_SB_LOCATION    0            /* block the superblock lives in */
+#define SFS_ROOT_LOCATION  1            /* loc'n of the root dir inode */
+#define SFS_MAP_LOCATION   2            /* 1st block of the freemap */
+#define SFS_NOINO          0            /* inode # for free dir entry */
+
+/* Number of bits in a block */
+#define SFS_BLOCKBITS (SFS_BLOCKSIZE * CHAR_BIT)
+
+/* Utility macro */
+#define SFS_ROUNDUP(a,b)       ((((a)+(b)-1)/(b))*b)
+
+/* Size of bitmap (in bits) */
+#define SFS_BITMAPSIZE(nblocks) SFS_ROUNDUP(nblocks, SFS_BLOCKBITS)
+
+/* Size of bitmap (in blocks) */
+#define SFS_BITBLOCKS(nblocks)  (SFS_BITMAPSIZE(nblocks)/SFS_BLOCKBITS)
+
+/* File types for dfi_type */
+#define SFS_TYPE_INVAL    0       /* Should not appear on disk */
+#define SFS_TYPE_FILE     1
+#define SFS_TYPE_DIR      2
+
+/*
+ * On-disk superblock
+ */
+struct sfs_super {
+	u_int32_t sp_magic;       /* Magic number, should be SFS_MAGIC */
+	u_int32_t sp_nblocks;     /* Number of blocks in fs */
+	char sp_volname[SFS_VOLNAME_SIZE];  /* Name of this volume */
+	u_int32_t reserved[118];
+};
+
+/*
+ * On-disk inode
+ */
+struct sfs_inode {
+	u_int32_t sfi_size;        /* Size of this file (bytes) */
+	u_int16_t sfi_type;        /* One of SFS_TYPE_* above */
+	u_int16_t sfi_linkcount;   /* Number of hard links to this file */
+	u_int32_t sfi_direct[SFS_NDIRECT];	/* Direct blocks */
+	u_int32_t sfi_indirect;			/* Indirect block */
+	u_int32_t sfi_waste[128-3-SFS_NDIRECT]; /* unused space */
+};
+
+/*
+ * On-disk directory entry
+ */
+struct sfs_dir {
+	u_int32_t sfd_ino;              /* Inode number */
+	char sfd_name[SFS_NAMELEN];  /* Filename */
+};
+
+#endif /* _KERN_SFS_H_ */
diff --git a/os161-1.10/kern/include/kern/stat.h b/os161-1.10/kern/include/kern/stat.h
new file mode 100644
index 0000000..07a4cbf
--- /dev/null
+++ b/os161-1.10/kern/include/kern/stat.h
@@ -0,0 +1,38 @@
+#ifndef _KERN_STAT_H_
+#define _KERN_STAT_H_
+
+/*
+ * Structure for stat (call to get file information)
+ */
+
+struct stat {
+	u_int32_t st_mode;	/* protection mode and file type */
+	u_int32_t st_nlink;	/* number of hard links */
+	off_t st_size;		/* file size (bytes) */
+	u_int32_t st_blocks;	/* number of blocks file is using */
+};
+
+/*
+ * File types for st_mode.
+ * The permissions are the low 12 bits; in OS/161 we don't use those.
+ * (Unless you're implementing security and permissions and doing it
+ * completely Unix-style.)
+ */
+
+#define S_IFMT  070000		/* mask for type of file */
+#define S_IFREG 010000		/* ordinary regular file */
+#define S_IFDIR 020000		/* directory */
+#define S_IFLNK 030000		/* symbolic link */
+#define S_IFCHR 040000		/* character device */
+#define S_IFBLK 050000		/* block device */
+
+/*
+ * Macros for testing a mode value
+ */
+#define S_ISREG(mode)	(((mode) & S_IFMT) == S_IFREG)	/* regular file */
+#define S_ISDIR(mode)	(((mode) & S_IFMT) == S_IFDIR)	/* directory */
+#define S_ISLNK(mode)	(((mode) & S_IFMT) == S_IFLNK)	/* symlink */
+#define S_ISCHR(mode)	(((mode) & S_IFMT) == S_IFCHR)	/* char device */
+#define S_ISBLK(mode)	(((mode) & S_IFMT) == S_IFBLK)	/* block device */
+
+#endif /* _KERN_STAT_H_ */
diff --git a/os161-1.10/kern/include/kern/types.h b/os161-1.10/kern/include/kern/types.h
new file mode 100644
index 0000000..b2933df
--- /dev/null
+++ b/os161-1.10/kern/include/kern/types.h
@@ -0,0 +1,14 @@
+#ifndef _KERN_TYPES_H_
+#define _KERN_TYPES_H_
+
+/*
+ * Machine-independent types visible to user level.
+ *
+ * In many real systems, off_t and time_t are int64_t.
+ */
+
+typedef int32_t off_t;   /* Offset within file */
+typedef int32_t pid_t;   /* Process ID */
+typedef int32_t time_t;  /* Time in seconds */
+
+#endif /* _KERN_TYPES_H_ */
diff --git a/os161-1.10/kern/include/kern/unistd.h b/os161-1.10/kern/include/kern/unistd.h
new file mode 100644
index 0000000..94c921a
--- /dev/null
+++ b/os161-1.10/kern/include/kern/unistd.h
@@ -0,0 +1,40 @@
+#ifndef _KERN_UNISTD_H_
+#define _KERN_UNISTD_H_
+
+/*
+ * Constants for system calls
+ */
+
+/* Flags for open: choose one of these: */
+#define O_RDONLY      0      /* Open for read */
+#define O_WRONLY      1      /* Open for write */
+#define O_RDWR        2      /* Open for read and write */
+/* then or in any of these: */
+#define O_CREAT       4      /* Create file if it doesn't exist */
+#define O_EXCL        8      /* With O_CREAT, fail if file already exists */
+#define O_TRUNC      16      /* Truncate file upon open */
+#define O_APPEND     32      /* All writes happen at EOF (optional feature) */
+
+/* Additional related definition */
+#define O_ACCMODE     3      /* mask for O_RDONLY/O_WRONLY/O_RDWR */
+
+
+/* Constants for read/write/etc: special file handles */
+#define STDIN_FILENO  0      /* Standard input */
+#define STDOUT_FILENO 1      /* Standard output */
+#define STDERR_FILENO 2      /* Standard error */
+
+/* Codes for reboot */
+#define RB_REBOOT     0      /* Reboot system */
+#define RB_HALT       1      /* Halt system and do not reboot */
+#define RB_POWEROFF   2      /* Halt system and power off */
+
+/* Codes for lseek */
+#define SEEK_SET      0      /* Seek relative to beginning of file */
+#define SEEK_CUR      1      /* Seek relative to current position in file */
+#define SEEK_END      2      /* Seek relative to end of file */
+
+/* The codes for ioctl are in kern/ioctl.h */
+/* The codes for stat/fstat/lstat are in kern/stat.h */
+
+#endif /* _KERN_UNISTD_H_ */
diff --git a/os161-1.10/kern/include/lib.h b/os161-1.10/kern/include/lib.h
new file mode 100644
index 0000000..34244ff
--- /dev/null
+++ b/os161-1.10/kern/include/lib.h
@@ -0,0 +1,213 @@
+#ifndef _LIB_H_
+#define _LIB_H_
+
+/*
+ * Miscellaneous standard C functions for the kernel, and other widely used
+ * kernel functions.
+ */
+
+#include <machine/setjmp.h>
+
+/*
+ * Tell GCC to check printf formats.
+ */
+#ifdef __GNUC__
+#define __PF(a,b) __attribute__((__format__(__printf__, a, b)))
+#else
+#define __PF(a,b)
+#endif
+
+/*
+ * If not GCC, disable __PRETTY_FUNCTION__
+ */
+#ifndef __GNUC__
+#define __PRETTY_FUNCTION__ "<unknown function>"
+#endif
+
+/*
+ * Standard assert macro.
+ */
+#define assert(x) { \
+    if (!(x)) { \
+            panic("Assertion failed: %s, at %s:%d (%s)\n", #x, \
+                    __FILE__, __LINE__, __PRETTY_FUNCTION__); \
+    } \
+  }
+
+/*
+ * Bit flags for DEBUG()
+ */
+#define DB_LOCORE      0x001
+#define DB_SYSCALL     0x002
+#define DB_INTERRUPT   0x004
+#define DB_DEVICE      0x008
+#define DB_THREADS     0x010
+#define DB_VM          0x020
+#define DB_EXEC        0x040
+#define DB_VFS         0x080
+#define DB_SFS         0x100
+#define DB_NET         0x200
+#define DB_NETFS       0x400
+#define DB_KMALLOC     0x800
+
+extern u_int32_t dbflags;
+
+/*
+ * DEBUG() is for conditionally printing debug messages to the console.
+ *
+ * The idea is that you put lots of lines of the form
+ *
+ *      DEBUG(DB_VM, "VM free pages: %u\n", free_pages);
+ *
+ * throughout the kernel; then you can toggle whether these messages
+ * are printed or not at runtime by setting the value of dbflags with
+ * the debugger.
+ *
+ * Unfortunately, as of this writing, there are only a very few such
+ * messages actually present in the system yet. Feel free to add more.
+ *
+ * DEBUG is a varargs macro. The first form is the standard C99
+ * way. The second is the gcc way, which, in light of C99, is obsolete -
+ * - but the gcc we're using doesn't know the C99 syntax yet.
+ */
+#if 0
+#define DEBUG(d, fmt, ...) ((dbflags & (d)) ? kprintf(fmt, __VA_ARGS__) : 0)
+#else
+#define DEBUG(d, fmt, args...) ((dbflags & (d)) ? kprintf(fmt, ##args) : 0)
+#endif
+
+/*
+ * Random number generator, using the random device.
+ */
+#define RAND_MAX (randmax())
+u_int32_t randmax(void);
+u_int32_t random(void);
+
+/*
+ * Kernel heap memory allocation. Like malloc/free.
+ * If out of memory, kmalloc returns NULL.
+ */
+void *kmalloc(size_t sz);
+void kfree(void *ptr);
+void kheap_printstats(void);
+
+/*
+ * C string functions. 
+ *
+ * kstrdup is like strdup, but calls kmalloc instead of malloc.
+ * If out of memory, it returns NULL.
+ */
+size_t strlen(const char *);
+int strcmp(const char *, const char *);
+char *strcpy(char *, const char *);
+char *strcat(char *, const char *);
+char *kstrdup(const char *);
+char *strchr(const char *, int);
+char *strrchr(const char *, int);
+char *strtok_r(char *buf, const char *seps, char **context);
+
+void *memcpy(void *, const void *, size_t);
+void *memmove(void *, const void *, size_t);
+void bzero(void *, size_t);
+int atoi(const char *);
+
+int snprintf(char *buf, size_t maxlen, const char *fmt, ...) __PF(3,4);
+
+const char *strerror(int errcode);
+
+/*
+ * setjmp/longjmp functionality.
+ */
+
+int setjmp(jmp_buf jb);
+void longjmp(jmp_buf jb, int retval);
+
+/*
+ * Low-level console access.
+ */
+void putch(int ch);
+int getch(void);
+void beep(void);
+
+/*
+ * Higher-level console output.
+ *
+ * kprintf is like printf, only in the kernel.
+ * panic prepends the string "panic: " to the message printed, and then
+ * resets the system.
+ * kgets is like gets, only with a buffer size argument.
+ *
+ * kprintf_init sets up a lock for kprintf and should be called during boot
+ * once malloc is available and before any additional threads are created.
+ */
+int kprintf(const char *fmt, ...) __PF(1,2);
+void panic(const char *fmt, ...) __PF(1,2);
+
+void kgets(char *buf, size_t maxbuflen);
+
+void kprintf_bootstrap(void);
+
+/*
+ * Byte swap functions for the kernel.
+ */
+u_int16_t ntohs(u_int16_t);
+u_int16_t htons(u_int16_t);
+u_int32_t ntohl(u_int32_t);
+u_int32_t htonl(u_int32_t);
+u_int64_t ntohll(u_int64_t);
+u_int64_t htonll(u_int64_t);
+
+/*
+ * copyin/copyout/copyinstr/copyoutstr are standard BSD kernel functions.
+ *
+ * copyin copies LEN bytes from a user-space address USERSRC to a
+ * kernel-space address DEST.
+ *
+ * copyout copies LEN bytes from a kernel-space address SRC to a
+ * user-space address USERDEST.
+ *
+ * copyinstr copies a null-terminated string of at most LEN bytes from
+ * a user-space address USERSRC to a kernel-space address DEST, and 
+ * returns the actual length of string found in GOT. DEST is always
+ * null-terminated on success. LEN and GOT include the null terminator.
+ *
+ * copyoutstr copies a null-terminated string of at most LEN bytes from
+ * a kernel-space address SRC to a user-space address USERDEST, and 
+ * returns the actual length of string found in GOT. DEST is always
+ * null-terminated on success. LEN and GOT include the null terminator.
+ *
+ * All of these functions return 0 on success, EFAULT if a memory
+ * addressing error was encountered, or (for the string versions)
+ * ENAMETOOLONG if the space available was insufficient.
+ *
+ * NOTE that the order of the arguments is the same as bcopy() or 
+ * cp/mv, that is, source on the left, NOT the same as strcpy().
+ *
+ * These functions are machine-dependent.
+ */
+ 
+int copyin(const_userptr_t usersrc, void *dest, size_t len);
+int copyout(const void *src, userptr_t userdest, size_t len);
+int copyinstr(const_userptr_t usersrc, char *dest, size_t len, size_t *got);
+int copyoutstr(const char *src, userptr_t userdest, size_t len, size_t *got);
+
+/*
+ * Simple timing hooks.
+ *
+ * Threads sleeping on lbolt are woken up once a second.
+ *
+ * clocksleep() suspends execution for the requested number of seconds,
+ * like userlevel sleep(3). (Don't confuse it with thread_sleep.)
+ */
+extern int lbolt;
+void clocksleep(int seconds);
+
+/*
+ * Other miscellaneous stuff
+ */
+
+#define DIVROUNDUP(a,b) (((a)+(b)-1)/(b))
+#define ROUNDUP(a,b)    (DIVROUNDUP(a,b)*b)
+
+
+#endif /* _LIB_H_ */
diff --git a/os161-1.10/kern/include/queue.h b/os161-1.10/kern/include/queue.h
new file mode 100644
index 0000000..4adf99b
--- /dev/null
+++ b/os161-1.10/kern/include/queue.h
@@ -0,0 +1,56 @@
+#ifndef _QUEUE_H_
+#define _QUEUE_H_
+
+/* 
+ * Queue of void pointers, implemented as a ring buffer.
+ *
+ * Functions:
+ *       q_create  - allocate a new queue, with initial size SIZE.
+ *                   Returns NULL on error.
+ *       q_preallocate - extend the queue if necessary so its size is
+ *                   at least SIZE. Returns an error code.
+ *       q_empty   - return true if queue is empty.
+ *       q_addtail - add a pointer to the tail of the queue. If the queue
+ *                   overflows, it will extend itself, but this is slow.
+ *                   Returns an error code if the extension fails. Does not
+ *                   fail if no extension is required.
+ *       q_remhead - remove a pointer from the head of the queue. If the
+ *                   queue is empty, panics.
+ *       q_destroy - dispose of the queue.
+ */
+
+struct queue; /* Opaque. */
+
+struct queue *q_create(int size);
+int           q_preallocate(struct queue *, int size);
+int           q_empty(struct queue *);
+int           q_addtail(struct queue *, void *ptr);
+void         *q_remhead(struct queue *);
+void          q_destroy(struct queue *);
+
+/* 
+ * These are really intended only for debugging. Using them encodes 
+ * knowledge of how the queue works, which is usually undesirable.
+ *
+ *      q_getstart - return the index of the front of the queue
+ *      q_getend   - return the index of the back of the queue
+ *      q_getsize  - return the current size of the queue
+ *      q_getguy   - return queue member by index
+ *
+ * To iterate over the queue, do something like
+ *      struct queue *q;
+ *      int i;
+ *      
+ *      for (i=q_getstart(q); i!=q_getend(q); i=(i+1)%q_getsize(q)) {
+ *              void *ptr = q_getguy(q, i);
+ *                :
+ *      }
+ *
+ * If you do this, synchronization is your problem.
+ */
+int   q_getstart(struct queue *);
+int   q_getend(struct queue *);
+int   q_getsize(struct queue *);
+void *q_getguy(struct queue *, int index);
+
+#endif /* _QUEUE_H_ */
diff --git a/os161-1.10/kern/include/scheduler.h b/os161-1.10/kern/include/scheduler.h
new file mode 100644
index 0000000..86f7186
--- /dev/null
+++ b/os161-1.10/kern/include/scheduler.h
@@ -0,0 +1,33 @@
+#ifndef _SCHEDULER_H_
+#define _SCHEDULER_H_
+
+/*
+ * Scheduler-related function calls.
+ *
+ *     scheduler     - run the scheduler and choose the next thread to run.
+ *     make_runnable - add the specified thread to the run queue. If it's
+ *                     already on the run queue or sleeping, weird things
+ *                     may happen. Returns an error code.
+ *
+ *     print_run_queue - dump the run queue to the console for debugging.
+ *
+ *     scheduler_bootstrap - initialize scheduler data 
+ *                           (must happen early in boot)
+ *     scheduler_shutdown -  clean up scheduler data
+ *     scheduler_preallocate - ensure space for at least NUMTHREADS threads.
+ *                           Returns an error code.
+ */
+
+struct thread;
+
+struct thread *scheduler(void);
+int make_runnable(struct thread *t);
+
+void print_run_queue(void);
+
+void scheduler_bootstrap(void);
+int scheduler_preallocate(int numthreads);
+void scheduler_killall(void);
+void scheduler_shutdown(void);
+
+#endif /* _SCHEDULER_H_ */
diff --git a/os161-1.10/kern/include/sfs.h b/os161-1.10/kern/include/sfs.h
new file mode 100644
index 0000000..026daf1
--- /dev/null
+++ b/os161-1.10/kern/include/sfs.h
@@ -0,0 +1,55 @@
+#ifndef _SFS_H_
+#define _SFS_H_
+
+/*
+ * Get abstract structure definitions
+ */
+#include <vnode.h>
+#include <fs.h>
+
+/*
+ * Get on-disk structures and constants that are made available to 
+ * userland for the benefit of mksfs, dumpsfs, etc.
+ */
+#include <kern/sfs.h>
+
+struct sfs_vnode {
+	struct vnode sv_v;              /* abstract vnode structure */
+	struct sfs_inode sv_i;		/* on-disk inode */
+	u_int32_t sv_ino;               /* inode number */
+	int sv_dirty;                   /* true if sv_i modified */
+};
+
+struct sfs_fs {
+	struct fs sfs_absfs;            /* abstract filesystem structure */
+	struct sfs_super sfs_super;	/* on-disk superblock */
+	int sfs_superdirty;             /* true if superblock modified */
+	struct device *sfs_device;      /* device mounted on */
+	struct array *sfs_vnodes;       /* vnodes loaded into memory */
+	struct bitmap *sfs_freemap;     /* blocks in use are marked 1 */
+	int sfs_freemapdirty;           /* true if freemap modified */
+};
+
+/*
+ * Function for mounting a sfs (calls vfs_mount)
+ */
+int sfs_mount(const char *device);
+
+
+/*
+ * Internal functions
+ */
+
+/* Initialize uio structure */
+#define SFSUIO(uio, ptr, block, rw) \
+    mk_kuio(uio, ptr, SFS_BLOCKSIZE, ((off_t)(block))*SFS_BLOCKSIZE, rw)
+
+/* Convenience functions for block I/O */
+int sfs_rwblock(struct sfs_fs *sfs, struct uio *uio);
+int sfs_rblock(struct sfs_fs *sfs, void *data, u_int32_t block);
+int sfs_wblock(struct sfs_fs *sfs, void *data, u_int32_t block);
+
+/* Get root vnode */
+struct vnode *sfs_getroot(struct fs *fs);
+
+#endif /* _SFS_H_ */
diff --git a/os161-1.10/kern/include/stdarg.h b/os161-1.10/kern/include/stdarg.h
new file mode 100644
index 0000000..32b14ac
--- /dev/null
+++ b/os161-1.10/kern/include/stdarg.h
@@ -0,0 +1,37 @@
+#ifndef _STDARG_H_
+#define _STDARG_H_
+
+/* Make sure we have __PF() */
+#include <lib.h>
+
+/*
+ * As of gcc 3.0, the stdarg declarations can be made
+ * machine-independent because gcc abstracts the implementations away
+ * for us.
+ */
+
+typedef __builtin_va_list __va_list;
+typedef __va_list va_list;
+
+#define va_start(ap,fmt) __builtin_stdarg_start(ap,fmt)
+#define va_arg(ap,t) __builtin_va_arg(ap,t)
+#define va_copy(ap1,ap2) __builtin_va_copy(ap1,ap2)
+#define va_end(ap) __builtin_va_end(ap)
+
+/*
+ * The v... versions of printf functions in <lib.h>. This is not really
+ * the best place for them...
+ */
+void vkprintf(const char *fmt, va_list ap) __PF(1,0);
+int vsnprintf(char *buf, size_t maxlen, const char *f, va_list ap) __PF(3,0);
+
+/*
+ * The printf driver function (shared with libc).
+ * Does v...printf, passing the output data piecemeal to the function
+ * supplied. The "clientdata" argument is passed through to the function.
+ * The strings passed to the function might not be null-terminated.
+ */
+int __vprintf(void (*func)(void *clientdata, const char *str, size_t len), 
+	      void *clientdata, const char *format, va_list ap) __PF(3,0);
+
+#endif /* _STDARG_H_ */
diff --git a/os161-1.10/kern/include/synch.h b/os161-1.10/kern/include/synch.h
new file mode 100644
index 0000000..3583e78
--- /dev/null
+++ b/os161-1.10/kern/include/synch.h
@@ -0,0 +1,102 @@
+/*
+ * Header file for synchronization primitives.
+ */
+
+#ifndef _SYNCH_H_
+#define _SYNCH_H_
+
+/*
+ * Dijkstra-style semaphore.
+ * Operations:
+ *     P (proberen): decrement count. If the count is 0, block until
+ *                   the count is 1 again before decrementing.
+ *     V (verhogen): increment count.
+ * 
+ * Both operations are atomic.
+ *
+ * The name field is for easier debugging. A copy of the name is made
+ * internally.
+ */
+
+struct semaphore {
+	char *name;
+	volatile int count;
+};
+
+struct semaphore *sem_create(const char *name, int initial_count);
+void              P(struct semaphore *);
+void              V(struct semaphore *);
+void              sem_destroy(struct semaphore *);
+
+
+/*
+ * Simple lock for mutual exclusion.
+ * Operations:
+ *    lock_acquire - Get the lock. Only one thread can hold the lock at the
+ *                   same time.
+ *    lock_release - Free the lock. Only the thread holding the lock may do
+ *                   this.
+ *    lock_do_i_hold - Return true if the current thread holds the lock; 
+ *                   false otherwise.
+ *
+ * These operations must be atomic. You get to write them.
+ *
+ * When the lock is created, no thread should be holding it. Likewise,
+ * when the lock is destroyed, no thread should be holding it.
+ *
+ * The name field is for easier debugging. A copy of the name is made
+ * internally.
+ */
+
+struct lock {
+	char *name;
+	// add what you need here
+	// (don't forget to mark things volatile as needed)
+};
+
+struct lock *lock_create(const char *name);
+void         lock_acquire(struct lock *);
+void         lock_release(struct lock *);
+int          lock_do_i_hold(struct lock *);
+void         lock_destroy(struct lock *);
+
+
+/*
+ * Condition variable.
+ *
+ * Note that the "variable" is a bit of a misnomer: a CV is normally used
+ * to wait until a variable meets a particular condition, but there's no
+ * actual variable, as such, in the CV.
+ *
+ * Operations:
+ *    cv_wait      - Release the supplied lock, go to sleep, and, after
+ *                   waking up again, re-acquire the lock.
+ *    cv_signal    - Wake up one thread that's sleeping on this CV.
+ *    cv_broadcast - Wake up all threads sleeping on this CV.
+ *
+ * For all three operations, the current thread must hold the lock passed 
+ * in. Note that under normal circumstances the same lock should be used
+ * on all operations with any particular CV.
+ *
+ * These operations must be atomic. You get to write them.
+ *
+ * These CVs are expected to support Mesa semantics, that is, no
+ * guarantees are made about scheduling.
+ *
+ * The name field is for easier debugging. A copy of the name is made
+ * internally.
+ */
+
+struct cv {
+	char *name;
+	// add what you need here
+	// (don't forget to mark things volatile as needed)
+};
+
+struct cv *cv_create(const char *name);
+void       cv_wait(struct cv *cv, struct lock *lock);
+void       cv_signal(struct cv *cv, struct lock *lock);
+void       cv_broadcast(struct cv *cv, struct lock *lock);
+void       cv_destroy(struct cv *);
+
+#endif /* _SYNCH_H_ */
diff --git a/os161-1.10/kern/include/syscall.h b/os161-1.10/kern/include/syscall.h
new file mode 100644
index 0000000..339514d
--- /dev/null
+++ b/os161-1.10/kern/include/syscall.h
@@ -0,0 +1,11 @@
+#ifndef _SYSCALL_H_
+#define _SYSCALL_H_
+
+/*
+ * Prototypes for IN-KERNEL entry points for system call implementations.
+ */
+
+int sys_reboot(int code);
+
+
+#endif /* _SYSCALL_H_ */
diff --git a/os161-1.10/kern/include/test.h b/os161-1.10/kern/include/test.h
new file mode 100644
index 0000000..29c5ce2
--- /dev/null
+++ b/os161-1.10/kern/include/test.h
@@ -0,0 +1,50 @@
+#ifndef _TEST_H_
+#define _TEST_H_
+
+/*
+ * Declarations for test code and other miscellaneous functions.
+ */
+
+
+/* These are only actually available if OPT_SYNCHPROBS is set. */
+int catmousesem(int, char **);
+int catmouselock(int, char **);
+int createcars(int, char **);
+
+/*
+ * Test code.
+ */
+
+/* lib tests */
+int arraytest(int, char **);
+int bitmaptest(int, char **);
+int queuetest(int, char **);
+
+/* thread tests */
+int threadtest(int, char **);
+int threadtest2(int, char **);
+int threadtest3(int, char **);
+int semtest(int, char **);
+int locktest(int, char **);
+int cvtest(int, char **);
+
+/* filesystem tests */
+int fstest(int, char **);
+int readstress(int, char **);
+int writestress(int, char **);
+int writestress2(int, char **);
+int createstress(int, char **);
+int printfile(int, char **);
+
+/* other tests */
+int malloctest(int, char **);
+int mallocstress(int, char **);
+int nettest(int, char **);
+
+/* Kernel menu system */
+void menu(char *argstr);
+
+/* Routine for running userlevel test code. */
+int runprogram(char *progname);
+
+#endif /* _TEST_H_ */
diff --git a/os161-1.10/kern/include/thread.h b/os161-1.10/kern/include/thread.h
new file mode 100644
index 0000000..b051467
--- /dev/null
+++ b/os161-1.10/kern/include/thread.h
@@ -0,0 +1,112 @@
+#ifndef _THREAD_H_
+#define _THREAD_H_
+
+/*
+ * Definition of a thread.
+ */
+
+/* Get machine-dependent stuff */
+#include <machine/pcb.h>
+
+
+struct addrspace;
+
+struct thread {
+	/**********************************************************/
+	/* Private thread members - internal to the thread system */
+	/**********************************************************/
+	
+	struct pcb t_pcb;
+	char *t_name;
+	const void *t_sleepaddr;
+	char *t_stack;
+	
+	/**********************************************************/
+	/* Public thread members - can be used by other code      */
+	/**********************************************************/
+	
+	/*
+	 * This is public because it isn't part of the thread system,
+	 * and will need to be manipulated by the userprog and/or vm
+	 * code.
+	 */
+	struct addrspace *t_vmspace;
+
+	/*
+	 * This is public because it isn't part of the thread system,
+	 * and is manipulated by the virtual filesystem (VFS) code.
+	 */
+	struct vnode *t_cwd;
+};
+
+/* Call once during startup to allocate data structures. */
+struct thread *thread_bootstrap(void);
+
+/* Call during panic to stop other threads in their tracks */
+void thread_panic(void);
+
+/* Call during shutdown to clean up (must be called by initial thread) */
+void thread_shutdown(void);
+
+/*
+ * Make a new thread, which will start executing at "func".  The
+ * "data" arguments (one pointer, one integer) are passed to the
+ * function.  The current thread is used as a prototype for creating
+ * the new one. If "ret" is non-null, the thread structure for the new
+ * thread is handed back. (Note that using said thread structure from
+ * the parent thread should be done only with caution, because in
+ * general the child thread might exit at any time.) Returns an error
+ * code.
+ */
+int thread_fork(const char *name, 
+		void *data1, unsigned long data2, 
+		void (*func)(void *, unsigned long),
+		struct thread **ret);
+
+/*
+ * Cause the current thread to exit.
+ * Interrupts need not be disabled.
+ */
+void thread_exit(void);
+
+/*
+ * Cause the current thread to yield to the next runnable thread, but
+ * itself stay runnable.
+ * Interrupts need not be disabled.
+ */
+void thread_yield(void);
+
+/*
+ * Cause the current thread to yield to the next runnable thread, and
+ * go to sleep until wakeup() is called on the same address. The
+ * address is treated as a key and is not interpreted or dereferenced.
+ * Interrupts must be disabled.
+ */
+void thread_sleep(const void *addr);
+
+/*
+ * Cause all threads sleeping on the specified address to wake up.
+ * Interrupts must be disabled.
+ */
+void thread_wakeup(const void *addr);
+
+/*
+ * Return nonzero if there are any threads sleeping on the specified
+ * address. Meant only for diagnostic purposes.
+ */
+int thread_hassleepers(const void *addr);
+
+
+/*
+ * Private thread functions.
+ */
+
+/* Machine independent entry point for new threads. */
+void mi_threadstart(void *data1, unsigned long data2, 
+		    void (*func)(void *, unsigned long));
+
+/* Machine dependent context switch. */
+void md_switch(struct pcb *old, struct pcb *nu);
+
+
+#endif /* _THREAD_H_ */
diff --git a/os161-1.10/kern/include/types.h b/os161-1.10/kern/include/types.h
new file mode 100644
index 0000000..aa285a7
--- /dev/null
+++ b/os161-1.10/kern/include/types.h
@@ -0,0 +1,30 @@
+#ifndef _TYPES_H_
+#define _TYPES_H_
+
+/*
+ * The model for the include files in the kernel is as follows:
+ *
+ *     1. Every source file includes this file, <types.h>, first.
+ *
+ *     2. Every other header file may assume this file has been
+ *        included, but should explicitly include any other headers
+ *        it requires to compile.
+ */
+
+
+/* Get machine-dependent types visible to userland */
+#include <machine/types.h>
+
+/* Get machine-independent types visible to userland */
+#include <kern/types.h>
+
+/*
+ * Define userptr_t as a pointer to a one-byte struct, so it won't mix
+ * with other pointers.
+ */
+
+struct __userptr { char _dummy; };
+typedef struct __userptr *userptr_t;
+typedef const struct __userptr *const_userptr_t;
+
+#endif /* _TYPES_H_ */
diff --git a/os161-1.10/kern/include/uio.h b/os161-1.10/kern/include/uio.h
new file mode 100644
index 0000000..4062d7e
--- /dev/null
+++ b/os161-1.10/kern/include/uio.h
@@ -0,0 +1,86 @@
+#ifndef _UIO_H_
+#define _UIO_H_
+
+/*
+ * Like BSD uio, but simplified a bit. (In BSD, there can be more than one
+ * iovec in a uio.)
+ */
+
+enum uio_rw {
+	UIO_READ,
+	UIO_WRITE,
+};
+
+enum uio_seg {
+	UIO_USERSPACE,
+	UIO_SYSSPACE,
+	UIO_USERISPACE,
+};
+
+struct iovec {
+	union {
+		void      *un_kbase;   /* kernel address (UIO_SYSSPACE) */
+		userptr_t  un_ubase;   /* user address (UIO_USER{,I}SPACE */
+	} iov_un;
+	size_t iov_len;                /* Length of data */
+};
+#define iov_kbase  iov_un.un_kbase
+#define iov_ubase  iov_un.un_ubase
+
+struct uio {
+	struct iovec      uio_iovec;       /* Data block */
+	off_t             uio_offset;      /* desired offset into object */
+	size_t            uio_resid;       /* Remaining amt of data to xfer */
+	enum uio_seg      uio_segflg;      /* what kind of pointer we have */
+	enum uio_rw       uio_rw;          /* whether op is a read or write */
+	struct addrspace *uio_space;       /* address space for user pointer */
+};
+
+
+/*
+ * Copy data from a kernel buffer to a data region defined by a uio struct,
+ * updating the uio struct's offset and resid fields. May alter the iovec
+ * fields as well.
+ *
+ * Before calling this, you should
+ *   (1) set up uio_iovec to point to the buffer you want to transfer to;
+ *   (2) initialize uio_offset as desired;
+ *   (3) initialize uio_resid to the total amount of data that can be 
+ *       transferred through this uio;
+ *   (4) set up uio_seg and uio_rw correctly;
+ *   (5) if uio_seg is UIO_SYSSPACE, set uio_space to NULL; otherwise,
+ *       initialize uio_space to the address space in which the buffer
+ *       should be found.
+ *
+ * After calling, 
+ *   (1) the contents of uio_iovec may be altered and should not be 
+ *       interpreted;
+ *   (2) uio_offset will have been incremented by the amount transferred;
+ *   (3) uio_resid will have been decremented by the amount transferred;
+ *   (4) uio_segflg, uio_rw, and uio_space will be unchanged.
+ *
+ * uiomove() may be called repeatedly on the same uio to transfer
+ * additional data until the available buffer space the uio refers to
+ * is exhausted.
+ *
+ * Note that the actual value of uio_offset is not interpreted. It is
+ * provided to allow for easier file seek pointer management.
+ *
+ * When uiomove is called, the address space presently in context must
+ * be the same as the one recorded in uio_space. This is an important
+ * sanity check if I/O has been queued.
+ */
+
+int uiomove(void *kbuffer, size_t len, struct uio *uio);
+
+/*
+ * Like uiomove, but sends zeros.
+ */
+int uiomovezeros(size_t len, struct uio *uio);
+
+/*
+ * Initialize uio for I/O from a kernel buffer.
+ */
+void mk_kuio(struct uio *, void *kbuf, size_t len, off_t pos, enum uio_rw rw);
+
+#endif /* _UIO_H_ */
diff --git a/os161-1.10/kern/include/version.h b/os161-1.10/kern/include/version.h
new file mode 100644
index 0000000..347024f
--- /dev/null
+++ b/os161-1.10/kern/include/version.h
@@ -0,0 +1,16 @@
+#ifndef _VERSION_H_
+#define _VERSION_H_
+
+/*
+ * Leave this alone, so we can tell what version of the OS/161 base
+ * code we gave you.
+ */
+#define BASE_VERSION    "1.10"
+
+/*
+ * Change this as you see fit in the course of hacking the system.
+ */
+#define GROUP_VERSION   "0"
+
+
+#endif /* _VERSION_H_ */
diff --git a/os161-1.10/kern/include/vfs.h b/os161-1.10/kern/include/vfs.h
new file mode 100644
index 0000000..3a83566
--- /dev/null
+++ b/os161-1.10/kern/include/vfs.h
@@ -0,0 +1,149 @@
+#ifndef _VFS_H_
+#define _VFS_H_
+
+/*
+ * Virtual File System layer functions.
+ *
+ * The VFS layer translates operations on abstract on-disk files or
+ * pathnames to operations on specific files on specific filesystems.
+ */
+
+struct uio;    /* kernel or userspace I/O buffer (uio.h) */
+struct device; /* abstract structure for a device (dev.h) */
+struct fs;     /* abstract structure for a filesystem (fs.h) */
+struct vnode;  /* abstract structure for an on-disk file (vnode.h) */
+
+/*
+ * VFS layer low-level operations. 
+ * See vnode.h for direct operations on vnodes.
+ * See fs.h for direct operations on filesystems/devices.
+ *
+ *    vfs_setcurdir - change current directory of current thread by vnode
+ *    vfs_clearcurdir - change current directory of current thread to "none"
+ *    vfs_getcurdir - retrieve vnode of current directory of current thread
+ *    vfs_sync      - force all dirty buffers to disk
+ *    vfs_getroot   - get root vnode for the filesystem named DEVNAME
+ *    vfs_getdevname - get mounted device name for the filesystem passed in
+ */
+
+int vfs_setcurdir(struct vnode *dir);
+int vfs_clearcurdir(void);
+int vfs_getcurdir(struct vnode **retdir);
+int vfs_sync(void);
+int vfs_getroot(const char *devname, struct vnode **result);
+const char *vfs_getdevname(struct fs *fs);
+
+/*
+ * VFS layer mid-level operations.
+ *
+ *    vfs_lookup     - Like VOP_LOOKUP, but takes a full device:path name,
+ *                     or a name relative to the current directory, and
+ *                     goes to the correct filesystem.
+ *    vfs_lookparent - Likewise, for VOP_LOOKPARENT.
+ *
+ * Both of these may destroy the path passed in.
+ */
+
+int vfs_lookup(char *path, struct vnode **result);
+int vfs_lookparent(char *path, struct vnode **result,
+		   char *buf, size_t buflen);
+
+/*
+ * VFS layer high-level operations on pathnames
+ * Because namei may destroy pathnames, these all may too.
+ *
+ *    vfs_open         - Open or create a file. FLAGS per the syscall. 
+ *    vfs_readlink     - Read contents of a symlink into a uio.
+ *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.
+ *    vfs_mkdir        - Create a directory.
+ *    vfs_link         - Create a hard link to a file.
+ *    vfs_remove       - Delete a file.
+ *    vfs_rmdir        - Delete a directory.
+ *    vfs_rename       - rename a file.
+ *
+ *    vfs_chdir  - Change current directory of current thread by name.
+ *    vfs_getcwd - Retrieve name of current directory of current thread.
+ *
+ *    vfs_close  - Close a vnode opened with vfs_open. Does not fail.
+ *                 (See vfspath.c for a discussion of why.)
+ */
+
+int vfs_open(char *path, int openflags, struct vnode **ret);
+void vfs_close(struct vnode *vn);
+int vfs_readlink(char *path, struct uio *data);
+int vfs_symlink(const char *contents, char *path);
+int vfs_mkdir(char *path);
+int vfs_link(char *oldpath, char *newpath);
+int vfs_remove(char *path);
+int vfs_rmdir(char *path);
+int vfs_rename(char *oldpath, char *newpath);
+
+int vfs_chdir(char *path);
+int vfs_getcwd(struct uio *buf);
+
+/*
+ * Misc
+ *
+ *    vfs_bootstrap - Call during system initialization to allocate 
+ *                    structures.
+ *
+ *    vfs_initbootfs - Call during system initialization to allocate
+ *                    bootfs-related structures. (Called from 
+ *                    vfs_bootstrap.)
+ *
+ *    vfs_setbootfs - Set the filesystem that paths beginning with a
+ *                    slash are sent to. If not set, these paths fail
+ *                    with ENOENT. The argument should be the device
+ *                    name or volume name for the filesystem (such as
+ *                    "lhd0:") but need not have the trailing colon.
+ *
+ *    vfs_clearbootfs - Clear the bootfs filesystem. This should be
+ *                    done during shutdown so that the filesystem in
+ *                    question can be unmounted.
+ *
+ *    vfs_adddev    - Add a device to the VFS named device list. If
+ *                    MOUNTABLE is zero, the device will be accessible
+ *                    as "DEVNAME:". If the mountable flag is set, the
+ *                    device will be accessible as "DEVNAMEraw:" and
+ *                    mountable under the name "DEVNAME". Thus, the
+ *                    console, added with MOUNTABLE not set, would be
+ *                    accessed by pathname as "con:", and lhd0, added
+ *                    with mountable set, would be accessed by
+ *                    pathname as "lhd0raw:" and mounted by passing
+ *                    "lhd0" to vfs_mount.
+ *
+ *    vfs_addfs     - Add a hardwired filesystem to the VFS named device
+ *                    list. It will be accessible as "devname:". This is
+ *                    intended for filesystem-devices like emufs, and
+ *                    gizmos like Linux procfs or BSD kernfs, not for
+ *                    mounting filesystems on disk devices.
+ *
+ *    vfs_mount     - Attempt to mount a filesystem on a device. The
+ *                    device named by DEVNAME will be looked up and 
+ *                    passed, along with DATA, to the supplied function
+ *                    MOUNTFUNC, which should create a struct fs and
+ *                    return it in RESULT.
+ *
+ *    vfs_unmount   - Unmount the filesystem presently mounted on the
+ *                    specified device.
+ *
+ *    vfs_unmountall - Unmount all mounted filesystems.
+ */
+
+void vfs_bootstrap(void);
+
+void vfs_initbootfs(void);
+int vfs_setbootfs(const char *fsname);
+void vfs_clearbootfs(void);
+
+int vfs_adddev(const char *devname, struct device *dev, int mountable);
+int vfs_addfs(const char *devname, struct fs *fs);
+
+int vfs_mount(const char *devname, void *data, 
+	      int (*mountfunc)(void *data,
+			       struct device *dev, 
+			       struct fs **result));
+int vfs_unmount(const char *devname);
+int vfs_unmountall(void);
+
+#endif /* _VFS_H_ */
diff --git a/os161-1.10/kern/include/vm.h b/os161-1.10/kern/include/vm.h
new file mode 100644
index 0000000..baaa325
--- /dev/null
+++ b/os161-1.10/kern/include/vm.h
@@ -0,0 +1,29 @@
+#ifndef _VM_H_
+#define _VM_H_
+
+#include <machine/vm.h>
+
+/*
+ * VM system-related definitions.
+ *
+ * You'll probably want to add stuff here.
+ */
+
+
+/* Fault-type arguments to vm_fault() */
+#define VM_FAULT_READ        0    /* A read was attempted */
+#define VM_FAULT_WRITE       1    /* A write was attempted */
+#define VM_FAULT_READONLY    2    /* A write to a readonly page was attempted*/
+
+
+/* Initialization function */
+void vm_bootstrap(void);
+
+/* Fault handling function called by trap code */
+int vm_fault(int faulttype, vaddr_t faultaddress);
+
+/* Allocate/free kernel heap pages (called by kmalloc/kfree) */
+vaddr_t alloc_kpages(int npages);
+void free_kpages(vaddr_t addr);
+
+#endif /* _VM_H_ */
diff --git a/os161-1.10/kern/include/vnode.h b/os161-1.10/kern/include/vnode.h
new file mode 100644
index 0000000..e8fa116
--- /dev/null
+++ b/os161-1.10/kern/include/vnode.h
@@ -0,0 +1,286 @@
+#ifndef _VNODE_H_
+#define _VNODE_H_
+
+struct uio;
+struct stat;
+
+/*
+ * A struct vnode is an abstract representation of a file.
+ *
+ * It is an interface in the Java sense that allows the kernel's
+ * filesystem-independent code to interact usefully with multiple sets
+ * of filesystem code.
+ */
+
+/*
+ * Abstract low-level file.
+ *
+ * Note: vn_fs may be null if the vnode refers to a device.
+ *
+ * vn_opencount is managed using VOP_INCOPEN and VOP_DECOPEN by
+ * vfs_open() and vfs_close(). Code above the VFS layer should not
+ * need to worry about it.
+ */
+struct vnode {
+	int vn_refcount;                /* Reference count */
+	int vn_opencount;
+	struct lock *vn_countlock;      /* Lock for vn_refcount/opencount */
+
+	struct fs *vn_fs;               /* Filesystem vnode belongs to */
+
+	void *vn_data;                  /* Filesystem-specific data */
+
+	const struct vnode_ops *vn_ops; /* Functions on this vnode */
+};
+
+/*
+ * Abstract operations on a vnode.
+ *
+ * These are used in the form VOP_FOO(vnode, args), which are macros
+ * that expands to vnode->vn_ops->vop_foo(vnode, args). The operations
+ * "foo" are:
+ *
+ *    vop_open        - Called on *each* open() of a file. Can be used to
+ *                      reject illegal or undesired open modes. Note that
+ *                      various operations can be performed without the
+ *                      file actually being opened.
+ *                      The vnode need not look at O_CREAT, O_EXCL, or 
+ *                      O_TRUNC, as these are handled in the VFS layer.
+ *
+ *                      VOP_OPEN should not be called directly from above
+ *                      the VFS layer - use vfs_open() to open vnodes.
+ *                      This maintains the open count so VOP_CLOSE can be
+ *                      called at the right time.
+ *
+ *    vop_close       - To be called on *last* close() of a file.
+ *
+ *                      VOP_CLOSE should not be called directly from above
+ *                      the VFS layer - use vfs_close() to close vnodes
+ *                      opened with vfs_open().
+ *
+ *    vop_reclaim     - Called when vnode is no longer in use. Note that
+ *                      this may be substantially after vop_close is
+ *                      called.
+ *
+ *****************************************
+ *
+ *    vop_read        - Read data from file to uio, at offset specified
+ *                      in the uio, updating uio_resid to reflect the
+ *                      amount read, and updating uio_offset to match.
+ *                      Not allowed on directories or symlinks.
+ *
+ *    vop_readlink    - Read the contents of a symlink into a uio.
+ *                      Not allowed on other types of object.
+ *
+ *    vop_getdirentry - Read a single filename from a directory into a
+ *                      uio, choosing what name based on the offset
+ *                      field in the uio, and updating that field.
+ *                      Unlike with I/O on regular files, the value of
+ *                      the offset field is not interpreted outside
+ *                      the filesystem and thus need not be a byte
+ *                      count. However, the uio_resid field should be
+ *                      handled in the normal fashion.
+ *                      On non-directory objects, return ENOTDIR.
+ *
+ *    vop_write       - Write data from uio to file at offset specified
+ *                      in the uio, updating uio_resid to reflect the
+ *                      amount written, and updating uio_offset to match.
+ *                      Not allowed on directories or symlinks.
+ *
+ *    vop_ioctl       - Perform ioctl operation OP on file using data
+ *                      DATA. The interpretation of the data is specific
+ *                      to each ioctl.
+ *
+ *    vop_stat        - Return info about a file. The pointer is a 
+ *                      pointer to struct stat; see kern/stat.h.
+ *
+ *    vop_gettype     - Return type of file. The values for file types
+ *                      are in kern/stat.h.
+ *
+ *    vop_tryseek     - Check if seeking to the specified position within
+ *                      the file is legal. (For instance, all seeks
+ *                      are illegal on serial port devices, and seeks
+ *                      past EOF on files whose sizes are fixed may be
+ *                      as well.)
+ *
+ *    vop_fsync       - Force any dirty buffers associated with this file
+ *                      to stable storage.
+ *
+ *    vop_mmap        - Map file into memory. If you implement this
+ *                      feature, you're responsible for choosing the
+ *                      arguments for this operation.
+ *
+ *    vop_truncate    - Forcibly set size of file to the length passed
+ *                      in, discarding any excess blocks.
+ *
+ *    vop_namefile    - Compute pathname relative to filesystem root
+ *                      of the file and copy to the specified
+ *                      uio. Need not work on objects that are not
+ *                      directories.
+ *
+ *****************************************
+ *
+ *    vop_creat       - Create a regular file named NAME in the passed
+ *                      directory DIR. If flag EXCL is nonzero, fail
+ *                      if the file already exists; otherwise, use the
+ *                      existing file if there is one. Hand back the
+ *                      vnode for the file as per vop_lookup.
+ *
+ *    vop_symlink     - Create symlink named NAME in the passed directory,
+ *                      with contents CONTENTS.
+ *
+ *    vop_mkdir       - Make directory NAME in the passed directory PARENTDIR.
+ *
+ *    vop_link        - Create hard link, with name NAME, to file FILE
+ *                      in the passed directory DIR.
+ *
+ *    vop_remove      - Delete non-directory object NAME from passed 
+ *                      directory. If NAME refers to a directory,
+ *                      return EISDIR. If passed vnode is not a
+ *                      directory, return ENOTDIR.
+ *
+ *    vop_rmdir       - Delete directory object NAME from passed 
+ *                      directory.
+ *
+ *    vop_rename      - Rename file NAME1 in directory VN1 to be
+ *                      file NAME2 in directory VN2.
+ *
+ *****************************************
+ *
+ *    vop_lookup      - Parse PATHNAME relative to the passed directory
+ *                      DIR, and hand back the vnode for the file it
+ *                      refers to. May destroy PATHNAME. Should increment
+ *                      refcount on vnode handed back.
+ *
+ *    vop_lookparent  - Parse PATHNAME relative to the passed directory
+ *                      DIR, and hand back (1) the vnode for the
+ *                      parent directory of the file it refers to, and
+ *                      (2) the last component of the filename, copied
+ *                      into kernel buffer BUF with max length LEN. May
+ *                      destroy PATHNAME. Should increment refcount on
+ *                      vnode handed back.
+ */
+
+#define VOP_MAGIC	0xa2b3c4d5
+
+struct vnode_ops {
+	unsigned long vop_magic;	/* should always be VOP_MAGIC */
+
+	int (*vop_open)(struct vnode *object, int flags_from_open);
+	int (*vop_close)(struct vnode *object);
+	int (*vop_reclaim)(struct vnode *vnode);
+
+
+	int (*vop_read)(struct vnode *file, struct uio *uio);
+	int (*vop_readlink)(struct vnode *link, struct uio *uio);
+	int (*vop_getdirentry)(struct vnode *dir, struct uio *uio);
+	int (*vop_write)(struct vnode *file, struct uio *uio);
+	int (*vop_ioctl)(struct vnode *object, int op, userptr_t data);
+	int (*vop_stat)(struct vnode *object, struct stat *statbuf);
+	int (*vop_gettype)(struct vnode *object, int *result);
+	int (*vop_tryseek)(struct vnode *object, off_t pos);
+	int (*vop_fsync)(struct vnode *object);
+	int (*vop_mmap)(struct vnode *file /* add stuff */);
+	int (*vop_truncate)(struct vnode *file, off_t len);
+	int (*vop_namefile)(struct vnode *file, struct uio *uio);
+
+
+	int (*vop_creat)(struct vnode *dir, 
+			 const char *name, int excl,
+			 struct vnode **result);
+	int (*vop_symlink)(struct vnode *dir, 
+			   const char *contents, const char *name);
+	int (*vop_mkdir)(struct vnode *parentdir, 
+			 const char *name);
+	int (*vop_link)(struct vnode *dir, 
+			const char *name, struct vnode *file);
+	int (*vop_remove)(struct vnode *dir, 
+			  const char *name);
+	int (*vop_rmdir)(struct vnode *dir,
+			 const char *name);
+
+	int (*vop_rename)(struct vnode *vn1, const char *name1, 
+			  struct vnode *vn2, const char *name2);
+
+	
+	int (*vop_lookup)(struct vnode *dir, 
+			  char *pathname, struct vnode **result);
+	int (*vop_lookparent)(struct vnode *dir,
+			      char *pathname, struct vnode **result,
+			      char *buf, size_t len);
+};
+
+#define __VOP(vn, sym) (vnode_check(vn, #sym), (vn)->vn_ops->vop_##sym)
+
+#define VOP_OPEN(vn, flags)             (__VOP(vn, open)(vn, flags))
+#define VOP_CLOSE(vn)                   (__VOP(vn, close)(vn))
+#define VOP_RECLAIM(vn)                 (__VOP(vn, reclaim)(vn))
+
+#define VOP_READ(vn, uio)               (__VOP(vn, read)(vn, uio))
+#define VOP_READLINK(vn, uio)           (__VOP(vn, readlink)(vn, uio))
+#define VOP_GETDIRENTRY(vn, uio)        (__VOP(vn,getdirentry)(vn, uio))
+#define VOP_WRITE(vn, uio)              (__VOP(vn, write)(vn, uio))
+#define VOP_IOCTL(vn, code, buf)        (__VOP(vn, ioctl)(vn,code,buf))
+#define VOP_STAT(vn, ptr) 	        (__VOP(vn, stat)(vn, ptr))
+#define VOP_GETTYPE(vn, result)         (__VOP(vn, gettype)(vn, result))
+#define VOP_TRYSEEK(vn, pos)            (__VOP(vn, tryseek)(vn, pos))
+#define VOP_FSYNC(vn)                   (__VOP(vn, fsync)(vn))
+#define VOP_MMAP(vn /*add stuff */)     (__VOP(vn, mmap)(vn /*add stuff */))
+#define VOP_TRUNCATE(vn, pos)           (__VOP(vn, truncate)(vn, pos))
+#define VOP_NAMEFILE(vn, uio)           (__VOP(vn, namefile)(vn, uio))
+
+#define VOP_CREAT(vn, name, excl, res)  (__VOP(vn, creat)(vn, name, excl, res))
+#define VOP_SYMLINK(vn, name, content)  (__VOP(vn, symlink)(vn, name, content))
+#define VOP_MKDIR(vn, name)             (__VOP(vn, mkdir)(vn, name))
+#define VOP_LINK(vn, name, vn2)         (__VOP(vn, link)(vn, name, vn2))
+#define VOP_REMOVE(vn, name)            (__VOP(vn, remove)(vn, name))
+#define VOP_RMDIR(vn, name)             (__VOP(vn, rmdir)(vn, name))
+#define VOP_RENAME(vn1,name1,vn2,name2)(__VOP(vn1,rename)(vn1,name1,vn2,name2))
+
+#define VOP_LOOKUP(vn, name, res)       (__VOP(vn, lookup)(vn, name, res))
+#define VOP_LOOKPARENT(vn,nm,res,bf,ln) (__VOP(vn,lookparent)(vn,nm,res,bf,ln))
+
+/*
+ * Consistency check
+ */
+void vnode_check(struct vnode *, const char *op);
+
+/*
+ * Reference count manipulation (handled above filesystem level)
+ */
+void vnode_incref(struct vnode *);
+void vnode_decref(struct vnode *);
+
+#define VOP_INCREF(vn) 			vnode_incref(vn)
+#define VOP_DECREF(vn) 			vnode_decref(vn)
+
+/*
+ * Open count manipulation (handled above filesystem level)
+ *
+ * VOP_INCOPEN is called by vfs_open. VOP_DECOPEN is called by vfs_close.
+ * Neither of these should need to be called from above the vfs layer.
+ */
+void vnode_incopen(struct vnode *);
+void vnode_decopen(struct vnode *);
+
+#define VOP_INCOPEN(vn) 		vnode_incopen(vn)
+#define VOP_DECOPEN(vn) 		vnode_decopen(vn)
+
+/*
+ * Vnode initialization (intended for use by filesystem code)
+ * The reference count is initialized to 1.
+ */
+int vnode_init(struct vnode *, const struct vnode_ops *ops,
+	       struct fs *fs, void *fsdata);
+
+#define VOP_INIT(vn, ops, fs, data)     vnode_init(vn, ops, fs, data)
+
+/*
+ * Vnode final cleanup (intended for use by filesystem code)
+ * The reference count is asserted to be 1.
+ */
+void vnode_kill(struct vnode *);
+
+#define VOP_KILL(vn)			vnode_kill(vn)
+
+#endif /* _VNODE_H_ */
diff --git a/os161-1.10/kern/lib/array.c b/os161-1.10/kern/lib/array.c
new file mode 100644
index 0000000..10126ce
--- /dev/null
+++ b/os161-1.10/kern/lib/array.c
@@ -0,0 +1,134 @@
+/*
+ * Array of void pointers. See array.h.
+ */
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <array.h>
+
+struct array {
+	int num;
+	int max;
+	void **v;
+};
+
+struct array *
+array_create(void)
+{
+	struct array *a = kmalloc(sizeof(struct array));
+	if (a==NULL) {
+		return NULL;
+	}
+	a->v = NULL;
+	a->num = 0;
+	a->max = 0;
+	return a;
+}
+
+int
+array_getnum(struct array *a)
+{
+	return a->num;
+}
+
+void *
+array_getguy(struct array *a, int index)
+{
+	assert(a->num <= a->max);
+	assert(index >=0 && index < a->num);
+	return a->v[index];
+}
+
+int
+array_preallocate(struct array *a, int nguys)
+{
+	void **newv;
+	int i;
+	int newmax = a->max;
+
+	assert(a->num >=0 && a->num <= a->max);
+		
+	while (nguys > newmax) {
+		newmax = (newmax+1)*2;
+	}
+	newv = kmalloc(newmax * sizeof(void *));
+	if (newv==NULL) {
+		return ENOMEM;
+	}
+	a->max = newmax;
+	for (i=0; i<a->num; i++) newv[i] = a->v[i];
+	if (a->v!=NULL) {
+		kfree(a->v);
+	}
+	a->v = newv;
+	return 0;
+}
+
+int
+array_setsize(struct array *a, int nguys)
+{
+	int result;
+
+	assert(a->num >=0 && a->num <= a->max);
+
+	if (nguys > a->max) {
+		result = array_preallocate(a, nguys);
+		if (result) {
+			return result;
+		}
+	}
+	else if (nguys==0 && a->max > 16) {
+		assert(a->v!=NULL);
+		kfree(a->v);
+		a->v = NULL;
+		a->max = 0;
+	}
+	a->num = nguys;
+
+	return 0;
+}
+
+void
+array_setguy(struct array *a, int index, void *ptr)
+{
+	assert(a->num <= a->max);
+	assert(index >=0 && index < a->num);
+	a->v[index] = ptr;
+}
+
+int
+array_add(struct array *a, void *guy)
+{
+	int ix, result;
+
+	ix = a->num;
+
+	result = array_setsize(a, ix+1);
+	if (result) {
+		return result;
+	}
+
+	a->v[ix] = guy;
+
+	return 0;
+}
+
+void
+array_remove(struct array *a, int index)
+{
+	int nmove;
+
+	assert(a->num <= a->max);
+	assert(index >=0 && index < a->num);
+
+	nmove = a->num - (index + 1);
+	memmove(a->v+index, a->v+index+1, nmove*sizeof(void *));
+	a->num--;
+}
+
+void
+array_destroy(struct array *a)
+{
+	if (a->v) kfree(a->v);
+	kfree(a);
+}
diff --git a/os161-1.10/kern/lib/bitmap.c b/os161-1.10/kern/lib/bitmap.c
new file mode 100644
index 0000000..191c463
--- /dev/null
+++ b/os161-1.10/kern/lib/bitmap.c
@@ -0,0 +1,149 @@
+/*
+ * Manager for arrays of bits.
+ * See bitmap.h for more information.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <kern/errno.h>
+#include <bitmap.h>
+
+/*
+ * It would be a lot more efficient on most platforms to use u_int32_t
+ * or unsigned long as the base type for holding bits. But we don't,
+ * because if one uses any data type more than a single byte wide,
+ * bitmap data saved on disk becomes endian-dependent, which is a
+ * severe nuisance.
+ */
+
+
+#define BITS_PER_WORD   (CHAR_BIT)
+#define WORD_TYPE       unsigned char
+#define WORD_ALLBITS    (0xff)
+
+struct bitmap {
+	u_int32_t nbits;
+	WORD_TYPE *v;
+};
+
+
+struct bitmap *
+bitmap_create(u_int32_t nbits)
+{
+	struct bitmap *b; 
+	u_int32_t words;
+
+	words = DIVROUNDUP(nbits, BITS_PER_WORD);
+	b = kmalloc(sizeof(struct bitmap));
+	if (b == NULL) {
+		return NULL;
+	}
+	b->v = kmalloc(words*sizeof(WORD_TYPE));
+	if (b->v == NULL) {
+		kfree(b);
+		return NULL;
+	}
+
+	bzero(b->v, words*sizeof(WORD_TYPE));
+	b->nbits = nbits;
+
+	/* Mark any leftover bits at the end in use */
+	if (nbits / BITS_PER_WORD < words) {
+		u_int32_t j, ix = words-1;
+		u_int32_t overbits = nbits - ix*BITS_PER_WORD;
+
+		assert(nbits / BITS_PER_WORD == words-1);
+		assert(overbits > 0 && overbits < BITS_PER_WORD);
+		
+		for (j=overbits; j<BITS_PER_WORD; j++) {
+			b->v[ix] |= ((WORD_TYPE)1 << j);
+		}
+	}
+
+	return b;
+}
+
+void *
+bitmap_getdata(struct bitmap *b)
+{
+	return b->v;
+}
+
+int
+bitmap_alloc(struct bitmap *b, u_int32_t *index)
+{
+	u_int32_t ix;
+	u_int32_t maxix = DIVROUNDUP(b->nbits, BITS_PER_WORD);
+	u_int32_t offset;
+
+	for (ix=0; ix<maxix; ix++) {
+		if (b->v[ix]!=WORD_ALLBITS) {
+			for (offset = 0; offset < BITS_PER_WORD; offset++) {
+				WORD_TYPE mask = ((WORD_TYPE)1)<<offset;
+				if ((b->v[ix] & mask)==0) {
+					b->v[ix] |= mask;
+					*index = (ix*BITS_PER_WORD)+offset;
+					assert(*index < b->nbits);
+					return 0;
+				}
+			}
+			assert(0);
+		}
+	}
+	return ENOSPC;
+}
+
+static
+inline
+void
+bitmap_translate(u_int32_t bitno, u_int32_t *ix, WORD_TYPE *mask)
+{
+	u_int32_t offset;
+	*ix = bitno / BITS_PER_WORD;
+	offset = bitno % BITS_PER_WORD;
+	*mask = ((WORD_TYPE)1) << offset;
+}
+
+void
+bitmap_mark(struct bitmap *b, u_int32_t index)
+{
+	u_int32_t ix;
+	WORD_TYPE mask;
+	assert(index < b->nbits);
+	bitmap_translate(index, &ix, &mask);
+
+	assert((b->v[ix] & mask)==0);
+
+	b->v[ix] |= mask;
+}
+
+void
+bitmap_unmark(struct bitmap *b, u_int32_t index)
+{
+	u_int32_t ix;
+	WORD_TYPE mask;
+	assert(index < b->nbits);
+	bitmap_translate(index, &ix, &mask);
+
+	assert((b->v[ix] & mask)!=0);
+
+	b->v[ix] &= ~mask;
+}
+
+
+int
+bitmap_isset(struct bitmap *b, u_int32_t index) 
+{
+        u_int32_t ix;
+        WORD_TYPE mask;
+        bitmap_translate(index, &ix, &mask);
+
+        return (b->v[ix] & mask);
+}
+
+void
+bitmap_destroy(struct bitmap *b)
+{
+	kfree(b->v);
+	kfree(b);
+}
diff --git a/os161-1.10/kern/lib/copyinout.c b/os161-1.10/kern/lib/copyinout.c
new file mode 100644
index 0000000..e9de960
--- /dev/null
+++ b/os161-1.10/kern/lib/copyinout.c
@@ -0,0 +1,279 @@
+/*
+ * User/kernel memory copying functions.
+ *
+ * These are arranged to prevent fatal kernel memory faults if invalid
+ * addresses are supplied by user-level code. This code is itself
+ * machine-independent; it uses the machine-dependent C setjmp/longjmp
+ * facility to perform recovery.
+ *
+ * However, it assumes things about the memory subsystem that may not
+ * be true on all platforms. 
+ *
+ * (1) It assumes that access to user memory from the kernel behaves
+ * the same way as access to user memory from user space: for
+ * instance, that the processor honors read-only bits on memory pages
+ * when in kernel mode.
+ *
+ * (2) It assumes that the user-space region of memory is contiguous
+ * and extends from 0 to some virtual address USERSPACETOP, and so if
+ * a user process passes a kernel address the logic in copycheck()
+ * will trap it.
+ *
+ * (3) It assumes that if a proper user-space address that is valid
+ * but not present, or not valid at all, is touched from the kernel,
+ * that the correct faults will occur and the VM system will load the
+ * necessary pages and whatnot.
+ *
+ * (4) It assumes that the machine-dependent trap logic provides and
+ * honors a pcb_badfaultfunc field: if an otherwise fatal fault occurs
+ * in kernel mode, and pcb_badfaultfunc is set, execution resumes in
+ * the function pointed to by pcb_badfaultfunc.
+ *
+ * If these four assumptions are satisfied, the mechanism by which
+ * this code works, namely, setting pcb_badfaultfunc and then copying
+ * memory in an ordinary fashion, should function correctly. If the
+ * assumptions are not satisfied on some platform (for instance,
+ * certain old 80386 processors violate assumption 1), this code
+ * cannot be used, and platform-specific code must be written.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <machine/setjmp.h>
+#include <machine/pcb.h>
+#include <vm.h>
+#include <thread.h>
+#include <curthread.h>
+
+/*
+ * Recovery function. If a fatal fault occurs during copyin, copyout,
+ * copyinstr, or copyoutstr, execution resumes here. (This behavior is
+ * caused by setting pcb.pcb_badfaultfunc and is implemented in
+ * machine-dependent code.)
+ *
+ * We use the C standard function longjmp() to teleport up the call
+ * stack to where setjmp() was called. At that point we return EFAULT.
+ */
+static
+void
+copyfail(void)
+{
+	longjmp(curthread->t_pcb.pcb_copyjmp, 1);
+}
+
+/*
+ * Memory region check function. This checks to make sure the block of
+ * user memory provided (an address and a length) falls within the
+ * proper userspace region. If it does not, EFAULT is returned.
+ *
+ * stoplen is set to the actual maximum length that can be copied.
+ * This differs from len if and only if the region partially overlaps
+ * the kernel.
+ *
+ * Assumes userspace runs from 0 through USERTOP-1.
+ */
+static
+int
+copycheck(const_userptr_t userptr, size_t len, size_t *stoplen)
+{
+	vaddr_t bot, top;
+
+	*stoplen = len;
+
+	bot = (vaddr_t) userptr;
+	top = bot+len-1;
+
+	if (top < bot) {
+		/* addresses wrapped around */
+		return EFAULT;
+	}
+
+	if (bot >= USERTOP) {
+		/* region is within the kernel */
+		return EFAULT;
+	}
+
+	if (top >= USERTOP) {
+		/* region overlaps the kernel. adjust the max length. */
+		*stoplen = USERTOP - bot;
+	}
+
+	return 0;
+}
+
+/*
+ * copyin
+ *
+ * Copy a block of memory of length LEN from user-level address USERSRC 
+ * to kernel address DEST. We can use memcpy because it's protected by
+ * the pcb_badfaultfunc/copyfail logic.
+ */
+int
+copyin(const_userptr_t usersrc, void *dest, size_t len)
+{
+	int result;
+	size_t stoplen;
+
+	result = copycheck(usersrc, len, &stoplen);
+	if (result) {
+		return result;
+	}
+	if (stoplen != len) {
+		/* Single block, can't legally truncate it. */
+		return EFAULT;
+	}
+
+	curthread->t_pcb.pcb_badfaultfunc = copyfail;
+
+	result = setjmp(curthread->t_pcb.pcb_copyjmp);
+	if (result) {
+		curthread->t_pcb.pcb_badfaultfunc = NULL;
+		return EFAULT;
+	}
+
+	memcpy(dest, (const void *)usersrc, len);
+
+	curthread->t_pcb.pcb_badfaultfunc = NULL;
+	return 0;
+}
+
+/*
+ * copyout
+ *
+ * Copy a block of memory of length LEN from kernel address SRC to
+ * user-level address USERDEST. We can use memcpy because it's
+ * protected by the pcb_badfaultfunc/copyfail logic.
+ */
+int
+copyout(const void *src, userptr_t userdest, size_t len)
+{
+	int result;
+	size_t stoplen;
+
+	result = copycheck(userdest, len, &stoplen);
+	if (result) {
+		return result;
+	}
+	if (stoplen != len) {
+		/* Single block, can't legally truncate it. */
+		return EFAULT;
+	}
+
+	curthread->t_pcb.pcb_badfaultfunc = copyfail;
+
+	result = setjmp(curthread->t_pcb.pcb_copyjmp);
+	if (result) {
+		curthread->t_pcb.pcb_badfaultfunc = NULL;
+		return EFAULT;
+	}
+
+	memcpy((void *)userdest, src, len);
+
+	curthread->t_pcb.pcb_badfaultfunc = NULL;
+	return 0;
+}
+
+/*
+ * Common string copying function that behaves the way that's desired
+ * for copyinstr and copyoutstr.
+ *
+ * Copies a null-terminated string of maximum length MAXLEN from SRC
+ * to DEST. If GOTLEN is not null, store the actual length found
+ * there. Both lengths include the null-terminator. If the string
+ * exceeds the available length, the call fails and returns
+ * ENAMETOOLONG.
+ *
+ * STOPLEN is like MAXLEN but is assumed to have come from copycheck.
+ * If we hit MAXLEN it's because the string is too long to fit; if we
+ * hit STOPLEN it's because the string has run into the end of
+ * userspace. Thus in the latter case we return EFAULT, not 
+ * ENAMETOOLONG.
+ */
+static
+int
+copystr(char *dest, const char *src, size_t maxlen, size_t stoplen,
+	size_t *gotlen)
+{
+	size_t i;
+	for (i=0; i<maxlen && i<stoplen; i++) {
+		dest[i] = src[i];
+		if (src[i]==0) {
+			if (gotlen != NULL) {
+				*gotlen = i+1;
+			}
+			return 0;
+		}
+	}
+	if (stoplen < maxlen) {
+		/* ran into user-kernel boundary */
+		return EFAULT;
+	}
+	return ENAMETOOLONG;
+}
+
+/*
+ * copyinstr
+ *
+ * Copy a string from user-level address USERSRC to kernel address
+ * DEST, as per copystr above. Uses the pcb_badfaultfunc/copyfail
+ * logic to protect against invalid addresses supplied by a user
+ * process.
+ */
+int
+copyinstr(const_userptr_t usersrc, char *dest, size_t len, size_t *actual)
+{
+	int result;
+	size_t stoplen;
+
+	result = copycheck(usersrc, len, &stoplen);
+	if (result) {
+		return result;
+	}
+
+	curthread->t_pcb.pcb_badfaultfunc = copyfail;
+
+	result = setjmp(curthread->t_pcb.pcb_copyjmp);
+	if (result) {
+		curthread->t_pcb.pcb_badfaultfunc = NULL;
+		return EFAULT;
+	}
+
+	result = copystr(dest, (const char *)usersrc, len, stoplen, actual);
+
+	curthread->t_pcb.pcb_badfaultfunc = NULL;
+	return result;
+}
+
+/*
+ * copyoutstr
+ *
+ * Copy a string from kernel address SRC to user-level address
+ * USERDEST, as per copystr above. Uses the pcb_badfaultfunc/copyfail
+ * logic to protect against invalid addresses supplied by a user
+ * process.
+ */
+int
+copyoutstr(const char *src, userptr_t userdest, size_t len, size_t *actual)
+{
+	int result;
+	size_t stoplen;
+
+	result = copycheck(userdest, len, &stoplen);
+	if (result) {
+		return result;
+	}
+
+	curthread->t_pcb.pcb_badfaultfunc = copyfail;
+
+	result = setjmp(curthread->t_pcb.pcb_copyjmp);
+	if (result) {
+		curthread->t_pcb.pcb_badfaultfunc = NULL;
+		return EFAULT;
+	}
+
+	result = copystr((char *)userdest, src, len, stoplen, actual);
+
+	curthread->t_pcb.pcb_badfaultfunc = NULL;
+	return result;
+}
diff --git a/os161-1.10/kern/lib/kgets.c b/os161-1.10/kern/lib/kgets.c
new file mode 100644
index 0000000..ea72e1b
--- /dev/null
+++ b/os161-1.10/kern/lib/kgets.c
@@ -0,0 +1,83 @@
+#include <types.h>
+#include <lib.h>
+
+/*
+ * Do a backspace in typed input.
+ * We overwrite the current character with a space in case we're on
+ * a terminal where backspace is nondestructive.
+ */
+static
+void
+backsp(void)
+{
+	putch('\b');
+	putch(' ');
+	putch('\b');
+}
+
+/*
+ * Read a string off the console. Support a few of the more useful
+ * common control characters. Do not include the terminating newline
+ * in the buffer passed back.
+ */
+void
+kgets(char *buf, size_t maxlen)
+{
+	size_t pos = 0;
+	int ch;
+
+	while (1) {
+		ch = getch();
+		if (ch=='\n' || ch=='\r') {
+			putch('\n');
+			break;
+		}
+
+		/* Only allow the normal 7-bit ascii */
+		if (ch>=32 && ch<127 && pos < maxlen-1) {
+			putch(ch);
+			buf[pos++] = ch;
+		}
+		else if ((ch=='\b' || ch==127) && pos>0) {
+			/* backspace */
+			backsp();
+			pos--;
+		}
+		else if (ch==3) {
+			/* ^C - return empty string */
+			putch('^');
+			putch('C');
+			putch('\n');
+			pos = 0;
+			break;
+		}
+		else if (ch==18) {
+			/* ^R - reprint input */
+			buf[pos] = 0;
+			kprintf("^R\n%s", buf);
+		}
+		else if (ch==21) {
+			/* ^U - erase line */
+			while (pos > 0) {
+				backsp();
+				pos--;
+			}
+		}
+		else if (ch==23) {
+			/* ^W - erase word */
+			while (pos > 0 && buf[pos-1]==' ') {
+				backsp();
+				pos--;
+			}
+			while (pos > 0 && buf[pos-1]!=' ') {
+				backsp();
+				pos--;
+			}
+		}
+		else {
+			beep();
+		}
+	}
+
+	buf[pos] = 0;
+}
diff --git a/os161-1.10/kern/lib/kheap.c b/os161-1.10/kern/lib/kheap.c
new file mode 100644
index 0000000..8af3e4a
--- /dev/null
+++ b/os161-1.10/kern/lib/kheap.c
@@ -0,0 +1,578 @@
+#include <types.h>
+#include <lib.h>
+#include <vm.h>
+#include <machine/spl.h>
+
+static
+void
+fill_deadbeef(void *vptr, size_t len)
+{
+	u_int32_t *ptr = vptr;
+	size_t i;
+
+	for (i=0; i<len/sizeof(u_int32_t); i++) {
+		ptr[i] = 0xdeadbeef;
+	}
+}
+
+////////////////////////////////////////////////////////////
+//
+// Pool-based subpage allocator.
+//
+// It works like this:
+//
+//    We allocate one page at a time and fill it with objects of size k,
+//    for various k. Each page has its own freelist, maintained by a
+//    linked list in the first word of each object. Each page also has a
+//    freecount, so we know when the page is completely free and can 
+//    release it.
+//
+//    No assumptions are made about the sizes k; they need not be
+//    powers of two. Note, however, that malloc must always return
+//    pointers aligned to the maximum alignment requirements of the
+//    platform; thus block sizes must at least be multiples of 4,
+//    preferably 8. They must also be at least sizeof(struct
+//    freelist). It is only worth defining an additional block size if
+//    more blocks would fit on a page than with the existing block
+//    sizes, and large numbers of items of the new size are allocated.
+//
+//    The free counts and addresses of the pages are maintained in
+//    another list.  Maintaining this table is a nuisance, because it
+//    cannot recursively use the subpage allocator. (We could probably
+//    make that work, but it would be painful.)
+//
+
+#undef  SLOW	/* consistency checks */
+#undef SLOWER	/* lots of consistency checks */
+
+////////////////////////////////////////
+
+#if PAGE_SIZE == 4096
+
+#define NSIZES 8
+static const size_t sizes[NSIZES] = { 16, 32, 64, 128, 256, 512, 1024, 2048 };
+
+#define SMALLEST_SUBPAGE_SIZE 16
+#define LARGEST_SUBPAGE_SIZE 2048
+
+#elif PAGE_SIZE == 8192
+#error "No support for 8k pages"
+#else
+#error "Odd page size"
+#endif
+
+////////////////////////////////////////
+
+struct freelist {
+	struct freelist *next;
+};
+
+struct pageref {
+	struct pageref *next_samesize;
+	struct pageref *next_all;
+	vaddr_t pageaddr_and_blocktype;
+	u_int16_t freelist_offset;
+	u_int16_t nfree;
+};
+
+#define INVALID_OFFSET   (0xffff)
+
+#define PR_PAGEADDR(pr)  ((pr)->pageaddr_and_blocktype & PAGE_FRAME)
+#define PR_BLOCKTYPE(pr) ((pr)->pageaddr_and_blocktype & ~PAGE_FRAME)
+#define MKPAB(pa, blk)   (((pa)&PAGE_FRAME) | ((blk) & ~PAGE_FRAME))
+
+////////////////////////////////////////
+
+/*
+ * This is cheesy. 
+ *
+ * The problem is not that it's wasteful - we can only allocate whole
+ * pages of pageref structures at a time anyway. The problem is that
+ * we really ought to be able to have more than one of these pages.
+ *
+ * However, for the time being, one page worth of pagerefs gives us
+ * 256 pagerefs; this lets us manage 256 * 4k = 1M of kernel heap.
+ * That would be twice as much memory as we get for *everything*.
+ * Thus, we will cheat and not allow any mechanism for having a second
+ * page of pageref structs.
+ *
+ * Then, since the size is fixed at one page, we'll simplify a bit
+ * further by allocating the page in the kernel BSS instead of calling
+ * alloc_kpages to get it.
+ */
+
+#define NPAGEREFS (PAGE_SIZE / sizeof(struct pageref))
+static struct pageref pagerefs[NPAGEREFS];
+
+#define INUSE_WORDS (NPAGEREFS/32)
+static u_int32_t pagerefs_inuse[INUSE_WORDS];
+
+static
+struct pageref *
+allocpageref(void)
+{
+	unsigned i,j;
+	u_int32_t k;
+
+	for (i=0; i<INUSE_WORDS; i++) {
+		if (pagerefs_inuse[i]==0xffffffff) {
+			/* full */
+			continue;
+		}
+		for (k=1,j=0; k!=0; k<<=1,j++) {
+			if ((pagerefs_inuse[i] & k)==0) {
+				pagerefs_inuse[i] |= k;
+				return &pagerefs[i*32 + j];
+			}
+		}
+		assert(0);
+	}
+
+	/* ran out */
+	return NULL;
+}
+
+static
+void
+freepageref(struct pageref *p)
+{
+	size_t i, j;
+	u_int32_t k;
+
+	j = p-pagerefs;
+	assert(j < NPAGEREFS);  /* note: j is unsigned, don't test < 0 */
+	i = j/32;
+	k = ((u_int32_t)1) << (j%32);
+	assert((pagerefs_inuse[i] & k) != 0);
+	pagerefs_inuse[i] &= ~k;
+}
+
+////////////////////////////////////////
+
+static struct pageref *sizebases[NSIZES];
+static struct pageref *allbase;
+
+////////////////////////////////////////
+
+/* SLOWER implies SLOW */
+#ifdef SLOWER
+#ifndef SLOW
+#define SLOW
+#endif
+#endif
+
+#ifdef SLOW
+static
+void
+checksubpage(struct pageref *pr)
+{
+	vaddr_t prpage, fla;
+	struct freelist *fl;
+	int blktype;
+	int nfree=0;
+
+	assert(curspl>0);
+
+	if (pr->freelist_offset == INVALID_OFFSET) {
+		assert(pr->nfree==0);
+		return;
+	}
+
+	prpage = PR_PAGEADDR(pr);
+	blktype = PR_BLOCKTYPE(pr);
+
+	assert(pr->freelist_offset < PAGE_SIZE);
+	assert(pr->freelist_offset % sizes[blktype] == 0);
+
+	fla = prpage + pr->freelist_offset;
+	fl = (struct freelist *)fla;
+
+	for (; fl != NULL; fl = fl->next) {
+		fla = (vaddr_t)fl;
+		assert(fla >= prpage && fla < prpage + PAGE_SIZE);
+		assert((fla-prpage) % sizes[blktype] == 0);
+		assert(fla >= MIPS_KSEG0);
+		assert(fla < MIPS_KSEG1);
+		nfree++;
+	}
+	assert(nfree==pr->nfree);
+}
+#else
+#define checksubpage(pr) ((void)(pr))
+#endif
+
+#ifdef SLOWER
+static
+void
+checksubpages(void)
+{
+	struct pageref *pr;
+	int i;
+	unsigned sc=0, ac=0;
+
+	assert(curspl>0);
+
+	for (i=0; i<NSIZES; i++) {
+		for (pr = sizebases[i]; pr != NULL; pr = pr->next_samesize) {
+			checksubpage(pr);
+			assert(sc < NPAGEREFS);
+			sc++;
+		}
+	}
+
+	for (pr = allbase; pr != NULL; pr = pr->next_all) {
+		checksubpage(pr);
+		assert(ac < NPAGEREFS);
+		ac++;
+	}
+
+	assert(sc==ac);
+}
+#else
+#define checksubpages() 
+#endif
+
+////////////////////////////////////////
+
+static
+void
+dumpsubpage(struct pageref *pr)
+{
+	vaddr_t prpage, fla;
+	struct freelist *fl;
+	int blktype;
+	unsigned i, n, index;
+	u_int32_t freemap[PAGE_SIZE / (SMALLEST_SUBPAGE_SIZE*32)];
+
+	checksubpage(pr);
+	assert(curspl>0);
+
+	/* clear freemap[] */
+	for (i=0; i<sizeof(freemap)/sizeof(freemap[0]); i++) {
+		freemap[i] = 0;
+	}
+
+	prpage = PR_PAGEADDR(pr);
+	blktype = PR_BLOCKTYPE(pr);
+
+	/* compute how many bits we need in freemap and assert we fit */
+	n = PAGE_SIZE / sizes[blktype];
+	assert(n <= 32*sizeof(freemap)/sizeof(freemap[0]));
+
+	if (pr->freelist_offset != INVALID_OFFSET) {
+		fla = prpage + pr->freelist_offset;
+		fl = (struct freelist *)fla;
+
+		for (; fl != NULL; fl = fl->next) {
+			fla = (vaddr_t)fl;
+			index = (fla-prpage) / sizes[blktype];
+			assert(index<n);
+			freemap[index/32] |= (1<<(index%32));
+		}
+	}
+
+	kprintf("at 0x%08lx: size %-4lu  %u/%u free\n", 
+		(unsigned long)prpage, (unsigned long) sizes[blktype],
+		(unsigned) pr->nfree, n);
+	kprintf("   ");
+	for (i=0; i<n; i++) {
+		int val = (freemap[i/32] & (1<<(i%32)))!=0;
+		kprintf("%c", val ? '.' : '*');
+		if (i%64==63 && i<n-1) {
+			kprintf("\n   ");
+		}
+	}
+	kprintf("\n");
+}
+
+void
+kheap_printstats(void)
+{
+	struct pageref *pr;
+
+	/* print the whole thing with interrupts off */
+	int spl = splhigh();
+
+	kprintf("Subpage allocator status:\n");
+
+	for (pr = allbase; pr != NULL; pr = pr->next_all) {
+		dumpsubpage(pr);
+	}
+
+	splx(spl);
+}
+
+////////////////////////////////////////
+
+static
+void
+remove_lists(struct pageref *pr, int blktype)
+{
+	struct pageref **guy;
+
+	assert(blktype>=0 && blktype<NSIZES);
+
+	for (guy = &sizebases[blktype]; *guy; guy = &(*guy)->next_samesize) {
+		checksubpage(*guy);
+		if (*guy == pr) {
+			*guy = pr->next_samesize;
+			break;
+		}
+	}
+
+	for (guy = &allbase; *guy; guy = &(*guy)->next_all) {
+		checksubpage(*guy);
+		if (*guy == pr) {
+			*guy = pr->next_all;
+			break;
+		}
+	}
+}
+
+static
+inline
+int blocktype(size_t sz)
+{
+	unsigned i;
+	for (i=0; i<NSIZES; i++) {
+		if (sz <= sizes[i]) {
+			return i;
+		}
+	}
+
+	panic("Subpage allocator cannot handle allocation of size %lu\n", 
+	      (unsigned long)sz);
+
+	// keep compiler happy
+	return 0;
+}
+
+static
+void *
+subpage_kmalloc(size_t sz)
+{
+	int spl;		// saved interrupt level
+	unsigned blktype;	// index into sizes[] that we're using
+	struct pageref *pr;	// pageref for page we're allocating from
+	vaddr_t prpage;		// PR_PAGEADDR(pr)
+	vaddr_t fla;		// free list entry address
+	struct freelist *volatile fl;	// free list entry
+	void *retptr;		// our result
+
+	volatile int i;
+
+
+	blktype = blocktype(sz);
+	sz = sizes[blktype];
+
+	spl = splhigh();
+
+	checksubpages();
+
+	for (pr = sizebases[blktype]; pr != NULL; pr = pr->next_samesize) {
+
+		/* check for corruption */
+		assert(PR_BLOCKTYPE(pr) == blktype);
+		checksubpage(pr);
+
+		if (pr->nfree > 0) {
+
+		doalloc: /* comes here after getting a whole fresh page */
+
+			assert(pr->freelist_offset < PAGE_SIZE);
+			prpage = PR_PAGEADDR(pr);
+			fla = prpage + pr->freelist_offset;
+			fl = (struct freelist *)fla;
+
+			retptr = fl;
+			fl = fl->next;
+			pr->nfree--;
+
+			if (fl != NULL) {
+				assert(pr->nfree > 0);
+				fla = (vaddr_t)fl;
+				assert(fla - prpage < PAGE_SIZE);
+				pr->freelist_offset = fla - prpage;
+			}
+			else {
+				assert(pr->nfree == 0);
+				pr->freelist_offset = INVALID_OFFSET;
+			}
+
+			checksubpages();
+
+			splx(spl);
+			return retptr;
+		}
+	}
+
+	/*
+	 * No page of the right size available.
+	 * Make a new one.
+	 */
+
+	pr = allocpageref();
+	if (pr==NULL) {
+		/* Couldn't allocate accounting space for the new page. */
+		splx(spl);
+		kprintf("kmalloc: Subpage allocator couldn't get pageref\n"); 
+		return NULL;
+	}
+
+	prpage = alloc_kpages(1);
+	if (prpage==0) {
+		/* Out of memory. */
+		freepageref(pr);
+		splx(spl);
+		kprintf("kmalloc: Subpage allocator couldn't get a page\n"); 
+		return NULL;
+	}
+
+	pr->pageaddr_and_blocktype = MKPAB(prpage, blktype);
+	pr->nfree = PAGE_SIZE / sizes[blktype];
+
+	/*
+	 * Note: fl is volatile because the MIPS toolchain we were
+	 * using in spring 2001 attempted to optimize this loop and
+	 * blew it. Making fl volatile inhibits the optimization.
+	 */
+
+	fla = prpage;
+	fl = (struct freelist *)fla;
+	fl->next = NULL;
+	for (i=1; i<pr->nfree; i++) {
+		fl = (struct freelist *)(fla + i*sizes[blktype]);
+		fl->next = (struct freelist *)(fla + (i-1)*sizes[blktype]);
+		assert(fl != fl->next);
+	}
+	fla = (vaddr_t) fl;
+	pr->freelist_offset = fla - prpage;
+	assert(pr->freelist_offset == (pr->nfree-1)*sizes[blktype]);
+
+	pr->next_samesize = sizebases[blktype];
+	sizebases[blktype] = pr;
+
+	pr->next_all = allbase;
+	allbase = pr;
+
+	/* This is kind of cheesy, but avoids duplicating the alloc code. */
+	goto doalloc;
+}
+
+static
+int
+subpage_kfree(void *ptr)
+{
+	int spl;		// saved interrupt level
+	int blktype;		// index into sizes[] that we're using
+	vaddr_t ptraddr;	// same as ptr
+	struct pageref *pr;	// pageref for page we're freeing in
+	vaddr_t prpage;		// PR_PAGEADDR(pr)
+	vaddr_t fla;		// free list entry address
+	struct freelist *fl;	// free list entry
+	vaddr_t offset;		// offset into page
+
+	ptraddr = (vaddr_t)ptr;
+
+	spl = splhigh();
+
+	checksubpages();
+
+	for (pr = allbase; pr; pr = pr->next_all) {
+		prpage = PR_PAGEADDR(pr);
+		blktype = PR_BLOCKTYPE(pr);
+
+		/* check for corruption */
+		assert(blktype>=0 && blktype<NSIZES);
+		checksubpage(pr);
+
+		if (ptraddr >= prpage && ptraddr < prpage + PAGE_SIZE) {
+			break;
+		}
+	}
+
+	if (pr==NULL) {
+		/* Not on any of our pages - not a subpage allocation */
+		splx(spl);
+		return -1;
+	}
+
+	offset = ptraddr - prpage;
+
+	/* Check for proper positioning and alignment */
+	if (offset >= PAGE_SIZE || offset % sizes[blktype] != 0) {
+		panic("kfree: subpage free of invalid addr %p\n", ptr);
+	}
+
+	/*
+	 * Clear the block to 0xdeadbeef to make it easier to detect
+	 * uses of dangling pointers.
+	 */
+	fill_deadbeef(ptr, sizes[blktype]);
+
+	/*
+	 * We probably ought to check for free twice by seeing if the block
+	 * is already on the free list. But that's expensive, so we don't.
+	 */
+
+	fla = prpage + offset;
+	fl = (struct freelist *)fla;
+	if (pr->freelist_offset == INVALID_OFFSET) {
+		fl->next = NULL;
+	} else {
+		fl->next = (struct freelist *)(prpage + pr->freelist_offset);
+	}
+	pr->freelist_offset = offset;
+	pr->nfree++;
+
+	assert(pr->nfree <= PAGE_SIZE / sizes[blktype]);
+	if (pr->nfree == PAGE_SIZE / sizes[blktype]) {
+		/* Whole page is free. */
+		remove_lists(pr, blktype);
+		free_kpages(prpage);
+		freepageref(pr);
+	}
+
+	checksubpages();
+
+	splx(spl);
+	return 0;
+}
+
+//
+////////////////////////////////////////////////////////////
+
+void *
+kmalloc(size_t sz)
+{
+	if (sz>=LARGEST_SUBPAGE_SIZE) {
+		unsigned long npages;
+		vaddr_t address;
+
+		/* Round up to a whole number of pages. */
+		npages = (sz + PAGE_SIZE - 1)/PAGE_SIZE;
+		address = alloc_kpages(npages);
+		if (address==0) {
+			return NULL;
+		}
+
+		return (void *)address;
+	}
+
+	return subpage_kmalloc(sz);
+}
+
+void
+kfree(void *ptr)
+{
+	/*
+	 * Try subpage first; if that fails, assume it's a big allocation.
+	 */
+	if (ptr == NULL) {
+		return;
+	} else if (subpage_kfree(ptr)) {
+		assert((vaddr_t)ptr%PAGE_SIZE==0);
+		free_kpages((vaddr_t)ptr);
+	}
+}
+
diff --git a/os161-1.10/kern/lib/kprintf.c b/os161-1.10/kern/lib/kprintf.c
new file mode 100644
index 0000000..f703002
--- /dev/null
+++ b/os161-1.10/kern/lib/kprintf.c
@@ -0,0 +1,138 @@
+#include <types.h>
+#include <stdarg.h>
+#include <kern/unistd.h>
+#include <lib.h>
+#include <synch.h>
+#include <vfs.h>          // for vfs_sync()
+#include <thread.h>       // for thread_panic();
+#include <machine/pcb.h>  // for md_panic()
+#include <machine/spl.h>
+
+/* Flags word for DEBUG() macro. */
+u_int32_t dbflags = 0;
+
+/* Lock for non-polled kprintfs */
+static struct lock *kprintf_lock;
+
+/*
+ * Warning: all this has to work from interrupt handlers and when
+ * interrupts are disabled.
+ */
+
+
+/* Send characters to the console. */
+static
+void
+console_send(void *junk, const char *data, size_t len)
+{
+	size_t i;
+
+	(void)junk;
+
+	for (i=0; i<len; i++) {
+		putch(data[i]);
+	}
+}
+
+/* Create the kprintf lock. Must be called before creating a second thread. */
+void
+kprintf_bootstrap(void)
+{
+	assert(kprintf_lock == NULL);
+
+	kprintf_lock = lock_create("kprintf_lock");
+	if (kprintf_lock == NULL) {
+		panic("Could not create kprintf lock\n");
+	}
+}
+
+/* Printf to the console. */
+int
+kprintf(const char *fmt, ...)
+{
+	int chars;
+	va_list ap;
+
+	if (kprintf_lock != NULL && !in_interrupt && curspl==0) {
+		lock_acquire(kprintf_lock);
+	}
+
+	va_start(ap, fmt);
+	chars = __vprintf(console_send, NULL, fmt, ap);
+	va_end(ap);
+
+	if (kprintf_lock != NULL && !in_interrupt && curspl==0) {
+		lock_release(kprintf_lock);
+	}
+
+	return chars;
+}
+
+/*
+ * panic() is for fatal errors. It prints the printf arguments it's
+ * passed and then halts the system.
+ */
+
+void
+panic(const char *fmt, ...)
+{
+	va_list ap;
+
+	/*
+	 * When we reach panic, the system is usually fairly screwed up.
+	 * It's not entirely uncommon for anything else we try to do 
+	 * here to trigger more panics.
+	 *
+	 * This variable makes sure that if we try to do something here,
+	 * and it causes another panic, *that* panic doesn't try again;
+	 * trying again almost inevitably causes infinite recursion.
+	 *
+	 * This is not excessively paranoid - these things DO happen!
+	 */
+	static volatile int evil;
+
+	if (evil==0) {
+		evil = 1;
+
+		/*
+		 * Not only do we not want to be interrupted while
+		 * panicking, but we also want the console to be
+		 * printing in polling mode so as not to do context
+		 * switches. So turn interrupts off.
+		 */
+		splhigh();
+	}
+
+	if (evil==1) {
+		evil = 2;
+
+		thread_panic();
+	}
+
+	if (evil==2) {
+		evil = 3;
+
+		kprintf("panic: ");
+		va_start(ap, fmt);
+		__vprintf(console_send, NULL, fmt, ap);
+		va_end(ap);
+	}
+
+	if (evil==3) {
+		evil = 4;
+
+		vfs_sync();
+	}
+
+	if (evil==4) {
+		evil = 5;
+
+		md_panic();
+	}
+
+	/*
+	 * Last resort, just in case.
+	 */
+
+	for (;;);
+}
diff --git a/os161-1.10/kern/lib/misc.c b/os161-1.10/kern/lib/misc.c
new file mode 100644
index 0000000..2fc91e9
--- /dev/null
+++ b/os161-1.10/kern/lib/misc.c
@@ -0,0 +1,31 @@
+#include <types.h>
+#include <kern/errmsg.h>
+#include <lib.h>
+
+/*
+ * Like strdup, but calls kmalloc.
+ */
+char *
+kstrdup(const char *s)
+{
+	char *z = kmalloc(strlen(s)+1);
+	if (z==NULL) {
+		return NULL;
+	}
+	strcpy(z, s);
+	return z;
+}
+
+/*
+ * Standard C function to return a string for a given errno.
+ * Kernel version; panics if it hits an unknown error.
+ */
+const char *
+strerror(int errcode)
+{
+	if (errcode>=0 && errcode < sys_nerr) {
+		return sys_errlist[errcode];
+	}
+	panic("Invalid error code %d\n", errcode);
+	return NULL;
+}
diff --git a/os161-1.10/kern/lib/ntoh.c b/os161-1.10/kern/lib/ntoh.c
new file mode 100644
index 0000000..25fba35
--- /dev/null
+++ b/os161-1.10/kern/lib/ntoh.c
@@ -0,0 +1,64 @@
+/*
+ * Byte-swap functions.
+ *
+ * *s are for "short" (16-bit)
+ * *l are for "long" (32-bit)
+ * *ll are for "long long" (64-bit)
+ *
+ * hton* convert from host byte order to network byte order.
+ * ntoh* convert from network byte order to host byte order.
+ *
+ * Network byte order is big-endian.
+ *
+ * Note that right now the only platforms OS/161 runs on are
+ * big-endian, so these functions are actually all empty.
+ */
+
+#include <types.h>
+#include <lib.h>
+
+#ifdef _LITTLE_ENDIAN
+
+#define SWAPFUNCS(size, type)                               \
+    type                                                    \
+    ntoh##size(volatile type val)                           \
+    {                                                       \
+            volatile type rv;                               \
+            volatile char *src, *dest;                      \
+	    unsigned i;                                     \
+	    src = (char *)&val;                             \
+	    dest = (char *)&rv;                             \
+	    for (i=0; i<sizeof(rv); i++) {                  \
+		    dest[i] = src[sizeof(rv)-i-1];          \
+	    }                                               \
+	    return rv;                                      \
+                                                            \
+    }                                                       \
+                                                            \
+    type                                                    \
+    hton##size(type val)                                    \
+    {                                                       \
+            return ntoh##size(val);                         \
+    }
+#endif
+
+/*
+ * Use a separate #if, so if the header file defining the symbols gets
+ * omitted or messed up the build will fail instead of silently choosing
+ * the wrong option.
+ */
+#ifdef _BIG_ENDIAN
+
+#define SWAPFUNCS(size, type) \
+   type ntoh##size(type val) { return val; } \
+   type hton##size(type val) { return val; }
+
+#endif
+
+#ifndef SWAPFUNCS
+#error "_BIG_ENDIAN/_LITTLE_ENDIAN not set"
+#endif
+
+SWAPFUNCS(s, u_int16_t)
+SWAPFUNCS(l, u_int32_t)
+SWAPFUNCS(ll, u_int64_t)
diff --git a/os161-1.10/kern/lib/queue.c b/os161-1.10/kern/lib/queue.c
new file mode 100644
index 0000000..e990c70
--- /dev/null
+++ b/os161-1.10/kern/lib/queue.c
@@ -0,0 +1,158 @@
+/*
+ * Queue of void pointers. See queue.h for details.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <queue.h>
+
+struct queue {
+	int size;
+	int nextwrite;	// next element to write to (was head)
+	int nextread;	// next element to read from (was tail)
+	void **data;
+};
+
+static
+int
+q_grow(struct queue *q, int targetsize)
+{
+	void **olddata = q->data;
+	int onr = q->nextread;
+	int onw = q->nextwrite;
+	int osize = q->size;
+
+	int nsize;
+	void **ndata;
+
+	int i, result;
+
+	nsize = q->size;
+	while (nsize < targetsize) {
+		nsize *= 2;
+		/* prevent infinite loop */
+		assert(nsize > 0);
+	}
+	ndata = kmalloc(nsize * sizeof(void *));
+	if (ndata == NULL) {
+		return ENOMEM;
+	}
+	q->size = nsize;
+	q->data = ndata;
+	q->nextread = q->nextwrite = 0;
+	
+	for (i=onr; i!=onw; i = (i+1)%osize) {
+		result = q_addtail(q, olddata[i]);
+		assert(result==0);
+	}
+	kfree(olddata);
+	return 0;
+}
+
+struct queue *
+q_create(int size)
+{
+	struct queue *q = kmalloc(sizeof(struct queue));
+	if (q==NULL) {
+		return NULL;
+	}
+	q->size = size;
+	q->data = kmalloc(size * sizeof(void *));
+	if (q->data==NULL) {
+		kfree(q);
+		return NULL;
+	}
+	q->nextread = q->nextwrite = 0;
+	return q;
+}
+
+int
+q_preallocate(struct queue *q, int size)
+{
+	int result = 0;
+
+	assert(q->size > 0);
+
+	if (size > q->size) {
+		result = q_grow(q, size);
+	}
+	return result;
+}
+
+inline
+int
+q_empty(struct queue *q)
+{
+	return q->nextwrite == q->nextread;
+}
+
+int
+q_addtail(struct queue *q, void *ptr)
+{
+	int nextnext, result;
+
+	assert(q->size > 0);
+
+	nextnext = (q->nextwrite+1) % q->size;
+	if (nextnext==q->nextread) {
+		result = q_grow(q, q->size+1);
+		if (result) {
+			return result;
+		}
+		nextnext = (q->nextwrite+1) % q->size;
+	}
+	q->data[q->nextwrite] = ptr;
+	q->nextwrite = nextnext;
+	return 0;
+}
+
+void *
+q_remhead(struct queue *q)
+{
+	void *ret;
+
+	assert(q->size > 0);
+
+	assert(!q_empty(q));
+	ret = q->data[q->nextread];
+	q->nextread = (q->nextread+1)%q->size;
+	return ret;
+}
+
+void
+q_destroy(struct queue *q)
+{
+	assert(q_empty(q));
+	kfree(q->data);
+	kfree(q);
+}
+
+/* These are really intended only for debugging. */
+int
+q_getstart(struct queue *q)
+{
+	return q->nextread;
+}
+
+int
+q_getend(struct queue *q)
+{
+	return q->nextwrite;
+}
+
+int
+q_getsize(struct queue *q)
+{
+	return q->size;
+}
+
+void *
+q_getguy(struct queue *q, int index)
+{
+	// note that we don't check to make sure the access isn't in the
+	// unused part of the queue space. we probably should.
+
+	assert(index>=0 && index<q->size);
+	return q->data[index];
+}
diff --git a/os161-1.10/kern/main/main.c b/os161-1.10/kern/main/main.c
new file mode 100644
index 0000000..a19b0f2
--- /dev/null
+++ b/os161-1.10/kern/main/main.c
@@ -0,0 +1,167 @@
+/*
+ * Main.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/unistd.h>
+#include <lib.h>
+#include <machine/spl.h>
+#include <test.h>
+#include <synch.h>
+#include <thread.h>
+#include <scheduler.h>
+#include <dev.h>
+#include <vfs.h>
+#include <vm.h>
+#include <syscall.h>
+#include <version.h>
+
+/*
+ * These two pieces of data are maintained by the makefiles and build system.
+ * buildconfig is the name of the config file the kernel was configured with.
+ * buildversion starts at 1 and is incremented every time you link a kernel. 
+ *
+ * The purpose is not to show off how many kernels you've linked, but
+ * to make it easy to make sure that the kernel you just booted is the
+ * same one you just built.
+ */
+extern const int buildversion;
+extern const char buildconfig[];
+
+/*
+ * Copyright message for the OS/161 base code.
+ */
+static const char harvard_copyright[] =
+    "Copyright (c) 2000, 2001, 2002, 2003\n"
+    "   President and Fellows of Harvard College.  All rights reserved.\n";
+
+
+/*
+ * Initial boot sequence.
+ */
+static
+void
+boot(void)
+{
+	/*
+	 * The order of these is important!
+	 * Don't go changing it without thinking about the consequences.
+	 *
+	 * Among other things, be aware that console output gets
+	 * buffered up at first and does not actually appear until
+	 * dev_bootstrap() attaches the console device. This can be
+	 * remarkably confusing if a bug occurs at this point. So
+	 * don't put new code before dev_bootstrap if you don't
+	 * absolutely have to.
+	 *
+	 * Also note that the buffer for this is only 1k. If you
+	 * overflow it, the system will crash without printing
+	 * anything at all. You can make it larger though (it's in
+	 * dev/generic/console.c).
+	 */
+
+	kprintf("\n");
+	kprintf("OS/161 base system version %s\n", BASE_VERSION);
+	kprintf("%s", harvard_copyright);
+	kprintf("\n");
+
+	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+		GROUP_VERSION, buildconfig, buildversion);
+	kprintf("\n");
+
+	ram_bootstrap();
+	scheduler_bootstrap();
+	thread_bootstrap();
+	vfs_bootstrap();
+	dev_bootstrap();
+	vm_bootstrap();
+	kprintf_bootstrap();
+
+	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+	vfs_setbootfs("emu0");
+
+
+	/*
+	 * Make sure various things aren't screwed up.
+	 */
+	assert(sizeof(userptr_t)==sizeof(char *));
+	assert(sizeof(*(userptr_t)0)==sizeof(char));
+}
+
+/*
+ * Shutdown sequence. Opposite to boot().
+ */
+static
+void
+shutdown(void)
+{
+
+	kprintf("Shutting down.\n");
+	
+	vfs_clearbootfs();
+	vfs_clearcurdir();
+	vfs_unmountall();
+
+	splhigh();
+
+	scheduler_shutdown();
+	thread_shutdown();
+}
+
+/*****************************************/
+
+/*
+ * reboot() system call.
+ *
+ * Note: this is here because it's directly related to the code above,
+ * not because this is where system call code should go. Other syscall
+ * code should probably live in the "userprog" directory.
+ */
+int
+sys_reboot(int code)
+{
+	switch (code) {
+	    case RB_REBOOT:
+	    case RB_HALT:
+	    case RB_POWEROFF:
+		break;
+	    default:
+		return EINVAL;
+	}
+
+	shutdown();
+
+	switch (code) {
+	    case RB_HALT:
+		kprintf("The system is halted.\n");
+		md_halt();
+		break;
+	    case RB_REBOOT:
+		kprintf("Rebooting...\n");
+		md_reboot();
+		break;
+	    case RB_POWEROFF:
+		kprintf("The system is halted.\n");
+		md_poweroff();
+		break;
+	}
+
+	panic("reboot operation failed\n");
+	return 0;
+}
+
+/*
+ * Kernel main. Boot up, then fork the menu thread; wait for a reboot
+ * request, and then shut down.
+ */
+int
+kmain(char *arguments)
+{
+	boot();
+
+	menu(arguments);
+
+	/* Should not get here */
+	return 0;
+}
diff --git a/os161-1.10/kern/main/menu.c b/os161-1.10/kern/main/menu.c
new file mode 100644
index 0000000..4c1b4c9
--- /dev/null
+++ b/os161-1.10/kern/main/menu.c
@@ -0,0 +1,654 @@
+/*
+ * In-kernel menu and command dispatcher.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/unistd.h>
+#include <kern/limits.h>
+#include <lib.h>
+#include <clock.h>
+#include <thread.h>
+#include <syscall.h>
+#include <uio.h>
+#include <vfs.h>
+#include <sfs.h>
+#include <test.h>
+#include "opt-synchprobs.h"
+#include "opt-sfs.h"
+#include "opt-net.h"
+
+#define _PATH_SHELL "/bin/sh"
+
+#define MAXMENUARGS  16
+
+void
+getinterval(time_t s1, u_int32_t ns1, time_t s2, u_int32_t ns2,
+	    time_t *rs, u_int32_t *rns)
+{
+	if (ns2 < ns1) {
+		ns2 += 1000000000;
+		s2--;
+	}
+
+	*rns = ns2 - ns1;
+	*rs = s2 - s1;
+}
+
+////////////////////////////////////////////////////////////
+//
+// Command menu functions 
+
+/*
+ * Function for a thread that runs an arbitrary userlevel program by
+ * name.
+ *
+ * Note: this cannot pass arguments to the program. You may wish to 
+ * change it so it can, because that will make testing much easier
+ * in the future.
+ *
+ * It copies the program name because runprogram destroys the copy
+ * it gets by passing it to vfs_open(). 
+ */
+static
+void
+cmd_progthread(void *ptr, unsigned long nargs)
+{
+	char **args = ptr;
+	char progname[128];
+	int result;
+
+	assert(nargs >= 1);
+
+	if (nargs > 2) {
+		kprintf("Warning: argument passing from menu not supported\n");
+	}
+
+	/* Hope we fit. */
+	assert(strlen(args[0]) < sizeof(progname));
+
+	strcpy(progname, args[0]);
+
+	result = runprogram(progname);
+	if (result) {
+		kprintf("Running program %s failed: %s\n", args[0],
+			strerror(result));
+		return;
+	}
+
+	/* NOTREACHED: runprogram only returns on error. */
+}
+
+/*
+ * Common code for cmd_prog and cmd_shell.
+ *
+ * Note that this does not wait for the subprogram to finish, but
+ * returns immediately to the menu. This is usually not what you want,
+ * so you should have it call your system-calls-assignment waitpid
+ * code after forking.
+ *
+ * Also note that because the subprogram's thread uses the "args"
+ * array and strings, until you do this a race condition exists
+ * between that code and the menu input code.
+ */
+static
+int
+common_prog(int nargs, char **args)
+{
+	int result;
+
+#if OPT_SYNCHPROBS
+	kprintf("Warning: this probably won't work with a "
+		"synchronization-problems kernel.\n");
+#endif
+
+	result = thread_fork(args[0] /* thread name */,
+			args /* thread arg */, nargs /* thread arg */,
+			cmd_progthread, NULL);
+	if (result) {
+		kprintf("thread_fork failed: %s\n", strerror(result));
+		return result;
+	}
+
+	return 0;
+}
+
+/*
+ * Command for running an arbitrary userlevel program.
+ */
+static
+int
+cmd_prog(int nargs, char **args)
+{
+	if (nargs < 2) {
+		kprintf("Usage: p program [arguments]\n");
+		return EINVAL;
+	}
+
+	/* drop the leading "p" */
+	args++;
+	nargs--;
+
+	return common_prog(nargs, args);
+}
+
+/*
+ * Command for starting the system shell.
+ */
+static
+int
+cmd_shell(int nargs, char **args)
+{
+	(void)args;
+	if (nargs != 1) {
+		kprintf("Usage: s\n");
+		return EINVAL;
+	}
+
+	args[0] = (char *)_PATH_SHELL;
+
+	return common_prog(nargs, args);
+}
+
+/*
+ * Command for changing directory.
+ */
+static
+int
+cmd_chdir(int nargs, char **args)
+{
+	if (nargs != 2) {
+		kprintf("Usage: cd directory\n");
+		return EINVAL;
+	}
+
+	return vfs_chdir(args[1]);
+}
+
+/*
+ * Command for printing the current directory.
+ */
+static
+int
+cmd_pwd(int nargs, char **args)
+{
+	char buf[PATH_MAX+1];
+	struct uio ku;
+	int result;
+
+	(void)nargs;
+	(void)args;
+
+	mk_kuio(&ku, buf, sizeof(buf)-1, 0, UIO_READ);
+	result = vfs_getcwd(&ku);
+	if (result) {
+		kprintf("vfs_getcwd failed (%s)\n", strerror(result));
+		return result;
+	}
+
+	/* null terminate */
+	buf[sizeof(buf)-1-ku.uio_resid] = 0;
+
+	/* print it */
+	kprintf("%s\n", buf);
+
+	return 0;
+}
+
+/*
+ * Command for running sync.
+ */
+static
+int
+cmd_sync(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	vfs_sync();
+
+	return 0;
+}
+
+/*
+ * Command for doing an intentional panic.
+ */
+static
+int
+cmd_panic(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	panic("User requested panic\n");
+	return 0;
+}
+
+/*
+ * Command for shutting down.
+ */
+static
+int
+cmd_quit(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	vfs_sync();
+	sys_reboot(RB_POWEROFF);
+	thread_exit();
+	return 0;
+}
+
+/*
+ * Command for mounting a filesystem.
+ */
+
+/* Table of mountable filesystem types. */
+static const struct {
+	const char *name;
+	int (*func)(const char *device);
+} mounttable[] = {
+#if OPT_SFS
+	{ "sfs", sfs_mount },
+#endif
+	{ NULL, NULL }
+};
+
+static
+int
+cmd_mount(int nargs, char **args)
+{
+	char *fstype;
+	char *device;
+	int i;
+
+	if (nargs != 3) {
+		kprintf("Usage: mount fstype device:\n");
+		return EINVAL;
+	}
+
+	fstype = args[1];
+	device = args[2];
+
+	/* Allow (but do not require) colon after device name */
+	if (device[strlen(device)-1]==':') {
+		device[strlen(device)-1] = 0;
+	}
+
+	for (i=0; mounttable[i].name; i++) {
+		if (!strcmp(mounttable[i].name, fstype)) {
+			return mounttable[i].func(device);
+		}
+	}
+	kprintf("Unknown filesystem type %s\n", fstype);
+	return EINVAL;
+}
+
+static
+int
+cmd_unmount(int nargs, char **args)
+{
+	char *device;
+
+	if (nargs != 2) {
+		kprintf("Usage: unmount device:\n");
+		return EINVAL;
+	}
+
+	device = args[1];
+
+	/* Allow (but do not require) colon after device name */
+	if (device[strlen(device)-1]==':') {
+		device[strlen(device)-1] = 0;
+	}
+
+	return vfs_unmount(device);
+}
+
+/*
+ * Command to set the "boot fs". 
+ *
+ * The boot filesystem is the one that pathnames like /bin/sh with
+ * leading slashes refer to.
+ *
+ * The default bootfs is "emu0".
+ */
+static
+int
+cmd_bootfs(int nargs, char **args)
+{
+	char *device;
+
+	if (nargs != 2) {
+		kprintf("Usage: bootfs device\n");
+		return EINVAL;
+	}
+
+	device = args[1];
+
+	/* Allow (but do not require) colon after device name */
+	if (device[strlen(device)-1]==':') {
+		device[strlen(device)-1] = 0;
+	}
+
+	return vfs_setbootfs(device);
+}
+
+static
+int
+cmd_kheapstats(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	kheap_printstats();
+	
+	return 0;
+}
+
+////////////////////////////////////////
+//
+// Menus.
+
+static
+void
+showmenu(const char *name, const char *x[])
+{
+	int ct, half, i;
+
+	kprintf("\n");
+	kprintf("%s\n", name);
+	
+	for (i=ct=0; x[i]; i++) {
+		ct++;
+	}
+	half = (ct+1)/2;
+
+	for (i=0; i<half; i++) {
+		kprintf("    %-36s", x[i]);
+		if (i+half < ct) {
+			kprintf("%s", x[i+half]);
+		}
+		kprintf("\n");
+	}
+
+	kprintf("\n");
+}
+
+static const char *opsmenu[] = {
+	"[s]       Shell                     ",
+	"[p]       Other program             ",
+	"[mount]   Mount a filesystem        ",
+	"[unmount] Unmount a filesystem      ",
+	"[bootfs]  Set \"boot\" filesystem     ",
+	"[pf]      Print a file              ",
+	"[cd]      Change directory          ",
+	"[pwd]     Print current directory   ",
+	"[sync]    Sync filesystems          ",
+	"[panic]   Intentional panic         ",
+	"[q]       Quit and shut down        ",
+	NULL
+};
+
+static
+int
+cmd_opsmenu(int n, char **a)
+{
+	(void)n;
+	(void)a;
+
+	showmenu("OS/161 operations menu", opsmenu);
+	return 0;
+}
+
+static const char *testmenu[] = {
+	"[at]  Array test                    ",
+	"[bt]  Bitmap test                   ",
+	"[qt]  Queue test                    ",
+	"[km1] Kernel malloc test            ",
+	"[km2] kmalloc stress test           ",
+	"[tt1] Thread test 1                 ",
+	"[tt2] Thread test 2                 ",
+	"[tt3] Thread test 3                 ",
+#if OPT_NET
+	"[net] Network test                  ",
+#endif
+	"[sy1] Semaphore test                ",
+	"[sy2] Lock test             (1)     ",
+	"[sy3] CV test               (1)     ",
+	"[fs1] Filesystem test               ",
+	"[fs2] FS read stress        (4)     ",
+	"[fs3] FS write stress       (4)     ",
+	"[fs4] FS write stress 2     (4)     ",
+	"[fs5] FS create stress      (4)     ",
+	NULL
+};
+
+static
+int
+cmd_testmenu(int n, char **a)
+{
+	(void)n;
+	(void)a;
+
+	showmenu("OS/161 tests menu", testmenu);
+	kprintf("    (1) These tests will fail until you finish the "
+		"synch assignment.\n");
+	kprintf("    (4) These tests will fail until you finish the "
+		"file system assignment.\n");
+	kprintf("\n");
+
+	return 0;
+}
+
+static const char *mainmenu[] = {
+	"[?o] Operations menu                ",
+	"[?t] Tests menu                     ",
+#if OPT_SYNCHPROBS
+	"[1a] Cat/mouse with semaphores      ",
+	"[1b] Cat/mouse with locks and CVs   ",
+	"[1c] Stoplight                      ",
+#endif
+	"[kh] Kernel heap stats              ",
+	"[q] Quit and shut down              ",
+	NULL
+};
+
+static
+int
+cmd_mainmenu(int n, char **a)
+{
+	(void)n;
+	(void)a;
+
+	showmenu("OS/161 kernel menu", mainmenu);
+	return 0;
+}
+
+////////////////////////////////////////
+//
+// Command table.
+
+static struct {
+	const char *name;
+	int (*func)(int nargs, char **args);
+} cmdtable[] = {
+	/* menus */
+	{ "?",		cmd_mainmenu },
+	{ "h",		cmd_mainmenu },
+	{ "help",	cmd_mainmenu },
+	{ "?o",		cmd_opsmenu },
+	{ "?t",		cmd_testmenu },
+
+	/* operations */
+	{ "s",		cmd_shell },
+	{ "p",		cmd_prog },
+	{ "mount",	cmd_mount },
+	{ "unmount",	cmd_unmount },
+	{ "bootfs",	cmd_bootfs },
+	{ "pf",		printfile },
+	{ "cd",		cmd_chdir },
+	{ "pwd",	cmd_pwd },
+	{ "sync",	cmd_sync },
+	{ "panic",	cmd_panic },
+	{ "q",		cmd_quit },
+	{ "exit",	cmd_quit },
+	{ "halt",	cmd_quit },
+
+#if OPT_SYNCHPROBS
+	/* in-kernel synchronization problems */
+	{ "1a",		catmousesem },
+	{ "1b",		catmouselock },
+	{ "1c",		createcars },
+#endif
+
+	/* stats */
+	{ "kh",         cmd_kheapstats },
+
+	/* base system tests */
+	{ "at",		arraytest },
+	{ "bt",		bitmaptest },
+	{ "qt",		queuetest },
+	{ "km1",	malloctest },
+	{ "km2",	mallocstress },
+#if OPT_NET
+	{ "net",	nettest },
+#endif
+	{ "tt1",	threadtest },
+	{ "tt2",	threadtest2 },
+	{ "tt3",	threadtest3 },
+	{ "sy1",	semtest },
+
+	/* synchronization assignment tests */
+	{ "sy2",	locktest },
+	{ "sy3",	cvtest },
+
+	/* file system assignment tests */
+	{ "fs1",	fstest },
+	{ "fs2",	readstress },
+	{ "fs3",	writestress },
+	{ "fs4",	writestress2 },
+	{ "fs5",	createstress },
+
+	{ NULL, NULL }
+};
+
+/*
+ * Process a single command.
+ */
+static
+int
+cmd_dispatch(char *cmd)
+{
+	time_t beforesecs, aftersecs, secs;
+	u_int32_t beforensecs, afternsecs, nsecs;
+	char *args[MAXMENUARGS];
+	int nargs=0;
+	char *word;
+	char *context;
+	int i, result;
+
+	for (word = strtok_r(cmd, " \t", &context);
+	     word != NULL;
+	     word = strtok_r(NULL, " \t", &context)) {
+
+		if (nargs >= MAXMENUARGS) {
+			kprintf("Command line has too many words\n");
+			return E2BIG;
+		}
+		args[nargs++] = word;
+	}
+
+	if (nargs==0) {
+		return 0;
+	}
+
+	for (i=0; cmdtable[i].name; i++) {
+		if (*cmdtable[i].name && !strcmp(args[0], cmdtable[i].name)) {
+			assert(cmdtable[i].func!=NULL);
+
+			gettime(&beforesecs, &beforensecs);
+
+			result = cmdtable[i].func(nargs, args);
+
+			gettime(&aftersecs, &afternsecs);
+			getinterval(beforesecs, beforensecs,
+				    aftersecs, afternsecs,
+				    &secs, &nsecs);
+
+			kprintf("Operation took %lu.%09lu seconds\n",
+				(unsigned long) secs,
+				(unsigned long) nsecs);
+
+			return result;
+		}
+	}
+
+	kprintf("%s: Command not found\n", args[0]);
+	return EINVAL;
+}
+
+/*
+ * Evaluate a command line that may contain multiple semicolon-delimited
+ * commands.
+ *
+ * If "isargs" is set, we're doing command-line processing; print the
+ * comamnds as we execute them and panic if the command is invalid or fails.
+ */
+static
+void
+menu_execute(char *line, int isargs)
+{
+	char *command;
+	char *context;
+	int result;
+
+	for (command = strtok_r(line, ";", &context);
+	     command != NULL;
+	     command = strtok_r(NULL, ";", &context)) {
+
+		if (isargs) {
+			kprintf("OS/161 kernel: %s\n", command);
+		}
+
+		result = cmd_dispatch(command);
+		if (result) {
+			kprintf("Menu command failed: %s\n", strerror(result));
+			if (isargs) {
+				panic("Failure processing kernel arguments\n");
+			}
+		}
+	}
+}
+
+/*
+ * Command menu main loop.
+ *
+ * First, handle arguments passed on the kernel's command line from
+ * the bootloader. Then loop prompting for commands.
+ *
+ * The line passed in from the bootloader is treated as if it had been
+ * typed at the prompt. Semicolons separate commands; spaces and tabs
+ * separate words (command names and arguments).
+ *
+ * So, for instance, to mount an SFS on lhd0 and make it the boot
+ * filesystem, and then boot directly into the shell, one would use
+ * the kernel command line
+ *
+ *      "mount sfs lhd0; bootfs lhd0; s"
+ */
+
+void
+menu(char *args)
+{
+	char buf[64];
+
+	menu_execute(args, 1);
+
+	while (1) {
+		kprintf("OS/161 kernel [? for menu]: ");
+		kgets(buf, sizeof(buf));
+		menu_execute(buf, 0);
+	}
+}
diff --git a/os161-1.10/kern/test/arraytest.c b/os161-1.10/kern/test/arraytest.c
new file mode 100644
index 0000000..1b5308b
--- /dev/null
+++ b/os161-1.10/kern/test/arraytest.c
@@ -0,0 +1,114 @@
+#include <types.h>
+#include <lib.h>
+#include <array.h>
+#include <test.h>
+
+#define TESTSIZE 73
+
+static
+void
+testa(struct array *a)
+{
+	int testarray[TESTSIZE];
+	int i, j, n, r, *p;
+
+	for (i=0; i<TESTSIZE; i++) {
+		testarray[i]=i;
+	}
+
+	n = array_getnum(a);
+	assert(n==0);
+
+	for (i=0; i<TESTSIZE; i++) {
+		r = array_add(a, &testarray[i]);
+		assert(r==0);
+		n = array_getnum(a);
+		assert(n==i+1);
+	}
+	n = array_getnum(a);
+	assert(n==TESTSIZE);
+
+	for (i=0; i<TESTSIZE; i++) {
+		p = array_getguy(a, i);
+		assert(*p == i);
+	}
+	n = array_getnum(a);
+	assert(n==TESTSIZE);
+
+	for (j=0; j<TESTSIZE*4; j++) {
+		i = random()%TESTSIZE;
+		p = array_getguy(a, i);
+		assert(*p == i);
+	}
+	n = array_getnum(a);
+	assert(n==TESTSIZE);
+
+	for (i=0; i<TESTSIZE; i++) {
+		array_setguy(a, i, &testarray[TESTSIZE-i-1]);
+	}
+
+	for (i=0; i<TESTSIZE; i++) {
+		p = array_getguy(a, i);
+		assert(*p == TESTSIZE-i-1);
+	}
+
+	r = array_setsize(a, TESTSIZE/2);
+	assert(r==0);
+
+	for (i=0; i<TESTSIZE/2; i++) {
+		p = array_getguy(a, i);
+		assert(*p == TESTSIZE-i-1);
+	}
+
+	array_remove(a, 1);
+
+	for (i=1; i<TESTSIZE/2 - 1; i++) {
+		p = array_getguy(a, i);
+		assert(*p == TESTSIZE-i-2);
+	}
+	p = array_getguy(a, 0);
+	assert(*p == TESTSIZE-1);
+
+	array_setsize(a, 2);
+	p = array_getguy(a, 0);
+	assert(*p == TESTSIZE-1);
+	p = array_getguy(a, 1);
+	assert(*p == TESTSIZE-3);
+
+	array_setguy(a, 1, NULL);
+	array_setsize(a, 2);
+	p = array_getguy(a, 0);
+	assert(*p == TESTSIZE-1);
+	p = array_getguy(a, 1);
+	assert(p==NULL);
+
+	array_setsize(a, TESTSIZE*10);
+	p = array_getguy(a, 0);
+	assert(*p == TESTSIZE-1);
+	p = array_getguy(a, 1);
+	assert(p==NULL);
+}
+
+int
+arraytest(int nargs, char **args)
+{
+	struct array *a;
+
+	(void)nargs;
+	(void)args;
+
+	kprintf("Beginning array test...\n");
+	a = array_create();
+	assert(a != NULL);
+
+	testa(a);
+
+	array_setsize(a, 0);
+
+	testa(a);
+
+	array_destroy(a);
+
+	kprintf("Array test complete\n");
+	return 0;
+}
diff --git a/os161-1.10/kern/test/bitmaptest.c b/os161-1.10/kern/test/bitmaptest.c
new file mode 100644
index 0000000..932497b
--- /dev/null
+++ b/os161-1.10/kern/test/bitmaptest.c
@@ -0,0 +1,77 @@
+#include <types.h>
+#include <lib.h>
+#include <bitmap.h>
+#include <test.h>
+
+#define TESTSIZE 533
+
+int
+bitmaptest(int nargs, char **args)
+{
+	struct bitmap *b;
+	char data[TESTSIZE];
+	u_int32_t x;
+	int i;
+
+	(void)nargs;
+	(void)args;
+
+	kprintf("Starting bitmap test...\n");
+
+	for (i=0; i<TESTSIZE; i++) {
+		data[i] = random()%2;
+	}
+
+	b = bitmap_create(TESTSIZE);
+	assert(b != NULL);
+
+	for (i=0; i<TESTSIZE; i++) {
+		assert(bitmap_isset(b, i)==0);
+	}
+
+	for (i=0; i<TESTSIZE; i++) {
+		if (data[i]) {
+			bitmap_mark(b, i);
+		}
+	}
+	for (i=0; i<TESTSIZE; i++) {
+		if (data[i]) {
+			assert(bitmap_isset(b, i));
+		}
+		else {
+			assert(bitmap_isset(b, i)==0);
+		}
+	}
+
+	for (i=0; i<TESTSIZE; i++) {
+		if (data[i]) {
+			bitmap_unmark(b, i);
+		}
+		else {
+			bitmap_mark(b, i);
+		}
+	}
+	for (i=0; i<TESTSIZE; i++) {
+		if (data[i]) {
+			assert(bitmap_isset(b, i)==0);
+		}
+		else {
+			assert(bitmap_isset(b, i));
+		}
+	}
+
+	while (bitmap_alloc(b, &x)==0) {
+		assert(x < TESTSIZE);
+		assert(bitmap_isset(b, x));
+		assert(data[x]==1);
+		data[x] = 0;
+	}
+
+	for (i=0; i<TESTSIZE; i++) {
+		assert(bitmap_isset(b, i));
+		assert(data[i]==0);
+	}
+
+	kprintf("Bitmap test complete\n");
+	return 0;
+}
diff --git a/os161-1.10/kern/test/fstest.c b/os161-1.10/kern/test/fstest.c
new file mode 100644
index 0000000..ca13a51
--- /dev/null
+++ b/os161-1.10/kern/test/fstest.c
@@ -0,0 +1,607 @@
+/*
+ * fstest - filesystem test code
+ *
+ * Writes a file (in small chunks) and then reads it back again
+ * (also in small chunks) and complains if what it reads back is
+ * not the same.
+ *
+ * The length of SLOGAN is intentionally a prime number and 
+ * specifically *not* a power of two.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/unistd.h>
+#include <lib.h>
+#include <synch.h>
+#include <fs.h>
+#include <vnode.h>
+#include <vfs.h>
+#include <uio.h>
+#include <test.h>
+#include <thread.h>
+
+#define SLOGAN   "HODIE MIHI - CRAS TIBI\n"
+#define FILENAME "fstest.tmp"
+#define NCHUNKS  720
+#define NTHREADS 12
+#define NCREATES 32
+
+static struct semaphore *threadsem = NULL;
+
+static
+void
+init_threadsem(void)
+{
+	if (threadsem==NULL) {
+		threadsem = sem_create("fstestsem", 0);
+		if (threadsem == NULL) {
+			panic("fstest: sem_create failed\n");
+		}
+	}
+}
+
+/*
+ * Vary each line of the test file in a way that's predictable but
+ * unlikely to mask bugs in the filesystem.
+ */
+static
+void
+rotate(char *str, int amt)
+{
+	int i, ch;
+
+	amt = (amt+2600)%26;
+	assert(amt>=0);
+
+	for (i=0; str[i]; i++) {
+		ch = str[i];
+		if (ch>='A' && ch<='Z') {
+			ch = ch - 'A';
+			ch += amt;
+			ch %= 26;
+			ch = ch + 'A';
+			assert(ch>='A' && ch<='Z');
+		}
+		str[i] = ch;
+	}
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+fstest_makename(char *buf, size_t buflen, 
+		const char *fs, const char *namesuffix)
+{
+	snprintf(buf, buflen, "%s:%s%s", fs, FILENAME, namesuffix);
+	assert(strlen(buf) < buflen);
+}
+
+#define MAKENAME() fstest_makename(name, sizeof(name), fs, namesuffix)
+
+static
+int
+fstest_remove(const char *fs, const char *namesuffix)
+{
+	char name[32];
+	char buf[32];
+	int err;
+
+	MAKENAME();
+
+	strcpy(buf, name);
+	err = vfs_remove(buf);
+	if (err) {
+		kprintf("Could not remove %s: %s\n", name, strerror(err));
+		return -1;
+	}
+	
+	return 0;
+}
+
+static
+int
+fstest_write(const char *fs, const char *namesuffix,
+	     int stridesize, int stridepos)
+{
+	struct vnode *vn;
+	int err;
+	int i;
+	size_t shouldbytes=0;
+	size_t bytes=0;
+	off_t pos=0;
+	char name[32];
+	char buf[32];
+	struct uio ku;
+	int flags;
+
+	assert(sizeof(buf) > strlen(SLOGAN));
+
+	MAKENAME();
+
+	flags = O_WRONLY|O_CREAT;
+	if (stridesize == 1) {
+		flags |= O_TRUNC;
+	}
+
+	/* vfs_open destroys the string it's passed */
+	strcpy(buf, name);
+	err = vfs_open(buf, flags, &vn);
+	if (err) {
+		kprintf("Could not open %s for write: %s\n", 
+			name, strerror(err));
+		return -1;
+	}
+
+	for (i=0; i<NCHUNKS; i++) {
+		if (i % stridesize != stridepos) {
+			pos += strlen(SLOGAN);
+			continue;
+		}
+		strcpy(buf, SLOGAN);
+		rotate(buf, i);
+		mk_kuio(&ku, buf, strlen(SLOGAN), pos, UIO_WRITE);
+		err = VOP_WRITE(vn, &ku);
+		if (err) {
+			kprintf("%s: Write error: %s\n", name, strerror(err));
+			vfs_close(vn);
+			vfs_remove(name);
+			return -1;
+		}
+
+		if (ku.uio_resid > 0) {
+			kprintf("%s: Short write: %lu bytes left over\n",
+				name, (unsigned long) ku.uio_resid);
+			vfs_close(vn);
+			vfs_remove(name);
+			return -1;
+		}
+
+		bytes += (ku.uio_offset - pos);
+		shouldbytes += strlen(SLOGAN);
+		pos = ku.uio_offset;
+	}
+
+	vfs_close(vn);
+
+	if (bytes != shouldbytes) {
+		kprintf("%s: %lu bytes written, should have been %lu!\n",
+			name, (unsigned long) bytes, 
+			(unsigned long) (NCHUNKS*strlen(SLOGAN)));
+		vfs_remove(name);
+		return -1;
+	}
+	kprintf("%s: %lu bytes written\n", name, (unsigned long) bytes);
+
+	return 0;
+}
+
+static
+int
+fstest_read(const char *fs, const char *namesuffix)
+{
+	struct vnode *vn;
+	int err;
+	int i;
+	size_t bytes=0;
+	char name[32];
+	char buf[32];
+	struct uio ku;
+
+	MAKENAME();
+
+	/* vfs_open destroys the string it's passed */
+	strcpy(buf, name);
+	err = vfs_open(buf, O_RDONLY, &vn);
+	if (err) {
+		kprintf("Could not open test file for read: %s\n",
+			strerror(err));
+		return -1;
+	}
+
+	for (i=0; i<NCHUNKS; i++) {
+		mk_kuio(&ku, buf, strlen(SLOGAN), bytes, UIO_READ);
+		err = VOP_READ(vn, &ku);
+		if (err) {
+			kprintf("%s: Read error: %s\n", name, strerror(err));
+			vfs_close(vn);
+			return -1;
+		}
+
+		if (ku.uio_resid > 0) {
+			kprintf("%s: Short read: %lu bytes left over\n", name,
+				(unsigned long) ku.uio_resid);
+			vfs_close(vn);
+			return -1;
+		}
+		buf[strlen(SLOGAN)] = 0;
+		rotate(buf, -i);
+		if (strcmp(buf, SLOGAN)) {
+			kprintf("%s: Test failed: line %d mismatched: %s\n",
+				name, i+1, buf);
+			vfs_close(vn);
+			return -1;
+		}
+
+		bytes = ku.uio_offset;
+	}
+
+	vfs_close(vn);
+
+	if (bytes != NCHUNKS*strlen(SLOGAN)) {
+		kprintf("%s: %lu bytes read, should have been %lu!\n",
+			name, (unsigned long) bytes, 
+			(unsigned long) (NCHUNKS*strlen(SLOGAN)));
+		return -1;
+	}
+	kprintf("%s: %lu bytes read\n", name, (unsigned long) bytes);
+	return 0;
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+dofstest(const char *filesys)
+{
+	kprintf("*** Starting filesystem test on %s:\n", filesys);
+
+	if (fstest_write(filesys, "", 1, 0)) {
+		kprintf("*** Test failed\n");
+		return;
+	}
+	
+	if (fstest_read(filesys, "")) {
+		kprintf("*** Test failed\n");
+		return;
+	}
+
+	if (fstest_remove(filesys, "")) {
+		kprintf("*** Test failed\n");
+		return;
+	}
+
+	kprintf("*** Filesystem test done\n");
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+readstress_thread(void *fs, unsigned long num)
+{
+	const char *filesys = fs;
+	if (fstest_read(filesys, "")) {
+		kprintf("*** Thread %lu: failed\n", num);
+	}
+	V(threadsem);
+}
+
+static
+void
+doreadstress(const char *filesys)
+{
+	int i, err;
+
+	init_threadsem();
+
+	kprintf("*** Starting fs read stress test on %s:\n", filesys);
+
+	if (fstest_write(filesys, "", 1, 0)) {
+		kprintf("*** Test failed\n");
+		return;
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		err = thread_fork("readstress", (void *)filesys, i, 
+				  readstress_thread, NULL);
+		if (err) {
+			panic("readstress: thread_fork failed: %s\n",
+			      strerror(err));
+		}
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		P(threadsem);
+	}
+
+	if (fstest_remove(filesys, "")) {
+		kprintf("*** Test failed\n");
+		return;
+	}
+	
+	kprintf("*** fs read stress test done\n");
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+writestress_thread(void *fs, unsigned long num)
+{
+	const char *filesys = fs;
+	char numstr[8];
+	snprintf(numstr, sizeof(numstr), "%lu", num);
+
+	if (fstest_write(filesys, numstr, 1, 0)) {
+		kprintf("*** Thread %lu: failed\n", num);
+		V(threadsem);
+		return;
+	}
+
+	if (fstest_read(filesys, numstr)) {
+		kprintf("*** Thread %lu: failed\n", num);
+		V(threadsem);
+		return;
+	}
+
+	if (fstest_remove(filesys, numstr)) {
+		kprintf("*** Thread %lu: failed\n", num);
+	}
+
+	kprintf("*** Thread %lu: done\n", num);
+
+	V(threadsem);
+}
+
+static
+void
+dowritestress(const char *filesys)
+{
+	int i, err;
+
+	init_threadsem();
+
+	kprintf("*** Starting fs write stress test on %s:\n", filesys);
+
+	for (i=0; i<NTHREADS; i++) {
+		err = thread_fork("writestress", (void *)filesys, i, 
+				     writestress_thread, NULL);
+		if (err) {
+			panic("thread_fork failed %s\n", strerror(err));
+		}
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		P(threadsem);
+	}
+
+	kprintf("*** fs write stress test done\n");
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+writestress2_thread(void *fs, unsigned long num)
+{
+	const char *filesys = fs;
+
+	if (fstest_write(filesys, "", NTHREADS, num)) {
+		kprintf("*** Thread %lu: failed\n", num);
+		V(threadsem);
+		return;
+	}
+
+	V(threadsem);
+}
+
+static
+void
+dowritestress2(const char *filesys)
+{
+	int i, err;
+	char name[32];
+	struct vnode *vn;
+
+	init_threadsem();
+
+	kprintf("*** Starting fs write stress test 2 on %s:\n", filesys);
+
+	/* Create and truncate test file */
+	fstest_makename(name, sizeof(name), filesys, "");
+	err = vfs_open(name, O_WRONLY|O_CREAT|O_TRUNC, &vn);
+	if (err) {
+		kprintf("Could not create test file: %s\n", strerror(err));
+		kprintf("*** Test failed\n");
+		return;
+	}
+	vfs_close(vn);
+
+	for (i=0; i<NTHREADS; i++) {
+		err = thread_fork("writestress2", (void *)filesys, i, 
+				      writestress2_thread, NULL);
+		if (err) {
+			panic("writestress2: thread_fork failed: %s\n",
+			      strerror(err));
+		}
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		P(threadsem);
+	}
+
+	if (fstest_read(filesys, "")) {
+		kprintf("*** Test failed\n");
+		return;
+	}
+
+	if (fstest_remove(filesys, "")) {
+		kprintf("*** Test failed\n");
+	}
+
+
+	kprintf("*** fs write stress test 2 done\n");
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+createstress_thread(void *fs, unsigned long num)
+{
+	const char *filesys = fs;
+	int i;
+	char numstr[16];
+
+	for (i=0; i<NCREATES; i++) {
+
+		snprintf(numstr, sizeof(numstr), "%lu-%d", num, i);
+
+		if (fstest_write(filesys, numstr, 1, 0)) {
+			kprintf("*** Thread %lu: file %d: failed\n", num, i);
+			V(threadsem);
+			return;
+		}
+		
+		if (fstest_read(filesys, numstr)) {
+			kprintf("*** Thread %lu: file %d: failed\n", num, i);
+			V(threadsem);
+			return;
+		}
+
+		if (fstest_remove(filesys, numstr)) {
+			kprintf("*** Thread %lu: file %d: failed\n", num, i);
+			V(threadsem);
+			return;
+		}
+
+	}
+
+	V(threadsem);
+}
+
+static
+void
+docreatestress(const char *filesys)
+{
+	int i, err;
+
+	init_threadsem();
+
+	kprintf("*** Starting fs create stress test on %s:\n", filesys);
+
+	for (i=0; i<NTHREADS; i++) {
+		err = thread_fork("createstress", (void *)filesys, i, 
+				  createstress_thread, NULL);
+		if (err) {
+			panic("createstress: thread_fork failed %s\n",
+			      strerror(err));
+		}
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		P(threadsem);
+	}
+
+	kprintf("*** fs create stress test done\n");
+}
+
+////////////////////////////////////////////////////////////
+
+static
+int
+checkfilesystem(int nargs, char **args)
+{
+	char *device;
+
+	if (nargs != 2) {
+		kprintf("Usage: fs[12345] filesystem:\n");
+		return EINVAL;
+	}
+
+	device = args[1];
+
+	/* Allow (but do not require) colon after device name */
+	if (device[strlen(device)-1]==':') {
+		device[strlen(device)-1] = 0;
+	}
+
+	return 0;
+}
+
+#define DEFTEST(testname)                         \
+  int                                             \
+  testname(int nargs, char **args)                \
+  {                                               \
+	int result;                               \
+	result = checkfilesystem(nargs, args);    \
+	if (result) {                             \
+		return result;                    \
+	}                                         \
+	do##testname(args[1]);                    \
+	return 0;                                 \
+  }
+
+DEFTEST(fstest);
+DEFTEST(readstress);
+DEFTEST(writestress);
+DEFTEST(writestress2);
+DEFTEST(createstress);
+
+////////////////////////////////////////////////////////////
+
+int
+printfile(int nargs, char **args)
+{
+	struct vnode *rv, *wv;
+	struct uio ku;
+	off_t rpos=0, wpos=0;
+	char buf[128];
+	char outfile[16];
+	int result;
+	int done=0;
+
+	if (nargs != 2) {
+		kprintf("Usage: pf filename\n");
+		return EINVAL;
+	}
+
+	/* vfs_open destroys the string it's passed; make a copy */
+	strcpy(outfile, "con:");
+
+	result = vfs_open(args[1], O_RDONLY, &rv);
+	if (result) {
+		kprintf("printfile: %s\n", strerror(result));
+		return result;
+	}
+
+	result = vfs_open(outfile, O_WRONLY, &wv);
+	if (result) {
+		kprintf("printfile: output: %s\n", strerror(result));
+		vfs_close(rv);
+		return result;
+	}
+
+	while (!done) {
+		mk_kuio(&ku, buf, sizeof(buf), rpos, UIO_READ);
+		result = VOP_READ(rv, &ku);
+		if (result) {
+			kprintf("Read error: %s\n", strerror(result));
+			break;
+		}
+		rpos = ku.uio_offset;
+
+		if (ku.uio_resid > 0) {
+			done = 1;
+		}
+
+		mk_kuio(&ku, buf, sizeof(buf)-ku.uio_resid, wpos, UIO_WRITE);
+		result = VOP_WRITE(wv, &ku);
+		if (result) {
+			kprintf("Write error: %s\n", strerror(result));
+			break;
+		}
+		wpos = ku.uio_offset;
+
+		if (ku.uio_resid > 0) {
+			kprintf("Warning: short write\n");
+		}
+	}
+
+	vfs_close(wv);
+	vfs_close(rv);
+
+	return 0;
+}
diff --git a/os161-1.10/kern/test/malloctest.c b/os161-1.10/kern/test/malloctest.c
new file mode 100644
index 0000000..9a3db1e
--- /dev/null
+++ b/os161-1.10/kern/test/malloctest.c
@@ -0,0 +1,110 @@
+/*
+ * Test code for kmalloc.
+ */
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <thread.h>
+#include <test.h>
+
+/*
+ * Test kmalloc; allocate ITEMSIZE bytes NTRIES times, freeing
+ * somewhat later.
+ *
+ * The total of ITEMSIZE * NTRIES is intended to exceed the size of
+ * available memory.
+ *
+ * mallocstress does the same thing, but from NTHREADS different
+ * threads at once.
+ */
+
+#define NTRIES   1200
+#define ITEMSIZE  997
+#define NTHREADS  8
+
+static
+void
+mallocthread(void *sm, unsigned long num)
+{
+	struct semaphore *sem = sm;
+	void *ptr;
+	void *oldptr=NULL;
+	void *oldptr2=NULL;
+	int i;
+
+	for (i=0; i<NTRIES; i++) {
+		ptr = kmalloc(ITEMSIZE);
+		if (ptr==NULL) {
+			if (sem) {
+				kprintf("thread %lu: kmalloc returned NULL\n",
+					num);
+				V(sem);
+				return;
+			}
+			kprintf("kmalloc returned null; test failed.\n");
+			return;
+		}
+		if (oldptr2) {
+			kfree(oldptr2);
+		}
+		oldptr2 = oldptr;
+		oldptr = ptr;
+	}
+	if (oldptr2) {
+		kfree(oldptr2);
+	}
+	if (oldptr) {
+		kfree(oldptr);
+	}
+	if (sem) {
+		V(sem);
+	}
+}
+
+int
+malloctest(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	kprintf("Starting kmalloc test...\n");
+	mallocthread(NULL, 0);
+	kprintf("kmalloc test done\n");
+
+	return 0;
+}
+
+int
+mallocstress(int nargs, char **args)
+{
+	struct semaphore *sem;
+	int i, result;
+
+	(void)nargs;
+	(void)args;
+
+	sem = sem_create("mallocstress", 0);
+	if (sem == NULL) {
+		panic("mallocstress: sem_create failed\n");
+	}
+
+	kprintf("Starting kmalloc stress test...\n");
+
+	for (i=0; i<NTHREADS; i++) {
+		result = thread_fork("mallocstress", sem, i, mallocthread,
+				     NULL);
+		if (result) {
+			panic("mallocstress: thread_fork failed: %s\n",
+			      strerror(result));
+		}
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		P(sem);
+	}
+
+	sem_destroy(sem);
+	kprintf("kmalloc stress test done\n");
+
+	return 0;
+}
diff --git a/os161-1.10/kern/test/nettest.c b/os161-1.10/kern/test/nettest.c
new file mode 100644
index 0000000..f2f8ed6
--- /dev/null
+++ b/os161-1.10/kern/test/nettest.c
@@ -0,0 +1,12 @@
+/*
+ * Network test code.
+ */
+#include <types.h>
+#include <lib.h>
+#include <test.h>
+
+void
+nettest(void)
+{
+	kprintf("No network support available\n");
+}
diff --git a/os161-1.10/kern/test/queuetest.c b/os161-1.10/kern/test/queuetest.c
new file mode 100644
index 0000000..80a1ac9
--- /dev/null
+++ b/os161-1.10/kern/test/queuetest.c
@@ -0,0 +1,58 @@
+#include <types.h>
+#include <lib.h>
+#include <queue.h>
+#include <test.h>
+
+static
+void
+testq(struct queue *q, int n)
+{
+	int i, result, *x, *r;
+
+	x = kmalloc(n * sizeof(int));
+	for (i=0; i<n; i++) {
+		x[i] = i;
+	}
+
+	assert(q_empty(q));
+
+	for (i=0; i<n; i++) {
+		kprintf("queue: adding %d\n", i);
+		result = q_addtail(q, &x[i]);
+		assert(result==0);
+	}
+
+	for (i=0; i<n; i++) {
+		r = q_remhead(q);
+		assert(r != NULL);
+		kprintf("queue: got %d, should be %d\n", *r, i);
+		assert(*r == i);
+	}
+
+	assert(q_empty(q));
+
+	kfree(x);
+}
+
+
+int
+queuetest(int nargs, char **args)
+{
+	struct queue *q;
+
+	(void)nargs;
+	(void)args;
+
+	q = q_create(8);
+	assert(q != NULL);
+
+	/* this doesn't require growing the queue */
+	testq(q, 6);
+
+	/* this requires growing the queue */
+	testq(q, 27);
+
+	q_destroy(q);
+
+	return 0;
+}
diff --git a/os161-1.10/kern/test/synchtest.c b/os161-1.10/kern/test/synchtest.c
new file mode 100644
index 0000000..0894b76
--- /dev/null
+++ b/os161-1.10/kern/test/synchtest.c
@@ -0,0 +1,275 @@
+/*
+ * Synchronization test code.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <thread.h>
+#include <test.h>
+#include <clock.h>
+
+#define NSEMLOOPS     63
+#define NLOCKLOOPS    120
+#define NCVLOOPS      5
+#define NTHREADS      32
+
+static volatile unsigned long testval1;
+static volatile unsigned long testval2;
+static volatile unsigned long testval3;
+static struct semaphore *testsem;
+static struct lock *testlock;
+static struct cv *testcv;
+static struct semaphore *donesem;
+
+static
+void
+inititems(void)
+{
+	if (testsem==NULL) {
+		testsem = sem_create("testsem", 2);
+		if (testsem == NULL) {
+			panic("synchtest: sem_create failed\n");
+		}
+	}
+	if (testlock==NULL) {
+		testlock = lock_create("testlock");
+		if (testlock == NULL) {
+			panic("synchtest: lock_create failed\n");
+		}
+	}
+	if (testcv==NULL) {
+		testcv = cv_create("testlock");
+		if (testcv == NULL) {
+			panic("synchtest: cv_create failed\n");
+		}
+	}
+	if (donesem==NULL) {
+		donesem = sem_create("donesem", 0);
+		if (donesem == NULL) {
+			panic("synchtest: sem_create failed\n");
+		}
+	}
+}
+
+static
+void
+semtestthread(void *junk, unsigned long num)
+{
+	int i;
+	(void)junk;
+
+	/*
+	 * Only one of these should print at a time.
+	 */
+	P(testsem);
+	kprintf("Thread %2lu: ", num);
+	for (i=0; i<NSEMLOOPS; i++) {
+		kprintf("%c", (int)num+64);
+	}
+	kprintf("\n");
+	V(donesem);
+}
+
+int
+semtest(int nargs, char **args)
+{
+	int i, result;
+
+	(void)nargs;
+	(void)args;
+
+	inititems();
+	kprintf("Starting semaphore test...\n");
+	kprintf("If this hangs, it's broken: ");
+	P(testsem);
+	P(testsem);
+	kprintf("ok\n");
+
+	for (i=0; i<NTHREADS; i++) {
+		result = thread_fork("semtest", NULL, i, semtestthread, NULL);
+		if (result) {
+			panic("semtest: thread_fork failed: %s\n", 
+			      strerror(result));
+		}
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		V(testsem);
+		P(donesem);
+	}
+
+	/* so we can run it again */
+	V(testsem);
+	V(testsem);
+
+	kprintf("Semaphore test done.\n");
+	return 0;
+}
+
+static
+void
+fail(unsigned long num, const char *msg)
+{
+	kprintf("thread %lu: Mismatch on %s\n", num, msg);
+	kprintf("Test failed\n");
+
+	lock_release(testlock);
+
+	V(donesem);
+	thread_exit();
+}
+
+static
+void
+locktestthread(void *junk, unsigned long num)
+{
+	int i;
+	(void)junk;
+
+	for (i=0; i<NLOCKLOOPS; i++) {
+		lock_acquire(testlock);
+		testval1 = num;
+		testval2 = num*num;
+		testval3 = num%3;
+
+		if (testval2 != testval1*testval1) {
+			fail(num, "testval2/testval1");
+		}
+
+		if (testval2%3 != (testval3*testval3)%3) {
+			fail(num, "testval2/testval3");
+		}
+
+		if (testval3 != testval1%3) {
+			fail(num, "testval3/testval1");
+		}
+
+		if (testval1 != num) {
+			fail(num, "testval1/num");
+		}
+
+		if (testval2 != num*num) {
+			fail(num, "testval2/num");
+		}
+
+		if (testval3 != num%3) {
+			fail(num, "testval3/num");
+		}
+
+		lock_release(testlock);
+	}
+	V(donesem);
+}
+
+
+int
+locktest(int nargs, char **args)
+{
+	int i, result;
+
+	(void)nargs;
+	(void)args;
+
+	inititems();
+	kprintf("Starting lock test...\n");
+
+	for (i=0; i<NTHREADS; i++) {
+		result = thread_fork("synchtest", NULL, i, locktestthread,
+				     NULL);
+		if (result) {
+			panic("locktest: thread_fork failed: %s\n",
+			      strerror(result));
+		}
+	}
+	for (i=0; i<NTHREADS; i++) {
+		P(donesem);
+	}
+
+	kprintf("Lock test done.\n");
+
+	return 0;
+}
+
+static
+void
+cvtestthread(void *junk, unsigned long num)
+{
+	int i;
+	volatile int j;
+	time_t secs1, secs2;
+	u_int32_t nsecs1, nsecs2;
+
+	(void)junk;
+
+	for (i=0; i<NCVLOOPS; i++) {
+		lock_acquire(testlock);
+		while (testval1 != num) {
+			gettime(&secs1, &nsecs1);
+			cv_wait(testcv, testlock);
+			gettime(&secs2, &nsecs2);
+
+			if (nsecs2 < nsecs1) {
+				secs2--;
+				nsecs2 += 1000000000;
+			}
+			
+			nsecs2 -= nsecs1;
+			secs2 -= secs1;
+
+			/* Require at least 2000 cpu cycles (we're 25mhz) */
+			if (secs2==0 && nsecs2 < 40*2000) {
+				kprintf("cv_wait took only %u ns\n", nsecs2);
+				kprintf("That's too fast... you must be "
+					"busy-looping\n");
+				V(donesem);
+				thread_exit();
+			}
+
+		}
+		kprintf("Thread %lu\n", num);
+		testval1 = (testval1 + NTHREADS - 1)%NTHREADS;
+
+		/*
+		 * loop a little while to make sure we can measure the
+		 * time waiting on the cv.
+		 */
+		for (j=0; j<3000; j++);
+
+		cv_broadcast(testcv, testlock);
+		lock_release(testlock);
+	}
+	V(donesem);
+}
+
+int
+cvtest(int nargs, char **args)
+{
+
+	int i, result;
+
+	(void)nargs;
+	(void)args;
+
+	inititems();
+	kprintf("Starting CV test...\n");
+	kprintf("Threads should print out in reverse order.\n");
+
+	testval1 = NTHREADS-1;
+
+	for (i=0; i<NTHREADS; i++) {
+		result = thread_fork("synchtest", NULL, i, cvtestthread,
+				      NULL);
+		if (result) {
+			panic("cvtest: thread_fork failed: %s\n",
+			      strerror(result));
+		}
+	}
+	for (i=0; i<NTHREADS; i++) {
+		P(donesem);
+	}
+
+	kprintf("CV test done\n");
+
+	return 0;
+}
diff --git a/os161-1.10/kern/test/threadtest.c b/os161-1.10/kern/test/threadtest.c
new file mode 100644
index 0000000..eb81c9c
--- /dev/null
+++ b/os161-1.10/kern/test/threadtest.c
@@ -0,0 +1,117 @@
+/*
+ * Thread test code.
+ */
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <thread.h>
+#include <test.h>
+
+#define NTHREADS  8
+
+static struct semaphore *tsem = NULL;
+
+static
+void
+init_sem(void)
+{
+	if (tsem==NULL) {
+		tsem = sem_create("tsem", 0);
+		if (tsem == NULL) {
+			panic("threadtest: sem_create failed\n");
+		}
+	}
+}
+
+static
+void
+loudthread(void *junk, unsigned long num)
+{
+	int ch = '0' + num;
+	int i;
+
+	(void)junk;
+
+	for (i=0; i<120; i++) {
+		putch(ch);
+	}
+	V(tsem);
+}
+
+/*
+ * The idea with this is that you should see
+ *
+ *   01234567 <pause> 01234567
+ *
+ * (possibly with the numbers in different orders)
+ *
+ * The delay loop is supposed to be long enough that it should be clear
+ * if either timeslicing or the scheduler is not working right.
+ */
+static
+void
+quietthread(void *junk, unsigned long num)
+{
+	int ch = '0' + num;
+	volatile int i;
+
+	(void)junk;
+
+	putch(ch);
+	for (i=0; i<200000; i++);
+	putch(ch);
+
+	V(tsem);
+}
+
+static
+void
+runthreads(int doloud)
+{
+	char name[16];
+	int i, result;
+
+	for (i=0; i<NTHREADS; i++) {
+		snprintf(name, sizeof(name), "threadtest%d", i);
+		result = thread_fork(name, NULL, i, 
+				     doloud ? loudthread : quietthread,
+				     NULL);
+		if (result) {
+			panic("threadtest: thread_fork failed %s)\n", 
+			      strerror(result));
+		}
+	}
+
+	for (i=0; i<NTHREADS; i++) {
+		P(tsem);
+	}
+}
+
+
+int
+threadtest(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	init_sem();
+	kprintf("Starting thread test...\n");
+	runthreads(1);
+	kprintf("\nThread test done.\n");
+
+	return 0;
+}
+
+int
+threadtest2(int nargs, char **args)
+{
+	(void)nargs;
+	(void)args;
+
+	init_sem();
+	kprintf("Starting thread test 2...\n");
+	runthreads(0);
+	kprintf("\nThread test 2 done.\n");
+
+	return 0;
+}
diff --git a/os161-1.10/kern/test/tt3.c b/os161-1.10/kern/test/tt3.c
new file mode 100644
index 0000000..6913fb4
--- /dev/null
+++ b/os161-1.10/kern/test/tt3.c
@@ -0,0 +1,231 @@
+/*
+ * More thread test code.
+ */
+#include <types.h>
+#include <lib.h>
+#include <machine/spl.h>
+#include <synch.h>
+#include <thread.h>
+#include <test.h>
+
+#include "opt-synchprobs.h"
+
+/* dimension of matrices (cannot be too large or will overflow stack) */
+
+#if OPT_SYNCHPROBS
+#define DIM 10
+#else
+#define DIM 70
+#endif
+
+/* number of iterations for sleepalot threads */
+#define SLEEPALOT_PRINTS      20	/* number of printouts */
+#define SLEEPALOT_ITERS       4		/* iterations per printout */
+/* polling frequency of waker thread */
+#define WAKER_WAKES          100
+/* number of iterations per compute thread */
+#define COMPUTE_ITERS         10
+
+#define NWAITADDRS 12
+static const char waitaddrs[NWAITADDRS];  /* N distinct wait addresses */
+
+static volatile int wakerdone;
+static struct semaphore *wakersem;
+static struct semaphore *donesem;
+
+static
+void
+setup(void)
+{
+	if (wakersem == NULL) {
+		wakersem = sem_create("wakersem", 1);
+	}
+	if (donesem == NULL) {
+		donesem = sem_create("donesem", 0);
+	}
+	wakerdone = 0;
+}
+
+static
+void
+sleepalot_thread(void *junk, unsigned long num)
+{
+	int i, j, spl;
+
+	(void)junk;
+
+	for (i=0; i<SLEEPALOT_PRINTS; i++) {
+		for (j=0; j<SLEEPALOT_ITERS; j++) {
+			spl = splhigh();
+			thread_sleep(&waitaddrs[random()%NWAITADDRS]);
+			splx(spl);
+		}
+		kprintf("[%lu]", num);
+	}
+	V(donesem);
+}
+
+static
+void
+waker_thread(void *junk1, unsigned long junk2)
+{
+	int i, spl, done;
+
+	(void)junk1;
+	(void)junk2;
+
+	while (1) {
+		P(wakersem);
+		done = wakerdone;
+		V(wakersem);
+		if (done) {
+			break;
+		}
+
+		for (i=0; i<WAKER_WAKES; i++) {
+			spl = splhigh();
+			thread_wakeup(&waitaddrs[random()%NWAITADDRS]);
+			splx(spl);
+
+			thread_yield();
+		}
+	}
+	V(donesem);
+}
+
+static
+void
+make_sleepalots(int howmany)
+{
+	char name[16];
+	int i, result;
+
+	for (i=0; i<howmany; i++) {
+		snprintf(name, sizeof(name), "sleepalot%d", i);
+		result = thread_fork(name, NULL, i, sleepalot_thread, NULL);
+		if (result) {
+			panic("thread_fork failed: %s\n", strerror(result));
+		}
+	}
+	result = thread_fork("waker", NULL, 0, waker_thread, NULL);
+	if (result) {
+		panic("thread_fork failed: %s\n", strerror(result));
+	}
+}
+
+static
+void
+compute_thread(void *junk1, unsigned long num)
+{
+	struct matrix {
+		char m[DIM][DIM];
+	};
+	struct matrix *m1, *m2, *m3;
+	unsigned char tot;
+	int i, j, k, m;
+	u_int32_t rand;
+
+	(void)junk1;
+
+	m1 = kmalloc(sizeof(struct matrix));
+	assert(m1 != NULL);
+	m2 = kmalloc(sizeof(struct matrix));
+	assert(m2 != NULL);
+	m3 = kmalloc(sizeof(struct matrix));
+	assert(m3 != NULL);
+
+	for (m=0; m<COMPUTE_ITERS; m++) {
+
+		for (i=0; i<DIM; i++) {
+			for (j=0; j<DIM; j++) {
+				rand = random();
+				m1->m[i][j] = rand >> 16;
+				m2->m[i][j] = rand & 0xffff;
+			}
+		}
+		
+		for (i=0; i<DIM; i++) {
+			for (j=0; j<DIM; j++) {
+				tot = 0;
+				for (k=0; k<DIM; k++) {
+					tot += m1->m[i][k] * m2->m[k][j];
+				}
+				m3->m[i][j] = tot;
+			}
+		}
+		
+		tot = 0;
+		for (i=0; i<DIM; i++) {
+			tot += m3->m[i][i];
+		}
+
+		kprintf("{%lu: %u}", num, (unsigned) tot);
+		thread_yield();
+	}
+
+	kfree(m1);
+	kfree(m2);
+	kfree(m3);
+
+	V(donesem);
+}
+
+static
+void
+make_computes(int howmany)
+{
+	char name[16];
+	int i, result;
+
+	for (i=0; i<howmany; i++) {
+		snprintf(name, sizeof(name), "compute%d", i);
+		result = thread_fork(name, NULL, i, compute_thread, NULL);
+		if (result) {
+			panic("thread_fork failed: %s\n", strerror(result));
+		}
+	}
+}
+
+static
+void
+finish(int howmanytotal)
+{
+	int i;
+	for (i=0; i<howmanytotal; i++) {
+		P(donesem);
+	}
+	P(wakersem);
+	wakerdone = 1;
+	V(wakersem);
+	P(donesem);
+}
+
+static
+void
+runtest3(int nsleeps, int ncomputes)
+{
+	setup();
+	kprintf("Starting thread test 3 (%d [sleepalots], %d {computes}, "
+		"1 waker)\n",
+		nsleeps, ncomputes);
+	make_sleepalots(nsleeps);
+	make_computes(ncomputes);
+	finish(nsleeps+ncomputes);
+	kprintf("\nThread test 3 done\n");
+}
+
+int
+threadtest3(int nargs, char **args)
+{
+	if (nargs==1) {
+		runtest3(5, 2);
+	}
+	else if (nargs==3) {
+		runtest3(atoi(args[1]), atoi(args[2]));
+	}
+	else {
+		kprintf("Usage: tt3 [sleepthreads computethreads]\n");
+		return 1;
+	}
+	return 0;
+}
diff --git a/os161-1.10/kern/thread/hardclock.c b/os161-1.10/kern/thread/hardclock.c
new file mode 100644
index 0000000..79afc2d
--- /dev/null
+++ b/os161-1.10/kern/thread/hardclock.c
@@ -0,0 +1,49 @@
+#include <types.h>
+#include <lib.h>
+#include <machine/spl.h>
+#include <thread.h>
+#include <clock.h>
+
+/* 
+ * The address of lbolt has thread_wakeup called on it once a second.
+ */
+int lbolt;
+
+static int lbolt_counter;
+
+/*
+ * This is called HZ times a second by the timer device setup.
+ */
+
+void
+hardclock(void)
+{
+	/*
+	 * Collect statistics here as desired.
+	 */
+
+
+	lbolt_counter++;
+	if (lbolt_counter >= HZ) {
+		lbolt_counter = 0;
+		thread_wakeup(&lbolt);
+	}
+
+	thread_yield();
+}
+
+/*
+ * Suspend execution for n seconds.
+ */
+void
+clocksleep(int num_secs)
+{
+	int s;
+
+	s = splhigh();
+	while (num_secs > 0) {
+		thread_sleep(&lbolt);
+		num_secs--;
+	}
+	splx(s);
+}
diff --git a/os161-1.10/kern/thread/scheduler.c b/os161-1.10/kern/thread/scheduler.c
new file mode 100644
index 0000000..795f292
--- /dev/null
+++ b/os161-1.10/kern/thread/scheduler.c
@@ -0,0 +1,140 @@
+/*
+ * Scheduler.
+ *
+ * The default scheduler is very simple, just a round-robin run queue.
+ * You'll want to improve it.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <scheduler.h>
+#include <thread.h>
+#include <machine/spl.h>
+#include <queue.h>
+
+/*
+ *  Scheduler data
+ */
+
+// Queue of runnable threads
+static struct queue *runqueue;
+
+/*
+ * Setup function
+ */
+void
+scheduler_bootstrap(void)
+{
+	runqueue = q_create(32);
+	if (runqueue == NULL) {
+		panic("scheduler: Could not create run queue\n");
+	}
+}
+
+/*
+ * Ensure space for handling at least NTHREADS threads.
+ * This is done only to ensure that make_runnable() does not fail -
+ * if you change the scheduler to not require space outside the 
+ * thread structure, for instance, this function can reasonably
+ * do nothing.
+ */
+int
+scheduler_preallocate(int nthreads)
+{
+	assert(curspl>0);
+	return q_preallocate(runqueue, nthreads);
+}
+
+/*
+ * This is called during panic shutdown to dispose of threads other
+ * than the one invoking panic. We drop them on the floor instead of
+ * cleaning them up properly; since we're about to go down it doesn't
+ * really matter, and freeing everything might cause further panics.
+ */
+void
+scheduler_killall(void)
+{
+	assert(curspl>0);
+	while (!q_empty(runqueue)) {
+		struct thread *t = q_remhead(runqueue);
+		kprintf("scheduler: Dropping thread %s.\n", t->t_name);
+	}
+}
+
+/*
+ * Cleanup function.
+ *
+ * The queue objects to being destroyed if it's got stuff in it.
+ * Use scheduler_killall to make sure this is the case. During
+ * ordinary shutdown, normally it should be.
+ */
+void
+scheduler_shutdown(void)
+{
+	scheduler_killall();
+
+	assert(curspl>0);
+	q_destroy(runqueue);
+	runqueue = NULL;
+}
+
+/*
+ * Actual scheduler. Returns the next thread to run.  Calls cpu_idle()
+ * if there's nothing ready. (Note: cpu_idle must be called in a loop
+ * until something's ready - it doesn't know whether the things that
+ * wake it up are going to make a thread runnable or not.) 
+ */
+struct thread *
+scheduler(void)
+{
+	// meant to be called with interrupts off
+	assert(curspl>0);
+	
+	while (q_empty(runqueue)) {
+		cpu_idle();
+	}
+
+	// You can actually uncomment this to see what the scheduler's
+	// doing - even this deep inside thread code, the console
+	// still works. However, the amount of text printed is
+	// prohibitive.
+	// 
+	//print_run_queue();
+	
+	return q_remhead(runqueue);
+}
+
+/* 
+ * Make a thread runnable.
+ * With the base scheduler, just add it to the end of the run queue.
+ */
+int
+make_runnable(struct thread *t)
+{
+	// meant to be called with interrupts off
+	assert(curspl>0);
+
+	return q_addtail(runqueue, t);
+}
+
+/*
+ * Debugging function to dump the run queue.
+ */
+void
+print_run_queue(void)
+{
+	/* Turn interrupts off so the whole list prints atomically. */
+	int spl = splhigh();
+
+	int i,k=0;
+	i = q_getstart(runqueue);
+	
+	while (i!=q_getend(runqueue)) {
+		struct thread *t = q_getguy(runqueue, i);
+		kprintf("  %2d: %s %p\n", k, t->t_name, t->t_sleepaddr);
+		i=(i+1)%q_getsize(runqueue);
+		k++;
+	}
+	
+	splx(spl);
+}
diff --git a/os161-1.10/kern/thread/synch.c b/os161-1.10/kern/thread/synch.c
new file mode 100644
index 0000000..cdc47a3
--- /dev/null
+++ b/os161-1.10/kern/thread/synch.c
@@ -0,0 +1,216 @@
+/*
+ * Synchronization primitives.
+ * See synch.h for specifications of the functions.
+ */
+
+#include <types.h>
+#include <lib.h>
+#include <synch.h>
+#include <thread.h>
+#include <curthread.h>
+#include <machine/spl.h>
+
+////////////////////////////////////////////////////////////
+//
+// Semaphore.
+
+struct semaphore *
+sem_create(const char *namearg, int initial_count)
+{
+	struct semaphore *sem;
+
+	sem = kmalloc(sizeof(struct semaphore));
+	if (sem == NULL) {
+		return NULL;
+	}
+
+	sem->name = kstrdup(namearg);
+	if (sem->name == NULL) {
+		kfree(sem);
+		return NULL;
+	}
+
+	sem->count = initial_count;
+	return sem;
+}
+
+void
+sem_destroy(struct semaphore *sem)
+{
+	int spl;
+	assert(sem != NULL);
+
+	spl = splhigh();
+	assert(thread_hassleepers(sem)==0);
+	splx(spl);
+
+	/*
+	 * Note: while someone could theoretically start sleeping on
+	 * the semaphore after the above test but before we free it,
+	 * if they're going to do that, they can just as easily wait
+	 * a bit and start sleeping on the semaphore after it's been
+	 * freed. Consequently, there's not a whole lot of point in 
+	 * including the kfrees in the splhigh block, so we don't.
+	 */
+
+	kfree(sem->name);
+	kfree(sem);
+}
+
+void 
+P(struct semaphore *sem)
+{
+	int spl;
+	assert(sem != NULL);
+
+	/*
+	 * May not block in an interrupt handler.
+	 *
+	 * For robustness, always check, even if we can actually
+	 * complete the P without blocking.
+	 */
+	assert(in_interrupt==0);
+
+	spl = splhigh();
+	while (sem->count==0) {
+		thread_sleep(sem);
+	}
+	assert(sem->count>0);
+	sem->count--;
+	splx(spl);
+}
+
+void
+V(struct semaphore *sem)
+{
+	int spl;
+	assert(sem != NULL);
+	spl = splhigh();
+	sem->count++;
+	assert(sem->count>0);
+	thread_wakeup(sem);
+	splx(spl);
+}
+
+////////////////////////////////////////////////////////////
+//
+// Lock.
+
+struct lock *
+lock_create(const char *name)
+{
+	struct lock *lock;
+
+	lock = kmalloc(sizeof(struct lock));
+	if (lock == NULL) {
+		return NULL;
+	}
+
+	lock->name = kstrdup(name);
+	if (lock->name == NULL) {
+		kfree(lock);
+		return NULL;
+	}
+	
+	// add stuff here as needed
+	
+	return lock;
+}
+
+void
+lock_destroy(struct lock *lock)
+{
+	assert(lock != NULL);
+
+	// add stuff here as needed
+	
+	kfree(lock->name);
+	kfree(lock);
+}
+
+void
+lock_acquire(struct lock *lock)
+{
+	// Write this
+
+	(void)lock;  // suppress warning until code gets written
+}
+
+void
+lock_release(struct lock *lock)
+{
+	// Write this
+
+	(void)lock;  // suppress warning until code gets written
+}
+
+int
+lock_do_i_hold(struct lock *lock)
+{
+	// Write this
+
+	(void)lock;  // suppress warning until code gets written
+
+	return 1;    // dummy until code gets written
+}
+
+////////////////////////////////////////////////////////////
+//
+// CV
+
+
+struct cv *
+cv_create(const char *name)
+{
+	struct cv *cv;
+
+	cv = kmalloc(sizeof(struct cv));
+	if (cv == NULL) {
+		return NULL;
+	}
+
+	cv->name = kstrdup(name);
+	if (cv->name==NULL) {
+		kfree(cv);
+		return NULL;
+	}
+	
+	// add stuff here as needed
+	
+	return cv;
+}
+
+void
+cv_destroy(struct cv *cv)
+{
+	assert(cv != NULL);
+
+	// add stuff here as needed
+	
+	kfree(cv->name);
+	kfree(cv);
+}
+
+void
+cv_wait(struct cv *cv, struct lock *lock)
+{
+	// Write this
+	(void)cv;    // suppress warning until code gets written
+	(void)lock;  // suppress warning until code gets written
+}
+
+void
+cv_signal(struct cv *cv, struct lock *lock)
+{
+	// Write this
+	(void)cv;    // suppress warning until code gets written
+	(void)lock;  // suppress warning until code gets written
+}
+
+void
+cv_broadcast(struct cv *cv, struct lock *lock)
+{
+	// Write this
+	(void)cv;    // suppress warning until code gets written
+	(void)lock;  // suppress warning until code gets written
+}
diff --git a/os161-1.10/kern/thread/thread.c b/os161-1.10/kern/thread/thread.c
new file mode 100644
index 0000000..d08f473
--- /dev/null
+++ b/os161-1.10/kern/thread/thread.c
@@ -0,0 +1,594 @@
+/*
+ * Core thread system.
+ */
+#include <types.h>
+#include <lib.h>
+#include <kern/errno.h>
+#include <array.h>
+#include <machine/spl.h>
+#include <machine/pcb.h>
+#include <thread.h>
+#include <curthread.h>
+#include <scheduler.h>
+#include <addrspace.h>
+#include <vnode.h>
+#include "opt-synchprobs.h"
+
+/* States a thread can be in. */
+typedef enum {
+	S_RUN,
+	S_READY,
+	S_SLEEP,
+	S_ZOMB,
+} threadstate_t;
+
+/* Global variable for the thread currently executing at any given time. */
+struct thread *curthread;
+
+/* Table of sleeping threads. */
+static struct array *sleepers;
+
+/* List of dead threads to be disposed of. */
+static struct array *zombies;
+
+/* Total number of outstanding threads. Does not count zombies[]. */
+static int numthreads;
+
+/*
+ * Create a thread. This is used both to create the first thread's 
+ * thread structure and to create subsequent threads.
+ */
+
+static
+struct thread *
+thread_create(const char *name)
+{
+	struct thread *thread = kmalloc(sizeof(struct thread));
+	if (thread==NULL) {
+		return NULL;
+	}
+	thread->t_name = kstrdup(name);
+	if (thread->t_name==NULL) {
+		kfree(thread);
+		return NULL;
+	}
+	thread->t_sleepaddr = NULL;
+	thread->t_stack = NULL;
+	
+	thread->t_vmspace = NULL;
+
+	thread->t_cwd = NULL;
+	
+	// If you add things to the thread structure, be sure to initialize
+	// them here.
+	
+	return thread;
+}
+
+/*
+ * Destroy a thread.
+ *
+ * This function cannot be called in the victim thread's own context.
+ * Freeing the stack you're actually using to run would be... inadvisable.
+ */
+static
+void
+thread_destroy(struct thread *thread)
+{
+	assert(thread != curthread);
+
+	// If you add things to the thread structure, be sure to dispose of
+	// them here or in thread_exit.
+
+	// These things are cleaned up in thread_exit.
+	assert(thread->t_vmspace==NULL);
+	assert(thread->t_cwd==NULL);
+	
+	if (thread->t_stack) {
+		kfree(thread->t_stack);
+	}
+
+	kfree(thread->t_name);
+	kfree(thread);
+}
+
+
+/*
+ * Remove zombies. (Zombies are threads/processes that have exited but not
+ * been fully deleted yet.)
+ */
+static
+void
+exorcise(void)
+{
+	int i, result;
+
+	assert(curspl>0);
+	
+	for (i=0; i<array_getnum(zombies); i++) {
+		struct thread *z = array_getguy(zombies, i);
+		assert(z!=curthread);
+		thread_destroy(z);
+	}
+	result = array_setsize(zombies, 0);
+	/* Shrinking the array; not supposed to be able to fail. */
+	assert(result==0);
+}
+
+/*
+ * Kill all sleeping threads. This is used during panic shutdown to make 
+ * sure they don't wake up again and interfere with the panic.
+ */
+static
+void
+thread_killall(void)
+{
+	int i, result;
+
+	assert(curspl>0);
+
+	/*
+	 * Move all sleepers to the zombie list, to be sure they don't
+	 * wake up while we're shutting down.
+	 */
+
+	for (i=0; i<array_getnum(sleepers); i++) {
+		struct thread *t = array_getguy(sleepers, i);
+		kprintf("sleep: Dropping thread %s\n", t->t_name);
+
+		/*
+		 * Don't do this: because these threads haven't
+		 * been through thread_exit, thread_destroy will
+		 * get upset. Just drop the threads on the floor,
+		 * which is safer anyway during panic.
+		 *
+		 * array_add(zombies, t);
+		 */
+	}
+
+	result = array_setsize(sleepers, 0);
+	/* shrinking array: not supposed to fail */
+	assert(result==0);
+}
+
+/*
+ * Shut down the other threads in the thread system when a panic occurs.
+ */
+void
+thread_panic(void)
+{
+	assert(curspl > 0);
+
+	thread_killall();
+	scheduler_killall();
+}
+
+/*
+ * Thread initialization.
+ */
+struct thread *
+thread_bootstrap(void)
+{
+	struct thread *me;
+
+	/* Create the data structures we need. */
+	sleepers = array_create();
+	if (sleepers==NULL) {
+		panic("Cannot create sleepers array\n");
+	}
+
+	zombies = array_create();
+	if (zombies==NULL) {
+		panic("Cannot create zombies array\n");
+	}
+	
+	/*
+	 * Create the thread structure for the first thread
+	 * (the one that's already running)
+	 */
+	me = thread_create("<boot/menu>");
+	if (me==NULL) {
+		panic("thread_bootstrap: Out of memory\n");
+	}
+
+	/*
+	 * Leave me->t_stack NULL. This means we're using the boot stack,
+	 * which can't be freed.
+	 */
+
+	/* Initialize the first thread's pcb */
+	md_initpcb0(&me->t_pcb);
+
+	/* Set curthread */
+	curthread = me;
+
+	/* Number of threads starts at 1 */
+	numthreads = 1;
+
+	/* Done */
+	return me;
+}
+
+/*
+ * Thread final cleanup.
+ */
+void
+thread_shutdown(void)
+{
+	array_destroy(sleepers);
+	sleepers = NULL;
+	array_destroy(zombies);
+	zombies = NULL;
+	// Don't do this - it frees our stack and we blow up
+	//thread_destroy(curthread);
+}
+
+/*
+ * Create a new thread based on an existing one.
+ * The new thread has name NAME, and starts executing in function FUNC.
+ * DATA1 and DATA2 are passed to FUNC.
+ */
+int
+thread_fork(const char *name, 
+	    void *data1, unsigned long data2,
+	    void (*func)(void *, unsigned long),
+	    struct thread **ret)
+{
+	struct thread *newguy;
+	int s, result;
+
+	/* Allocate a thread */
+	newguy = thread_create(name);
+	if (newguy==NULL) {
+		return ENOMEM;
+	}
+
+	/* Allocate a stack */
+	newguy->t_stack = kmalloc(STACK_SIZE);
+	if (newguy->t_stack==NULL) {
+		kfree(newguy->t_name);
+		kfree(newguy);
+		return ENOMEM;
+	}
+
+	/* stick a magic number on the bottom end of the stack */
+	newguy->t_stack[0] = 0xae;
+	newguy->t_stack[1] = 0x11;
+	newguy->t_stack[2] = 0xda;
+	newguy->t_stack[3] = 0x33;
+
+	/* Inherit the current directory */
+	if (curthread->t_cwd != NULL) {
+		VOP_INCREF(curthread->t_cwd);
+		newguy->t_cwd = curthread->t_cwd;
+	}
+
+	/* Set up the pcb (this arranges for func to be called) */
+	md_initpcb(&newguy->t_pcb, newguy->t_stack, data1, data2, func);
+
+	/* Interrupts off for atomicity */
+	s = splhigh();
+
+	/*
+	 * Make sure our data structures have enough space, so we won't
+	 * run out later at an inconvenient time.
+	 */
+	result = array_preallocate(sleepers, numthreads+1);
+	if (result) {
+		goto fail;
+	}
+	result = array_preallocate(zombies, numthreads+1);
+	if (result) {
+		goto fail;
+	}
+
+	/* Do the same for the scheduler. */
+	result = scheduler_preallocate(numthreads+1);
+	if (result) {
+		goto fail;
+	}
+
+	/* Make the new thread runnable */
+	result = make_runnable(newguy);
+	if (result != 0) {
+		goto fail;
+	}
+
+	/*
+	 * Increment the thread counter. This must be done atomically
+	 * with the preallocate calls; otherwise the count can be
+	 * temporarily too low, which would obviate its reason for
+	 * existence.
+	 */
+	numthreads++;
+
+	/* Done with stuff that needs to be atomic */
+	splx(s);
+
+	/*
+	 * Return new thread structure if it's wanted.  Note that
+	 * using the thread structure from the parent thread should be
+	 * done only with caution, because in general the child thread
+	 * might exit at any time.
+	 */
+	if (ret != NULL) {
+		*ret = newguy;
+	}
+
+	return 0;
+
+ fail:
+	splx(s);
+	if (newguy->t_cwd != NULL) {
+		VOP_DECREF(newguy->t_cwd);
+	}
+	kfree(newguy->t_stack);
+	kfree(newguy->t_name);
+	kfree(newguy);
+
+	return result;
+}
+
+/*
+ * High level, machine-independent context switch code.
+ */
+static
+void
+mi_switch(threadstate_t nextstate)
+{
+	struct thread *cur, *next;
+	int result;
+	
+	/* Interrupts should already be off. */
+	assert(curspl>0);
+
+	if (curthread != NULL && curthread->t_stack != NULL) {
+		/*
+		 * Check the magic number we put on the bottom end of
+		 * the stack in thread_fork. If these assertions go
+		 * off, it most likely means you overflowed your stack
+		 * at some point, which can cause all kinds of
+		 * mysterious other things to happen.
+		 */
+		assert(curthread->t_stack[0] == (char)0xae);
+		assert(curthread->t_stack[1] == (char)0x11);
+		assert(curthread->t_stack[2] == (char)0xda);
+		assert(curthread->t_stack[3] == (char)0x33);
+	}
+	
+	/* 
+	 * We set curthread to NULL while the scheduler is running, to
+	 * make sure we don't call it recursively (this could happen
+	 * otherwise, if we get a timer interrupt in the idle loop.)
+	 */
+	if (curthread == NULL) {
+		return;
+	}
+	cur = curthread;
+	curthread = NULL;
+
+	/*
+	 * Stash the current thread on whatever list it's supposed to go on.
+	 * Because we preallocate during thread_fork, this should not fail.
+	 */
+
+	if (nextstate==S_READY) {
+		result = make_runnable(cur);
+	}
+	else if (nextstate==S_SLEEP) {
+		/*
+		 * Because we preallocate sleepers[] during thread_fork,
+		 * this should never fail.
+		 */
+		result = array_add(sleepers, cur);
+	}
+	else {
+		assert(nextstate==S_ZOMB);
+		result = array_add(zombies, cur);
+	}
+	assert(result==0);
+
+	/*
+	 * Call the scheduler (must come *after* the array_adds)
+	 */
+
+	next = scheduler();
+
+	/* update curthread */
+	curthread = next;
+	
+	/* 
+	 * Call the machine-dependent code that actually does the
+	 * context switch.
+	 */
+	md_switch(&cur->t_pcb, &next->t_pcb);
+	
+	/*
+	 * If we switch to a new thread, we don't come here, so anything
+	 * done here must be in mi_threadstart() as well, or be skippable,
+	 * or not apply to new threads.
+	 *
+	 * exorcise is skippable; as_activate is done in mi_threadstart.
+	 */
+
+	exorcise();
+
+	if (curthread->t_vmspace) {
+		as_activate(curthread->t_vmspace);
+	}
+}
+
+/*
+ * Cause the current thread to exit.
+ *
+ * We clean up the parts of the thread structure we don't actually
+ * need to run right away. The rest has to wait until thread_destroy
+ * gets called from exorcise().
+ */
+void
+thread_exit(void)
+{
+	if (curthread->t_stack != NULL) {
+		/*
+		 * Check the magic number we put on the bottom end of
+		 * the stack in thread_fork. If these assertions go
+		 * off, it most likely means you overflowed your stack
+		 * at some point, which can cause all kinds of
+		 * mysterious other things to happen.
+		 */
+		assert(curthread->t_stack[0] == (char)0xae);
+		assert(curthread->t_stack[1] == (char)0x11);
+		assert(curthread->t_stack[2] == (char)0xda);
+		assert(curthread->t_stack[3] == (char)0x33);
+	}
+
+	splhigh();
+
+	if (curthread->t_vmspace) {
+		/*
+		 * Do this carefully to avoid race condition with
+		 * context switch code.
+		 */
+		struct addrspace *as = curthread->t_vmspace;
+		curthread->t_vmspace = NULL;
+		as_destroy(as);
+	}
+
+	if (curthread->t_cwd) {
+		VOP_DECREF(curthread->t_cwd);
+		curthread->t_cwd = NULL;
+	}
+
+	assert(numthreads>0);
+	numthreads--;
+	mi_switch(S_ZOMB);
+
+	panic("Thread came back from the dead!\n");
+}
+
+/*
+ * Yield the cpu to another process, but stay runnable.
+ */
+void
+thread_yield(void)
+{
+	int spl = splhigh();
+
+	/* Check sleepers just in case we get here after shutdown */
+	assert(sleepers != NULL);
+
+	mi_switch(S_READY);
+	splx(spl);
+}
+
+/*
+ * Yield the cpu to another process, and go to sleep, on "sleep
+ * address" ADDR. Subsequent calls to thread_wakeup with the same
+ * value of ADDR will make the thread runnable again. The address is
+ * not interpreted. Typically it's the address of a synchronization
+ * primitive or data structure.
+ *
+ * Note that (1) interrupts must be off (if they aren't, you can
+ * end up sleeping forever), and (2) you cannot sleep in an 
+ * interrupt handler.
+ */
+void
+thread_sleep(const void *addr)
+{
+	// may not sleep in an interrupt handler
+	assert(in_interrupt==0);
+	
+	curthread->t_sleepaddr = addr;
+	mi_switch(S_SLEEP);
+	curthread->t_sleepaddr = NULL;
+}
+
+/*
+ * Wake up one or more threads who are sleeping on "sleep address"
+ * ADDR.
+ */
+void
+thread_wakeup(const void *addr)
+{
+	int i, result;
+	
+	// meant to be called with interrupts off
+	assert(curspl>0);
+	
+	// This is inefficient. Feel free to improve it.
+	
+	for (i=0; i<array_getnum(sleepers); i++) {
+		struct thread *t = array_getguy(sleepers, i);
+		if (t->t_sleepaddr == addr) {
+			
+			// Remove from list
+			array_remove(sleepers, i);
+			
+			// must look at the same sleepers[i] again
+			i--;
+
+			/*
+			 * Because we preallocate during thread_fork,
+			 * this should never fail.
+			 */
+			result = make_runnable(t);
+			assert(result==0);
+		}
+	}
+}
+
+/*
+ * Return nonzero if there are any threads who are sleeping on "sleep address"
+ * ADDR. This is meant to be used only for diagnostic purposes.
+ */
+int
+thread_hassleepers(const void *addr)
+{
+	int i;
+	
+	// meant to be called with interrupts off
+	assert(curspl>0);
+	
+	for (i=0; i<array_getnum(sleepers); i++) {
+		struct thread *t = array_getguy(sleepers, i);
+		if (t->t_sleepaddr == addr) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/*
+ * New threads actually come through here on the way to the function
+ * they're supposed to start in. This is so when that function exits,
+ * thread_exit() can be called automatically.
+ */
+void
+mi_threadstart(void *data1, unsigned long data2, 
+	       void (*func)(void *, unsigned long))
+{
+	/* If we have an address space, activate it */
+	if (curthread->t_vmspace) {
+		as_activate(curthread->t_vmspace);
+	}
+
+	/* Enable interrupts */
+	spl0();
+
+#if OPT_SYNCHPROBS
+	/* Yield a random number of times to get a good mix of threads */
+	{
+		int i, n;
+		n = random()%161 + random()%161;
+		for (i=0; i<n; i++) {
+			thread_yield();
+		}
+	}
+#endif
+	
+	/* Call the function */
+	func(data1, data2);
+
+	/* Done. */
+	thread_exit();
+}
diff --git a/os161-1.10/kern/userprog/loadelf.c b/os161-1.10/kern/userprog/loadelf.c
new file mode 100644
index 0000000..9651c88
--- /dev/null
+++ b/os161-1.10/kern/userprog/loadelf.c
@@ -0,0 +1,239 @@
+/*
+ * Code to load an ELF-format executable into the current address space.
+ *
+ * Right now it just copies into userspace and hopes the addresses are
+ * mappable to real memory. This works with dumbvm; however, when you
+ * write a real VM system, you will need to either (1) add code that 
+ * makes the address range used for load valid, or (2) if you implement
+ * memory-mapped files, map each segment instead of copying it into RAM.
+ */
+
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <uio.h>
+#include <elf.h>
+#include <addrspace.h>
+#include <thread.h>
+#include <curthread.h>
+#include <vnode.h>
+
+/*
+ * Load a segment at virtual address VADDR. The segment in memory
+ * extends from VADDR up to (but not including) VADDR+MEMSIZE. The
+ * segment on disk is located at file offset OFFSET and has length
+ * FILESIZE.
+ *
+ * FILESIZE may be less than MEMSIZE; if so the remaining portion of
+ * the in-memory segment should be zero-filled.
+ *
+ * Note that uiomove will catch it if someone tries to load an
+ * executable whose load address is in kernel space. If you should
+ * change this code to not use uiomove, be sure to check for this case
+ * explicitly.
+ */
+static
+int
+load_segment(struct vnode *v, off_t offset, vaddr_t vaddr, 
+	     size_t memsize, size_t filesize,
+	     int is_executable)
+{
+	struct uio u;
+	int result;
+	size_t fillamt;
+
+	if (filesize > memsize) {
+		kprintf("ELF: warning: segment filesize > segment memsize\n");
+		filesize = memsize;
+	}
+
+	DEBUG(DB_EXEC, "ELF: Loading %lu bytes to 0x%lx\n", 
+	      (unsigned long) filesize, (unsigned long) vaddr);
+
+	u.uio_iovec.iov_ubase = (userptr_t)vaddr;
+	u.uio_iovec.iov_len = memsize;   // length of the memory space
+	u.uio_resid = filesize;          // amount to actually read
+	u.uio_offset = offset;
+	u.uio_segflg = is_executable ? UIO_USERISPACE : UIO_USERSPACE;
+	u.uio_rw = UIO_READ;
+	u.uio_space = curthread->t_vmspace;
+
+	result = VOP_READ(v, &u);
+	if (result) {
+		return result;
+	}
+
+	if (u.uio_resid != 0) {
+		/* short read; problem with executable? */
+		kprintf("ELF: short read on segment - file truncated?\n");
+		return ENOEXEC;
+	}
+
+	/* Fill the rest of the memory space (if any) with zeros */
+	fillamt = memsize - filesize;
+	if (fillamt > 0) {
+		DEBUG(DB_EXEC, "ELF: Zero-filling %lu more bytes\n", 
+		      (unsigned long) fillamt);
+		u.uio_resid += fillamt;
+		result = uiomovezeros(fillamt, &u);
+	}
+	
+	return result;
+}
+
+/*
+ * Load an ELF executable user program into the current address space.
+ *
+ * Returns the entry point (initial PC) for the program in ENTRYPOINT.
+ */
+int
+load_elf(struct vnode *v, vaddr_t *entrypoint)
+{
+	Elf_Ehdr eh;   /* Executable header */
+	Elf_Phdr ph;   /* "Program header" = segment header */
+	int result, i;
+	struct uio ku;
+
+	/*
+	 * Read the executable header from offset 0 in the file.
+	 */
+
+	mk_kuio(&ku, &eh, sizeof(eh), 0, UIO_READ);
+	result = VOP_READ(v, &ku);
+	if (result) {
+		return result;
+	}
+
+	if (ku.uio_resid != 0) {
+		/* short read; problem with executable? */
+		kprintf("ELF: short read on header - file truncated?\n");
+		return ENOEXEC;
+	}
+
+	/*
+	 * Check to make sure it's a 32-bit ELF-version-1 executable
+	 * for our processor type. If it's not, we can't run it.
+	 *
+	 * Ignore EI_OSABI and EI_ABIVERSION - properly, we should
+	 * define our own, but that would require tinkering with the
+	 * linker to have it emit our magic numbers instead of the
+	 * default ones. (If the linker even supports these fields,
+	 * which were not in the original elf spec.)
+	 */
+
+	if (eh.e_ident[EI_MAG0] != ELFMAG0 ||
+	    eh.e_ident[EI_MAG1] != ELFMAG1 ||
+	    eh.e_ident[EI_MAG2] != ELFMAG2 ||
+	    eh.e_ident[EI_MAG3] != ELFMAG3 ||
+	    eh.e_ident[EI_CLASS] != ELFCLASS32 ||
+	    eh.e_ident[EI_DATA] != ELFDATA2MSB ||
+	    eh.e_ident[EI_VERSION] != EV_CURRENT ||
+	    eh.e_version != EV_CURRENT ||
+	    eh.e_type!=ET_EXEC ||
+	    eh.e_machine!=EM_MACHINE) {
+		return ENOEXEC;
+	}
+
+	/*
+	 * Go through the list of segments and set up the address space.
+	 *
+	 * Ordinarily there will be one code segment, one read-only
+	 * data segment, and one data/bss segment, but there might
+	 * conceivably be more. You don't need to support such files
+	 * if it's unduly awkward to do so.
+	 *
+	 * Note that the expression eh.e_phoff + i*eh.e_phentsize is 
+	 * mandated by the ELF standard - we use sizeof(ph) to load,
+	 * because that's the structure we know, but the file on disk
+	 * might have a larger structure, so we must use e_phentsize
+	 * to find where the phdr starts.
+	 */
+
+	for (i=0; i<eh.e_phnum; i++) {
+		off_t offset = eh.e_phoff + i*eh.e_phentsize;
+		mk_kuio(&ku, &ph, sizeof(ph), offset, UIO_READ);
+
+		result = VOP_READ(v, &ku);
+		if (result) {
+			return result;
+		}
+
+		if (ku.uio_resid != 0) {
+			/* short read; problem with executable? */
+			kprintf("ELF: short read on phdr - file truncated?\n");
+			return ENOEXEC;
+		}
+
+		switch (ph.p_type) {
+		    case PT_NULL: /* skip */ continue;
+		    case PT_PHDR: /* skip */ continue;
+		    case PT_MIPS_REGINFO: /* skip */ continue;
+		    case PT_LOAD: break;
+		    default:
+			kprintf("loadelf: unknown segment type %d\n", 
+				ph.p_type);
+			return ENOEXEC;
+		}
+
+		result = as_define_region(curthread->t_vmspace,
+					  ph.p_vaddr, ph.p_memsz,
+					  ph.p_flags & PF_R,
+					  ph.p_flags & PF_W,
+					  ph.p_flags & PF_X);
+		if (result) {
+			return result;
+		}
+	}
+
+	result = as_prepare_load(curthread->t_vmspace);
+	if (result) {
+		return result;
+	}
+
+	/*
+	 * Now actually load each segment.
+	 */
+
+	for (i=0; i<eh.e_phnum; i++) {
+		off_t offset = eh.e_phoff + i*eh.e_phentsize;
+		mk_kuio(&ku, &ph, sizeof(ph), offset, UIO_READ);
+
+		result = VOP_READ(v, &ku);
+		if (result) {
+			return result;
+		}
+
+		if (ku.uio_resid != 0) {
+			/* short read; problem with executable? */
+			kprintf("ELF: short read on phdr - file truncated?\n");
+			return ENOEXEC;
+		}
+
+		switch (ph.p_type) {
+		    case PT_NULL: /* skip */ continue;
+		    case PT_PHDR: /* skip */ continue;
+		    case PT_MIPS_REGINFO: /* skip */ continue;
+		    case PT_LOAD: break;
+		    default:
+			kprintf("loadelf: unknown segment type %d\n", 
+				ph.p_type);
+			return ENOEXEC;
+		}
+
+		result = load_segment(v, ph.p_offset, ph.p_vaddr, 
+				      ph.p_memsz, ph.p_filesz,
+				      ph.p_flags & PF_X);
+		if (result) {
+			return result;
+		}
+	}
+
+	result = as_complete_load(curthread->t_vmspace);
+	if (result) {
+		return result;
+	}
+
+	*entrypoint = eh.e_entry;
+
+	return 0;
+}
diff --git a/os161-1.10/kern/userprog/runprogram.c b/os161-1.10/kern/userprog/runprogram.c
new file mode 100644
index 0000000..7473e27
--- /dev/null
+++ b/os161-1.10/kern/userprog/runprogram.c
@@ -0,0 +1,76 @@
+/*
+ * Sample/test code for running a user program.  You can use this for
+ * reference when implementing the execv() system call. Remember though
+ * that execv() needs to do more than this function does.
+ */
+
+#include <types.h>
+#include <kern/unistd.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <addrspace.h>
+#include <thread.h>
+#include <curthread.h>
+#include <vm.h>
+#include <vfs.h>
+#include <test.h>
+
+/*
+ * Load program "progname" and start running it in usermode.
+ * Does not return except on error.
+ *
+ * Calls vfs_open on progname and thus may destroy it.
+ */
+int
+runprogram(char *progname)
+{
+	struct vnode *v;
+	vaddr_t entrypoint, stackptr;
+	int result;
+
+	/* Open the file. */
+	result = vfs_open(progname, O_RDONLY, &v);
+	if (result) {
+		return result;
+	}
+
+	/* We should be a new thread. */
+	assert(curthread->t_vmspace == NULL);
+
+	/* Create a new address space. */
+	curthread->t_vmspace = as_create();
+	if (curthread->t_vmspace==NULL) {
+		vfs_close(v);
+		return ENOMEM;
+	}
+
+	/* Activate it. */
+	as_activate(curthread->t_vmspace);
+
+	/* Load the executable. */
+	result = load_elf(v, &entrypoint);
+	if (result) {
+		/* thread_exit destroys curthread->t_vmspace */
+		vfs_close(v);
+		return result;
+	}
+
+	/* Done with the file now. */
+	vfs_close(v);
+
+	/* Define the user stack in the address space */
+	result = as_define_stack(curthread->t_vmspace, &stackptr);
+	if (result) {
+		/* thread_exit destroys curthread->t_vmspace */
+		return result;
+	}
+
+	/* Warp to user mode. */
+	md_usermode(0 /*argc*/, NULL /*userspace addr of argv*/,
+		    stackptr, entrypoint);
+	
+	/* md_usermode does not return */
+	panic("md_usermode returned\n");
+	return EINVAL;
+}
+
diff --git a/os161-1.10/kern/userprog/uio.c b/os161-1.10/kern/userprog/uio.c
new file mode 100644
index 0000000..e1cf0e1
--- /dev/null
+++ b/os161-1.10/kern/userprog/uio.c
@@ -0,0 +1,123 @@
+#include <types.h>
+#include <lib.h>
+#include <uio.h>
+#include <thread.h>
+#include <curthread.h>
+
+/*
+ * See uio.h for a description.
+ */
+
+int
+uiomove(void *ptr, size_t n, struct uio *uio)
+{
+	struct iovec *iov;
+	size_t size;
+	int result;
+
+	if (uio->uio_rw != UIO_READ && uio->uio_rw != UIO_WRITE) {
+		panic("uiomove: Invalid uio_rw %d\n", (int) uio->uio_rw);
+	}
+	if (uio->uio_segflg==UIO_SYSSPACE) {
+		assert(uio->uio_space == NULL);
+	}
+	else {
+		assert(uio->uio_space == curthread->t_vmspace);
+	}
+
+	while (n > 0 && uio->uio_resid > 0) {
+		iov = &uio->uio_iovec;
+		size = iov->iov_len;
+
+		if (size > n) {
+			size = n;
+		}
+
+		if (size==0) {
+			/* 
+			 * This should only happen if you set uio_resid
+			 * incorrectly (to more than the total length of
+			 * buffers the uio points to). 
+			 */
+			panic("uiomove: size reached 0\n");
+		}
+
+		switch (uio->uio_segflg) {
+		    case UIO_SYSSPACE:
+			    result = 0;
+			    if (uio->uio_rw == UIO_READ) {
+				    memmove(iov->iov_kbase, ptr, size);
+			    }
+			    else {
+				    memmove(ptr, iov->iov_kbase, size);
+			    }
+			    iov->iov_kbase = ((char *)iov->iov_kbase+size);
+			    break;
+		    case UIO_USERSPACE:
+		    case UIO_USERISPACE:
+			    if (uio->uio_rw == UIO_READ) {
+				    result = copyout(ptr, iov->iov_ubase,size);
+			    }
+			    else {
+				    result = copyin(iov->iov_ubase, ptr, size);
+			    }
+			    if (result) {
+				    return result;
+			    }
+			    iov->iov_ubase += size;
+			    break;
+		    default:
+			    panic("uiomove: Invalid uio_segflg %d\n",
+				  (int)uio->uio_segflg);
+		}
+
+		iov->iov_len -= size;
+		uio->uio_resid -= size;
+		uio->uio_offset += size;
+		ptr = ((char *)ptr + size);
+		n -= size;
+	}
+
+	return 0;
+}
+
+int
+uiomovezeros(size_t n, struct uio *uio)
+{
+	/* static, so initialized as zero */
+	static char zeros[16];
+	size_t amt;
+	int result;
+
+	/* This only makes sense when reading */
+	assert(uio->uio_rw == UIO_READ);
+
+	while (n>0) {
+		amt = sizeof(zeros);
+		if (amt > n) {
+			amt = n;
+		}
+		result = uiomove(zeros, amt, uio);
+		if (result) {
+			return result;
+		}
+		n -= amt;
+	}
+
+	return 0;
+}
+
+/*
+ * Convenience function to cons up a uio for kernel I/O.
+ */
+void
+mk_kuio(struct uio *uio, void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+{
+	uio->uio_iovec.iov_kbase = kbuf;
+	uio->uio_iovec.iov_len = len;
+	uio->uio_offset = pos;
+	uio->uio_resid = len;
+	uio->uio_segflg = UIO_SYSSPACE;
+	uio->uio_rw = rw;
+	uio->uio_space = NULL;
+}
diff --git a/os161-1.10/kern/vm/addrspace.c b/os161-1.10/kern/vm/addrspace.c
new file mode 100644
index 0000000..1cbadd9
--- /dev/null
+++ b/os161-1.10/kern/vm/addrspace.c
@@ -0,0 +1,131 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <addrspace.h>
+#include <vm.h>
+
+/*
+ * Note! If OPT_DUMBVM is set, as is the case until you start the VM
+ * assignment, this file is not compiled or linked or in any way
+ * used. The cheesy hack versions in dumbvm.c are used instead.
+ */
+
+struct addrspace *
+as_create(void)
+{
+	struct addrspace *as = kmalloc(sizeof(struct addrspace));
+	if (as==NULL) {
+		return NULL;
+	}
+
+	/*
+	 * Initialize as needed.
+	 */
+
+	return as;
+}
+
+int
+as_copy(struct addrspace *old, struct addrspace **ret)
+{
+	struct addrspace *newas;
+
+	newas = as_create();
+	if (newas==NULL) {
+		return ENOMEM;
+	}
+
+	/*
+	 * Write this.
+	 */
+
+	(void)old;
+	
+	*ret = newas;
+	return 0;
+}
+
+void
+as_destroy(struct addrspace *as)
+{
+	/*
+	 * Clean up as needed.
+	 */
+	
+	kfree(as);
+}
+
+void
+as_activate(struct addrspace *as)
+{
+	/*
+	 * Write this.
+	 */
+
+	(void)as;  // suppress warning until code gets written
+}
+
+/*
+ * Set up a segment at virtual address VADDR of size MEMSIZE. The
+ * segment in memory extends from VADDR up to (but not including)
+ * VADDR+MEMSIZE.
+ *
+ * The READABLE, WRITEABLE, and EXECUTABLE flags are set if read,
+ * write, or execute permission should be set on the segment. At the
+ * moment, these are ignored. When you write the VM system, you may
+ * want to implement them.
+ */
+int
+as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+		 int readable, int writeable, int executable)
+{
+	/*
+	 * Write this.
+	 */
+
+	(void)as;
+	(void)vaddr;
+	(void)sz;
+	(void)readable;
+	(void)writeable;
+	(void)executable;
+	return EUNIMP;
+}
+
+int
+as_prepare_load(struct addrspace *as)
+{
+	/*
+	 * Write this.
+	 */
+
+	(void)as;
+	return 0;
+}
+
+int
+as_complete_load(struct addrspace *as)
+{
+	/*
+	 * Write this.
+	 */
+
+	(void)as;
+	return 0;
+}
+
+int
+as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+{
+	/*
+	 * Write this.
+	 */
+
+	(void)as;
+
+	/* Initial user-level stack pointer */
+	*stackptr = USERSTACK;
+	
+	return 0;
+}
+
diff --git a/os161-1.10/lib/Makefile b/os161-1.10/lib/Makefile
new file mode 100644
index 0000000..9898999
--- /dev/null
+++ b/os161-1.10/lib/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for src/lib (sources for libraries installed in /lib)
+#
+# Note that all includes are found in src/include - the "includes"
+# make rule for installing .h files does not come here.
+#
+
+include ../defs.mk
+
+all tags depend clean install:
+	(cd crt0 && $(MAKE) $@)
+	(cd libc && $(MAKE) $@)
+	(cd hostcompat && $(MAKE) $@)
+
+clean: cleanhere
+cleanhere:
+	rm -f *~
+
+.PHONY: all depend tags clean cleanhere install
diff --git a/os161-1.10/lib/crt0/Makefile b/os161-1.10/lib/crt0/Makefile
new file mode 100644
index 0000000..bd0492c
--- /dev/null
+++ b/os161-1.10/lib/crt0/Makefile
@@ -0,0 +1,28 @@
+#
+# Makefile for crt0.o
+#
+
+include ../../defs.mk
+
+all: crt0.o
+
+# Assemble the crt0 for the current platform. Depend on defs.mk in case
+# the platform gets changed.
+crt0.o: $(PLATFORM)-crt0.S ../../defs.mk
+	$(CC) $(TREE_CFLAGS) $(CFLAGS) -c $(PLATFORM)-crt0.S -o crt0.o
+
+# Remove extraneous files.
+clean:
+	rm -f *.o *~
+
+# tags/depend don't need to do anything.
+tags depend:;
+
+#
+# [ -d $(OSTREE)/lib ] succeeds if $(OSTREE)/lib is a directory.
+# (See test(1).) Thus, if $(OSTREE)/lib doesn't exist, it will be
+# created.
+#
+install:
+	[ -d $(OSTREE)/lib ] || mkdir $(OSTREE)/lib
+	cp crt0.o $(OSTREE)/lib
diff --git a/os161-1.10/lib/crt0/mips-crt0.S b/os161-1.10/lib/crt0/mips-crt0.S
new file mode 100644
index 0000000..8f54211
--- /dev/null
+++ b/os161-1.10/lib/crt0/mips-crt0.S
@@ -0,0 +1,80 @@
+/*
+ * crt0.o for MIPS r2000/r3000.
+ *
+ * crt stands for "C runtime".
+ *
+ * Basically, this is the startup code that gets invoked before main(),
+ * and regains control when main returns.
+ *
+ * All we really do is save a copy of argv for use by the err* and warn*
+ * functions, and call exit when main returns.
+ */
+
+#include <machine/asmdefs.h>
+#include <kern/callno.h>
+
+	.set noreorder	/* so we can use delay slots explicitly */
+
+	.text
+	.globl __start
+	.type __start,@function
+	.ent __start
+__start:
+	/* Load the "global pointer" register */
+	la gp, _gp
+
+   	/*
+	 * We expect that the kernel passes argc in a0 and argv in a1.
+	 * We do not expect the kernel to set up a complete stack frame,
+	 * however.
+	 *
+	 * The MIPS ABI decrees that every caller will leave 16 bytes of
+	 * space in the bottom of its stack frame for writing back the
+	 * values of a0-a3, even when calling functions that take fewer
+	 * than four arguments. It also requires the stack to be aligned
+	 * to an 8-byte boundary. (This is because of 64-bit MIPS, which
+	 * we're not dealing with... but we'll conform to the standard.)
+	 */
+	li t0, 0xfffffff8		/* mask for stack alignment */
+	and sp, sp, t0			/* align the stack */
+	addiu sp, sp, -16		/* create our frame */
+
+	sw a1, __argv	/* save second arg (argv) in __argv for use later */
+
+	jal main	/* call main */
+	nop		/* delay slot */
+
+	/*
+	 * Now, we have the return value of main in v0.
+	 *
+	 * Move it to s0 (which is callee-save) so we still have
+	 * it in case exit() returns.
+	 *
+	 * Also move it to a0 so it's the argument to exit.
+	 */
+	move s0, v0	/* save return value */
+	jal exit	/* call exit() */
+	move a0, s0   	/* Set argument (in delay slot) */
+
+	/*
+	 * If we got here, something is broken in exit().
+	 * Try using _exit().
+	 */
+	jal _exit	/* Try _exit() */
+	move a0, s0	/* Set argument (in delay slot) */
+
+	/*
+	 * If *that* doesn't work, try doing an _exit syscall by hand.
+	 */
+1:
+	move a0, s0
+	li v0, SYS__exit
+	syscall
+
+	/*
+	 * ...and if we still can't exit, there's not much we can do
+	 * but keep trying.
+	 */
+	j 1b		/* loop back */
+	nop		/* delay slot */
+	.end __start
diff --git a/os161-1.10/lib/hostcompat/.cvsignore b/os161-1.10/lib/hostcompat/.cvsignore
new file mode 100644
index 0000000..0445101
--- /dev/null
+++ b/os161-1.10/lib/hostcompat/.cvsignore
@@ -0,0 +1,2 @@
+*.ho
+*.ha
diff --git a/os161-1.10/lib/hostcompat/Makefile b/os161-1.10/lib/hostcompat/Makefile
new file mode 100644
index 0000000..bbadce0
--- /dev/null
+++ b/os161-1.10/lib/hostcompat/Makefile
@@ -0,0 +1,122 @@
+#
+# Makefile for hostcompat library
+#
+# defs.mk contains two special settings for us.
+#
+#   COMPAT_CFLAGS  contains our configuration cflags.
+#   COMPAT_TARGETS are additional targets to run at install time.
+#
+# COMPAT_CFLAGS may include any of the following:
+#
+#   -DNEED_ERR     Compile err, errx, etc.
+#
+# COMPAT_TARGETS may include any of the following:
+#
+#   install-errh   Install an <err.h>
+#
+
+LIB=hostcompat
+SRCS=err.c time.c hostcompat.c
+
+include ../../defs.mk
+
+########################################
+
+# .ho is a host object; .ha is a host archive (library)
+.SUFFIXES: .ho .ha
+
+#
+# The list of .ho files is the list of .c and .S files with those suffixes
+# changed to .ho.
+#
+OBJS1=$(SRCS:.c=.ho)
+OBJS=$(OBJS1:.S=.ho)
+
+#
+# Default rule - create library.
+#
+all: lib$(LIB).ha
+
+#
+# Delete everything extraneous.
+#
+clean:
+	rm -f *.ho *.ha *~
+
+#
+# Use the -MM argument to gcc to get it to output dependency information.
+# Note that in this case we use -MM and not -M, because the #include <...>
+# files we're using aren't our own but belong to the host OS.
+#
+# The sed command replaces the value of $(OSTREE) - which is some pathname -
+# with the string $(OSTREE). This makes the dependh.mk file independent
+# of what $(OSTREE) actually is.
+#
+depend:
+	$(HOST_CC) $(HOST_CFLAGS) $(COMPAT_CFLAGS) -MM $(SRCS) |\
+	  awk '{x=$$0~"^ ";for(i=1;i<=NF;i++){printf "%d %s\n",x,$$i;x=1; }}'|\
+	  sed '/1 \\/d' | awk '{ printf "%s%s", $$1?" \\\n ":"\n", $$2 }' |\
+	  sed 's/\.o/\.ho/' |\
+	  sed 's|$(OSTREE)|$$(OSTREE)|;$$p;$$x' > dependh.mk
+include dependh.mk
+
+#
+# [ -d $(OSTREE)/hostlib ] succeeds if $(OSTREE)/hostlib is a directory.
+# (See test(1).) Thus, if $(OSTREE)/hostlib doesn't exist, it will be
+# created.
+#
+# On certain systems with broken native linkers (most notably OS X) you 
+# have to rerun ranlib again after installing a library, or you can't
+# link with it.
+#
+install:
+	[ -d $(OSTREE)/hostlib ] || mkdir $(OSTREE)/hostlib
+	cp lib$(LIB).ha $(OSTREE)/hostlib/lib$(LIB).a
+	$(HOST_RANLIB) $(OSTREE)/hostlib/lib$(LIB).a
+
+includes:
+	[ -d $(OSTREE)/hostinclude ] || mkdir $(OSTREE)/hostinclude
+	rm -f $(OSTREE)/hostinclude/kern
+	ln -s ../include/kern $(OSTREE)/hostinclude/kern
+	cp hostcompat.h $(OSTREE)/hostinclude
+
+#
+# No tags here.
+#
+tags:;
+
+#
+# Create the library.
+#
+lib$(LIB).ha: $(OBJS)
+	$(HOST_AR) -cruv lib$(LIB).ha $(OBJS)
+	$(HOST_RANLIB) lib$(LIB).ha
+
+#
+# Generic make rule for compiling .c files into .ho files.
+#
+.c.ho:
+	$(HOST_CC) $(HOST_CFLAGS) $(COMPAT_CFLAGS) -c $< -o $@
+
+#
+# Generic make rule for compiling .S files (assembler to be fed through cpp)
+# into .o files. gcc knows how to do this, so just use it.
+#
+.S.o:
+	$(HOST_CC) $(HOST_CFLAGS) $(COMPAT_CFLAGS) -c $< -o $@
+
+#
+# This tells make that all, clean, depend, install, and tags are not files
+# so it (hopefully) won't become confused if files by those names appear.
+#
+.PHONY: all clean depend install tags
+
+########################################
+
+includes: $(COMPAT_TARGETS)
+
+install-errh:
+	[ -d $(OSTREE)/hostinclude ] || mkdir $(OSTREE)/hostinclude
+	cp host-err.h $(OSTREE)/hostinclude/err.h
+
+.PHONY: install-errh
diff --git a/os161-1.10/lib/hostcompat/dependh.mk b/os161-1.10/lib/hostcompat/dependh.mk
new file mode 100644
index 0000000..58d01a5
--- /dev/null
+++ b/os161-1.10/lib/hostcompat/dependh.mk
@@ -0,0 +1,10 @@
+
+err.ho: \
+ err.c \
+ host-err.h
+time.ho: \
+ time.c \
+ hostcompat.h
+hostcompat.ho: \
+ hostcompat.c \
+ hostcompat.h
diff --git a/os161-1.10/lib/hostcompat/err.c b/os161-1.10/lib/hostcompat/err.c
new file mode 100644
index 0000000..9764fda
--- /dev/null
+++ b/os161-1.10/lib/hostcompat/err.c
@@ -0,0 +1,138 @@
+/*
+ * 4.4BSD error printing functions.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+
+#include "host-err.h"
+
+#ifdef NEED_ERR
+
+/*
+ * This is initialized by hostcompat_init
+ */
+extern const char *hostcompat_progname;
+
+/*
+ * Common routine for all the *err* and *warn* functions.
+ */
+static
+void
+hostcompat_printerr(int use_errno, const char *fmt, va_list ap)
+{
+	const char *errmsg;
+
+	/*
+	 * Get the error message for the current errno.
+	 * Do this early, before doing anything that might change the
+	 * value in errno.
+	 */
+	errmsg = strerror(errno);
+
+	/*
+	 * Look up the program name.
+	 * Strictly speaking we should pull off the rightmost
+	 * path component of argv[0] and use that as the program
+	 * name (this is how BSD err* prints) but it doesn't make
+	 * much difference.
+	 */
+	if (hostcompat_progname != NULL) {
+		fprintf(stderr, "%s: ", hostcompat_progname);
+	}
+	else {
+		fprintf(stderr, "libhostcompat: hostcompat_init not called\n");
+		fprintf(stderr, "libhostcompat-program: ");
+	}
+
+	/* process the printf format and args */
+	vfprintf(stderr, fmt, ap);
+
+	if (use_errno) {
+		/* if we're using errno, print the error string from above. */
+		fprintf(stderr, ": %s\n", errmsg);
+	}
+	else {
+		/* otherwise, just a newline. */
+		fprintf(stderr, "\n");
+	}
+}
+
+/*
+ * The va_list versions of the warn/err functions.
+ */
+
+/* warn/vwarn: use errno, don't exit */
+void
+vwarn(const char *fmt, va_list ap)
+{
+	hostcompat_printerr(1, fmt, ap);
+}
+
+/* warnx/vwarnx: don't use errno, don't exit */
+void
+vwarnx(const char *fmt, va_list ap)
+{
+	hostcompat_printerr(0, fmt, ap);
+}
+
+/* err/verr: use errno, then exit */
+void
+verr(int exitcode, const char *fmt, va_list ap)
+{
+	hostcompat_printerr(1, fmt, ap);
+	exit(exitcode);
+}
+
+/* errx/verrx: don't use errno, but do then exit */
+void
+verrx(int exitcode, const char *fmt, va_list ap)
+{
+	hostcompat_printerr(0, fmt, ap);
+	exit(exitcode);
+}
+
+/*
+ * The non-va_list versions of the warn/err functions.
+ * Just hand off to the va_list versions.
+ */
+
+void
+warn(const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	vwarn(fmt, ap);
+	va_end(ap);
+}
+
+void
+warnx(const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	vwarnx(fmt, ap);
+	va_end(ap);
+}
+
+void
+err(int exitcode, const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	verr(exitcode, fmt, ap);
+	va_end(ap);
+}
+
+void
+errx(int exitcode, const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	verrx(exitcode, fmt, ap);
+	va_end(ap);
+}
+
+#endif /* NEED_ERR */
diff --git a/os161-1.10/lib/hostcompat/host-err.h b/os161-1.10/lib/hostcompat/host-err.h
new file mode 100644
index 0000000..d0ae72d
--- /dev/null
+++ b/os161-1.10/lib/hostcompat/host-err.h
@@ -0,0 +1,29 @@
+
+#ifndef HOSTCOMPAT_ERR_H
+#define HOSTCOMPAT_ERR_H
+
+#include <stdarg.h>
+
+/*
+ * 4.4BSD error-printing functions.
+ *
+ * These print the program name and the supplied message, and
+ * (non-*x versions only) the string for the error currently
+ * stored in "errno", and a newline. The err* versions then
+ * exit with the supplied exitcode.
+ *
+ * The v* versions are to the non-v* versions like vprintf is to
+ * printf.
+ */
+
+void warn(const char *fmt, ...);
+void warnx(const char *fmt, ...);
+void err(int exitcode, const char *fmt, ...);
+void errx(int exitcode, const char *fmt, ...);
+
+void vwarn(const char *fmt, va_list);
+void vwarnx(const char *fmt, va_list);
+void verr(int exitcode, const char *fmt, va_list);
+void verrx(int exitcode, const char *fmt, va_list);
+
+#endif /* HOSTCOMPAT_ERR_H */
diff --git a/os161-1.10/lib/hostcompat/hostcompat.c b/os161-1.10/lib/hostcompat/hostcompat.c
new file mode 100644
index 0000000..0c44733
--- /dev/null
+++ b/os161-1.10/lib/hostcompat/hostcompat.c
@@ -0,0 +1,209 @@
+#include <unistd.h>
+#include <termios.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "hostcompat.h"
+
+/*
+ * The program name.
+ * This is used in err.c.
+ */
+const char *hostcompat_progname = NULL;
+
+/*
+ * Unix tty state, for when we're running and to put it back the way it was,
+ * respectively.
+ */
+static struct termios hostcompat_runtios;
+static struct termios hostcompat_savetios;
+
+/*
+ * Put the tty state back the way it was.
+ */
+static
+void
+hostcompat_ttyreset(void)
+{
+	tcsetattr(STDIN_FILENO, TCSADRAIN, &hostcompat_savetios);
+}
+
+/*
+ * Set the tty state back to the way we want it for running.
+ */
+static
+void
+hostcompat_ttyresume(void)
+{
+	tcsetattr(STDIN_FILENO, TCSADRAIN, &hostcompat_runtios);
+}
+
+/*
+ * Set up the tty state stuff.
+ */
+static
+int
+hostcompat_ttysetup(void)
+{
+	struct termios tios;
+
+	/* Get the current tty state. */
+	if (tcgetattr(STDIN_FILENO, &tios) < 0) {
+		/* stdin is not a tty */
+		return -1;
+	}
+
+	hostcompat_savetios = tios;
+
+	/* Turn off canonical ("cooked") input. */
+	tios.c_lflag &= ~ICANON;
+
+	/*
+	 * With canonical input off, this says how many characters must be
+	 * typed before read() will return.
+	 */
+	tios.c_cc[VMIN] = 1;
+
+	/* This can be used to set up read timeouts, but we don't need that. */
+	tios.c_cc[VTIME] = 0;
+
+	/* Turn off echoing of keypresses. */
+	tios.c_lflag &= ~(ECHO|ECHONL|ECHOCTL);
+
+	/* Do not support XON/XOFF flow control. */
+	tios.c_iflag &= ~(IXON|IXOFF);
+
+	/* On input, we want no CR/LF translation. */
+	tios.c_iflag &= ~(INLCR|IGNCR|ICRNL);
+
+	/* However, on output we want LF ('\n') mapped to CRLF. */
+#ifdef OCRNL	/* missing on OS X */
+	tios.c_oflag &= ~(OCRNL);
+#endif
+	tios.c_oflag |= OPOST|ONLCR;
+
+	/* Enable keyboard signals (^C, ^Z, etc.) because they're useful. */
+	tios.c_lflag |= ISIG;
+
+	/* Set the new tty state. */
+	hostcompat_runtios = tios;
+	tcsetattr(STDIN_FILENO, TCSADRAIN, &tios);
+
+	return 0;
+}
+
+/*
+ * Signal handler for all the fatal signals (SIGSEGV, SIGTERM, etc.)
+ */
+static
+void
+hostcompat_die(int sig)
+{
+	/* Set the tty back to the way we found it */
+	hostcompat_ttyreset();
+
+	/* Make sure the default action will occur when we get another signal*/
+	signal(sig, SIG_DFL);
+
+	/* Post the signal back to ourselves, to cause the right exit status.*/
+	kill(getpid(), sig);
+
+	/* Just in case. */
+	_exit(255);
+}
+
+/*
+ * Signal handler for the stop signals (SIGTSTP, SIGTTIN, etc.)
+ */
+static
+void
+hostcompat_stop(int sig)
+{
+	/* Set the tty back to the way we found it */
+	hostcompat_ttyreset();
+
+	/* Make sure the default action will occur when we get another signal*/
+	signal(sig, SIG_DFL);
+
+	/* Post the signal back to ourselves. */
+	kill(getpid(), sig);
+}
+
+/*
+ * Signal handler for SIGCONT.
+ */
+static
+void
+hostcompat_cont(int sig)
+{
+	(void)sig;
+
+	/* Set the tty to the way we want it for running. */
+	hostcompat_ttyresume();
+
+	/*
+	 * Reload the signal handlers for stop/continue signals, in case
+	 * they were set up with one-shot signals.
+	 */
+	signal(SIGTTIN, hostcompat_stop);
+	signal(SIGTTOU, hostcompat_stop);
+	signal(SIGTSTP, hostcompat_stop);
+	signal(SIGCONT, hostcompat_cont);
+}
+
+/*
+ * Initialize the hostcompat library.
+ */
+void
+hostcompat_init(int argc, char *argv[])
+{
+	/* Set the program name */
+	if (argc > 0 && argv[0] != NULL) {
+		hostcompat_progname = argv[0];
+	}
+
+	/* Set the tty modes */
+	if (hostcompat_ttysetup() < 0) {
+		return;
+	}
+
+	/* When exit() is called, clean up */
+	atexit(hostcompat_ttyreset);
+
+	/* stdout/stderr should be unbuffered */
+	setvbuf(stdout, NULL, _IONBF, 0);
+	setvbuf(stderr, NULL, _IONBF, 0);
+
+	/* Catch all the fatal signals, so we can clean up */
+	signal(SIGHUP, hostcompat_die);
+	signal(SIGINT, hostcompat_die);
+	signal(SIGQUIT, hostcompat_die);
+	signal(SIGILL, hostcompat_die);
+	signal(SIGTRAP, hostcompat_die);
+	signal(SIGABRT, hostcompat_die);
+#ifdef SIGEMT
+	signal(SIGEMT, hostcompat_die);
+#endif
+	signal(SIGFPE, hostcompat_die);
+	signal(SIGBUS, hostcompat_die);
+	signal(SIGSEGV, hostcompat_die);
+	signal(SIGSYS, hostcompat_die);
+	signal(SIGPIPE, hostcompat_die);
+	signal(SIGALRM, hostcompat_die);
+	signal(SIGTERM, hostcompat_die);
+	signal(SIGXCPU, hostcompat_die);
+	signal(SIGXFSZ, hostcompat_die);
+	signal(SIGVTALRM, hostcompat_die);
+	signal(SIGPROF, hostcompat_die);
+	signal(SIGUSR1, hostcompat_die);
+	signal(SIGUSR2, hostcompat_die);
+
+	/* Catch the stop signals, so we can adjust the tty */
+	signal(SIGTTIN, hostcompat_stop);
+	signal(SIGTTOU, hostcompat_stop);
+	signal(SIGTSTP, hostcompat_stop);
+
+	/* Catch the continue signal, so we can adjust the tty */
+	signal(SIGCONT, hostcompat_cont);
+}
diff --git a/os161-1.10/lib/hostcompat/hostcompat.h b/os161-1.10/lib/hostcompat/hostcompat.h
new file mode 100644
index 0000000..ca6cf51
--- /dev/null
+++ b/os161-1.10/lib/hostcompat/hostcompat.h
@@ -0,0 +1,6 @@
+
+#include <sys/types.h>
+
+void hostcompat_init(int argc, char **argv);
+
+time_t __time(time_t *secs, unsigned long *nsecs);
diff --git a/os161-1.10/lib/hostcompat/time.c b/os161-1.10/lib/hostcompat/time.c
new file mode 100644
index 0000000..301ebc1
--- /dev/null
+++ b/os161-1.10/lib/hostcompat/time.c
@@ -0,0 +1,25 @@
+/*
+ * OS/161 __time implementation in terms of Unix gettimeofday().
+ */
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <string.h>	/* sometimes required for NULL */
+
+#include "hostcompat.h"
+
+time_t
+__time(time_t *secs, unsigned long *nsecs)
+{
+	struct timeval tv;
+	if (gettimeofday(&tv, NULL) < 0) {
+		return -1;
+	}
+	if (secs) {
+		*secs = tv.tv_sec;
+	}
+	if (nsecs) {
+		*nsecs = tv.tv_usec * 1000;
+	}
+	return tv.tv_sec;
+}
diff --git a/os161-1.10/lib/libc/.cvsignore b/os161-1.10/lib/libc/.cvsignore
new file mode 100644
index 0000000..c866eb9
--- /dev/null
+++ b/os161-1.10/lib/libc/.cvsignore
@@ -0,0 +1 @@
+syscalls.S
diff --git a/os161-1.10/lib/libc/Makefile b/os161-1.10/lib/libc/Makefile
new file mode 100644
index 0000000..7d67d3c
--- /dev/null
+++ b/os161-1.10/lib/libc/Makefile
@@ -0,0 +1,59 @@
+#
+# Makefile for OS/161 C standard library
+#
+
+include ../../defs.mk
+
+# Printf implementation
+SRCS+=__printf.c snprintf.c printf.c
+
+# C files for standard string operations
+SRCS+=atoi.c bzero.c \
+      memcmp.c memcpy.c memmove.c memset.c \
+      strcat.c strchr.c strcmp.c strcpy.c strlen.c strrchr.c \
+      strtok.c strtok_r.c
+
+# Standard I/O functions
+SRCS+=__assert.c __puts.c err.c getchar.c putchar.c puts.c 
+
+# Other stuff
+SRCS+=abort.c errno.c exit.c getcwd.c random.c strerror.c system.c time.c
+
+# Machine-dependent setjmp implementation
+SRCS+=$(PLATFORM)-setjmp.S
+
+# System call entry points
+SRCS+=syscalls.S
+
+# Name of the library.
+LIB=c
+
+# Let the templates do most of the work.
+include ../../mk/lib.mk
+
+#
+# Generate syscall entry points from system call list.
+#
+
+CALLNO_H=../../kern/include/kern/callno.h
+
+syscalls.S: $(CALLNO_H) callno-parse.sh syscalls-$(PLATFORM).S ../../defs.mk
+	-rm -f syscalls.S syscalls.S.tmp
+	echo '/* Automatically generated from syscalls-$(PLATFORM).S */' \
+		> syscalls.S.tmp
+	cat syscalls-$(PLATFORM).S >> syscalls.S.tmp
+	./callno-parse.sh < $(CALLNO_H) >> syscalls.S.tmp
+	mv -f syscalls.S.tmp syscalls.S
+
+clean: cleanhere
+cleanhere:
+	rm -f syscalls.S
+
+depend: predepend
+predepend:
+	$(MAKE) syscalls.S
+
+# Have the machine-dependent stuff depend on defs.mk in case the platform
+# is changed.
+
+syscalls.o $(PLATFORM)-setjmp.o: ../../defs.mk
diff --git a/os161-1.10/lib/libc/__assert.c b/os161-1.10/lib/libc/__assert.c
new file mode 100644
index 0000000..b20935f
--- /dev/null
+++ b/os161-1.10/lib/libc/__assert.c
@@ -0,0 +1,21 @@
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+/*
+ * Function that gets called when an assert() fails.
+ * Print a message to stderr and bail out of the program.
+ */
+
+void
+__bad_assert(const char *file, int line, const char *expr)
+{
+	char buf[256];
+	snprintf(buf, sizeof(buf), "Assertion failed: %s (%s line %d)\n",
+		 expr, file, line);
+
+	write(STDERR_FILENO, buf, strlen(buf));
+	abort();
+}
diff --git a/os161-1.10/lib/libc/__printf.c b/os161-1.10/lib/libc/__printf.c
new file mode 100644
index 0000000..9282264
--- /dev/null
+++ b/os161-1.10/lib/libc/__printf.c
@@ -0,0 +1,553 @@
+/*
+ * Guts of printf.
+ *
+ * This file is used in both libc and the kernel and needs to work in both
+ * contexts. This makes a few things a bit awkward.
+ *
+ * This is a slightly simplified version of the real-life printf used in
+ * the VINO kernel.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+
+#include <sys/types.h>
+#include <assert.h>
+#include <string.h>
+#include <stdio.h>
+#endif
+
+#include <stdarg.h>
+
+
+/* 
+ * Do we want to support "long long" types with %lld and %qd?
+ *
+ * For now, this is turned off. Using 64-bit types with gcc causes gcc
+ * to emit calls to functions like __moddi3 and __divdi3. These need
+ * to be provided at link time, and while that's not by any means
+ * impossible, it adds a bunch of ugly complications, so we don't do
+ * it.
+ */
+#undef USE_LONGLONG  /* not for now */
+
+/*
+ * Define a type that holds the longest signed integer we intend to support.
+ */
+#ifdef USE_LONGLONG
+#define INTTYPE  long long
+#else
+#define INTTYPE  long
+#endif
+
+
+/* 
+ * Space for a long long in base 8, plus a NUL, plus one 
+ * character extra for slop. 
+ *
+ * CHAR_BIT is the number of bits in a char; thus sizeof(long long)*CHAR_BIT
+ * is the number of bits in a long long. Each octal digit prints 3 bits.
+ * Values printed in larger bases will be shorter strings.
+ */
+#define NUMBER_BUF_SIZE ((sizeof(INTTYPE) * CHAR_BIT) / 3 + 2)
+
+/*
+ * Structure holding the state for printf.
+ */
+typedef struct {
+	/* Callback for sending printed string data */
+	void (*sendfunc)(void *clientdata, const char *str, size_t len);
+	void *clientdata;
+
+	/* The varargs argument pointer */
+	va_list ap;
+
+	/* Total count of characters printed */
+	int charcount;
+
+	/* Flag that's true if we are currently looking in a %-format */
+	int in_pct;
+
+	/* Size of the integer argument to retrieve */
+	enum { 
+		INTSZ, 
+		LONGSZ, 
+#ifdef USE_LONGLONG
+		LLONGSZ,
+#endif
+	} size;
+
+	/* The value of the integer argument retrieved */
+	unsigned INTTYPE num;
+
+	/* Sign of the integer argument (0 = positive; -1 = negative) */
+	int sign;
+
+	/* Field width (number of spaces) */
+	int spacing;
+
+	/* Flag: align to left in field instead of right */
+	int rightspc;
+
+	/* Character to pad to field size with (space or 0) */
+	int fillchar;
+
+	/* Number base to print the integer argument in (8, 10, 16) */
+	int base;
+
+	/* Flag: if set, print 0x before hex and 0 before octal numbers */
+	int baseprefix;
+
+	/* Flag: alternative output format selected with %#... */
+	int altformat;
+} PF;
+
+/*
+ * Send some text onward to the output.
+ *
+ * We count the total length we send out so we can return it from __vprintf,
+ * since that's what most printf-like functions want to return.
+ */
+static
+void
+__pf_print(PF *pf, const char *txt, size_t len)
+{
+	pf->sendfunc(pf->clientdata, txt, len);
+	pf->charcount += len;
+}
+
+/*
+ * Reset the state for the next %-field.
+ */
+static
+void
+__pf_endfield(PF *pf)
+{
+	pf->in_pct = 0;
+	pf->size = INTSZ;
+	pf->num = 0;
+	pf->sign = 0;
+	pf->spacing = 0;
+	pf->rightspc = 0;
+	pf->fillchar = ' ';
+	pf->base = 0;
+	pf->baseprefix = 0;
+	pf->altformat = 0;
+}
+
+/*
+ * Process modifier chars (between the % and the type specifier)
+ *    #           use "alternate display format"
+ *    -           left align in field instead of right align
+ *    l           value is long (ll = long long)
+ *    q           value is quad (long long)
+ *    0-9         field width
+ *    leading 0   pad with zeros instead of spaces
+ */
+static
+void
+__pf_modifier(PF *pf, int ch)
+{
+	switch (ch) {
+	case '#':
+		pf->altformat = 1;
+		break;
+	case '-':
+		pf->rightspc = 1;
+		break;
+	case 'l': 
+		if (pf->size==LONGSZ) {
+#ifdef USE_LONGLONG
+			pf->size = LLONGSZ;
+#endif
+		}
+		else {
+			pf->size = LONGSZ;
+		}
+		break;
+	case 'q': 
+#ifdef USE_LONGLONG
+		pf->size = LLONGSZ;
+#else
+		pf->size = LONGSZ;
+#endif
+		break;
+	case '0': 
+		if (pf->spacing>0) {
+			/*
+			 * Already seen some digits; this is part of the
+			 * field size.
+			 */
+			pf->spacing = pf->spacing*10;
+		}
+		else {
+			/*
+			 * Leading zero; set the padding character to 0.
+			 */
+			pf->fillchar = '0';
+		}
+		break;
+	default:
+		/*
+		 * Invalid characters should be filtered out by a
+		 * higher-level function, so if this assert goes off
+		 * it's our fault.
+		 */
+		assert(ch>'0' && ch<='9');
+
+		/*
+		 * Got a digit; accumulate the field size.
+		 */
+		pf->spacing = pf->spacing*10 + (ch-'0');
+		break;
+	}
+}
+
+/*
+ * Retrieve a numeric argument from the argument list and store it
+ * in pf->num, according to the size recorded in pf->size and using
+ * the numeric type specified by ch.
+ */
+static
+void
+__pf_getnum(PF *pf, int ch)
+{
+	if (ch=='p') {
+		/* 
+		 * Pointer.
+		 *
+		 * u_intptr_t is a C99 standard type that's an unsigned
+		 * integer the same size as a pointer.
+		 */
+		pf->num = (uintptr_t) va_arg(pf->ap, void *);
+	}
+	else if (ch=='d') {
+		/* signed integer */
+		INTTYPE signednum=0;
+		switch (pf->size) {
+		case INTSZ:
+			/* %d */
+			signednum = va_arg(pf->ap, int);
+			break;
+		case LONGSZ:
+			/* %ld */
+			signednum = va_arg(pf->ap, long);
+			break;
+#ifdef USE_LONGLONG
+		case LLONGSZ:
+			/* %lld or %qd */
+			signednum = va_arg(pf->ap, long long);
+			break;
+#endif
+		}
+
+		/*
+		 * Check for negative numbers.
+		 */
+		if (signednum < 0) {
+			pf->sign = -1;
+			pf->num = -signednum;
+		}
+		else {
+			pf->num = signednum;
+		}
+	}
+	else {
+		/* unsigned integer */
+		switch (pf->size) {
+		case INTSZ:
+			/* %u (or %o, %x) */
+			pf->num = va_arg(pf->ap, unsigned int);
+			break;
+		case LONGSZ:
+			/* %lu (or %lo, %lx) */
+			pf->num = va_arg(pf->ap, unsigned long);
+			break;
+#ifdef USE_LONGLONG
+		case LLONGSZ:
+			/* %llu, %qu, %llo, %qo, %llx, %qx */
+			pf->num = va_arg(pf->ap, unsigned long long);
+			break;
+#endif
+		}
+	}
+}
+
+/*
+ * Set the printing base based on the numeric type specified in ch.
+ *     %o     octal
+ *     %d,%u  decimal
+ *     %x     hex
+ *     %p     pointer (print as hex)
+ *
+ * If the "alternate format" was requested, or always for pointers,
+ * note to print the C prefix for the type.
+ */
+static
+void
+__pf_setbase(PF *pf, int ch)
+{
+	switch (ch) {
+	case 'd':
+	case 'u':
+		pf->base = 10;
+		break;
+	case 'x':
+	case 'p':
+		pf->base = 16;
+		break;
+	case 'o':
+		pf->base = 8;
+		break;
+	}
+	if (pf->altformat || ch=='p') {
+		pf->baseprefix = 1;
+	}
+}
+
+/*
+ * Function to print "spc" instances of the fill character.
+ */
+static
+void
+__pf_fill(PF *pf, int spc)
+{
+	char f = pf->fillchar;
+	int i;
+	for (i=0; i<spc; i++) {
+		__pf_print(pf, &f, 1);
+	}
+}
+
+/*
+ * General printing function. Prints the string "stuff".
+ * The two prefixes (in practice one is a type prefix, such as "0x",
+ * and the other is the sign) get printed *after* space padding but
+ * *before* zero padding, if padding is on the left.
+ */
+static
+void
+__pf_printstuff(PF *pf,
+		const char *prefix, const char *prefix2,
+		const char *stuff)
+{
+	/* Total length to print. */
+	int len = strlen(prefix)+strlen(prefix2)+strlen(stuff);
+
+	/* Get field width and compute amount of padding in "spc". */
+	int spc = pf->spacing;
+	if (spc > len) {
+		spc -= len;
+	}
+	else {
+		spc = 0;
+	}
+
+	/* If padding on left and the fill char is not 0, pad first. */
+	if (spc > 0 && pf->rightspc==0 && pf->fillchar!='0') {
+		__pf_fill(pf, spc);
+	}
+
+	/* Print the prefixes. */
+	__pf_print(pf, prefix, strlen(prefix));
+	__pf_print(pf, prefix2, strlen(prefix2));
+
+	/* If padding on left and the fill char *is* 0, pad here. */
+	if (spc > 0 && pf->rightspc==0 && pf->fillchar=='0') {
+		__pf_fill(pf, spc);
+	}
+
+	/* Print the actual string. */
+	__pf_print(pf, stuff, strlen(stuff));
+
+	/* If padding on the right, pad afterwards. */
+	if (spc > 0 && pf->rightspc!=0) {
+		__pf_fill(pf, spc);
+	}
+}
+
+/*
+ * Function to convert a number to ascii and then print it.
+ *
+ * Works from right to left in a buffer of NUMBER_BUF_SIZE bytes.
+ * NUMBER_BUF_SIZE is set so that the longest number string we can 
+ * generate (a long long printed in octal) will fit. See above.
+ */
+static
+void
+__pf_printnum(PF *pf)
+{
+	/* Digits to print with. */
+	const char *const digits = "0123456789abcdef";
+
+	char buf[NUMBER_BUF_SIZE];   /* Accumulation buffer for string. */
+	char *x;                     /* Current pointer into buf. */ 
+	unsigned INTTYPE xnum;       /* Current value to print. */
+	const char *bprefix;         /* Base prefix (0, 0x, or nothing) */
+	const char *sprefix;         /* Sign prefix (- or nothing) */
+
+	/* Start in the last slot of the buffer. */
+	x = buf+sizeof(buf)-1;
+
+	/* Insert null terminator. */
+	*x-- = 0;
+
+	/* Initialize value. */
+	xnum = pf->num;
+
+	/* 
+	 * Convert a single digit.
+	 * Do this loop at least once - that way 0 prints as 0 and not "". 
+	 */
+	do {
+		/* 
+		 * Get the digit character for the least significant
+		 * part of xnum.
+		 */
+		*x = digits[xnum % pf->base];
+		
+		/*
+		 * Back up the pointer to point to the next space to the left.
+		 */
+		x--;
+
+		/*
+		 * Drop the value of the digit we just printed from xnum.
+		 */
+		xnum = xnum / pf->base;
+
+		/*
+		 * If xnum hits 0 there's no more number left.
+		 */
+	} while (xnum > 0);
+
+	/*
+	 * x points to the *next* slot in the buffer to use.
+	 * However, we're done printing the number. So it's pointing
+	 * one slot *before* the start of the actual number text.
+	 * So advance it by one so it actually points at the number.
+	 */
+	x++;
+
+	/*
+	 * If a base prefix was requested, select it.
+	 */
+	if (pf->baseprefix && pf->base==16) {
+		bprefix = "0x";
+	}
+	else if (pf->baseprefix && pf->base==8) {
+		bprefix = "0";
+	}
+	else {
+		bprefix = "";
+	}
+
+	/*
+	 * Choose the sign prefix.
+	 */
+	sprefix = pf->sign ? "-" : "";
+
+	/*
+	 * Now actually print the string we just generated.
+	 */
+	__pf_printstuff(pf, sprefix, bprefix, x);
+}
+
+/*
+ * Process a single character out of the format string.
+ */
+static
+void
+__pf_send(PF *pf, int ch)
+{
+	/* Cannot get NULs here. */
+	assert(ch!=0);
+
+	if (pf->in_pct==0 && ch!='%') {
+		/*
+		 * Not currently in a format, and not a %. Just send
+		 * the character on through.
+		 */
+		char c = ch;
+		__pf_print(pf, &c, 1);
+	}
+	else if (pf->in_pct==0) {
+		/*
+		 * Not in a format, but got a %. Start a format.
+		 */
+		pf->in_pct = 1;
+	}
+	else if (strchr("#-ql0123456789", ch)) {
+		/*
+		 * These are the modifier characters we recognize.
+		 * (These are the characters between the % and the type.)
+		 */
+		__pf_modifier(pf, ch);
+	}
+	else if (strchr("doupx", ch)) {
+		/*
+		 * Integer types.
+		 * Fetch the number, set the base, print it, then
+		 * reset for the next format.
+		 */
+		__pf_getnum(pf, ch);
+		__pf_setbase(pf, ch);
+		__pf_printnum(pf);
+		__pf_endfield(pf);
+	}
+	else if (ch=='s') {
+		/*
+		 * Print a string.
+		 */
+		const char *str = va_arg(pf->ap, const char *);
+		if (str==NULL) {
+			str = "(null)";
+		}
+		__pf_printstuff(pf, "", "", str);
+		__pf_endfield(pf);
+	}
+	else {
+		/* 
+		 * %%, %c, or illegal character. 
+		 * Illegal characters are printed like %%.
+		 * for example, %5k prints "    k".
+		 */
+		char x[2];
+		if (ch=='c') {
+			x[0] = va_arg(pf->ap, int);
+		}
+		else {
+			x[0] = ch;
+		}
+		x[1] = 0;
+		__pf_printstuff(pf, "", "", x);
+		__pf_endfield(pf);
+	}
+}
+
+/*
+ * Do a whole printf session.
+ * Create and initialize a printf state object,
+ * then send it each character from the format string.
+ */
+int
+__vprintf(void (*func)(void *clientdata, const char *str, size_t len), 
+	  void *clientdata, const char *format, va_list ap)
+{
+	PF pf;
+	int i;
+
+	pf.sendfunc = func;
+	pf.clientdata = clientdata;
+	pf.ap = ap;
+	pf.charcount = 0;
+	__pf_endfield(&pf);
+
+	for (i=0; format[i]; i++) {
+		__pf_send(&pf, format[i]);
+	}
+
+	return pf.charcount;
+}
diff --git a/os161-1.10/lib/libc/__puts.c b/os161-1.10/lib/libc/__puts.c
new file mode 100644
index 0000000..deac08e
--- /dev/null
+++ b/os161-1.10/lib/libc/__puts.c
@@ -0,0 +1,20 @@
+#include <stdio.h>
+
+/*
+ * Nonstandard (hence the __) version of puts that doesn't append
+ * a newline.
+ *
+ * Returns the length of the string printed.
+ */
+
+int
+__puts(const char *str)
+{
+	int count=0;
+	while (*str) {
+		putchar(*str);
+		str++;
+		count++;
+	}
+	return count;
+}
diff --git a/os161-1.10/lib/libc/abort.c b/os161-1.10/lib/libc/abort.c
new file mode 100644
index 0000000..b1c3bd2
--- /dev/null
+++ b/os161-1.10/lib/libc/abort.c
@@ -0,0 +1,16 @@
+#include <stdlib.h>
+#include <unistd.h>
+
+/*
+ * C standard function: panic exit from a user program.
+ *
+ * On most Unix systems, this sends the current process a fatal signal.
+ * We can't do that (no signals in OS/161) so we just exit with a
+ * nonzero exit code, skipping any libc cleanup.
+ */
+
+void
+abort(void)
+{
+	_exit(255);
+}
diff --git a/os161-1.10/lib/libc/atoi.c b/os161-1.10/lib/libc/atoi.c
new file mode 100644
index 0000000..139092b
--- /dev/null
+++ b/os161-1.10/lib/libc/atoi.c
@@ -0,0 +1,69 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <stdlib.h>
+#include <string.h>
+#endif
+
+/*
+ * Standard C function: parse a string that represents a decimal integer.
+ * Leading whitespace is allowed. Trailing gunk is allowed too. Doesn't
+ * really report syntax errors in any useful way.
+ */
+
+int
+atoi(const char *s)
+{
+	static const char digits[] = "0123456789";  /* legal digits in order */
+	unsigned val=0;		/* value we're accumulating */
+	int neg=0;		/* set to true if we see a minus sign */
+
+	/* skip whitespace */
+	while (*s==' ' || *s=='\t') {
+		s++;
+	}
+
+	/* check for negative number */
+	if (*s=='-') {
+		neg=1;
+		s++;
+	}
+
+	/* process each digit */
+	while (*s) {
+		const char *where;
+		unsigned digit;
+		
+		/* look for the digit in the list of digits */
+		where = strchr(digits, *s);
+		if (where==NULL) {
+			/* not found; not a digit, so stop */
+			break;
+		}
+
+		/* get the index into the digit list, which is the value */
+		digit = (where - digits);
+
+		/* could (should?) check for overflow here */
+
+		/* shift the number over and add in the new digit */
+		val = val*10 + digit;
+
+		/* look at the next character */
+		s++;
+	}
+	
+	/* handle negative numbers */
+	if (neg) {
+		return -val;
+	}
+	
+	/* done */
+	return val;
+}
diff --git a/os161-1.10/lib/libc/bzero.c b/os161-1.10/lib/libc/bzero.c
new file mode 100644
index 0000000..2d62199
--- /dev/null
+++ b/os161-1.10/lib/libc/bzero.c
@@ -0,0 +1,46 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * Standard (well, semi-standard) C string function - zero a block of
+ * memory.
+ */
+
+void
+bzero(void *vblock, size_t len)
+{
+	char *block = vblock;
+	size_t i;
+
+	/*
+	 * For performance, optimize the common case where the pointer
+	 * and the length are word-aligned, and write word-at-a-time
+	 * instead of byte-at-a-time. Otherwise, write bytes.
+	 *
+	 * The alignment logic here should be portable. We rely on the
+	 * compiler to be reasonably intelligent about optimizing the
+	 * divides and moduli out. Fortunately, it is.
+	 */
+
+	if ((uintptr_t)block % sizeof(long) == 0 &&
+	    len % sizeof(long) == 0) {
+		long *lb = (long *)block;
+		for (i=0; i<len/sizeof(long); i++) {
+			lb[i] = 0;
+		}
+	}
+	else {
+		for (i=0; i<len; i++) {
+			block[i] = 0;
+		}
+	}
+}
diff --git a/os161-1.10/lib/libc/callno-parse.sh b/os161-1.10/lib/libc/callno-parse.sh
new file mode 100755
index 0000000..7879430
--- /dev/null
+++ b/os161-1.10/lib/libc/callno-parse.sh
@@ -0,0 +1,26 @@
+#!/bin/sh
+#
+# callno-parse.sh
+# Usage: ./callno-parse.sh < callno.h
+#
+# Parses the kernel's callno.h into the body of syscalls.S
+#
+
+# tabs to spaces, just in case
+tr '\t' ' ' |\
+awk '
+    # Do not read the parts of the file that are not between the markers.
+    /^\/\*CALLBEGIN\*\// { look=1; }
+    /^\/\*CALLEND\*\// { look=0; }
+
+    # And, do not read lines that do not match the approximate right pattern.
+    look && /^#define SYS_/ && NF==3 {
+	sub("^SYS_", "", $2);
+	# print the name of the call and the number.
+	print $2, $3;
+    }
+' | awk '{
+	# output something simple that will work in syscalls.S.
+	printf "SYSCALL(%s, %s)\n", $1, $2;
+}'
+    
diff --git a/os161-1.10/lib/libc/depend.mk b/os161-1.10/lib/libc/depend.mk
new file mode 100644
index 0000000..e8aad83
--- /dev/null
+++ b/os161-1.10/lib/libc/depend.mk
@@ -0,0 +1,246 @@
+
+__printf.o: \
+ __printf.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/assert.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h
+snprintf.o: \
+ snprintf.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h
+printf.o: \
+ printf.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h
+atoi.o: \
+ atoi.c \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/string.h
+bzero.o: \
+ bzero.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+memcmp.o: \
+ memcmp.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+memcpy.o: \
+ memcpy.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+memmove.o: \
+ memmove.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+memset.o: \
+ memset.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strcat.o: \
+ strcat.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strchr.o: \
+ strchr.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strcmp.o: \
+ strcmp.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strcpy.o: \
+ strcpy.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strlen.o: \
+ strlen.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strrchr.o: \
+ strrchr.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strtok.o: \
+ strtok.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strtok_r.o: \
+ strtok_r.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+__assert.o: \
+ __assert.c \
+ $(OSTREE)/include/assert.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/string.h
+__puts.o: \
+ __puts.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h
+err.o: \
+ err.c \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/stdlib.h
+getchar.o: \
+ getchar.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
+putchar.o: \
+ putchar.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
+puts.o: \
+ puts.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h
+abort.o: \
+ abort.c \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
+errno.o: \
+ errno.c \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h
+exit.o: \
+ exit.c \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
+getcwd.o: \
+ getcwd.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h
+random.o: \
+ random.c \
+ $(OSTREE)/include/assert.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h
+strerror.o: \
+ strerror.c \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/errmsg.h
+system.o: \
+ system.c \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/string.h
+time.o: \
+ time.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
+mips-setjmp.o: \
+ mips-setjmp.S \
+ $(OSTREE)/include/machine/asmdefs.h
+syscalls.o: \
+ syscalls.S \
+ $(OSTREE)/include/kern/callno.h \
+ $(OSTREE)/include/machine/asmdefs.h
diff --git a/os161-1.10/lib/libc/err.c b/os161-1.10/lib/libc/err.c
new file mode 100644
index 0000000..80eb90e
--- /dev/null
+++ b/os161-1.10/lib/libc/err.c
@@ -0,0 +1,161 @@
+#include <err.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+
+/*
+ * 4.4BSD error printing functions.
+ */
+
+/*
+ * This is initialized by crt0, though it actually lives in errno.c
+ */
+extern char **__argv;
+
+/*
+ * Routine to print error message text to stderr.
+ */
+static
+void
+__senderr(void *junk, const char *data, size_t len)
+{
+	(void)junk;  /* not needed or used */
+
+	write(STDERR_FILENO, data, len);
+}
+
+/*
+ * Shortcut to call __senderr on a null-terminated string.
+ * (__senderr is set up to be called by __vprintf.)
+ */
+static
+void
+__senderrstr(const char *str)
+{
+	__senderr(NULL, str, strlen(str));
+}
+
+/*
+ * Common routine for all the *err* and *warn* functions.
+ */
+static
+void
+__printerr(int use_errno, const char *fmt, va_list ap)
+{
+	const char *errmsg;
+	const char *prog;
+
+	/*
+	 * Get the error message for the current errno.
+	 * Do this early, before doing anything that might change the
+	 * value in errno.
+	 */
+	errmsg = strerror(errno);
+
+	/*
+	 * Look up the program name.
+	 * Strictly speaking we should pull off the rightmost
+	 * path component of argv[0] and use that as the program
+	 * name (this is how BSD err* prints) but it doesn't make
+	 * much difference.
+	 */
+	if (__argv!=NULL && __argv[0]!=NULL) {
+		prog = __argv[0];
+	}
+	else {
+		prog = "(program name unknown)";
+	}
+
+	/* print the program name */
+	__senderrstr(prog);
+	__senderrstr(": ");
+
+	/* process the printf format and args */
+	__vprintf(__senderr, NULL, fmt, ap);
+
+	/* if we're using errno, print the error string from above. */
+	if (use_errno) {
+		__senderrstr(": ");
+		__senderrstr(errmsg);
+	}
+
+	/* and always add a newline. */
+	__senderrstr("\n");
+}
+
+/*
+ * The va_list versions of the warn/err functions.
+ */
+
+/* warn/vwarn: use errno, don't exit */
+void
+vwarn(const char *fmt, va_list ap)
+{
+	__printerr(1, fmt, ap);
+}
+
+/* warnx/vwarnx: don't use errno, don't exit */
+void
+vwarnx(const char *fmt, va_list ap)
+{
+	__printerr(0, fmt, ap);
+}
+
+/* err/verr: use errno, then exit */
+void
+verr(int exitcode, const char *fmt, va_list ap)
+{
+	__printerr(1, fmt, ap);
+	exit(exitcode);
+}
+
+/* errx/verrx: don't use errno, but do then exit */
+void
+verrx(int exitcode, const char *fmt, va_list ap)
+{
+	__printerr(0, fmt, ap);
+	exit(exitcode);
+}
+
+/*
+ * The non-va_list versions of the warn/err functions.
+ * Just hand off to the va_list versions.
+ */
+
+void
+warn(const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	vwarn(fmt, ap);
+	va_end(ap);
+}
+
+void
+warnx(const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	vwarnx(fmt, ap);
+	va_end(ap);
+}
+
+void
+err(int exitcode, const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	verr(exitcode, fmt, ap);
+	va_end(ap);
+}
+
+void
+errx(int exitcode, const char *fmt, ...)
+{
+	va_list ap;
+	va_start(ap, fmt);
+	verrx(exitcode, fmt, ap);
+	va_end(ap);
+}
diff --git a/os161-1.10/lib/libc/errno.c b/os161-1.10/lib/libc/errno.c
new file mode 100644
index 0000000..5abfa85
--- /dev/null
+++ b/os161-1.10/lib/libc/errno.c
@@ -0,0 +1,14 @@
+#include <errno.h>
+
+/*
+ * Source file that declares the space for the global variable errno.
+ *
+ * We also declare the space for __argv, which is used by the err*
+ * functions. But since it is set by crt0, it is always referenced in
+ * every program; putting it here prevents gratuitously linking all
+ * the err* and warn* functions (and thus printf) into every program.
+ */
+
+char **__argv;
+
+int errno;
diff --git a/os161-1.10/lib/libc/exit.c b/os161-1.10/lib/libc/exit.c
new file mode 100644
index 0000000..18e88df
--- /dev/null
+++ b/os161-1.10/lib/libc/exit.c
@@ -0,0 +1,49 @@
+#include <stdlib.h>
+#include <unistd.h>
+
+/*
+ * C standard function: exit process.
+ */
+
+void
+exit(int code)
+{
+	/*
+	 * In a more complicated libc, this would call functions registered
+	 * with atexit() before calling the syscall to actually exit.
+	 */
+
+	_exit(code);
+}
+
+/*
+ * The mips gcc we were using in 2001, and probably other versions as
+ * well, knows more than is healthy: it knows without being told that
+ * exit and _exit don't return.
+ * 
+ * This causes it to make foolish optimizations that cause broken
+ * things to happen if _exit *does* return, as it does in the base
+ * system (because it's unimplemented) and may also do if someone has
+ * a bug.
+ *
+ * The way it works is that if _exit returns, execution falls into
+ * whatever happens to come after exit(), with the registers set up in
+ * such a way that when *that* function returns it actually ends up
+ * calling itself again. This causes weird things to happen.
+ *
+ * This function has no purpose except to trap that
+ * circumstance. Looping doing nothing is not entirely optimal, but
+ * there's not much we *can* do, and it's better than jumping around
+ * wildly as would happen if this function were removed.
+ *
+ * If you change this to loop calling _exit(), gcc "helpfully"
+ * optimizes the loop away and the behavior reverts to that previously
+ * described.
+ */
+
+void
+__exit_hack(void)
+{
+	volatile int blah = 1;
+	while (blah) {}
+}
diff --git a/os161-1.10/lib/libc/getchar.c b/os161-1.10/lib/libc/getchar.c
new file mode 100644
index 0000000..7268299
--- /dev/null
+++ b/os161-1.10/lib/libc/getchar.c
@@ -0,0 +1,27 @@
+#include <stdio.h>
+#include <unistd.h>
+
+/*
+ * C standard I/O function - read character from stdin
+ * and return it or the symbolic constant EOF (-1).
+ */
+
+int
+getchar(void)
+{
+	char ch;
+	int len;
+
+	len = read(STDIN_FILENO, &ch, 1);
+	if (len<=0) {
+		/* end of file or error */
+		return EOF;
+	}
+
+	/*
+	 * Cast through unsigned char, to prevent sign extension. This
+	 * sends back values on the range 0-255, rather than -128 to 127,
+	 * so EOF can be distinguished from legal input.
+	 */
+	return (int)(unsigned char)ch;
+}
diff --git a/os161-1.10/lib/libc/getcwd.c b/os161-1.10/lib/libc/getcwd.c
new file mode 100644
index 0000000..399be7c
--- /dev/null
+++ b/os161-1.10/lib/libc/getcwd.c
@@ -0,0 +1,27 @@
+#include <unistd.h>
+#include <errno.h>
+
+/*
+ * POSIX C function: retrieve current working directory.
+ * Uses the system call __getcwd(), which does essentially
+ * all the work.
+ */
+
+char *
+getcwd(char *buf, size_t buflen)
+{
+	int r;
+
+	if (buflen < 1) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	r = __getcwd(buf, buflen-1);
+	if (r < 0) {
+		return NULL;
+	}
+
+	buf[r] = 0;
+	return buf;
+}
diff --git a/os161-1.10/lib/libc/memcmp.c b/os161-1.10/lib/libc/memcmp.c
new file mode 100644
index 0000000..5d1e0c3
--- /dev/null
+++ b/os161-1.10/lib/libc/memcmp.c
@@ -0,0 +1,21 @@
+#include <string.h>
+
+/*
+ * Standard C string function: compare two memory blocks and return
+ * their sort order.
+ */
+
+int
+memcmp(const void *av, const void *bv, size_t len)
+{
+	const unsigned char *a = av;
+	const unsigned char *b = bv;
+	size_t i;
+
+	for (i=0; i<len; i++) {
+		if (a[i] != b[i]) {
+			return (int)(a[i] - b[i]);
+		}
+	}
+	return 0;
+}
diff --git a/os161-1.10/lib/libc/memcpy.c b/os161-1.10/lib/libc/memcpy.c
new file mode 100644
index 0000000..8d2e4ad
--- /dev/null
+++ b/os161-1.10/lib/libc/memcpy.c
@@ -0,0 +1,56 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * C standard function - copy a block of memory.
+ */
+
+void *
+memcpy(void *dst, const void *src, size_t len)
+{
+	size_t i;
+
+	/*
+	 * memcpy does not support overlapping buffers, so always do it
+	 * forwards. (Don't change this without adjusting memmove.)
+	 *
+	 * For speedy copying, optimize the common case where both pointers
+	 * and the length are word-aligned, and copy word-at-a-time instead
+	 * of byte-at-a-time. Otherwise, copy by bytes.
+	 *
+	 * The alignment logic below should be portable. We rely on
+	 * the compiler to be reasonably intelligent about optimizing
+	 * the divides and modulos out. Fortunately, it is.
+	 */
+
+	if ((uintptr_t)dst % sizeof(long) == 0 &&
+	    (uintptr_t)src % sizeof(long) == 0 &&
+	    len % sizeof(long) == 0) {
+
+		long *d = dst;
+		const long *s = src;
+
+		for (i=0; i<len/sizeof(long); i++) {
+			d[i] = s[i];
+		}
+	}
+	else {
+		char *d = dst;
+		const char *s = src;
+
+		for (i=0; i<len; i++) {
+			d[i] = s[i];
+		}
+	}
+
+	return dst;
+}
diff --git a/os161-1.10/lib/libc/memmove.c b/os161-1.10/lib/libc/memmove.c
new file mode 100644
index 0000000..3fc261a
--- /dev/null
+++ b/os161-1.10/lib/libc/memmove.c
@@ -0,0 +1,87 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * C standard function - copy a block of memory, handling overlapping
+ * regions correctly.
+ */
+
+void *
+memmove(void *dst, const void *src, size_t len)
+{
+	size_t i;
+
+	/*
+	 * If the buffers don't overlap, it doesn't matter what direction
+	 * we copy in. If they do, it does, so just assume they always do.
+	 * We don't concern ourselves with the possibility that the region
+	 * to copy might roll over across the top of memory, because it's
+	 * not going to happen.
+	 *
+	 * If the destination is above the source, we have to copy
+	 * back to front to avoid overwriting the data we want to
+	 * copy.
+	 *
+	 *      dest:       dddddddd
+	 *      src:    ssssssss   ^
+	 *              |   ^  |___|
+         *              |___|
+	 *
+	 * If the destination is below the source, we have to copy
+	 * front to back.
+	 *
+	 *      dest:   dddddddd
+	 *      src:    ^   ssssssss
+	 *              |___|  ^   |
+         *                     |___|
+	 */
+
+	if ((uintptr_t)dst < (uintptr_t)src) {
+		/*
+		 * As author/maintainer of libc, take advantage of the
+		 * fact that we know memcpy copies forwards.
+		 */
+		return memcpy(dst, src, len);
+	}
+
+	/*
+	 * Copy by words in the common case. Look in memcpy.c for more
+	 * information.
+	 */
+
+	if ((uintptr_t)dst % sizeof(long) == 0 &&
+	    (uintptr_t)src % sizeof(long) == 0 &&
+	    len % sizeof(long) == 0) {
+
+		long *d = dst;
+		const long *s = src;
+
+		/*
+		 * The reason we copy index i-1 and test i>0 is that
+		 * i is unsigned - so testing i>=0 doesn't work.
+		 */
+
+		for (i=len/sizeof(long); i>0; i--) {
+			d[i-1] = s[i-1];
+		}
+	}
+	else {
+		char *d = dst;
+		const char *s = src;
+
+		for (i=len; i>0; i--) {
+			d[i-1] = s[i-1];
+		}
+	}
+
+	return dst;
+}
diff --git a/os161-1.10/lib/libc/memset.c b/os161-1.10/lib/libc/memset.c
new file mode 100644
index 0000000..217b461
--- /dev/null
+++ b/os161-1.10/lib/libc/memset.c
@@ -0,0 +1,18 @@
+#include <string.h>
+
+/*
+ * C standard function - initialize a block of memory
+ */
+
+void *
+memset(void *ptr, int ch, size_t len)
+{
+	char *p = ptr;
+	size_t i;
+	
+	for (i=0; i<len; i++) {
+		p[i] = ch;
+	}
+
+	return ptr;
+}
diff --git a/os161-1.10/lib/libc/mips-setjmp.S b/os161-1.10/lib/libc/mips-setjmp.S
new file mode 100644
index 0000000..2c30e1d
--- /dev/null
+++ b/os161-1.10/lib/libc/mips-setjmp.S
@@ -0,0 +1,75 @@
+/*
+ * setjmp and longjmp for MIPS.
+ */
+
+#include <machine/asmdefs.h>
+
+   .text
+   .set noreorder
+
+   /*
+    * int setjmp(jmp_buf jb);
+    *
+    * Save the current state so we can return again from the call later
+    * if/when longjmp is called. (If the function that called setjmp
+    * returns before longjmp is called, the results are undefined. We
+    * only need to save registers, not the whole contents of the stack.)
+    */
+   
+   .globl setjmp
+   .type setjmp,@function
+   .ent setjmp
+setjmp:
+   /*
+    * jmp_buf is in a0. We need to save s0-s8, sp, and ra in it.
+    * Don't store more registers without adjusting machine/setjmp.h.
+    */
+
+   sw sp, 0(a0)		/* save registers */
+   sw ra, 4(a0)
+   sw s0, 8(a0)
+   sw s1, 12(a0)
+   sw s2, 16(a0)
+   sw s3, 20(a0)
+   sw s4, 24(a0)
+   sw s5, 28(a0)
+   sw s6, 32(a0)
+   sw s7, 36(a0)
+   sw s8, 40(a0)
+
+   j ra			/* done */
+   li v0, 0		/* return 0 (in delay slot) */
+   .end setjmp
+
+
+   /*
+    * void longjmp(jmp_buf jb, int code);
+    */
+   .globl longjmp
+   .type longjmp,@function
+   .ent longjmp
+longjmp:
+   /*
+    * jmp_buf is in a0. Return code is in a1.
+    * We need to restore s0-s8, sp, and ra from the jmp_buf.
+    * The return code is forced to 1 if 0 is passed in.
+    */
+
+   sltiu t0, a1, 1	/* set t0 to 1 if return code is 0... otherwise 0 */
+   addu a1, a1, t0	/* update the return code */
+
+   lw sp, 0(a0)		/* restore registers */
+   lw ra, 4(a0)
+   lw s0, 8(a0)
+   lw s1, 12(a0)
+   lw s2, 16(a0)
+   lw s3, 20(a0)
+   lw s4, 24(a0)
+   lw s5, 28(a0)
+   lw s6, 32(a0)
+   lw s7, 36(a0)
+   lw s8, 40(a0)
+
+   j ra			/* return, to where setjmp was called from */
+   move v0, a1		/* set return value */
+   .end longjmp
diff --git a/os161-1.10/lib/libc/printf.c b/os161-1.10/lib/libc/printf.c
new file mode 100644
index 0000000..950c948
--- /dev/null
+++ b/os161-1.10/lib/libc/printf.c
@@ -0,0 +1,41 @@
+#include <stdio.h>
+#include <stdarg.h>
+
+/*
+ * printf - C standard I/O function.
+ */
+
+
+/*
+ * Function passed to __vprintf to do the actual output.
+ */
+static
+void
+__printf_send(void *mydata, const char *data, size_t len)
+{
+	unsigned i;
+	(void)mydata;  /* not needed */
+
+	for (i=0; i<len; i++) {
+		putchar(data[i]);
+	}
+}
+
+/* printf: hand off to vprintf */
+int
+printf(const char *fmt, ...)
+{
+	int chars;
+	va_list ap;
+	va_start(ap, fmt);
+	chars = vprintf(fmt, ap);
+	va_end(ap);
+	return chars;
+}
+
+/* vprintf: call __vprintf to do the work. */
+int
+vprintf(const char *fmt, va_list ap)
+{
+	return __vprintf(__printf_send, NULL, fmt, ap);
+}
diff --git a/os161-1.10/lib/libc/putchar.c b/os161-1.10/lib/libc/putchar.c
new file mode 100644
index 0000000..0f5578c
--- /dev/null
+++ b/os161-1.10/lib/libc/putchar.c
@@ -0,0 +1,21 @@
+#include <stdio.h>
+#include <unistd.h>
+
+/*
+ * C standard function - print a single character.
+ *
+ * Properly, stdio is supposed to be buffered, but for present purposes
+ * writing that code is not really worthwhile.
+ */
+
+int
+putchar(int ch)
+{
+	char c = ch;
+	int len;
+	len = write(STDOUT_FILENO, &c, 1);
+	if (len<=0) {
+		return EOF;
+	}
+	return ch;
+}
diff --git a/os161-1.10/lib/libc/puts.c b/os161-1.10/lib/libc/puts.c
new file mode 100644
index 0000000..290e931
--- /dev/null
+++ b/os161-1.10/lib/libc/puts.c
@@ -0,0 +1,13 @@
+#include <stdio.h>
+
+/*
+ * C standard I/O function - print a string and a newline.
+ */
+
+int
+puts(const char *s)
+{
+	__puts(s);
+	putchar('\n');
+	return 0;
+}
diff --git a/os161-1.10/lib/libc/random.c b/os161-1.10/lib/libc/random.c
new file mode 100644
index 0000000..425d9c4
--- /dev/null
+++ b/os161-1.10/lib/libc/random.c
@@ -0,0 +1,453 @@
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * From:
+ *    NetBSD: random.c,v 1.19 2000/01/22 22:19:20 mycroft Exp
+ *
+ * Hacked gruesomely for OS/161.
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/*
+ * For a thread-safe libc, declare a lock for this file and change
+ * these to be nonempty.
+ */
+#define LOCKME()
+#define UNLOCKME()
+
+static void srandom_unlocked(unsigned long);
+static long random_unlocked(void);
+
+
+/*
+ * random.c:
+ *
+ * An improved random number generation package.  In addition to the standard
+ * rand()/srand() like interface, this package also has a special state info
+ * interface.  The initstate() routine is called with a seed, an array of
+ * bytes, and a count of how many bytes are being passed in; this array is
+ * then initialized to contain information for random number generation with
+ * that much state information.  Good sizes for the amount of state
+ * information are 32, 64, 128, and 256 bytes.  The state can be switched by
+ * calling the setstate() routine with the same array as was initiallized
+ * with initstate().  By default, the package runs with 128 bytes of state
+ * information and generates far better random numbers than a linear
+ * congruential generator.  If the amount of state information is less than
+ * 32 bytes, a simple linear congruential R.N.G. is used.
+ *
+ * Internally, the state information is treated as an array of longs; the
+ * zeroeth element of the array is the type of R.N.G. being used (small
+ * integer); the remainder of the array is the state information for the
+ * R.N.G.  Thus, 32 bytes of state information will give 7 longs worth of
+ * state information, which will allow a degree seven polynomial.  (Note:
+ * the zeroeth word of state information also has some other information
+ * stored in it -- see setstate() for details).
+ * 
+ * The random number generation technique is a linear feedback shift register
+ * approach, employing trinomials (since there are fewer terms to sum up that
+ * way).  In this approach, the least significant bit of all the numbers in
+ * the state table will act as a linear feedback shift register, and will
+ * have period 2^deg - 1 (where deg is the degree of the polynomial being
+ * used, assuming that the polynomial is irreducible and primitive).  The
+ * higher order bits will have longer periods, since their values are also
+ * influenced by pseudo-random carries out of the lower bits.  The total
+ * period of the generator is approximately deg*(2**deg - 1); thus doubling
+ * the amount of state information has a vast influence on the period of the
+ * generator.  Note: the deg*(2**deg - 1) is an approximation only good for
+ * large deg, when the period of the shift register is the dominant factor.
+ * With deg equal to seven, the period is actually much longer than the
+ * 7*(2**7 - 1) predicted by this formula.
+ *
+ * Modified 28 December 1994 by Jacob S. Rosenberg.
+ * The following changes have been made:
+ * All references to the type u_int have been changed to unsigned long.
+ * All references to type int have been changed to type long.  Other
+ * cleanups have been made as well.  A warning for both initstate and
+ * setstate has been inserted to the effect that on Sparc platforms
+ * the 'arg_state' variable must be forced to begin on word boundaries.
+ * This can be easily done by casting a long integer array to char *.
+ * The overall logic has been left STRICTLY alone.  This software was
+ * tested on both a VAX and Sun SpacsStation with exactly the same
+ * results.  The new version and the original give IDENTICAL results.
+ * The new version is somewhat faster than the original.  As the
+ * documentation says:  "By default, the package runs with 128 bytes of
+ * state information and generates far better random numbers than a linear
+ * congruential generator.  If the amount of state information is less than
+ * 32 bytes, a simple linear congruential R.N.G. is used."  For a buffer of
+ * 128 bytes, this new version runs about 19 percent faster and for a 16
+ * byte buffer it is about 5 percent faster.
+ */
+
+/*
+ * For each of the currently supported random number generators, we have a
+ * break value on the amount of state information (you need at least this
+ * many bytes of state info to support this random number generator), a degree
+ * for the polynomial (actually a trinomial) that the R.N.G. is based on, and
+ * the separation between the two lower order coefficients of the trinomial.
+ */
+#define	TYPE_0		0		/* linear congruential */
+#define	BREAK_0		8
+#define	DEG_0		0
+#define	SEP_0		0
+
+#define	TYPE_1		1		/* x**7 + x**3 + 1 */
+#define	BREAK_1		32
+#define	DEG_1		7
+#define	SEP_1		3
+
+#define	TYPE_2		2		/* x**15 + x + 1 */
+#define	BREAK_2		64
+#define	DEG_2		15
+#define	SEP_2		1
+
+#define	TYPE_3		3		/* x**31 + x**3 + 1 */
+#define	BREAK_3		128
+#define	DEG_3		31
+#define	SEP_3		3
+
+#define	TYPE_4		4		/* x**63 + x + 1 */
+#define	BREAK_4		256
+#define	DEG_4		63
+#define	SEP_4		1
+
+/*
+ * Array versions of the above information to make code run faster --
+ * relies on fact that TYPE_i == i.
+ */
+#define	MAX_TYPES	5		/* max number of types above */
+
+static const int degrees[MAX_TYPES] =	{ DEG_0, DEG_1, DEG_2, DEG_3, DEG_4 };
+static const int seps[MAX_TYPES] =	{ SEP_0, SEP_1, SEP_2, SEP_3, SEP_4 };
+
+/*
+ * Initially, everything is set up as if from:
+ *
+ *	initstate(1, &randtbl, 128);
+ *
+ * Note that this initialization takes advantage of the fact that srandom()
+ * advances the front and rear pointers 10*rand_deg times, and hence the
+ * rear pointer which starts at 0 will also end up at zero; thus the zeroeth
+ * element of the state information, which contains info about the current
+ * position of the rear pointer is just
+ *
+ *	MAX_TYPES * (rptr - state) + TYPE_3 == TYPE_3.
+ */
+
+static long randtbl[DEG_3 + 1] = {
+	TYPE_3,
+	(long)0x9a319039L, (long)0x32d9c024L, (long)0x9b663182L,
+	(long)0x5da1f342L, (long)0xde3b81e0L, (long)0xdf0a6fb5L,
+	(long)0xf103bc02L, (long)0x48f340fbL, (long)0x7449e56bL,
+	(long)0xbeb1dbb0L, (long)0xab5c5918L, (long)0x946554fdL,
+	(long)0x8c2e680fL, (long)0xeb3d799fL, (long)0xb11ee0b7L,
+	(long)0x2d436b86L, (long)0xda672e2aL, (long)0x1588ca88L,
+	(long)0xe369735dL, (long)0x904f35f7L, (long)0xd7158fd6L,
+	(long)0x6fa6f051L, (long)0x616e6b96L, (long)0xac94efdcL,
+	(long)0x36413f93L, (long)0xc622c298L, (long)0xf5a42ab8L,
+	(long)0x8a88d77bL, (long)0xf5ad9d0eL, (long)0x8999220bL,
+	(long)0x27fb47b9L,
+};
+
+/*
+ * fptr and rptr are two pointers into the state info, a front and a rear
+ * pointer.  These two pointers are always rand_sep places aparts, as they
+ * cycle cyclically through the state information.  (Yes, this does mean we
+ * could get away with just one pointer, but the code for random() is more
+ * efficient this way).  The pointers are left positioned as they would be
+ * from the call
+ *
+ *	initstate(1, randtbl, 128);
+ *
+ * (The position of the rear pointer, rptr, is really 0 (as explained above
+ * in the initialization of randtbl) because the state table pointer is set
+ * to point to randtbl[1] (as explained below).
+ */
+static long *fptr = &randtbl[SEP_3 + 1];
+static long *rptr = &randtbl[1];
+
+/*
+ * The following things are the pointer to the state information table, the
+ * type of the current generator, the degree of the current polynomial being
+ * used, and the separation between the two pointers.  Note that for efficiency
+ * of random(), we remember the first location of the state information, not
+ * the zeroeth.  Hence it is valid to access state[-1], which is used to
+ * store the type of the R.N.G.  Also, we remember the last location, since
+ * this is more efficient than indexing every time to find the address of
+ * the last element to see if the front and rear pointers have wrapped.
+ */
+static long *state = &randtbl[1];
+static long rand_type = TYPE_3;
+static int rand_deg = DEG_3;
+static int rand_sep = SEP_3;
+static long *end_ptr = &randtbl[DEG_3 + 1];
+
+/*
+ * srandom:
+ *
+ * Initialize the random number generator based on the given seed.  If the
+ * type is the trivial no-state-information type, just remember the seed.
+ * Otherwise, initializes state[] based on the given "seed" via a linear
+ * congruential generator.  Then, the pointers are set to known locations
+ * that are exactly rand_sep places apart.  Lastly, it cycles the state
+ * information a given number of times to get rid of any initial dependencies
+ * introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]
+ * for default usage relies on values produced by this routine.
+ */
+static
+void
+srandom_unlocked(unsigned long x)
+{
+	int i;
+
+	if (rand_type == TYPE_0)
+		state[0] = x;
+	else {
+		state[0] = x;
+		for (i = 1; i < rand_deg; i++)
+			state[i] = 1103515245L * state[i - 1] + 12345L;
+		fptr = &state[rand_sep];
+		rptr = &state[0];
+		for (i = 0; i < 10 * rand_deg; i++)
+			(void)random_unlocked();
+	}
+}
+
+void
+srandom(unsigned long x)
+{
+
+	LOCKME();
+	srandom_unlocked(x);
+	UNLOCKME();
+}
+
+/*
+ * initstate:
+ *
+ * Initialize the state information in the given array of n bytes for future
+ * random number generation.  Based on the number of bytes we are given, and
+ * the break values for the different R.N.G.'s, we choose the best (largest)
+ * one we can and set things up for it.  srandom() is then called to
+ * initialize the state information.
+ * 
+ * Note that on return from srandom(), we set state[-1] to be the type
+ * multiplexed with the current value of the rear pointer; this is so
+ * successive calls to initstate() won't lose this information and will be
+ * able to restart with setstate().
+ * 
+ * Note: the first thing we do is save the current state, if any, just like
+ * setstate() so that it doesn't matter when initstate is called.
+ *
+ * Returns a pointer to the old state.
+ *
+ * Note: The Sparc platform requires that arg_state begin on a long
+ * word boundary; otherwise a bus error will occur. Even so, lint will
+ * complain about mis-alignment, but you should disregard these messages.
+ */
+char *
+initstate(
+	unsigned long seed,		/* seed for R.N.G. */
+	char *arg_state,		/* pointer to state array */
+	size_t n)			/* # bytes of state info */
+{
+	void *ostate = (void *)(&state[-1]);
+	long *long_arg_state;
+
+	assert(arg_state != NULL);
+
+	long_arg_state = (long *)(void *)arg_state;
+
+	LOCKME();
+	if (rand_type == TYPE_0)
+		state[-1] = rand_type;
+	else
+		state[-1] = MAX_TYPES * (rptr - state) + rand_type;
+	if (n < BREAK_0) {
+		UNLOCKME();
+		return (NULL);
+	} else if (n < BREAK_1) {
+		rand_type = TYPE_0;
+		rand_deg = DEG_0;
+		rand_sep = SEP_0;
+	} else if (n < BREAK_2) {
+		rand_type = TYPE_1;
+		rand_deg = DEG_1;
+		rand_sep = SEP_1;
+	} else if (n < BREAK_3) {
+		rand_type = TYPE_2;
+		rand_deg = DEG_2;
+		rand_sep = SEP_2;
+	} else if (n < BREAK_4) {
+		rand_type = TYPE_3;
+		rand_deg = DEG_3;
+		rand_sep = SEP_3;
+	} else {
+		rand_type = TYPE_4;
+		rand_deg = DEG_4;
+		rand_sep = SEP_4;
+	}
+	state = (long *) (long_arg_state + 1); /* first location */
+	end_ptr = &state[rand_deg];	/* must set end_ptr before srandom */
+	srandom_unlocked(seed);
+	if (rand_type == TYPE_0)
+		long_arg_state[0] = rand_type;
+	else
+		long_arg_state[0] = MAX_TYPES * (rptr - state) + rand_type;
+	UNLOCKME();
+	return((char *)ostate);
+}
+
+/*
+ * setstate:
+ *
+ * Restore the state from the given state array.
+ *
+ * Note: it is important that we also remember the locations of the pointers
+ * in the current state information, and restore the locations of the pointers
+ * from the old state information.  This is done by multiplexing the pointer
+ * location into the zeroeth word of the state information.
+ *
+ * Note that due to the order in which things are done, it is OK to call
+ * setstate() with the same state as the current state.
+ *
+ * Returns a pointer to the old state information.
+ *
+ * Note: The Sparc platform requires that arg_state begin on a long
+ * word boundary; otherwise a bus error will occur. Even so, lint will
+ * complain about mis-alignment, but you should disregard these messages.
+ */
+char *
+setstate(char *arg_state)		/* pointer to state array */
+{
+	long *new_state;
+	int type;
+	int rear;
+	void *ostate = (void *)(&state[-1]);
+
+	assert(arg_state != NULL);
+
+	new_state = (long *)(void *)arg_state;
+	type = (int)(new_state[0] % MAX_TYPES);
+	rear = (int)(new_state[0] / MAX_TYPES);
+
+	LOCKME();
+	if (rand_type == TYPE_0)
+		state[-1] = rand_type;
+	else
+		state[-1] = MAX_TYPES * (rptr - state) + rand_type;
+	switch(type) {
+	case TYPE_0:
+	case TYPE_1:
+	case TYPE_2:
+	case TYPE_3:
+	case TYPE_4:
+		rand_type = type;
+		rand_deg = degrees[type];
+		rand_sep = seps[type];
+		break;
+	default:
+		UNLOCKME();
+		return (NULL);
+	}
+	state = (long *) (new_state + 1);
+	if (rand_type != TYPE_0) {
+		rptr = &state[rear];
+		fptr = &state[(rear + rand_sep) % rand_deg];
+	}
+	end_ptr = &state[rand_deg];		/* set end_ptr too */
+	UNLOCKME();
+	return((char *)ostate);
+}
+
+/*
+ * random:
+ *
+ * If we are using the trivial TYPE_0 R.N.G., just do the old linear
+ * congruential bit.  Otherwise, we do our fancy trinomial stuff, which is
+ * the same in all the other cases due to all the global variables that have
+ * been set up.  The basic operation is to add the number at the rear pointer
+ * into the one at the front pointer.  Then both pointers are advanced to
+ * the next location cyclically in the table.  The value returned is the sum
+ * generated, reduced to 31 bits by throwing away the "least random" low bit.
+ *
+ * Note: the code takes advantage of the fact that both the front and
+ * rear pointers can't wrap on the same call by not testing the rear
+ * pointer if the front one has wrapped.
+ *
+ * Returns a 31-bit random number.
+ */
+static
+long
+random_unlocked(void)
+{
+	long i;
+	long *f, *r;
+
+	if (rand_type == TYPE_0) {
+		i = state[0];
+		state[0] = i = (i * 1103515245L + 12345L) & 0x7fffffff;
+	} else {
+		/*
+		 * Use local variables rather than static variables for speed.
+		 */
+		f = fptr; r = rptr;
+		*f += *r;
+		/* chucking least random bit */
+		i = ((unsigned long)*f >> 1) & 0x7fffffff;
+		if (++f >= end_ptr) {
+			f = state;
+			++r;
+		}
+		else if (++r >= end_ptr) {
+			r = state;
+		}
+
+		fptr = f; rptr = r;
+	}
+	return(i);
+}
+
+long
+random(void)
+{
+	long r;
+
+	LOCKME();
+	r = random_unlocked();
+	UNLOCKME();
+	return (r);
+}
diff --git a/os161-1.10/lib/libc/snprintf.c b/os161-1.10/lib/libc/snprintf.c
new file mode 100644
index 0000000..da01354
--- /dev/null
+++ b/os161-1.10/lib/libc/snprintf.c
@@ -0,0 +1,127 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+
+#else
+#include <stdio.h>
+
+#endif /* _KERNEL */
+
+#include <stdarg.h>
+
+/*
+ * Standard C string/IO function: printf into a character buffer.
+ */
+
+
+/*
+ * Context structure for snprintf: buffer to print into, maximum 
+ * length, and index of the next character to write.
+ *
+ * Note that while the length argument to snprintf includes space for
+ * a null terminator, SNP.buflen does not. This is to make something
+ * vaguely reasonable happen if a length of 0 is passed to snprintf.
+ */
+
+typedef struct {
+	char *buf;
+	size_t buflen;
+	size_t bufpos;
+} SNP;
+
+/*
+ * Send function for snprintf. This is the function handed to the
+ * printf guts. It gets called with mydata pointing to the context,
+ * and some string data of length LEN in DATA. DATA is not necessarily
+ * null-terminated.
+ */
+
+static
+void
+__snprintf_send(void *mydata, const char *data, size_t len)
+{
+	SNP *snp = mydata;
+	unsigned i;
+
+	/* For each character we're sent... */
+	for (i=0; i<len; i++) {
+
+		/* If we aren't past the length, */
+		if (snp->bufpos < snp->buflen) {
+
+			/* store the character */
+			snp->buf[snp->bufpos] = data[i];
+
+			/* and increment the position. */
+			snp->bufpos++;
+		}
+	}
+}
+
+/*
+ * The va_list version of snprintf.
+ */
+int
+vsnprintf(char *buf, size_t len, const char *fmt, va_list ap)
+{
+	int chars;
+	SNP snp;
+
+	/*
+	 * Fill in the context structure.
+	 * We set snp.buflen to the number of characters that can be
+	 * written (excluding the null terminator) so as not to have
+	 * to special-case the possibility that we got passed a length
+	 * of zero elsewhere.
+	 */
+	snp.buf = buf;
+	if (len==0) {
+		snp.buflen = 0;
+	}
+	else {
+		snp.buflen = len-1;
+	}
+	snp.bufpos = 0;
+
+	/* Call __vprintf to do the actual work. */
+	chars = __vprintf(__snprintf_send, &snp, fmt, ap);
+
+	/*
+	 * Add a null terminator. If the length *we were passed* is greater
+	 * than zero, we reserved a space in the buffer for the terminator,
+	 * so this won't overflow. If the length we were passed is zero,
+	 * nothing will have been or should be written anyway, and buf
+	 * might even be NULL. (C99 explicitly endorses this possibility.)
+	 */
+	if (len > 0) {
+		buf[snp.bufpos] = 0;
+	}
+
+	/*
+	 * Return the number of characters __vprintf processed.
+	 * According to C99, snprintf should return this number, not
+	 * the number of characters actually stored, and should not
+	 * return -1 on overflow but only on other errors.
+	 */
+	return chars;
+}
+
+/*
+ * snprintf - hand off to vsnprintf.
+ */
+int
+snprintf(char *buf, size_t len, const char *fmt, ...)
+{
+	int chars;
+	va_list ap;
+	va_start(ap, fmt);
+	chars = vsnprintf(buf, len, fmt, ap);
+	va_end(ap);
+	return chars;
+}
+
diff --git a/os161-1.10/lib/libc/strcat.c b/os161-1.10/lib/libc/strcat.c
new file mode 100644
index 0000000..c872980
--- /dev/null
+++ b/os161-1.10/lib/libc/strcat.c
@@ -0,0 +1,23 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * Standard C string function: append one string to another.
+ */
+
+char *
+strcat(char *dest, const char *src)
+{
+	size_t offset = strlen(dest);
+	strcpy(dest+offset, src);
+	return dest;
+}
diff --git a/os161-1.10/lib/libc/strchr.c b/os161-1.10/lib/libc/strchr.c
new file mode 100644
index 0000000..b3282c8
--- /dev/null
+++ b/os161-1.10/lib/libc/strchr.c
@@ -0,0 +1,36 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * C standard string function: find leftmost instance of a character
+ * in a string.
+ */
+char *
+strchr(const char *s, int ch)
+{
+	/* scan from left to right */
+	while (*s) {
+		/* if we hit it, return it */
+		if (*s==ch) {
+			return (char *)s;
+		}
+		s++;
+	}
+
+	/* if we were looking for the 0, return that */
+	if (*s==ch) {
+		return (char *)s;
+	}
+
+	/* didn't find it */
+	return NULL;
+}
diff --git a/os161-1.10/lib/libc/strcmp.c b/os161-1.10/lib/libc/strcmp.c
new file mode 100644
index 0000000..030d2ca
--- /dev/null
+++ b/os161-1.10/lib/libc/strcmp.c
@@ -0,0 +1,58 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * Standard C string function: compare two strings and return their
+ * sort order.
+ */
+
+int
+strcmp(const char *a, const char *b)
+{
+	int i;
+
+	/*
+	 * Walk down both strings until either they're different
+	 * or we hit the end of A.
+	 *
+	 * If A and B strings are not the same length, when the
+	 * shorter one ends, the two will be different, and we'll
+	 * stop before running off the end of either.
+	 *
+	 * If they *are* the same length, it's sufficient to check
+	 * that we haven't run off the end of A, because that's the
+	 * same as checking to make sure we haven't run off the end of
+	 * B.
+	 */
+
+	for (i=0; a[i]!=0 && a[i]==b[i]; i++);
+
+	/*
+	 * If A is greater than B, return 1. If A is less than B,
+	 * return -1.  If they're the same, return 0. Since we have
+	 * stopped at the first character of difference (or the end of
+	 * both strings) checking the character under I accomplishes
+	 * this.
+	 *
+	 * If we were doing internationalization, and/or we wanted to
+	 * be able to sort accented characters in with normal text, a
+	 * simple comparison of the values of the characters wouldn't
+	 * be sufficient. But for present purposes, it's adequate.
+	 */
+	if (a[i]>b[i]) {
+		return 1;
+	}
+	else if (a[i]==b[i]) {
+		return 0;
+	}
+	return -1;
+}
diff --git a/os161-1.10/lib/libc/strcpy.c b/os161-1.10/lib/libc/strcpy.c
new file mode 100644
index 0000000..3a966b3
--- /dev/null
+++ b/os161-1.10/lib/libc/strcpy.c
@@ -0,0 +1,34 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * Standard C string function: copy one string to another.
+ */
+char *
+strcpy(char *dest, const char *src)
+{
+	int i;
+
+	/*
+	 * Copy characters until we hit the null terminator.
+	 */
+	for (i=0; src[i]; i++) {
+		dest[i] = src[i];
+	}
+
+	/*
+	 * Add null terminator to result.
+	 */
+	dest[i] = 0;
+
+	return dest;
+}
diff --git a/os161-1.10/lib/libc/strerror.c b/os161-1.10/lib/libc/strerror.c
new file mode 100644
index 0000000..47a336a
--- /dev/null
+++ b/os161-1.10/lib/libc/strerror.c
@@ -0,0 +1,14 @@
+#include <string.h>
+#include <kern/errmsg.h>
+
+/*
+ * Standard C function to return a string for a given errno.
+ */
+const char *
+strerror(int errcode)
+{
+	if (errcode>=0 && errcode < sys_nerr) {
+		return sys_errlist[errcode];
+	}
+	return "Unknown error number";
+}
diff --git a/os161-1.10/lib/libc/strlen.c b/os161-1.10/lib/libc/strlen.c
new file mode 100644
index 0000000..b6a6cc6
--- /dev/null
+++ b/os161-1.10/lib/libc/strlen.c
@@ -0,0 +1,25 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * C standard string function: get length of a string
+ */
+
+size_t
+strlen(const char *s)
+{
+	size_t ret = 0;
+	while (s[ret]) {
+		ret++;
+	}
+	return ret;
+}
diff --git a/os161-1.10/lib/libc/strrchr.c b/os161-1.10/lib/libc/strrchr.c
new file mode 100644
index 0000000..c24bac4
--- /dev/null
+++ b/os161-1.10/lib/libc/strrchr.c
@@ -0,0 +1,37 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * C standard string function: find rightmost instance of a character
+ * in a string.
+ */
+char *
+strrchr(const char *s, int ch)
+{
+	/* start one past the last character INCLUDING NULL TERMINATOR */
+	unsigned i = strlen(s)+1;
+
+	/* go from right to left; stop at 0 */
+	while (i>0) {
+
+		/* decrement first */
+		i--;
+
+		/* now check the character we're over */
+		if (s[i]==ch) {
+			return (char *)(s+i);
+		}
+	}
+
+	/* didn't find it */
+	return NULL;
+}
diff --git a/os161-1.10/lib/libc/strtok.c b/os161-1.10/lib/libc/strtok.c
new file mode 100644
index 0000000..803e8d5
--- /dev/null
+++ b/os161-1.10/lib/libc/strtok.c
@@ -0,0 +1,9 @@
+#include <string.h>
+
+static char *__strtok_context;
+
+char *
+strtok(char *str, const char *seps)
+{
+	return strtok_r(str, seps, &__strtok_context);
+}
diff --git a/os161-1.10/lib/libc/strtok_r.c b/os161-1.10/lib/libc/strtok_r.c
new file mode 100644
index 0000000..17e1059
--- /dev/null
+++ b/os161-1.10/lib/libc/strtok_r.c
@@ -0,0 +1,67 @@
+/*
+ * This file is shared between libc and the kernel, so don't put anything
+ * in here that won't work in both contexts.
+ */
+
+#ifdef _KERNEL
+#include <types.h>
+#include <lib.h>
+#else
+#include <string.h>
+#endif
+
+/*
+ * Standard C string function: tokenize a string splitting based on a
+ * list of separator characters. Reentrant version.
+ *
+ * The "context" argument should point to a "char *" that is preserved
+ * between calls to strtok_r that wish to operate on same string.
+ */
+char *
+strtok_r(char *string, const char *seps, char **context)
+{
+	char *head;  /* start of word */
+	char *tail;  /* end of word */
+
+	/* If we're starting up, initialize context */
+	if (string) {
+		*context = string;
+	}
+
+	/* Get potential start of this next word */
+	head = *context;
+	if (head == NULL) {
+		return NULL;
+	}
+
+	/* Skip any leading separators */
+	while (*head && strchr(seps, *head)) {
+		head++;
+	}
+
+	/* Did we hit the end? */
+	if (*head == 0) {
+		/* Nothing left */
+		*context = NULL;
+		return NULL;
+	}
+
+	/* skip over word */
+	tail = head;
+	while (*tail && !strchr(seps, *tail)) {
+		tail++;
+	}
+
+	/* Save head for next time in context */
+	if (*tail == 0) {
+		*context = NULL;
+	}
+	else {
+		*tail = 0;
+		tail++;
+		*context = tail;
+	}
+
+	/* Return current word */
+	return head;
+}
diff --git a/os161-1.10/lib/libc/syscalls-mips.S b/os161-1.10/lib/libc/syscalls-mips.S
new file mode 100644
index 0000000..6604095
--- /dev/null
+++ b/os161-1.10/lib/libc/syscalls-mips.S
@@ -0,0 +1,66 @@
+/*
+ * This file is copied to syscalls.S, and then the actual syscalls are
+ * appended as lines of the form
+ *    SYSCALL(symbol, number)
+ *
+ * Warning: gccs before 3.0 run cpp in -traditional mode on .S files.
+ * So if you use an older gcc you'll need to change the token pasting
+ * in SYSCALL().
+ */
+
+#include <kern/callno.h>
+#include <machine/asmdefs.h>
+
+/*
+ * Definition for each syscall.
+ * All we do is load the syscall number into v0, the register the
+ * kernel expects to find it in, and jump to the shared syscall code.
+ * (Note that the addiu instruction is in the jump's delay slot.)
+ */    
+#define SYSCALL(sym, num) \
+   .set noreorder		; \
+   .globl sym			; \
+   .type sym,@function		; \
+   .ent sym			; \
+sym:				; \
+   j __syscall                  ; \
+   addiu v0, $0, SYS_##sym	; \
+   .end sym			; \
+   .set reorder
+
+/*
+ * Now, the shared system call code.
+ * The MIPS syscall ABI is as follows:	
+ *
+ *    On entry, call number in v0. The rest is like a normal function
+ *    call: four args in a0-a3, the other args on the stack.
+ *
+ *    On successful return, zero in a3 register; return value in v0
+ *    (v0 and v1 for a 64-bit return value).
+ *
+ *    On error return, nonzero in a3 register; errno value in v0.
+ *
+ * The use of a3 as a return register to hold the success flag is
+ * gross, but I didn't make it up.
+ *
+ * Note that by longstanding Unix convention and POSIX decree, errno
+ * is not to be set unless the call actually fails.
+ */
+
+   .set noreorder
+   .text
+   .type __syscall,@function
+   .ent __syscall
+__syscall:
+   syscall              /* make system call */
+   beq a3, $0, 1f       /* if a3 is zero, call succeeded */
+   nop			/* delay slot */
+   sw v0, errno        /* call failed: store errno */
+   li v1, -1		/* and force return value to -1 */
+   li v0, -1
+1:
+   j ra			/* return */
+   nop			/* delay slot */
+   .end __syscall
+   .set reorder
+
diff --git a/os161-1.10/lib/libc/system.c b/os161-1.10/lib/libc/system.c
new file mode 100644
index 0000000..913577f
--- /dev/null
+++ b/os161-1.10/lib/libc/system.c
@@ -0,0 +1,62 @@
+#include <errno.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+/*
+ * system(): ANSI C
+ *
+ * Run a command.
+ */
+
+#define MAXCMDSIZE 2048
+#define MAXARGS    128
+
+int
+system(const char *cmd)
+{
+	/*
+	 * Ordinarily, you call the shell to process the command.
+	 * But we don't know that the shell can do that. So, do it
+	 * ourselves.
+	 */
+
+	char tmp[MAXCMDSIZE];
+	char *argv[MAXARGS+1];
+	int nargs=0;
+	char *s;
+	int pid, status;
+
+	if (strlen(cmd) >= sizeof(tmp)) {
+		errno = E2BIG;
+		return -1;
+	}
+	strcpy(tmp, cmd);
+
+	for (s = strtok(tmp, " \t"); s; s = strtok(NULL, " \t")) {
+		if (nargs < MAXARGS) {
+			argv[nargs++] = s;
+		}
+		else {
+			errno = E2BIG;
+			return 1;
+		}
+	}
+
+	argv[nargs] = NULL;
+
+	pid = fork();
+	switch (pid) {
+	    case -1:
+		return -1;
+	    case 0:
+		/* child */
+		execv(argv[0], argv);
+		/* exec only returns if it fails */
+		_exit(255);
+	    default:
+		/* parent */
+		waitpid(pid, &status, 0);
+		return status;
+	}
+}
diff --git a/os161-1.10/lib/libc/time.c b/os161-1.10/lib/libc/time.c
new file mode 100644
index 0000000..046cd36
--- /dev/null
+++ b/os161-1.10/lib/libc/time.c
@@ -0,0 +1,13 @@
+#include <unistd.h>
+
+/*
+ * POSIX C function: retrieve time in seconds since the epoch.
+ * Uses the OS/161 system call __time, which does the same thing
+ * but also returns nanoseconds.
+ */
+
+time_t
+time(time_t *t)
+{
+	return __time(t, NULL);
+}
diff --git a/os161-1.10/man/Makefile b/os161-1.10/man/Makefile
new file mode 100644
index 0000000..771a40e
--- /dev/null
+++ b/os161-1.10/man/Makefile
@@ -0,0 +1,21 @@
+#
+# Makefile for src/man (man page tree)
+#
+
+include ../defs.mk
+
+all depend tags clean install:
+	(cd toplevel && $(MAKE) $@)
+	(cd bin && $(MAKE) $@)
+	(cd sbin && $(MAKE) $@)
+	(cd testbin && $(MAKE) $@)
+	(cd libc && $(MAKE) $@)
+	(cd syscall && $(MAKE) $@)
+	(cd dev && $(MAKE) $@)
+	(cd misc && $(MAKE) $@)
+
+clean: cleanhere
+cleanhere:
+	rm -f *~
+
+.PHONY: all depend tags clean cleanhere install
diff --git a/os161-1.10/man/bin/Makefile b/os161-1.10/man/bin/Makefile
new file mode 100644
index 0000000..d8253f5
--- /dev/null
+++ b/os161-1.10/man/bin/Makefile
@@ -0,0 +1,6 @@
+# Man pages for /bin programs
+
+MANDIR=/man/bin
+
+include ../../defs.mk
+include ../../mk/man.mk
diff --git a/os161-1.10/man/bin/cat.html b/os161-1.10/man/bin/cat.html
new file mode 100644
index 0000000..2b79d84
--- /dev/null
+++ b/os161-1.10/man/bin/cat.html
@@ -0,0 +1,42 @@
+<html>
+<head>
+<title>cat</title>
+<body bgcolor=#ffffff>
+<h2 align=center>cat</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+cat - concatenate and print files
+
+<h3>Synopsis</h3>
+/bin/cat <em>files...</em>
+
+<h3>Description</h3>
+
+cat prints the files listed on its command line in order to its
+standard output. If the magic filename "-" is encountered, cat
+prints its standard input up to the first EOF.
+<p>
+
+With no arguments, cat prints its standard input.
+<p>
+
+cat takes no options.
+<p>
+
+<h3>Requirements</h3>
+
+cat uses the following syscalls:
+<ul>
+<li><A HREF=../syscall/open.html>open</A>
+<li><A HREF=../syscall/read.html>read</A>
+<li><A HREF=../syscall/write.html>write</A>
+<li><A HREF=../syscall/close.html>close</A>
+<li><A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+cat should function properly once the basic system calls assignment is
+completed.
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/cp.html b/os161-1.10/man/bin/cp.html
new file mode 100644
index 0000000..ebc38b3
--- /dev/null
+++ b/os161-1.10/man/bin/cp.html
@@ -0,0 +1,42 @@
+<html>
+<head>
+<title>cp</title>
+<body bgcolor=#ffffff>
+<h2 align=center>cp</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+cp - copy files
+
+<h3>Synopsis</h3>
+/bin/cp <em>oldfile</em> <em>newfile</em>
+
+<h3>Description</h3>
+
+cp copies the file <em>oldfile</em> to the file <em>newfile</em>,
+overwriting <em>newfile</em> if it already exists.
+<p>
+
+cp supports no options.
+<p>
+
+<h3>Requirements</h3>
+
+cp uses the following syscalls:
+<ul>
+<li><A HREF=../syscall/open.html>open</A>
+<li><A HREF=../syscall/read.html>read</A>
+<li><A HREF=../syscall/write.html>write</A>
+<li><A HREF=../syscall/close.html>close</A>
+<li><A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+cp should function properly once the basic system calls assignment is
+completed.
+
+<h3>See Also</h3>
+
+<A HREF=ln.html>ln</A>, <A HREF=mv.html>mv<A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/false.html b/os161-1.10/man/bin/false.html
new file mode 100644
index 0000000..faed42f
--- /dev/null
+++ b/os161-1.10/man/bin/false.html
@@ -0,0 +1,31 @@
+<html>
+<head>
+<title>false</title>
+<body bgcolor=#ffffff>
+<h2 align=center>false</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+false - return false value
+
+<h3>Synopsis</h3>
+/bin/false
+
+<h3>Description</h3>
+
+false exits with exit code 1, signifying failure.
+
+<h3>Requirements</h3>
+
+false uses the <A HREF=../syscall/_exit.html>_exit</A> system call.
+<p>
+
+false should function properly once the basic system calls assignment
+is completed.
+
+<h3>See Also</h3>
+
+<A HREF=true.html>true</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/index.html b/os161-1.10/man/bin/index.html
new file mode 100644
index 0000000..25454e7
--- /dev/null
+++ b/os161-1.10/man/bin/index.html
@@ -0,0 +1,37 @@
+<html>
+<head>
+<title>OS/161 Binaries</title>
+</head>
+<body bgcolor=#ffffff>
+
+<h2 align=center>OS/161 Binaries (/bin)</h2>
+
+<p align=center>
+<A HREF=..>Top</A> |
+<A HREF=../sbin>Sysadmin binaries</A> |
+<A HREF=../testbin>Test binaries</A> |
+<A HREF=../libc>C standard library</A> |
+<A HREF=../syscall>System calls</A> |
+<A HREF=../dev>Device drivers</A> |
+<A HREF=../misc>Miscellaneous</A>
+</p>
+<br>
+
+<ul>
+<li> <A HREF=cat.html>cat</A> - concatenate and print files
+<li> <A HREF=cp.html>cp</A> - copy files
+<li> <A HREF=false.html>false</A> - return false value
+<li> <A HREF=ln.html>ln</A> - link files
+<li> <A HREF=ls.html>ls</A> - list files or directory contents
+<li> <A HREF=mkdir.html>mkdir</A> - create directory
+<li> <A HREF=mv.html>mv</A> - rename or move files
+<li> <A HREF=pwd.html>pwd</A> - print working directory
+<li> <A HREF=rm.html>rm</A> - remove (unlink) files
+<li> <A HREF=rmdir.html>rmdir</A> - remove directory
+<li> <A HREF=sh.html>sh</A> - user command shell
+<li> <A HREF=sync.html>sync</A> - synchronize buffers to disk
+<li> <A HREF=true.html>true</A> - return true value
+</ul>
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/ln.html b/os161-1.10/man/bin/ln.html
new file mode 100644
index 0000000..2e52ca8
--- /dev/null
+++ b/os161-1.10/man/bin/ln.html
@@ -0,0 +1,52 @@
+<html>
+<head>
+<title>ln</title>
+<body bgcolor=#ffffff>
+<h2 align=center>ln</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+ln - link files
+
+<h3>Synopsis</h3>
+/bin/ln <em>oldfile</em> <em>newfile</em>
+<br>
+/bin/ln -s <em>oldfile</em> <em>newfile</em>
+
+<h3>Description</h3>
+
+ln creates links to files. The first usage creates a hard link, that
+is, an additional name for the <strong>same</strong> file. The second
+usage, with the -s option, creates a symbolic link, a special
+filesystem entry that redirects accesses back to the first original
+file.
+<p>
+
+The symlink created is of the form <em>newfile</em> -> <em>oldfile</em>.
+<p>
+
+<h3>Requirements</h3>
+
+ln uses the following syscalls:
+<ul>
+<li><A HREF=../syscall/link.html>link</A>
+<li><A HREF=../syscall/symlink.html>symlink</A>
+<li><A HREF=../syscall/write.html>write</A>
+<li><A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+ln without the -s option should work once (or if) you implement hard
+links.  ln with the -s option should work once (or if) you implement
+symbolic links. Check your assignments for when (or if) you need to
+implement these features.
+<p>
+
+ln is able to create symlinks even if hard links are not implemented,
+and vice versa.
+
+<h3>See Also</h3>
+
+<A HREF=cp.html>cp</A>, <A HREF=mv.html>mv<A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/ls.html b/os161-1.10/man/bin/ls.html
new file mode 100644
index 0000000..bf9e769
--- /dev/null
+++ b/os161-1.10/man/bin/ls.html
@@ -0,0 +1,60 @@
+<html>
+<head>
+<title>ls</title>
+<body bgcolor=#ffffff>
+<h2 align=center>ls</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+ls - list files or directory contents
+
+<h3>Synopsis</h3>
+/bin/ls [-adlRs] [<em>path</em>...]
+
+<h3>Description</h3>
+
+ls lists the filesystem objects specified on the command line. If they
+are directories, the contents of the directories are listed (unless
+the -d option is used).
+<p>
+
+If the -a option is given, filenames beginning with dot (.) will be
+listed. Ordinarily, they are skipped.
+<p>
+
+If the -d option is given, directory contents will not be listed; the
+directories themselves will be.
+<p>
+
+If the -l option is given, a long format listing showing the file
+size, type, and link count will be displayed instead of just the
+filenames.
+<p>
+
+If the -R option is given, subdirectories encountered will be listed
+recursively.
+<p>
+
+If the -s option is given, the number of filesystem blocks used by
+each object will be displayed in addition to other information.
+<p>
+
+If no <em>paths</em> are specified, the current directory is assumed.
+
+<h3>Requirements</h3>
+
+ls uses the following syscalls:
+<ul>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/fstat.html>fstat</A>
+<li> <A HREF=../syscall/getdirentry.html>getdirentry</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+ls should function properly once the file system assignment is
+completed.
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/mkdir.html b/os161-1.10/man/bin/mkdir.html
new file mode 100644
index 0000000..1e91557
--- /dev/null
+++ b/os161-1.10/man/bin/mkdir.html
@@ -0,0 +1,36 @@
+<html>
+<head>
+<title>mkdir</title>
+<body bgcolor=#ffffff>
+<h2 align=center>mkdir</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+mkdir - create directory
+
+<h3>Synopsis</h3>
+/bin/mkdir <em>directory</em>
+
+<h3>Description</h3>
+
+mkdir creates the named directory. All intermediate components must
+already exist. If the named directory already exists, an error occurs.
+
+<h3>Requirements</h3>
+
+mkdir uses the following syscalls:
+<ul>
+<li> <A HREF=../syscall/mkdir.html>mkdir</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+mkdir should function properly once the file system assignment is
+completed.
+
+<h3>See Also</h3>
+
+<A HREF=rmdir.html>rmdir</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/mv.html b/os161-1.10/man/bin/mv.html
new file mode 100644
index 0000000..6e2ee2b
--- /dev/null
+++ b/os161-1.10/man/bin/mv.html
@@ -0,0 +1,42 @@
+<html>
+<head>
+<title>mv</title>
+<body bgcolor=#ffffff>
+<h2 align=center>mv</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+mv - rename or move files
+
+<h3>Synopsis</h3>
+/bin/mv <em>oldname</em> <em>newname</em>
+
+<h3>Description</h3>
+
+mv renames the filesystem object specified by <em>oldname</em> so that
+it is subsequently named <em>newname</em>. Both files and directories
+can be renamed or moved into other parts of the filesystem tree.
+However, devices may not be renamed and filesystem objects may not be
+moved across filesystems.
+<p>
+
+mv accepts no options.
+
+<h3>Requirements</h3>
+
+mv uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/rename.html>rename</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+mv should function properly once the file system assignment is
+completed.
+
+<h3>See Also</h3>
+
+<A HREF=cp.html>cp</A>, <A HREF=ln.html>ln<A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/pwd.html b/os161-1.10/man/bin/pwd.html
new file mode 100644
index 0000000..89cec06
--- /dev/null
+++ b/os161-1.10/man/bin/pwd.html
@@ -0,0 +1,37 @@
+<html>
+<head>
+<title>pwd</title>
+<body bgcolor=#ffffff>
+<h2 align=center>pwd</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+pwd - print working directory
+
+<h3>Synopsis</h3>
+/bin/pwd
+
+<h3>Description</h3>
+
+pwd prints the current working directory.
+
+<h3>Requirements</h3>
+
+pwd uses the following system calls:
+<ul>
+<li> <A HREF=../libc/getcwd.html>getcwd</A>
+<li> <A HREF=../syscall/__getcwd.html>__getcwd</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+pwd should function properly once the basic system calls assignment is
+completed, except on filesystems or in directories that do not support
+getcwd.
+<p>
+
+pwd should function properly in all directories of your filesystem
+once the file system assignment is completed.
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/rm.html b/os161-1.10/man/bin/rm.html
new file mode 100644
index 0000000..1bd861d
--- /dev/null
+++ b/os161-1.10/man/bin/rm.html
@@ -0,0 +1,47 @@
+<html>
+<head>
+<title>rm</title>
+<body bgcolor=#ffffff>
+<h2 align=center>rm</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+rm - remove (unlink) files
+
+<h3>Synopsis</h3>
+/bin/rm <em>file...</em>
+
+<h3>Description</h3>
+
+rm deletes the files specified on its command line. (If one of the
+filenames specified is one of several hard links to the same file, the
+actual file is only erased when all links are removed.)
+<p>
+
+Using rm on directories produces an error. Use 
+<A HREF=rmdir.html>rmdir</A> to remove
+directories. 
+
+<h3>Requirements</h3>
+
+rm uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/remove.html>remove</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+rm should function properly once the file system assignment is
+completed.
+
+<h3>Restrictions</h3>
+
+<A HREF=../dev/emu.html>emufs</A> does not support rm. (This is
+intentional.)
+
+<h3>See Also</h3>
+
+<A HREF=rmdir.html>rmdir</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/rmdir.html b/os161-1.10/man/bin/rmdir.html
new file mode 100644
index 0000000..8d19a1f
--- /dev/null
+++ b/os161-1.10/man/bin/rmdir.html
@@ -0,0 +1,45 @@
+<html>
+<head>
+<title>rmdir</title>
+<body bgcolor=#ffffff>
+<h2 align=center>rmdir</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+rmdir - remove directory
+
+<h3>Synopsis</h3>
+/bin/rmdir <em>directory</em>
+
+<h3>Description</h3>
+
+rmdir removes the specified directory. The directory must be empty.
+<p>
+
+It is an error to attempt to remove the . or .. names in a directory,
+or to apply rmdir to a filesystem object that is not a directory.
+<p>
+
+<h3>Requirements</h3>
+
+rmdir uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/rmdir.html>rmdir</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+rmdir should function properly once the file system assignment is
+completed.
+
+<h3>Restrictions</h3>
+
+<A HREF=../dev/emu.html>emufs</A> does not support rmdir. (This is
+intentional.)
+
+<h3>See Also</h3>
+
+<A HREF=mkdir.html>mkdir</A>, <A HREF=rm.html>rm</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/sh.html b/os161-1.10/man/bin/sh.html
new file mode 100644
index 0000000..cd01289
--- /dev/null
+++ b/os161-1.10/man/bin/sh.html
@@ -0,0 +1,38 @@
+<html>
+<head>
+<title>sh</title>
+<body bgcolor=#ffffff>
+<h2 align=center>sh</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+sh - user command shell
+
+<h3>Synopsis</h3>
+/bin/sh [-options] [args]
+
+<h3>Description</h3>
+
+How you make this work is entirely up to you. We recommend updating
+this page to describe how your shell works once you complete it.
+
+<h3>Requirements</h3>
+
+In large part up to you, though in all probability at least these
+system calls will be involved:
+
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/waitpid.html>waitpid</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+Your shell should function properly once the basic system calls
+assignment is complete, although it's certainly ok to include bells
+and whistles that won't work until later on.
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/sync.html b/os161-1.10/man/bin/sync.html
new file mode 100644
index 0000000..16fb450
--- /dev/null
+++ b/os161-1.10/man/bin/sync.html
@@ -0,0 +1,25 @@
+<html>
+<head>
+<title>sync</title>
+<body bgcolor=#ffffff>
+<h2 align=center>sync</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+sync - synchronize buffers to disk
+
+<h3>Synopsis</h3>
+/bin/sync
+
+<h3>Description</h3>
+
+sync causes filesystem I/O buffers that have been modified but not yet
+written to be written to disk.
+
+<h3>Requirements</h3>
+
+sync uses the <A HREF=../syscall/sync.html>sync</A> system call, and
+of course <A HREF=../syscall/_exit.html>_exit</A>.
+
+</body>
+</html>
diff --git a/os161-1.10/man/bin/true.html b/os161-1.10/man/bin/true.html
new file mode 100644
index 0000000..c594546
--- /dev/null
+++ b/os161-1.10/man/bin/true.html
@@ -0,0 +1,31 @@
+<html>
+<head>
+<title>true</title>
+<body bgcolor=#ffffff>
+<h2 align=center>true</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+true - return true value
+
+<h3>Synopsis</h3>
+/bin/true
+
+<h3>Description</h3>
+
+true exits with exit code 0, signifying success.
+
+<h3>Requirements</h3>
+
+true uses the <A HREF=../syscall/_exit.html>_exit</A> system call.
+<p>
+
+true should function properly once the basic system calls assignment
+is completed.
+
+<h3>See Also</h3>
+
+<A HREF=false.html>false</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/Makefile b/os161-1.10/man/dev/Makefile
new file mode 100644
index 0000000..8eb1fec
--- /dev/null
+++ b/os161-1.10/man/dev/Makefile
@@ -0,0 +1,6 @@
+# Man pages for device drivers
+
+MANDIR=/man/dev
+
+include ../../defs.mk
+include ../../mk/man.mk
diff --git a/os161-1.10/man/dev/beep.html b/os161-1.10/man/dev/beep.html
new file mode 100644
index 0000000..a788f87
--- /dev/null
+++ b/os161-1.10/man/dev/beep.html
@@ -0,0 +1,27 @@
+<html>
+<head>
+<title>beep</title>
+<body bgcolor=#ffffff>
+<h2 align=center>beep</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+beep - console beep device
+
+<h3>Synopsis</h3>
+device beep0 at ltimer*
+
+<h3>Description</h3>
+
+The beep device is an abstract entry point for in-kernel beeping. The
+beep() function is provided, and redirected to the first attached
+device. If no beep device is available, beeping will cause a warning
+to be printed to the system console.
+<p>
+
+<h3>See Also</h3>
+
+<A HREF=ltimer.html>ltimer</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/con.html b/os161-1.10/man/dev/con.html
new file mode 100644
index 0000000..2142b2d
--- /dev/null
+++ b/os161-1.10/man/dev/con.html
@@ -0,0 +1,35 @@
+<html>
+<head>
+<title>console</title>
+<body bgcolor=#ffffff>
+<h2 align=center>con</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+con - system login console
+
+<h3>Synopsis</h3>
+device con0 at lser*<br>
+device con0 at lscreen*<br>
+
+<h3>Description</h3>
+
+The generic console device can be attached to either a serial port or
+a memory-mapped screen. It provides no internal buffering or input
+editing. You may add such features if you desire.
+<p>
+
+The in-kernel kprintf() routine and its relatives send their
+output to the console device.
+
+<h3>Files</h3>
+
+<tt>con:</tt>
+
+<h3>See Also</h3>
+
+<A HREF=lser.html>lser</A>,
+<A HREF=lscreen.html>lscreen</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/emu.html b/os161-1.10/man/dev/emu.html
new file mode 100644
index 0000000..4b7481a
--- /dev/null
+++ b/os161-1.10/man/dev/emu.html
@@ -0,0 +1,32 @@
+<html>
+<head>
+<title>emu</title>
+<body bgcolor=#ffffff>
+<h2 align=center>emu</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+emu - emulator pass-through filesystem
+
+<h3>Synopsis</h3>
+device emu* at lamebus*
+
+<h3>Description</h3>
+
+emu, also known as emufs, is a driver for a special-purpose System/161
+device that provides access to the filesystem System/161 is running
+atop. It provides the appearance of a mounted filesystem.
+<p>
+
+It is not recommended to access the same underlying files through
+different instances of emufs.
+
+<h3>Files</h3>
+
+<tt>emu0:</tt>, <tt>emu1:</tt>, etc.
+
+<h3>See Also</h3>
+<A HREF=lamebus.html>lamebus</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/index.html b/os161-1.10/man/dev/index.html
new file mode 100644
index 0000000..e99bd97
--- /dev/null
+++ b/os161-1.10/man/dev/index.html
@@ -0,0 +1,38 @@
+<html>
+<head>
+<title>OS/161 Devices</title>
+</head>
+<body bgcolor=#ffffff>
+
+<h2 align=center>OS/161 Devices</h2>
+
+<p align=center>
+<A HREF=..>Top</A> |
+<A HREF=../bin>Binaries</A> |
+<A HREF=../sbin>Sysadmin binaries</A> |
+<A HREF=../testbin>Test binaries</A> |
+<A HREF=../libc>C standard library</A> |
+<A HREF=../syscall>System calls</A> |
+<A HREF=../misc>Miscellaneous</A>
+</p>
+<br>
+
+<ul>
+<li> <A HREF=beep.html>beep</A> - console beep device
+<li> <A HREF=con.html>con</A> - system login console
+<li> <A HREF=emu.html>emu</A> - emulator pass-through filesystem
+<li> <A HREF=lamebus.html>lamebus</A> - driver for LAMEbus system bus
+<li> <A HREF=lhd.html>lhd</A> - LAMEbus hard drive
+<li> <A HREF=lnet.html>lnet</A> - LAMEbus network card
+<li> <A HREF=lrandom.html>lrandom</A> - LAMEbus random source
+<li> <A HREF=lscreen.html>lscreen</A> - LAMEbus memory-mapped screen
+<li> <A HREF=lser.html>lser</A> - LAMEbus serial port
+<li> <A HREF=ltimer.html>ltimer</A> - LAMEbus timer device
+<li> <A HREF=null.html>null</A> - null device
+<li> <A HREF=pseudorand.html>pseudorand</A> - pseudorandom number generator
+<li> <A HREF=random.html>random</A> - kernel randomness source
+<li> <A HREF=rtclock.html>rtclock</A> - realtime clock
+</ul>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/lamebus.html b/os161-1.10/man/dev/lamebus.html
new file mode 100644
index 0000000..e5f7a1c
--- /dev/null
+++ b/os161-1.10/man/dev/lamebus.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>lamebus</title>
+<body bgcolor=#ffffff>
+<h2 align=center>lamebus</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+lamebus - driver for LAMEbus system bus
+
+<h3>Synopsis</h3>
+device lamebus0
+
+<h3>Description</h3>
+
+LAMEbus is the system bus for System/161. This driver takes care of
+managing the bus controller, distributing interrupts, and similar
+issues. It serves mostly as an attachment point for other drivers.
+
+<h3>See Also</h3>
+<A HREF=emu.html>emu</A>,
+<A HREF=lhd.html>lhd</A>,
+<A HREF=lnet.html>lnet</A>,
+<A HREF=lrandom.html>lrandom</A>,
+<A HREF=lscreen.html>lscreen</A>,
+<A HREF=lser.html>lser</A>,
+<A HREF=ltimer.html>ltimer</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/lhd.html b/os161-1.10/man/dev/lhd.html
new file mode 100644
index 0000000..15d7a37
--- /dev/null
+++ b/os161-1.10/man/dev/lhd.html
@@ -0,0 +1,27 @@
+<html>
+<head>
+<title>lhd</title>
+<body bgcolor=#ffffff>
+<h2 align=center>lhd</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+lhd - LAMEbus hard drive
+
+<h3>Synopsis</h3>
+device lhd* at lamebus*
+
+<h3>Description</h3>
+
+lhd is the driver for the CS161 LAMEbus fixed disk interface. It
+provides mountable block-device and raw-device access to the disk.
+
+<h3>Files</h3>
+
+<tt>lhd0:</tt>, <tt>lhd0raw:</tt>, <tt>lhd1:</tt>, <tt>lhd1raw:</tt>, etc.
+
+<h3>See Also</h3>
+<A HREF=lamebus.html>lamebus</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/lnet.html b/os161-1.10/man/dev/lnet.html
new file mode 100644
index 0000000..51b2e78
--- /dev/null
+++ b/os161-1.10/man/dev/lnet.html
@@ -0,0 +1,25 @@
+<html>
+<head>
+<title>lnet</title>
+<body bgcolor=#ffffff>
+<h2 align=center>lnet</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+lnet - LAMEbus network card
+
+<h3>Synopsis</h3>
+options net<br>
+device lnet* at lamebus*<br>
+
+<h3>Description</h3>
+
+lnet is the driver for the CS161 LAMEbus network interface card.  As
+of this writing the driver is not completed and is thus not available
+for actual use yet.
+
+<h3>See Also</h3>
+<A HREF=lamebus.html>lamebus</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/lrandom.html b/os161-1.10/man/dev/lrandom.html
new file mode 100644
index 0000000..b228a5e
--- /dev/null
+++ b/os161-1.10/man/dev/lrandom.html
@@ -0,0 +1,26 @@
+<html>
+<head>
+<title>lrandom</title>
+<body bgcolor=#ffffff>
+<h2 align=center>lrandom</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+lrandom - LAMEbus random source
+
+<h3>Synopsis</h3>
+device lrandom* at lamebus*
+
+<h3>Description</h3>
+
+lrandom is the driver for the CS161 LAMEbus random source card.
+<p>
+
+The generic <A HREF=random.html>random</A> device can be attached to
+an lrandom instance.
+
+<h3>See Also</h3>
+<A HREF=lamebus.html>lamebus</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/lscreen.html b/os161-1.10/man/dev/lscreen.html
new file mode 100644
index 0000000..9708d82
--- /dev/null
+++ b/os161-1.10/man/dev/lscreen.html
@@ -0,0 +1,33 @@
+<html>
+<head>
+<title>lscreen</title>
+<body bgcolor=#ffffff>
+<h2 align=center>lscreen</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+lscreen - LAMEbus memory-mapped screen
+
+<h3>Synopsis</h3>
+device lscreen* at lamebus*
+
+<h3>Description</h3>
+
+lscreen is the driver for the CS161 LAMEbus memory-mapped screen
+card. It does not provide any internal input buffering; that is
+expected to happen at a higher level.
+<p>
+
+Since the memory-mapped screen card is not actually available yet as
+of this writing, the driver has not been tested and probably does not
+work.
+<p>
+
+The <A HREF=con.html>system console</A> device can be attached to an
+lscreen instance.
+
+<h3>See Also</h3>
+<A HREF=lamebus.html>lamebus</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/lser.html b/os161-1.10/man/dev/lser.html
new file mode 100644
index 0000000..31478a0
--- /dev/null
+++ b/os161-1.10/man/dev/lser.html
@@ -0,0 +1,29 @@
+<html>
+<head>
+<title>lser</title>
+<body bgcolor=#ffffff>
+<h2 align=center>lser</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+lser - LAMEbus serial port
+
+<h3>Synopsis</h3>
+device lser* at lamebus*
+
+<h3>Description</h3>
+
+lser is the driver for the CS161 LAMEbus serial port card. It does not
+provide any internal buffering; that is expected to happen at a higher
+level. It can, however, operate in either polled or interrupt-driven
+output mode.
+<p>
+
+The <A HREF=con.html>system console</A> device can be attached to an
+lser instance.
+
+<h3>See Also</h3>
+<A HREF=lamebus.html>lamebus</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/ltimer.html b/os161-1.10/man/dev/ltimer.html
new file mode 100644
index 0000000..54ac7bd
--- /dev/null
+++ b/os161-1.10/man/dev/ltimer.html
@@ -0,0 +1,28 @@
+<html>
+<head>
+<title>ltimer</title>
+<body bgcolor=#ffffff>
+<h2 align=center>ltimer</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+ltimer - LAMEbus timer device
+
+<h3>Synopsis</h3>
+ltimer* at lamebus*
+
+<h3>Description</h3>
+
+ltimer is a driver for the CS161 LAMEbus clock/timer card. The first
+such card will provide "hardclock" functionality to the system. The
+card can also provide beep services to the kernel.
+<p>
+
+The <A HREF=beep.html>beep</A> and <A HREF=rtclock.html>rtclock</A>
+generic devices can be attached to an ltimer instance.
+
+<h3>See Also</h3>
+<A HREF=lamebus.html>lamebus</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/null.html b/os161-1.10/man/dev/null.html
new file mode 100644
index 0000000..2c9b251
--- /dev/null
+++ b/os161-1.10/man/dev/null.html
@@ -0,0 +1,21 @@
+<html>
+<head>
+<title>null</title>
+<body bgcolor=#ffffff>
+<h2 align=center>null</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+null - null device
+
+<h3>Description</h3>
+
+The null device does nothing. Reads generate immediate EOF; any data
+written is thrown away.
+
+<h3>Files</h3>
+
+<tt>null:</tt>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/pseudorand.html b/os161-1.10/man/dev/pseudorand.html
new file mode 100644
index 0000000..46555c6
--- /dev/null
+++ b/os161-1.10/man/dev/pseudorand.html
@@ -0,0 +1,28 @@
+<html>
+<head>
+<title>pseudorand</title>
+<body bgcolor=#ffffff>
+<h2 align=center>pseudorand</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+pseudorand - pseudorandom number generator
+
+<h3>Synopsis</h3>
+device pseudorand0
+
+<h3>Description</h3>
+
+The pseudorand device implements a minimal pseudo-random number
+generator that can be used if no hardware random source is found.
+<p>
+
+The pseudorand device is not necessary under normal circumstances,
+because System/161 provides a simulated hardware random source. It may
+be removed in the future.
+
+<h3>See Also</h3>
+<A HREF=random.html>random</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/random.html b/os161-1.10/man/dev/random.html
new file mode 100644
index 0000000..e71ecf5
--- /dev/null
+++ b/os161-1.10/man/dev/random.html
@@ -0,0 +1,35 @@
+<html>
+<head>
+<title>random</title>
+<body bgcolor=#ffffff>
+<h2 align=center>random</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+random - kernel randomness source
+
+<h3>Synopsis</h3>
+device random0 at lrandom*<br>
+device random0 at pseudorand0<br>
+
+<h3>Description</h3>
+
+The random device is the generalized interface to randomness sources.
+Only one random device is used; if more are attached they are ignored.
+If no random device is found, the kernel may not run.
+<p>
+
+The random device provides both the in-kernel random() function and a
+VFS character device, called <tt>random:</tt>. Bytes read from the
+latter have random values; writes are discarded.
+<p>
+
+<h3>Files</h3>
+<tt>random:</tt>
+
+<h3>See Also</h3>
+<A HREF=lrandom.html>lrandom</A>,
+<A HREF=pseudorand.html>pseudorand</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/dev/rtclock.html b/os161-1.10/man/dev/rtclock.html
new file mode 100644
index 0000000..9c13c0b
--- /dev/null
+++ b/os161-1.10/man/dev/rtclock.html
@@ -0,0 +1,28 @@
+<html>
+<head>
+<title>rtclock</title>
+<body bgcolor=#ffffff>
+<h2 align=center>rtclock</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+rtclock - realtime clock
+
+<h3>Synopsis</h3>
+device rtclock0 at ltimer*
+
+<h3>Description</h3>
+
+The rtclock device is the generalized interface to the time of day. It
+provides the in-kernel function gettime().
+<p>
+
+Only the first clock attached is used. If no clock at all is found,
+the system will panic if gettime() is called.
+<p>
+
+<h3>See Also</h3>
+<A HREF=ltimer.html>ltimer</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/Makefile b/os161-1.10/man/libc/Makefile
new file mode 100644
index 0000000..5bb456b
--- /dev/null
+++ b/os161-1.10/man/libc/Makefile
@@ -0,0 +1,6 @@
+# Man pages for libraries
+
+MANDIR=/man/libc
+
+include ../../defs.mk
+include ../../mk/man.mk
diff --git a/os161-1.10/man/libc/__vprintf.html b/os161-1.10/man/libc/__vprintf.html
new file mode 100644
index 0000000..1927e60
--- /dev/null
+++ b/os161-1.10/man/libc/__vprintf.html
@@ -0,0 +1,53 @@
+<html>
+<head>
+<title>__vprintf</title>
+<body bgcolor=#ffffff>
+<h2 align=center>__vprintf</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+__vprintf - printf backend
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+__vprintf(void (*<em>func</em>)(void *<em>clientdata</em>, 
+				const char *<em>str</em>, 
+				size_t <em>len</em>), 
+          void *<em>clientdata</em>, const char *<em>format</em>,
+	  va_list)
+
+<h3>Description</h3>
+
+In OS/161, __vprintf is the back-end engine for
+<A HREF=printf.html>printf</A> and printf-like functions. 
+Note that it is not portable - application code should use 
+<A HREF=snprintf.html>snprintf or vsnprintf</A> when implementing
+their own printf-like functions. This documentation is provided for
+use when extending OS/161 itself.
+<p>
+
+The <em>format</em> and subsequent arguments are treated as described
+under <A HREF=printf.html>printf</A>.
+<p>
+
+The <em>func</em> argument is called to print text generated by the
+formatting process. The <em>clientdata</em> argument is passed
+straight through __vprintf to <em>func</em>. The <em>str</em> argument
+to func points to some text that is to be printed; the <em>len</em>
+argument is the length of that string, which should not be assumed to
+be null-terminated.
+<p>
+
+The strings passed to <em>func</em> may be small; if printing is
+expensive buffering is probably indicated.
+
+<h3>Return Values</h3>
+__vprintf returns the number of characters printed.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/abort.html b/os161-1.10/man/libc/abort.html
new file mode 100644
index 0000000..5cbc1b7
--- /dev/null
+++ b/os161-1.10/man/libc/abort.html
@@ -0,0 +1,29 @@
+<html>
+<head>
+<title>abort</title>
+<body bgcolor=#ffffff>
+<h2 align=center>abort</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+abort - abnormal program termination
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;abort.h&gt;<br>
+<br>
+void<br>
+abort(void);
+
+<h3>Description</h3>
+
+The abort function causes immediate abnormal program termination.
+Cleanup is not performed.
+
+<h3>Return Values</h3>
+abort does not return.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/assert.html b/os161-1.10/man/libc/assert.html
new file mode 100644
index 0000000..8b83a79
--- /dev/null
+++ b/os161-1.10/man/libc/assert.html
@@ -0,0 +1,35 @@
+<html>
+<head>
+<title>assert</title>
+<body bgcolor=#ffffff>
+<h2 align=center>assert</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+assert - check assumptions at run time
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;assert.h&gt;<br>
+<br>
+assert(expression);
+
+<h3>Description</h3>
+
+assert checks that its argument evaluates to true. If this is not the
+case, an error message is printed and <A HREF=abort.html>abort</A> is
+called.
+<p>
+
+assert is a macro. If the macro NDEBUG is defined at compile time,
+assertion tests are removed.
+
+<h3>Caution</h3>
+
+Avoid writing assert expressions with side effects, as compiling with
+NDEBUG may or may not cause the side effects to disappear.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/atoi.html b/os161-1.10/man/libc/atoi.html
new file mode 100644
index 0000000..a1e8c22
--- /dev/null
+++ b/os161-1.10/man/libc/atoi.html
@@ -0,0 +1,32 @@
+<html>
+<head>
+<title>atoi</title>
+<body bgcolor=#ffffff>
+<h2 align=center>atoi</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+atoi - convert ascii to integer
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdlib.h&gt;<br>
+<br>
+int<br>
+atoi(const char *<em>string</em>);
+
+<h3>Description</h3>
+
+<em>string</em>, which should be a textual representation of an
+integer, is converted to the machine representation of that integer.
+Leading whitespace, if any, is skipped. Conversion stops when a
+non-numeric character is found.
+
+<h3>Return Values</h3>
+atoi returns the number converted. If no digits at all were found, it
+returns 0. 
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/bzero.html b/os161-1.10/man/libc/bzero.html
new file mode 100644
index 0000000..18382d2
--- /dev/null
+++ b/os161-1.10/man/libc/bzero.html
@@ -0,0 +1,26 @@
+<html>
+<head>
+<title>bzero</title>
+<body bgcolor=#ffffff>
+<h2 align=center>bzero</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+bzero - zero out memory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+void<br>
+bzero(void *<em>buf</em>, size_t <em>len</em>);
+
+<h3>Description</h3>
+
+The region of memory pointed to by <em>buf</em>, of length
+<em>len</em>, is zeroed out.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/calloc.html b/os161-1.10/man/libc/calloc.html
new file mode 100644
index 0000000..8d67243
--- /dev/null
+++ b/os161-1.10/man/libc/calloc.html
@@ -0,0 +1,37 @@
+<html>
+<head>
+<title>calloc</title>
+<body bgcolor=#ffffff>
+<h2 align=center>calloc</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+calloc - allocate and clear memory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdlib.h&gt;<br>
+<br>
+void *<br>
+calloc(size_t <em>number</em>, size_t <em>size</em>);
+
+<h3>Description</h3>
+
+calloc allocates <em>number</em>*<em>size</em> bytes of memory, zeros
+it, and returns a pointer to it. It is exactly equivalent to 
+<A HREF=malloc.html>malloc</A>(<em>number</em>*<em>size</em>) followed
+by <A HREF=bzero.html>bzero</A>.
+
+<h3>Return Values</h3>
+calloc returns a pointer to the memory allocated. If memory cannot be
+obtained, NULL is returned.
+
+<h3>See Also</h3>
+<A HREF=malloc.html>malloc</A>,
+<A HREF=realloc.html>realloc</A>,
+<A HREF=free.html>free</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/err.html b/os161-1.10/man/libc/err.html
new file mode 100644
index 0000000..8e4b026
--- /dev/null
+++ b/os161-1.10/man/libc/err.html
@@ -0,0 +1,60 @@
+<html>
+<head>
+<title>err</title>
+<body bgcolor=#ffffff>
+<h2 align=center>err</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+err - print error messages
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;err.h&gt;<br>
+<br>
+void<br>
+err(int <em>exitcode</em>, const char *<em>format</em>, ...);<br>
+<br>
+void<br>
+errx(int <em>exitcode</em>, const char *<em>format</em>, ...);<br>
+<br>
+void<br>
+verr(int <em>exitcode</em>, const char *<em>format</em>, va_list);<br>
+<br>
+void<br>
+verrx(int <em>exitcode</em>, const char *<em>format</em>, va_list);<br>
+
+<h3>Description</h3>
+
+The err, errx, verr, and verrx functions print error messages to
+the standard error stream.
+<p>
+
+errx prints the name of the program, a colon, the text generated by
+passing <em>format</em> and subsequent args through
+<A HREF=printf.html>printf</A>, and a newline. Then,
+<A HREF=exit.html>exit</A> is called and passed the supplied 
+<em>exitcode</em>.
+<p>
+
+err does the same thing, except that a colon and the error string
+for the current error (obtained by calling 
+<A HREF=strerror.html>strerror</A> on 
+<A HREF=../syscall/errno.html>errno</A>) are printed prior to the
+newline.
+<p>
+
+verrx and verr are the same as errx and err respectively, except
+that the additional arguments for printf are taken to have been
+already packaged up in a va_list by use of the
+<A HREF=stdarg.html>stdarg</A> facility.
+<p>
+
+<h3>See Also</h3>
+
+<A HREF=warn.html>warn</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/exit.html b/os161-1.10/man/libc/exit.html
new file mode 100644
index 0000000..3f9cbd4
--- /dev/null
+++ b/os161-1.10/man/libc/exit.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>exit</title>
+<body bgcolor=#ffffff>
+<h2 align=center>exit</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+exit - terminate program
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdlib.h&gt;<br>
+<br>
+int<br>
+exit(int <em>code</em>);
+
+<h3>Description</h3>
+
+exit causes the program to exit. It calls internal cleanup routines,
+and then performs the actual exit by calling 
+<A HREF=../syscall/_exit.html>_exit</A>.
+
+<h3>Return Values</h3>
+exit does not return.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/free.html b/os161-1.10/man/libc/free.html
new file mode 100644
index 0000000..566fc3c
--- /dev/null
+++ b/os161-1.10/man/libc/free.html
@@ -0,0 +1,58 @@
+<html>
+<head>
+<title>free</title>
+<body bgcolor=#ffffff>
+<h2 align=center>free</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+free - release/deallocate memory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdlib.h&gt;<br>
+<br>
+void<br>
+malloc(void *<em>ptr</em>);
+
+<h3>Description</h3>
+
+free releases a block of memory previously allocated with
+<A HREF=malloc.html>malloc</A>, <A HREF=calloc.html>calloc</A>,
+or <A HREF=realloc.html>realloc</A>.
+<p>
+
+Once free has been called, <em>ptr</em> is no longer valid and
+attempts to dereference it result in undefined behavior.
+(Pedantically, in fact, even using the <strong>value</strong> of
+<em>ptr</em> may produce undefined behavior.) Passing <em>ptr</em> to
+free a second or subsequent time (unless of course the same pointer
+value is again returned from malloc) is particularly likely to provoke
+undefined behavior in most implementations.
+<p>
+
+free(NULL) has no effect.
+<p>
+
+In practice it is desirable for implementations of free to detect, to
+the extent practically possible, pointers that were not previously
+allocated by one of the above functions or that are passed to free
+multiple times. However, this can be difficult and there is no useful
+standard mechanism for error reporting.
+<p>
+
+free does not necessarily unmap free memory or return it to the
+operating system, but may do so if it chooses.
+
+<h3>Return Values</h3>
+free returns no value.
+
+<h3>See Also</h3>
+<A HREF=calloc.html>calloc</A>,
+<A HREF=malloc.html>malloc</A>,
+<A HREF=realloc.html>realloc</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/getchar.html b/os161-1.10/man/libc/getchar.html
new file mode 100644
index 0000000..a3dadfa
--- /dev/null
+++ b/os161-1.10/man/libc/getchar.html
@@ -0,0 +1,36 @@
+<html>
+<head>
+<title>getchar</title>
+<body bgcolor=#ffffff>
+<h2 align=center>getchar</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+getchar - read character from standard input
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdio.h&gt;<br>
+<br>
+int<br>
+getchar(void);
+
+<h3>Description</h3>
+
+getchar reads a single character from standard input. The character is
+converted to unsigned char before being returned; thus, EOF, which is
+negative, is not a possible successful return value.
+
+<h3>Return Values</h3>
+On success, getchar returns the character read. On error, or end of
+file, EOF is returned.
+
+<h3>Errors</h3>
+
+Any of the errors associated with <A HREF=../syscall/read>read</A>
+may occur.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/getcwd.html b/os161-1.10/man/libc/getcwd.html
new file mode 100644
index 0000000..b1b903c
--- /dev/null
+++ b/os161-1.10/man/libc/getcwd.html
@@ -0,0 +1,53 @@
+<html>
+<head>
+<title>getcwd</title>
+<body bgcolor=#ffffff>
+<h2 align=center>getcwd</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+getcwd - get name of current working directory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+char *<br>
+getcwd(char *<em>buf</em>, size_t <em>buflen</em>);
+
+<h3>Description</h3>
+
+The name of the current directory is computed and stored in
+<em>buf</em>, an area of size <em>buflen</em>. The resulting string is
+0-terminated.
+<p>
+
+This call is a wrapper (for Unix compatibility) around the system call
+<A HREF=../syscall/__getcwd.html>__getcwd</A>.
+<p>
+
+Note, however, that the BSD extension whereby space is allocated with
+<A HREF=malloc.html>malloc</A> if <em>buf</em> is NULL is not supported.
+
+<h3>Return Values</h3>
+On success, getcwd returns <em>buf</em>.
+On error, NULL is returned, and <A HREF=errno.html>errno</A>
+is set according to the error encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENOENT</td>	<td>A component of the pathname no longer exists.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>buf</em> points to an invalid address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/index.html b/os161-1.10/man/libc/index.html
new file mode 100644
index 0000000..aaa8634
--- /dev/null
+++ b/os161-1.10/man/libc/index.html
@@ -0,0 +1,64 @@
+<html>
+<head>
+<title>OS/161 C Standard Library</title>
+</head>
+<body bgcolor=#ffffff>
+
+<h2 align=center>OS/161 C Standard Library (libc)</h2>
+
+<p align=center>
+<A HREF=..>Top</A> |
+<A HREF=../bin>Binaries</A> |
+<A HREF=../sbin>Sysadmin binaries</A> |
+<A HREF=../testbin>Test binaries</A> |
+<A HREF=../syscall>System calls</A> |
+<A HREF=../dev>Device drivers</A> |
+<A HREF=../misc>Miscellaneous</A>
+</p>
+<br>
+
+<ul>
+<li> <A HREF=__vprintf.html>__vprintf</A> - printf backend
+<li> <A HREF=abort.html>abort</A> - abnormal program termination
+<li> <A HREF=assert.html>assert</A> - check assumptions at run time
+<li> <A HREF=atoi.html>atoi</A> - convert ascii to integer
+<li> <A HREF=bzero.html>bzero</A> - zero out memory
+<li> <A HREF=calloc.html>calloc</A> - allocate and clear memory
+<li> <A HREF=err.html>err, errx</A> - print error messages
+<li> <A HREF=exit.html>exit</A> - terminate program
+<li> <A HREF=free.html>free</A> - release/deallocate memory
+<li> <A HREF=getchar.html>getchar</A> - read character from standard input
+<li> <A HREF=getcwd.html>getcwd</A> - get name of current working directory
+<li> <A HREF=setjmp.html>longjmp</A> - non-local jump operations
+<li> <A HREF=malloc.html>malloc</A> - allocate memory
+<li> <A HREF=memcpy.html>memcpy</A> - copy region of memory
+<li> <A HREF=memmove.html>memmove</A> - copy region of memory
+<li> <A HREF=memset.html>memset</A> - initialize region of memory
+<li> <A HREF=printf.html>printf</A> - print formatted output
+<li> <A HREF=putchar.html>putchar</A> - print character to standard output
+<li> <A HREF=puts.html>puts</A> - print string to standard output
+<li> <A HREF=random.html>random</A> - pseudorandom number generation
+<li> <A HREF=realloc.html>realloc</A> - resize allocated memory
+<li> <A HREF=setjmp.html>setjmp</A> - non-local jump operations
+<li> <A HREF=snprintf.html>snprintf</A> - print formatted text to string
+<li> <A HREF=stdarg.html>stdarg</A> - handle functions with variable arguments
+<li> <A HREF=strcat.html>strcat</A> - concatenate strings
+<li> <A HREF=strchr.html>strchr</A> - search string for character
+<li> <A HREF=strcmp.html>strcmp</A> - compare strings
+<li> <A HREF=strcpy.html>strcpy</A> - copy string
+<li> <A HREF=strerror.html>strerror</A> - get error message for error code
+<li> <A HREF=strlen.html>strlen</A> - determine length of string
+<li> <A HREF=strrchr.html>strrchr</A> - search string for character
+<li> <A HREF=strtok.html>strtok</A> - tokenize string
+<li> <A HREF=strtok_r.html>strtok_r</A> - tokenize string reentrantly
+<li> <A HREF=system.html>system</A> - run command as subprocess
+<li> <A HREF=time.html>time</A> - get time of day
+<li> <A HREF=err.html>verr, verrx</A> - print error messages
+<li> <A HREF=printf.html>vprintf</A> - print formatted output
+<li> <A HREF=snprintf.html>vsnprintf</A> - print formatted text to string
+<li> <A HREF=warn.html>vwarn, vwarnx</A> - print warning messages
+<li> <A HREF=warn.html>warn, warnx</A> - print warning messages
+</ul>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/malloc.html b/os161-1.10/man/libc/malloc.html
new file mode 100644
index 0000000..a0c2862
--- /dev/null
+++ b/os161-1.10/man/libc/malloc.html
@@ -0,0 +1,57 @@
+<html>
+<head>
+<title>malloc</title>
+<body bgcolor=#ffffff>
+<h2 align=center>malloc</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+malloc - allocate memory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdlib.h&gt;<br>
+<br>
+void *<br>
+malloc(size_t <em>size</em>);
+
+<h3>Description</h3>
+
+malloc allocates <em>size</em> bytes of memory and returns a pointer
+to it. The memory is not necessarily zero-filled. (To get zero-filled
+memory, call <A HREF=bzero.html>bzero</A> or 
+<A HREF=memset.html>memset</A>, or use
+<A HREF=calloc.html>calloc</A>.) 
+<p>
+
+The pointer returned must be suitably aligned for use with any data
+type.
+<p>
+
+When asked to allocate zero bytes, malloc may either always return
+NULL, or may return distinct non-null pointers that do not point to
+any storage.
+<p>
+
+While malloc may at its option allocate more than <em>size</em> bytes
+to fill a request, code that calls malloc may not depend on such
+behavior and must not perform any accesses outside of the bounds
+defined by <em>size</em>.
+<p>
+
+It is legitimate for memory returned by malloc to not actually be
+physically mapped until it is used.
+
+<h3>Return Values</h3>
+malloc returns a pointer to the memory allocated. If memory cannot be
+obtained, NULL is returned.
+
+<h3>See Also</h3>
+<A HREF=calloc.html>calloc</A>,
+<A HREF=realloc.html>realloc</A>,
+<A HREF=free.html>free</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/memcpy.html b/os161-1.10/man/libc/memcpy.html
new file mode 100644
index 0000000..2edb1bb
--- /dev/null
+++ b/os161-1.10/man/libc/memcpy.html
@@ -0,0 +1,35 @@
+<html>
+<head>
+<title>memcpy</title>
+<body bgcolor=#ffffff>
+<h2 align=center>memcpy</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+memcpy - copy region of memory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+void *<br>
+memcpy(void *<em>dest</em>, const void *<em>src</em>, size_t <em>len</em>);
+
+<h3>Description</h3>
+
+The block of memory beginning at <em>src</em>, of length <em>len</em>,
+is copied to <em>dest</em>. <em>dest</em> must point to a region large
+enough to hold it.
+<p>
+
+memcpy is not guaranteed to operate correctly if <em>src</em> and
+<em>dest</em> overlap. Use <A HREF=memmove.html>memmove</A> on
+overlapping regions.
+
+<h3>Return Values</h3>
+memcpy returns <em>dest</em>.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/memmove.html b/os161-1.10/man/libc/memmove.html
new file mode 100644
index 0000000..1611c70
--- /dev/null
+++ b/os161-1.10/man/libc/memmove.html
@@ -0,0 +1,34 @@
+<html>
+<head>
+<title>memmove</title>
+<body bgcolor=#ffffff>
+<h2 align=center>memmove</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+memmove - copy region of memory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+void *<br>
+memmove(void *<em>dest</em>, const void *<em>src</em>, size_t <em>len</em>);
+
+<h3>Description</h3>
+
+The block of memory beginning at <em>src</em>, of length <em>len</em>,
+is copied to <em>dest</em>. <em>dest</em> must point to a region large
+enough to hold it.
+<p>
+
+Unlike <A HREF=memcpy.html>memcpy</A>, memmove is guaranteed to
+operate correctly if <em>src</em> and <em>dest</em> overlap.
+
+<h3>Return Values</h3>
+memmove returns <em>dest</em>.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/memset.html b/os161-1.10/man/libc/memset.html
new file mode 100644
index 0000000..3aab74b
--- /dev/null
+++ b/os161-1.10/man/libc/memset.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>memset</title>
+<body bgcolor=#ffffff>
+<h2 align=center>memset</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+memset - initialize region of memory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+void *<br>
+memset(void *<em>buf</em>, int <em>chr</em>, size_t <em>len</em>);
+
+<h3>Description</h3>
+
+The memory region pointed to by <em>buf</em>, of length <em>len</em>,
+is initialized by setting each location of it to <em>chr</em>
+(converted to unsigned char).
+
+<h3>Return Values</h3>
+memset returns <em>buf</em>.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/printf.html b/os161-1.10/man/libc/printf.html
new file mode 100644
index 0000000..1e6e431
--- /dev/null
+++ b/os161-1.10/man/libc/printf.html
@@ -0,0 +1,93 @@
+<html>
+<head>
+<title>printf</title>
+<body bgcolor=#ffffff>
+<h2 align=center>printf</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+printf - print formatted output
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdio.h&gt;<br>
+<br>
+int<br>
+printf(const char *<em>format</em>, ...);
+
+<h3>Description</h3>
+
+printf prints formatted text to standard output. The text is generated
+from the <em>format</em> argument and subsequent arguments according
+to the following rules.
+<p>
+
+Characters in <em>format</em> that are not the percent sign (`%') are
+printed verbatim. When a percent sign is encountered, the next
+argument of the arguments following <em>format</em> is retrieved and
+printed. The type of the argument expected, as well as some simple
+formatting instructions, are derived from the characters following the
+percent sign.
+<p>
+
+The following characters designate types to print. One of these
+characters concludes the format sequence begun with a percent sign,
+and also determines the type expected as an argument.
+
+<blockquote>
+<table width=90%>
+<tr><td width=5%>%</td>	<td>A percent sign is printed; no argument 
+				is consumed.</td></tr>
+<tr><td>c</td>	<td>Character (char, passed as int)</td></tr>
+<tr><td>d</td>	<td>Signed integer printed in decimal</td></tr>
+<tr><td>o</td>	<td>Unsigned integer printed in octal</td></tr>
+<tr><td>p</td>	<td>Pointer (void *)</td></tr>
+<tr><td>s</td>	<td>String (const char *)</td></tr>
+<tr><td>u</td>	<td>Unsigned integer printed in decimal</td></tr>
+<tr><td>x</td>	<td>Unsigned integer printed in hexadecimal</td></tr>
+<tr><td>X</td>	<td>Unsigned integer printed in uppercase hex</td></tr>
+</table>
+</blockquote>
+
+The following characters are modifiers; they can be found between the
+percent sign and the type designator.
+
+<blockquote>
+<table width=90%>
+<tr><td width=5% valign=top>#</td> <td>Select an "alternate
+				format". On integer formats this
+				causes the C base prefix to be printed
+				along with the integer. On other
+				formats, this has no effect.</td></tr>
+<tr><td valign=top>l</td> <td>Assume an integer argument is long or
+				unsigned long instead of int or
+				unsigned int.</td></tr> 
+<tr><td valign=top>0-9</td> <td>Digits are treated as a decimal number,
+				which is considered to be the field
+				width. The argument is printed 
+				right-aligned in a field that many
+				characters wide.</td></tr>
+<tr><td valign=top>0</td> <td>If the field width has a leading 0, the
+				padding character for alignment is
+				made 0 (zero) instead of
+				space.</td></tr>
+<tr><td valign=top>-</td> <td>If a field width is given, use it for
+				left alignment instead of right
+				alignment.</td></tr>
+</table>
+</blockquote>
+
+<h3>Restrictions</h3>
+
+Note that this is a limited printf implementation - it has no support
+for precisions (".number" as a modifier), floating-point formats,
+field widths passed as arguments, or the rarely-used `+' and ` '
+modifiers.
+
+<h3>Return Values</h3>
+printf returns the number of characters printed.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/putchar.html b/os161-1.10/man/libc/putchar.html
new file mode 100644
index 0000000..e86dca2
--- /dev/null
+++ b/os161-1.10/man/libc/putchar.html
@@ -0,0 +1,35 @@
+<html>
+<head>
+<title>putchar</title>
+<body bgcolor=#ffffff>
+<h2 align=center>putchar</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+putchar - print character to standard output
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdio.h&gt;<br>
+<br>
+int<br>
+putchar(int <em>chr</em>);
+
+<h3>Description</h3>
+
+putchar writes its argument to standard output.
+
+<h3>Return Values</h3>
+putchar returns <em>chr</em>. On error, EOF is returned, and
+<A HREF=../syscall/errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+Any of the errors from <A HREF=../syscall/write.html>write</A> may
+occur.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/puts.html b/os161-1.10/man/libc/puts.html
new file mode 100644
index 0000000..7e1575b
--- /dev/null
+++ b/os161-1.10/man/libc/puts.html
@@ -0,0 +1,36 @@
+<html>
+<head>
+<title>puts</title>
+<body bgcolor=#ffffff>
+<h2 align=center>puts</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+puts - print string to standard output
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdio.h&gt;<br>
+<br>
+int<br>
+puts(const char *<em>string</em>);
+
+<h3>Description</h3>
+
+The string <em>string</em>, and a following newline character, is
+printed on the standard output.
+
+<h3>Return Values</h3>
+On success, puts returns a nonnegative integer. On error, -1 is
+returned, and <A HREF=../syscall/errno.html>errno</A> is set 
+according to the error encountered.
+
+<h3>Errors</h3>
+
+Any of the errors from <A HREF=../syscall/write.html>write</A> may
+occur.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/random.html b/os161-1.10/man/libc/random.html
new file mode 100644
index 0000000..9de279c
--- /dev/null
+++ b/os161-1.10/man/libc/random.html
@@ -0,0 +1,43 @@
+<html>
+<head>
+<title>random</title>
+<body bgcolor=#ffffff>
+<h2 align=center>random</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+random - pseudorandom number generation
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdlib.h&gt;<br>
+<br>
+long<br>
+random(void);<br>
+<br>
+void<br>
+srandom(unsigned long <em>seed</em>);<br>
+
+<h3>Description</h3>
+
+random returns a number between 0 and 0x7fffffff (RAND_MAX). This
+number is selected using a rather complex generator which is believed
+to generate randomness of an acceptable (though not cryptographic)
+quality. Unlike with some generators, all bits of the values returned
+are random.
+<p>
+
+srandom initializes the generator state based on the passed-in
+<em>seed</em>. If srandom is not called, the sequence of numbers
+returned by random is the same as if srandom had been called with a
+<em>seed</em> of 1.
+<p>
+
+The implementation of random and srandom used in OS/161 is software
+developed by the University of California, Berkeley and its
+contributors.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/realloc.html b/os161-1.10/man/libc/realloc.html
new file mode 100644
index 0000000..3a3876b
--- /dev/null
+++ b/os161-1.10/man/libc/realloc.html
@@ -0,0 +1,56 @@
+<html>
+<head>
+<title>realloc</title>
+<body bgcolor=#ffffff>
+<h2 align=center>realloc</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+realloc - resize allocated memory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdlib.h&gt;<br>
+<br>
+void *<br>
+realloc(void *<em>ptr</em>, size_t <em>newsize</em>);
+
+<h3>Description</h3>
+
+realloc attempts to change the size of the memory block pointed to by
+<em>ptr</em> to <em>newsize</em>, causing the block to shrink or grow
+as necessary. The size of NULL is treated as 0. Any newly allocated
+space has undefined contents; the contents of existing space not
+discarded by shrinkage are preserved.
+<p>
+
+<em>ptr</em> be NULL or have been previously returned by
+<A HREF=malloc.html>malloc</A>, <A HREF=calloc.html>calloc</A>, or
+realloc.
+<p>
+
+The alignment and other restrictions described for 
+<A HREF=malloc.html>malloc</A> apply equally to realloc.
+<p>
+
+<h3>Return Values</h3>
+realloc returns a pointer to the resized memory block. This may not be
+the same pointer as <em>ptr</em> if for internal reasons it is
+necessary to move the memory block. If such a move takes place, the
+old block is invalidated and <em>ptr</em> becomes invalid.
+<p>
+
+If the resize operation cannot be performed, NULL is returned, in
+which case the original block pointed to by <em>ptr</em> is untouched
+and remains valid.
+<p>
+
+<h3>See Also</h3>
+<A HREF=calloc.html>calloc</A>,
+<A HREF=malloc.html>malloc</A>,
+<A HREF=free.html>free</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/setjmp.html b/os161-1.10/man/libc/setjmp.html
new file mode 100644
index 0000000..771c8e4
--- /dev/null
+++ b/os161-1.10/man/libc/setjmp.html
@@ -0,0 +1,45 @@
+<html>
+<head>
+<title>setjmp</title>
+<body bgcolor=#ffffff>
+<h2 align=center>setjmp</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+setjmp, longjmp - non-local jump operations
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;setjmp.h&gt;<br>
+<br>
+int<br>
+setjmp(jmp_buf <em>jb</em>);<br>
+<br>
+void<br>
+longjmp(jmp_buf <em>jb</em>, int <em>returncode</em>);<br>
+
+<h3>Description</h3>
+
+setjmp saves the current stack frame and processor state in
+<em>jb</em>. A subsequent call to longjmp with the same <em>jb</em>
+causes execution to jump to where setjmp was called from.
+<p>
+
+If the stack frame that called setjmp returns before longjmp is
+called, the results are undefined.
+<p>
+
+<h3>Return Values</h3>
+
+When called, setjmp returns 0. When longjmp is called, it does not
+itself return, but instead causes setjmp to appear to return again,
+this time returning <em>returncode</em>.
+<p>
+
+If zero is passed <em>returncode</em>, it is forced to 1 instead.
+<p>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/snprintf.html b/os161-1.10/man/libc/snprintf.html
new file mode 100644
index 0000000..6ff9c27
--- /dev/null
+++ b/os161-1.10/man/libc/snprintf.html
@@ -0,0 +1,44 @@
+<html>
+<head>
+<title>snprintf</title>
+<body bgcolor=#ffffff>
+<h2 align=center>snprintf</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+snprintf - print formatted text to string
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+snprintf(char *<em>buf</em>, size_t <em>buflen</em>, 
+const char *<em>format</em>, ...);<br>
+<br>
+int<br>
+vsnprintf(char *<em>buf</em>, size_t <em>buflen</em>, 
+const char *<em>format</em>, va_list);<br>
+
+<h3>Description</h3>
+
+snprintf performs <A HREF=printf.html>printf</A>-style formatting on
+the string <em>format</em> and subsequent arguments. The resulting
+string is placed in <em>buf</em>, which is a memory area at least
+<em>buflen</em> bytes long. A null terminator is always added to
+<em>buf</em>; the space for this is presumed to be counted in
+<em>buflen</em>.
+<p>
+
+vsnprintf is the same as snprintf, except that the subsequent
+arguments are presumed to have already been collected using the
+<A HREF=stdarg.html>stdarg</A> facility.
+<p>
+
+<h3>Return Values</h3>
+snprintf and vsnprintf return the number of characters printed.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/stdarg.html b/os161-1.10/man/libc/stdarg.html
new file mode 100644
index 0000000..9c42d41
--- /dev/null
+++ b/os161-1.10/man/libc/stdarg.html
@@ -0,0 +1,79 @@
+<html>
+<head>
+<title>stdarg</title>
+<body bgcolor=#ffffff>
+<h2 align=center>stdarg</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+stdarg - handle functions with variable arguments
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdarg.h&gt;<br>
+<br>
+va_start(va_list <em>ap</em>, <em>start-argument</em>);<br>
+<br>
+va_end(va_list <em>ap</em>);<br>
+<br>
+<em>type</em><br>
+va_arg(va_list <em>ap</em>, <em>type</em>);<br>
+<br>
+va_copy(va_list <em>dest</em>, va_list <em>src</em>);<br>
+
+<h3>Description</h3>
+
+Functions where the number of arguments is not fixed at compile time
+can be written using the stdarg facility. This provides a type,
+va_list, and the macros listed above, which allow iterating through
+the arguments.
+<p>
+
+va_start initializes a va_list <em>ap</em> to point to the current
+function's arguments. The <em>start-argument</em> argument should be
+the name of the last fixed parameter in the calling sequence.
+<p>
+
+va_end cleans up a va_list once it is no longer needed. While failure
+to use va_end may have no effect on some architectures (in fact, in
+some cases va_end does nothing at all) on other architectures it may
+be fatal.
+<p>
+
+va_arg retrieves the next argument, which is presumed to be of type
+<em>type</em>. The function must have some way to determine what types
+to expect, and how many arguments, as this information cannot be
+extracted from the argument list itself. To rewind, use va_end and
+then va_start again. 
+<p>
+
+Remember that default C argument promotions occur when passing the
+variable arguments. There is no run-time checking of any kind, and
+little to no compile-time checking: if you retrieve a type different
+from that which was passed using va_arg, you will silently get garbage
+for that and all subsequent arguments.
+<p>
+
+va_copy assigns a copy of <em>src</em> to <em>dest</em>. Subsequent
+operations on either will not affect the other.
+<p>
+
+<h3>Restrictions</h3>
+
+Because the va_list is not necessarily a simple type, but may involve
+pointers to state maintained elsewhere, it is not necessarily a simple
+value. Thus, assigning va_lists to each other with `=', memcpy, or the
+like, or passing them to functions, may not give multiple independent
+objects. When in doubt, use va_copy, or invoke va_start multiple
+times.
+<p>
+
+<h3>Return Values</h3>
+
+va_start, va_end, and va_copy do not return anything. va_arg returns
+the value of the requested argument.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strcat.html b/os161-1.10/man/libc/strcat.html
new file mode 100644
index 0000000..6b5baf6
--- /dev/null
+++ b/os161-1.10/man/libc/strcat.html
@@ -0,0 +1,38 @@
+<html>
+<head>
+<title>strcat</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strcat</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strcat - concatenate strings
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+char *<br>
+strcat(char *<em>dest</em>, const char *<em>src</em>);
+
+<h3>Description</h3>
+
+strcat appends the contents of the string <em>src</em> to the string
+<em>dest</em>. 
+
+<h3>Restrictions</h3>
+
+If <em>dest</em> does not point to enough space to hold both strings,
+the resulting behavior is undefined.
+<p>
+
+If the memory areas pointed to by <em>dest</em> and <em>src</em>
+overlap, the behavior is undefined.
+
+<h3>Return Values</h3>
+strcat returns <em>dest</em>.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strchr.html b/os161-1.10/man/libc/strchr.html
new file mode 100644
index 0000000..055eace
--- /dev/null
+++ b/os161-1.10/man/libc/strchr.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>strchr</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strchr</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strchr - search string for character
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+char *<br>
+strchr(const char *<em>string</em>, int <em>chr</em>);
+
+<h3>Description</h3>
+
+strchr searches <em>string</em> from the left for the first instance
+of the character <em>chr</em>.
+
+<h3>Return Values</h3>
+strchr returns a pointer to the character found. If the character is
+not found, NULL is returned.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strcmp.html b/os161-1.10/man/libc/strcmp.html
new file mode 100644
index 0000000..5ad9ab8
--- /dev/null
+++ b/os161-1.10/man/libc/strcmp.html
@@ -0,0 +1,37 @@
+<html>
+<head>
+<title>strcmp</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strcmp</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strcmp - compare strings
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+int<br>
+strcmp(const char *<em>str1</em>, const char *<em>str2</em>);
+
+<h3>Description</h3>
+
+The two strings <em>str1</em> and <em>str2</em> are compared
+lexicographically.
+
+<h3>Return Values</h3>
+
+If <em>str1</em> sorts before <em>str2</em>, -1 is returned.
+<p>
+
+If <em>str1</em> sorts after <em>str2</em>, 1 is returned.
+<p>
+
+If <em>str1</em> is the same as <em>str2</em>, 0 is returned.
+<p>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strcpy.html b/os161-1.10/man/libc/strcpy.html
new file mode 100644
index 0000000..ebbf224
--- /dev/null
+++ b/os161-1.10/man/libc/strcpy.html
@@ -0,0 +1,38 @@
+<html>
+<head>
+<title>strcpy</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strcpy</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strcpy - copy string
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+char *<br>
+strcpy(char *<em>dest</em>, const char *<em>src</em>);
+
+<h3>Description</h3>
+
+The contents of the string <em>src</em> are copied into
+<em>dest</em>.
+
+<h3>Restrictions</h3>
+
+If <em>dest</em> does not point to enough space to hold the string,
+the resulting behavior is undefined.
+<p>
+
+If the memory areas pointed to by <em>dest</em> and <em>src</em>
+overlap, the behavior is undefined.
+
+<h3>Return Values</h3>
+strcpy returns <em>dest</em>.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strerror.html b/os161-1.10/man/libc/strerror.html
new file mode 100644
index 0000000..7bb4afc
--- /dev/null
+++ b/os161-1.10/man/libc/strerror.html
@@ -0,0 +1,36 @@
+<html>
+<head>
+<title>strerror</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strerror</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strerror - get error message for error code
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+const char *<br>
+strerror(int <em>code</em>);
+
+<h3>Description</h3>
+
+The error string for the error specified by <em>code</em> (see
+<A HREF=../syscall/errno.html>errno</A> for more information) is
+retrieved.
+<p>
+
+It is not itself an error to request error strings for out-of-range
+values of <em>code</em>, but the string returned under such
+circumstances may not be very enlightening when printed.
+
+<h3>Return Values</h3>
+
+The error string is returned.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strlen.html b/os161-1.10/man/libc/strlen.html
new file mode 100644
index 0000000..98de59f
--- /dev/null
+++ b/os161-1.10/man/libc/strlen.html
@@ -0,0 +1,26 @@
+<html>
+<head>
+<title>strlen</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strlen</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strlen - determine length of string
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+size_t<br>
+strlen(const char *<em>string</em>);
+
+<h3>Description</h3>
+
+strlen returns the length of the string <em>string</em>. The length
+does not include the null terminator.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strrchr.html b/os161-1.10/man/libc/strrchr.html
new file mode 100644
index 0000000..5e178c1
--- /dev/null
+++ b/os161-1.10/man/libc/strrchr.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>strrchr</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strrchr</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strrchr - search string for character
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+char *<br>
+strrchr(const char *<em>string</em>, int <em>chr</em>);
+
+<h3>Description</h3>
+
+strrchr searches <em>string</em> from the right for the first instance
+of the character <em>chr</em>. 
+
+<h3>Return Values</h3>
+strrchr returns a pointer to the character found. If the character is
+not found, NULL is returned.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strtok.html b/os161-1.10/man/libc/strtok.html
new file mode 100644
index 0000000..d27deeb
--- /dev/null
+++ b/os161-1.10/man/libc/strtok.html
@@ -0,0 +1,57 @@
+<html>
+<head>
+<title>strtok</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strtok</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strtok - tokenize string
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+char *<br>
+strtok(char *<em>string</em>, const char *<em>separators</em>);
+
+<h3>Description</h3>
+
+strtok splits up the string <em>string</em> into fields using the
+characters found in <em>separators</em> as delimiters. The delimiters
+found are discarded. Multiple delimiter characters in a row are
+treated as a single delimiter.
+<p>
+
+When first called, strtok returns the first field of <em>string</em>.
+To retrieve successive fields of <em>string</em>, call strtok again
+repeatedly, passing NULL as the first argument. When no more fields
+are left, NULL is returned. If the string is empty or contains only
+delimiters, NULL will be returned on the first call.
+<p>
+
+<h3>Cautions</h3>
+
+Note that the state used to remember <em>string</em> across calls is
+global. Thus, strtok cannot be used from more than one thread at a
+time in a multithreaded program, nor can it be used in a subroutine
+called from within a loop that itself uses strtok. If these
+restrictions are problematic, use <A HREF=strtok_r.html>strtok_r</A>.
+<p>
+
+The behavior if strtok is called again without passing a new
+<em>string</em> after it has returned NULL is undefined.
+<p>
+
+The behavior if strtok is called with the first argument NULL without
+having first passed a valid <em>string</em> is also undefined.
+<p>
+
+<h3>Return Values</h3>
+strtok returns successive components of the passed-in string, and
+NULL when no more remain.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/strtok_r.html b/os161-1.10/man/libc/strtok_r.html
new file mode 100644
index 0000000..404bce8
--- /dev/null
+++ b/os161-1.10/man/libc/strtok_r.html
@@ -0,0 +1,39 @@
+<html>
+<head>
+<title>strtok_r</title>
+<body bgcolor=#ffffff>
+<h2 align=center>strtok_r</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+strtok_r - tokenize string reentrantly
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;string.h&gt;<br>
+<br>
+char *<br>
+strtok_r(char *<em>string</em>, const char *<em>separators</em>,
+char **<em>context</em>);
+
+<h3>Description</h3>
+
+strtok_r is a reentrant version of <A HREF=strtok.html>strtok</A>. It
+behaves the same way, except that the internal state is kept using the
+<em>context</em> parameter rather than being global.
+<p>
+
+The value passed to the <em>context</em> parameter should be the
+address of a char * whose value is preserved between successive
+related calls to strtok_r. The char * need not be initialized
+before the first call, and its value should not be inspected.
+<p>
+
+<h3>Return Values</h3>
+strtok_r returns successive components of the passed-in string, and
+NULL when no more remain.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/system.html b/os161-1.10/man/libc/system.html
new file mode 100644
index 0000000..684f32a
--- /dev/null
+++ b/os161-1.10/man/libc/system.html
@@ -0,0 +1,49 @@
+<html>
+<head>
+<title>system</title>
+<body bgcolor=#ffffff>
+<h2 align=center>system</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+system - run command as subprocess
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;stdlib.h&gt;<br>
+<br>
+int<br>
+system(const char *<em>command</em>);
+
+<h3>Description</h3>
+
+The system routine executes <em>command</em> as if it were typed into
+the shell.
+
+<h3>Return Values</h3>
+On success, system returns the exit status returned from 
+<A HREF=../syscall/waitpid.html>waitpid</A>. 
+On error, -1 is returned, and <A HREF=../syscall/errno.html>errno</A> 
+is set according to the error encountered.
+
+<h3>Errors</h3>
+
+Any of the errors from <A HREF=../syscall/fork.html>fork</A> or
+<A HREF=../syscall/waitpid.html>waitpid</A>. Errors generated during
+<A HREF=../syscall/execv.html>execv</A> cannot readily be reported
+back in detail.
+
+<h3>Restrictions</h3>
+
+Because the OS/161 base system does not include a shell and makes no
+assumptions about the shell's operation, system() cannot actually
+reliably use the shell to parse and execute <em>command</em>.
+Consequently, system() does it itself, in a way which may not
+necessarily be compatible with the shell as it finally appears. You
+may want to change system() to invoke the shell once the shell is
+available.
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/time.html b/os161-1.10/man/libc/time.html
new file mode 100644
index 0000000..a83018b
--- /dev/null
+++ b/os161-1.10/man/libc/time.html
@@ -0,0 +1,47 @@
+<html>
+<head>
+<title>time</title>
+<body bgcolor=#ffffff>
+<h2 align=center>time</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+time - get time of day
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;time.h&gt;<br>
+<br>
+time_t<br>
+time(time_t *<em>ptr</em>);
+
+<h3>Description</h3>
+
+The current time (in seconds since midnight GMT on January 1, 1970) is
+retrieved. If <em>ptr</em> is non-null, the time is stored through
+<em>ptr</em>. The time is also returned.
+<p>
+
+time is a wrapper around the system call
+<A HREF=../syscall/__time.html>__time</A>, which returns nanoseconds
+as well as seconds.
+
+<h3>Return Values</h3>
+
+time returns the time. On error, -1 is returned, and errno is set to
+indicate the error.
+
+<h3>Errors</h3>
+
+The following error is the only way time should be capable of failing.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EFAULT</td>	<td><em>ptr</em> was an invalid non-NULL
+			address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/libc/warn.html b/os161-1.10/man/libc/warn.html
new file mode 100644
index 0000000..a2544d8
--- /dev/null
+++ b/os161-1.10/man/libc/warn.html
@@ -0,0 +1,58 @@
+<html>
+<head>
+<title>warn</title>
+<body bgcolor=#ffffff>
+<h2 align=center>warn</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+warn, warnx, vwarn, vwarnx - print warning messages
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;err.h&gt;<br>
+<br>
+void<br>
+warn(const char *<em>format</em>, ...);<br>
+<br>
+void<br>
+warnx(const char *<em>format</em>, ...);<br>
+<br>
+void<br>
+vwarn(const char *<em>format</em>, va_list);<br>
+<br>
+void<br>
+vwarnx(const char *<em>format</em>, va_list);<br>
+
+<h3>Description</h3>
+
+The warn, warnx, vwarn, and vwarnx functions print warning messages to
+the standard error stream.
+<p>
+
+warnx prints the name of the program, a colon, the text generated by
+passing <em>format</em> and subsequent args through
+<A HREF=printf.html>printf</A>, and a newline.
+<p>
+
+warn prints the same thing, except that a colon and the error string
+for the current error (obtained by calling 
+<A HREF=strerror.html>strerror</A> on 
+<A HREF=../syscall/errno.html>errno</A>) are printed prior to the
+newline.
+<p>
+
+vwarnx and vwarn are the same as warnx and warn respectively, except
+that the additional arguments for printf are taken to have been
+already packaged up in a va_list by use of the
+<A HREF=stdarg.html>stdarg</A> facility.
+<p>
+
+<h3>See Also</h3>
+
+<A HREF=err.html>err</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/misc/Makefile b/os161-1.10/man/misc/Makefile
new file mode 100644
index 0000000..c619bb4
--- /dev/null
+++ b/os161-1.10/man/misc/Makefile
@@ -0,0 +1,6 @@
+# Man pages for miscellaneous stuff
+
+MANDIR=/man/misc
+
+include ../../defs.mk
+include ../../mk/man.mk
diff --git a/os161-1.10/man/misc/index.html b/os161-1.10/man/misc/index.html
new file mode 100644
index 0000000..e8b0210
--- /dev/null
+++ b/os161-1.10/man/misc/index.html
@@ -0,0 +1,23 @@
+<html>
+<head>
+<title>OS/161 Miscellaneous Docs</title>
+</head>
+<body bgcolor=#ffffff>
+
+<h2 align=center>OS/161 Miscellaneous Docs</h2>
+
+<p align=center>
+<A HREF=..>Top</A> |
+<A HREF=../bin>Binaries</A> |
+<A HREF=../sbin>Sysadmin binaries</A> |
+<A HREF=../testbin>Test binaries</A> |
+<A HREF=../libc>C standard library</A> |
+<A HREF=../syscall>System calls</A> |
+<A HREF=../dev>Device drivers</A>
+</p>
+<br>
+
+<em>For now, there is nothing in this category.</em>
+
+</body>
+</html>
diff --git a/os161-1.10/man/sbin/Makefile b/os161-1.10/man/sbin/Makefile
new file mode 100644
index 0000000..09a2b0a
--- /dev/null
+++ b/os161-1.10/man/sbin/Makefile
@@ -0,0 +1,6 @@
+# Man pages for /sbin programs
+
+MANDIR=/man/sbin
+
+include ../../defs.mk
+include ../../mk/man.mk
diff --git a/os161-1.10/man/sbin/dumpsfs.html b/os161-1.10/man/sbin/dumpsfs.html
new file mode 100644
index 0000000..995060a
--- /dev/null
+++ b/os161-1.10/man/sbin/dumpsfs.html
@@ -0,0 +1,44 @@
+<html>
+<head>
+<title>dumpsfs</title>
+<body bgcolor=#ffffff>
+<h2 align=center>dumpsfs</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+dumpsfs - dump information about an SFS filesystem
+
+<h3>Synopsis</h3>
+/sbin/dumpsfs <em>raw-device</em>
+<br>
+host-dumpsfs <em>disk-image-file</em>
+
+<h3>Description</h3>
+
+dumpsfs dumps out selected information regarding the contents and
+structure of the SFS filesystem on the device it is passed.
+<p>
+
+Like <A HREF=mksfs.html>mksfs</A>, it is also compiled for the
+System/161 host OS, and in that form can access System/161's disk
+image files.
+
+<h3>Requirements</h3>
+
+dumpsfs uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/lseek.html>lseek</A>
+<li> <A HREF=../syscall/fstat.html>fstat</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+dumpsfs should function properly once the file system assignment is
+complete. You may wish to extend it in the course of doing that
+assignment.
+
+</body>
+</html>
diff --git a/os161-1.10/man/sbin/halt.html b/os161-1.10/man/sbin/halt.html
new file mode 100644
index 0000000..493226d
--- /dev/null
+++ b/os161-1.10/man/sbin/halt.html
@@ -0,0 +1,41 @@
+<html>
+<head>
+<title>halt</title>
+<body bgcolor=#ffffff>
+<h2 align=center>halt</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+halt - halt system
+
+<h3>Synopsis</h3>
+/sbin/halt
+
+<h3>Description</h3>
+
+halt shuts the system down. A clean shutdown is performed, flushing
+buffers to disk, unmounting filesystems, and so forth.
+<p>
+
+Once shutdown is complete, halt stops execution of the operating
+system. What this entails depends on the platform. On platforms with a
+hardware boot monitor, it normally returns to the boot monitor. On
+software-based platforms, such as System/161, it normally terminates
+the software simulation. On other platforms the system will generally
+wait for a keystroke on the console and then reboot.
+<p>
+
+<h3>Requirements</h3>
+
+halt uses the <A HREF=../syscall/reboot.html>reboot</A> system call.
+<p>
+
+halt will function properly even before you do any work on OS/161.
+
+<h3>See Also</h3>
+
+<A HREF=../bin/sync.html>/bin/sync</A><br>
+<A HREF=reboot.html>reboot</A>, <A HREF=poweroff.html>poweroff</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/sbin/index.html b/os161-1.10/man/sbin/index.html
new file mode 100644
index 0000000..fba3615
--- /dev/null
+++ b/os161-1.10/man/sbin/index.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>OS/161 Sysadmin binaries</title>
+</head>
+<body bgcolor=#ffffff>
+
+<h2 align=center>OS/161 Sysadmin binaries (/sbin)</h2>
+
+<p align=center>
+<A HREF=..>Top</A> |
+<A HREF=../bin>Binaries</A> |
+<A HREF=../testbin>Test binaries</A> |
+<A HREF=../libc>C standard library</A> |
+<A HREF=../syscall>System calls</A> |
+<A HREF=../dev>Device drivers</A> |
+<A HREF=../misc>Miscellaneous</A>
+</p>
+<br>
+
+<ul>
+<li> <A HREF=dumpsfs.html>dumpsfs</A> - dump information about an 
+   SFS filesystem
+<li> <A HREF=halt.html>halt</A> - halt system
+<li> <A HREF=mksfs.html>mksfs</A> - create an SFS filesystem
+<li> <A HREF=poweroff.html>poweroff</A> - halt system and power it off
+<li> <A HREF=reboot.html>reboot</A> - reboot system
+</ul>
+
+</body>
+</html>
diff --git a/os161-1.10/man/sbin/mksfs.html b/os161-1.10/man/sbin/mksfs.html
new file mode 100644
index 0000000..3679b1e
--- /dev/null
+++ b/os161-1.10/man/sbin/mksfs.html
@@ -0,0 +1,58 @@
+<html>
+<head>
+<title>mksfs</title>
+<body bgcolor=#ffffff>
+<h2 align=center>mksfs</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+mksfs - create an SFS filesystem
+
+<h3>Synopsis</h3>
+/sbin/mksfs <em>raw-device</em> <em>volname</em>
+<br>
+host-mksfs <em>disk-image-file</em> <em>volname</em>
+
+<h3>Description</h3>
+
+mksfs creates a new SFS filesystem on the specified device or disk
+image. The volume name is set to <em>volname</em>.
+<p>
+
+If mksfs is used under OS/161, the first form should be used, where
+<em>raw-device</em> is a raw device name (such as "lhd1raw:"). Don't
+use a device that's already mounted (or being used for swap).
+<p>
+
+mksfs can also be used on the System/161 host OS, in which case the
+second form should be used. The host-compiled version of mksfs knows
+how to deal with the header on System/161 disk images and does the
+right thing.
+<p>
+
+Note that as of this writing host-mksfs cannot create disk image
+files. This is a bug and will hopefully be addressed eventually.
+
+<h3>Requirements</h3>
+
+mksfs uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/lseek.html>lseek</A>
+<li> <A HREF=../syscall/fstat.html>fstat</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+mksfs should function properly once the file system assignment is
+complete. You will likely need to make some changes to it in the
+course of doing that assignment.
+
+<h3>See Also</h3>
+
+<A HREF=dumpsfs.html>dumpsfs</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/sbin/poweroff.html b/os161-1.10/man/sbin/poweroff.html
new file mode 100644
index 0000000..877a207
--- /dev/null
+++ b/os161-1.10/man/sbin/poweroff.html
@@ -0,0 +1,33 @@
+<html>
+<head>
+<title>poweroff</title>
+<body bgcolor=#ffffff>
+<h2 align=center>poweroff</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+poweroff - halt system and power it off
+
+<h3>Synopsis</h3>
+/sbin/poweroff
+
+<h3>Description</h3>
+
+poweroff shuts down the system and then turns the system power off. 
+On platforms where soft power-off is not supported, poweroff functions
+the same way as <A HREF=halt.html>halt</A>.
+
+<h3>Requirements</h3>
+
+poweroff uses the <A HREF=../syscall/reboot.html>reboot</A> system call.
+<p>
+
+poweroff will function properly even before you do any work on OS/161.
+
+<h3>See Also</h3>
+
+<A HREF=../bin/sync.html>/bin/sync</A><br>
+<A HREF=halt.html>halt</A>, <A HREF=reboot.html>reboot</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/sbin/reboot.html b/os161-1.10/man/sbin/reboot.html
new file mode 100644
index 0000000..e29dd7d
--- /dev/null
+++ b/os161-1.10/man/sbin/reboot.html
@@ -0,0 +1,33 @@
+<html>
+<head>
+<title>reboot</title>
+<body bgcolor=#ffffff>
+<h2 align=center>reboot</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+reboot - reboot system
+
+<h3>Synopsis</h3>
+/sbin/reboot
+
+<h3>Description</h3>
+
+reboot shuts the system down and then attempts to restart it. On
+platforms where reboot is not possible, it behaves the same way 
+as <A HREF=halt.html>halt</A>.
+
+<h3>Requirements</h3>
+
+reboot uses the <A HREF=../syscall/reboot.html>reboot</A> system call.
+<p>
+
+reboot will function properly even before you do any work on OS/161.
+
+<h3>See Also</h3>
+
+<A HREF=../bin/sync.html>/bin/sync</A><br>
+<A HREF=halt.html>halt</A>, <A HREF=poweroff.html>poweroff</A>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/Makefile b/os161-1.10/man/syscall/Makefile
new file mode 100644
index 0000000..6afb4f3
--- /dev/null
+++ b/os161-1.10/man/syscall/Makefile
@@ -0,0 +1,6 @@
+# Man pages for system calls
+
+MANDIR=/man/syscall
+
+include ../../defs.mk
+include ../../mk/man.mk
diff --git a/os161-1.10/man/syscall/__getcwd.html b/os161-1.10/man/syscall/__getcwd.html
new file mode 100644
index 0000000..fe9307f
--- /dev/null
+++ b/os161-1.10/man/syscall/__getcwd.html
@@ -0,0 +1,54 @@
+<html>
+<head>
+<title>__getcwd</title>
+<body bgcolor=#ffffff>
+<h2 align=center>__getcwd</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+__getcwd - get name of current working directory (backend)
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+__getcwd(char *<em>buf</em>, size_t <em>buflen</em>);
+
+<h3>Description</h3>
+
+The name of the current directory is computed and stored in
+<em>buf</em>, an area of size <em>buflen</em>. The length of data
+actually stored, which must be non-negative, is returned.
+<p>
+
+Note: this call behaves like <A HREF=read.html>read</A> - the name
+stored in <em>buf</em> is not 0-terminated.
+<p>
+
+This function is not meant to be called except by the C library;
+application programmers should use <A HREF=../libc/getcwd.html>getcwd</A>
+instead.
+
+<h3>Return Values</h3>
+On success, __getcwd returns the length of the data returned. 
+On error, -1 is returned, and <A HREF=errno.html>errno</A>
+is set according to the error encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENOENT</td>	<td>A component of the pathname no longer exists.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>buf</em> points to an invalid address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/__time.html b/os161-1.10/man/syscall/__time.html
new file mode 100644
index 0000000..535ea18
--- /dev/null
+++ b/os161-1.10/man/syscall/__time.html
@@ -0,0 +1,49 @@
+<html>
+<head>
+<title>__time</title>
+<body bgcolor=#ffffff>
+<h2 align=center>__time</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+__time - get time of day
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;time.h&gt;<br>
+<br>
+time_t<br>
+__time(time_t *<em>seconds</em>, unsigned long *nanoseconds);
+
+<h3>Description</h3>
+
+The current time (in seconds and nanoseconds since midnight GMT on
+January 1, 1970) is retrieved. If <em>seconds</em> and/or
+<em>nanoseconds</em> are non-null, the corresponding components of the
+time are stored through those pointers. The time in seconds is also
+returned. 
+<p>
+
+<h3>Return Values</h3>
+
+__time returns the time in seconds. On error, -1 is returned, and
+errno is set to indicate the error.
+
+<h3>Errors</h3>
+
+The following error is the only way __time should be capable of failing.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EFAULT</td>	<td><em>seconds</em> or <em>nanoseconds</em>
+			was an invalid non-NULL address.</td></tr>
+</table></blockquote>
+
+<h3>See Also</h3>
+
+<A HREF=../libc/time.html>time</A><br>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/_exit.html b/os161-1.10/man/syscall/_exit.html
new file mode 100644
index 0000000..0b000ba
--- /dev/null
+++ b/os161-1.10/man/syscall/_exit.html
@@ -0,0 +1,33 @@
+<html>
+<head>
+<title>_exit</title>
+<body bgcolor=#ffffff>
+<h2 align=center>_exit</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+_exit - terminate process
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+void<br>
+_exit(int <em>exitcode</em>);
+
+<h3>Description</h3>
+
+Cause the current process to exit. The exit code <em>exitcode</em> is
+reported back to other process(es) via the 
+<A HREF=waitpid.html>waitpid()</A> call. The process id of the exiting
+process should not be reused until all processes interested in
+collecting the exit code with waitpid have done so. (What "interested"
+means is intentionally left vague; you should design this.)
+
+<h3>Return Values</h3>
+_exit does not return.
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/chdir.html b/os161-1.10/man/syscall/chdir.html
new file mode 100644
index 0000000..737a66f
--- /dev/null
+++ b/os161-1.10/man/syscall/chdir.html
@@ -0,0 +1,51 @@
+<html>
+<head>
+<title>chdir</title>
+<body bgcolor=#ffffff>
+<h2 align=center>chdir</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+chdir - change current directory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+chdir(const char *<em>pathname</em>);
+
+<h3>Description</h3>
+
+The current directory of the current process is set to the directory
+named by <em>pathname</em>.
+<p>
+
+<h3>Return Values</h3>
+On success, chdir returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<tr><td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of <em>pathname</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>pathname</em>
+				was not a directory.</td></tr>
+<tr><td>ENOTDIR</td>	<td><em>pathname</em> did not refer to a
+				directory.</td> 
+<tr><td>ENOENT</td>	<td><em>pathname</em> did not exist.</td></tr>
+<tr><td>EIO</td>	<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>	<td><em>pathname</em> was an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/close.html b/os161-1.10/man/syscall/close.html
new file mode 100644
index 0000000..7efc417
--- /dev/null
+++ b/os161-1.10/man/syscall/close.html
@@ -0,0 +1,50 @@
+<html>
+<head>
+<title>close</title>
+<body bgcolor=#ffffff>
+<h2 align=center>close</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+close - close file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+close(int <em>fd</em>);
+
+<h3>Description</h3>
+
+The file handle <em>fd</em> is closed. The same file handle may then
+be returned again from <A HREF=open.html>open</A>,
+<A HREF=dup2.html>dup2</A>, <A HREF=pipe.html>pipe</A>, or similar
+calls.
+<p>
+
+Other file handles are not affected in any way, even if they are
+attached to the same file.
+<p>
+
+<h3>Return Values</h3>
+On success, close returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<tr><td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>	<td><em>fd</em> is not a valid file handle.</td></tr>
+<tr><td>EIO</td>	<td>A hard I/O error occurred.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/dup2.html b/os161-1.10/man/syscall/dup2.html
new file mode 100644
index 0000000..ac3130d
--- /dev/null
+++ b/os161-1.10/man/syscall/dup2.html
@@ -0,0 +1,68 @@
+<html>
+<head>
+<title>dup2</title>
+<body bgcolor=#ffffff>
+<h2 align=center>dup2</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+dup2 - clone file handles
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+dup2(int <em>oldfd</em>, int <em>newfd</em>);
+
+<h3>Description</h3>
+
+dup2 clones the file handle <em>oldfd</em> onto the file handle
+<em>newfd</em>. If <em>newfd</em> names an open file, that file is
+closed.
+<p>
+
+The two handles refer to the same "open" of the file - that is,
+they are references to the same object and share the same seek
+pointer. Note that this is different from opening the same file
+twice. 
+<p>
+
+dup2 is most commonly used to relocate opened files onto
+STDIN_FILENO, STDOUT_FILENO, and/or STDERR_FILENO.
+<p>
+
+Both filehandles must be non-negative.
+<p>
+
+Using dup2 to clone a file handle onto itself has no effect.
+<p>
+
+(The "2" in "dup2" arises from the existence of an older and less
+powerful Unix system call "dup".)
+
+<h3>Return Values</h3>
+dup2 returns <em>newfd</em>. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<tr><td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>		<td><em>oldfd</em> is not a valid file handle,
+				or <em>newfd</em> is a value that
+				cannot be a valid file handle.</td></tr>
+<tr><td>EMFILE</td>		<td>The process's file table was full, or a
+				process-specific limit on open files
+				was reached.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/errno.html b/os161-1.10/man/syscall/errno.html
new file mode 100644
index 0000000..6afc11a
--- /dev/null
+++ b/os161-1.10/man/syscall/errno.html
@@ -0,0 +1,174 @@
+<html>
+<head>
+<title>errno</title>
+<body bgcolor=#ffffff>
+<h2 align=center>errno</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+errno - error code reporting
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;errno.h&gt;<br>
+<br>
+extern int errno;
+
+<h3>Description</h3>
+
+When system calls, and sometimes other functions, fail, a code
+representing or describing the error condition is placed in the global
+variable errno.
+<p>
+
+errno is always left unchanged by successful operations.
+<p>
+
+errno may be a macro. In a multithreaded process it is almost
+invariably a macro. However, it is always an lvalue, that is, it may
+be assigned to.
+<p>
+
+Each numeric code has a symbolic name and a textual expansion. The
+symbolic names are used in source code; the textual expansions are
+printed out when errors are reported to a user.
+<p>
+
+The textual expansions can be retrieved with 
+<A HREF=../libc/strerror.html>strerror</A> or printed with 
+<A HREF=../libc/err.html>err</A> or <A HREF=../libc/warn.html>warn</A>. 
+<p>
+
+<h3>Symbolic names</h3>
+
+The following symbolic errors are defined in the OS/161 base system.
+You may add more at your pleasure; but be sure to read the notes in 
+the file kern/errno.h that defines them.
+
+<blockquote>
+<table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+
+<tr><td valign=top>EINVAL</td>
+<td>Invalid argument: an argument passed to a command or system call
+	was badly formed, invalid, or nonsensical.</td></tr>
+
+<tr><td valign=top>EFAULT</td>
+
+<td>Bad memory reference: a pointer passed as an argument was not
+	valid.</td></tr>
+
+<tr><td valign=top>ENAMETOOLONG</td>
+
+<td>String too long: a string passed as an argument was too long to
+	process.</td></tr>
+
+<tr><td valign=top>ENOMEM</td>
+
+<td>Out of memory: a memory allocation failed. This normally means
+	that a process has used up all the memory available to it
+	(either because of limits or because it has used up all the
+	memory available to the system.) It may also mean that memory
+	allocation within the kernel has failed.</td></tr>
+
+<tr><td valign=top>EIO</td>
+<td>Input/output error: a hardware error occured on a device. Media
+	errors on disks fall into this category.</td></tr>
+
+<tr><td valign=top>ENOENT</td>
+<td>No such file or directory: the requested filesystem object
+	does/did not exist.</td></tr>
+
+<tr><td valign=top>ENOTDIR</td>
+<td>Not a directory: a directory was expected and a non-directory
+	filesystem object was found.</td></tr>
+
+<tr><td valign=top>EISDIR</td>
+<td>Is a directory: a non-directory was expected and a directory was
+	found.</td></tr>
+
+<tr><td valign=top>EEXIST</td>
+<td>File exists: a filesystem object that was expected not to exist
+	did in fact already exist.</td></tr>
+
+<tr><td valign=top>EXDEV</td>
+<td>Cross-device link: an attempt was made to instruct one filesystem
+	to handle files on another filesystem.</td></tr>
+
+<tr><td valign=top>EAGAIN</td>
+<td>Try again later: some resource is temporarily
+	unavailable.</td></tr>
+
+<tr><td valign=top>ESPIPE</td>
+<td>Illegal seek: a seek operation was attempted on a sequential
+	object where seeking makes no sense, like a
+	terminal.</td></tr>
+
+<tr><td valign=top>EUNIMP</td>
+<td>Unimplemented feature: functionality not yet implemented would
+	have been needed to perform the requested operation.</td></tr>
+
+<tr><td valign=top>ENXIO</td>
+<td>Device not available: the requested device exists but is not
+	available (is not mounted, is off, etc.)</td></tr>
+
+<tr><td valign=top>ENODEV</td>
+<td>No such device: the requested device does not exist.</td></tr>
+
+<tr><td valign=top>EBUSY</td>
+<td>Device busy: the requested object cannot be used (or, perhaps,
+	released) because something else is using it.</td></tr>
+
+<tr><td valign=top>EIOCTL</td>
+<td>Invalid or inappropriate ioctl: an operation requested via the 
+	<A HREF=../syscall/ioctl.html>ioctl</A> system call was not
+	defined or could not be performed on the indicated
+	object.</td></tr>
+
+<tr><td valign=top>ENOTEMPTY</td>
+<td>Directory not empty: a directory must be empty of everything
+	(except . and ..) before it may be removed.</td></tr>
+
+<tr><td valign=top>ERANGE</td>
+<td>Result too large: the result of an operation did not fit in the
+	space provided.</td></tr>
+
+<tr><td valign=top>ENOSPC</td>
+<td>No space left on device: a filesystem is full.</td></tr>
+
+<tr><td valign=top>EMFILE</td>
+<td>Too many open files: the process file table is full, so the
+	process cannot open more files.</td></tr>
+
+<tr><td valign=top>ENFILE</td>
+<td>Too many open files in system: a system-wide limit of some sort,
+	if any exists, on the number of open files has been
+	reached.</td></tr>
+
+<tr><td valign=top>ENOSYS</td>
+<td>No such system call: the call made was not defined, or perhaps not
+	yet implemented.</td></tr>
+
+<tr><td valign=top>ENOEXEC</td>
+<td>File is not executable: an <A HREF=../syscalls/execv.html>execv</A>
+	operation was attempted but the kernel was unable to run the
+	requested program.</td></tr>
+
+<tr><td valign=top>E2BIG</td>
+<td>Argument list too long: the space taken up by the argv[] strings
+	passed to a newly started program is larger than the system
+	allows.</td></tr>
+
+<tr><td valign=top>EBADF</td>
+<td>Bad file number: a file operation was requested on an illegal file
+	handle, or a file handle that was not open. Or, a write
+	operation was attempted on a file handle that was open only
+	for read or vice-versa.</td></tr>
+
+</table>
+</blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/execv.html b/os161-1.10/man/syscall/execv.html
new file mode 100644
index 0000000..34d2d14
--- /dev/null
+++ b/os161-1.10/man/syscall/execv.html
@@ -0,0 +1,78 @@
+<html>
+<head>
+<title>execv</title>
+<body bgcolor=#ffffff>
+<h2 align=center>execv</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+execv - execute a program
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+execv(const char *<em>program</em>, char **<em>args</em>);
+
+<h3>Description</h3>
+
+execv replaces the currently executing program with a newly loaded
+program image. This occurs within one process; the process id is
+unchanged.
+<p>
+
+The pathname of the program to run is passed as <em>program</em>. The
+<em>args</em> argument is an array of 0-terminated strings. The array
+itself should be terminated by a NULL pointer.
+<p>
+
+The argument strings should be copied into the new process as the
+new process's argv[] array. In the new process, argv[argc] must be
+NULL.
+<p>
+
+By convention, argv[0] in new processes contains the name that was
+used to invoke the program. This is not necessarily the same as
+<em>program</em>, and furthermore is only a convention and should not
+be enforced by the kernel.
+<p>
+
+The process file table and current working directory are not modified
+by execve.
+
+<h3>Return Values</h3>
+On success, execv does not return; instead, the new program begins
+executing. On failure, execv returns -1, and sets
+<A HREF=errno.html>errno</A> to a suitable error code for the error
+condition encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<tr><td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of <em>program</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>program</em>
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>	<td><em>program</em> did not exist.</td></tr>
+<tr><td>EISDIR</td>	<td><em>program</em> is a directory.</td></tr>
+<tr><td>ENOEXEC</td>	<td><em>program</em> is not in a recognizable
+				executable file format, was for the
+				wrong platform, or contained invalid
+				fields.</td></tr>
+<tr><td>ENOMEM</td>	<td>Insufficient virtual memory is available.</td></tr>
+<tr><td>E2BIG</td>		<td>The total size of the argument strings is
+				too large.</td></tr>
+<tr><td>EIO</td>	<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>	<td>One of the args is an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/fork.html b/os161-1.10/man/syscall/fork.html
new file mode 100644
index 0000000..0f41987
--- /dev/null
+++ b/os161-1.10/man/syscall/fork.html
@@ -0,0 +1,64 @@
+<html>
+<head>
+<title>fork</title>
+<body bgcolor=#ffffff>
+<h2 align=center>fork</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+fork - copy the current process
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+pid_t<br>
+fork(void);
+
+<h3>Description</h3>
+
+fork duplicates the currently running process. The two copies are
+identical, except that one (the "new" one, or "child"), has a new,
+unique process id, and in the other (the "parent") the process id is
+unchanged.
+<p>
+
+The process id must be greater than 0.
+<p>
+
+The two processes do not share memory or open file tables; this state
+is copied into the new process, and subsequent modification in one
+process does not affect the other.
+<p>
+
+However, the file handle objects the file tables point to are shared,
+so, for instance, calls to lseek in one process can affect the other.
+<p>
+
+<h3>Return Values</h3>
+On success, fork returns twice, once in the parent process and once in
+the child process. In the child process, 0 is returned. In the parent
+process, the process id of the new child process is returned.
+<p>
+
+On error, no new process is created, fork only returns once, returning
+-1, and <A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<tr><td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EAGAIN</td>		<td>Too many processes already exist.</td></tr>
+<tr><td>ENOMEM</td>		<td>Sufficient virtual memory for the new
+				process was not available.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/fstat.html b/os161-1.10/man/syscall/fstat.html
new file mode 100644
index 0000000..d842dc3
--- /dev/null
+++ b/os161-1.10/man/syscall/fstat.html
@@ -0,0 +1,45 @@
+<html>
+<head>
+<title>fstat</title>
+<body bgcolor=#ffffff>
+<h2 align=center>fstat</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+fstat - get file state information
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+fstat(int <em>fd</em>, struct stat *<em>statbuf</em>);
+
+<h3>Description</h3>
+
+fstat retrieves status information about the file referred to by the
+file handle <em>fd</em> and stores it in the stat structure pointed to
+by <em>statbuf</em>.
+
+<h3>Return Values</h3>
+On success, fstat returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>	<td><em>fd</em> is not a valid file handle.</td></tr>
+<tr><td>EIO</td>	<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>	<td><em>statbuf</em> points to an invalid address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/fsync.html b/os161-1.10/man/syscall/fsync.html
new file mode 100644
index 0000000..5c4e429
--- /dev/null
+++ b/os161-1.10/man/syscall/fsync.html
@@ -0,0 +1,48 @@
+<html>
+<head>
+<title>fsync</title>
+<body bgcolor=#ffffff>
+<h2 align=center>fsync</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+fsync - flush filesystem data for a specific file to disk
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+fsync(int <em>fd</em>);
+
+<h3>Description</h3>
+
+The fsync function forces a write of dirty filesystem buffers and
+other dirty filesystem state associated with the object referred to by
+<em>fd</em> to be written to disk.
+<p>
+
+fsync should not return until the writes are complete.
+<p>
+
+<h3>Return Values</h3>
+On success, fsync returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>		<td><em>fd</em> is not a valid file handle.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/ftruncate.html b/os161-1.10/man/syscall/ftruncate.html
new file mode 100644
index 0000000..293f460
--- /dev/null
+++ b/os161-1.10/man/syscall/ftruncate.html
@@ -0,0 +1,50 @@
+<html>
+<head>
+<title>ftruncate</title>
+<body bgcolor=#ffffff>
+<h2 align=center>ftruncate</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+ftruncate - set size of a file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+ftruncate(int <em>fd</em>, off_t <em>filesize</em>);
+
+<h3>Description</h3>
+
+ftruncate forcibly sets the size of the file referred to by
+<em>fd</em> to <em>filesize</em>. If this expands the file, the new
+data appears as if it is zero-filled. If this shrinks the file, the
+excess data is discarded.
+<p>
+
+The file must be open for write.
+
+<h3>Return Values</h3>
+On success, ftruncate returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>		<td><em>fd</em> is not a valid file handle, or
+				it is not open for writing.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>buf</em> points to an invalid address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/getdirentry.html b/os161-1.10/man/syscall/getdirentry.html
new file mode 100644
index 0000000..d0bd8fd
--- /dev/null
+++ b/os161-1.10/man/syscall/getdirentry.html
@@ -0,0 +1,57 @@
+<html>
+<head>
+<title>getdirentry</title>
+<body bgcolor=#ffffff>
+<h2 align=center>getdirentry</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+getdirentry - read filename from directory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+getdirentry(int <em>fd</em>, char *<em>buf</em>, size_t <em>buflen</em>);
+
+<h3>Description</h3>
+
+getdirentry retrieves the next filename from a directory referred to
+by the file handle <em>filehandle</em>. The name is stored in
+<em>buf</em>, an area of size <em>buflen</em>. The length of of the
+name actually found is returned.
+<p>
+
+Note: this call behaves like read() - the name stored in <em>buf</em>
+is not null-terminated.
+<p>
+
+Which filename is the "next" is chosen based on the seek pointer
+associated with the file handle. The meaning of the seek pointer on a
+directory is defined by the filesystem in use and should not be
+interpreted - the only ways in which <A HREF=lseek.html>lseek</A>
+should be used are with SEEK_SET and an offset previously returned by
+lseek, or with any of SEEK_SET, SEEK_CUR, or SEEK_EOF with an offset
+of 0.
+<p>
+
+<h3>Return Values</h3>
+On success, getdirentry returns the length of the name transferred.
+On error, -1 is returned, and <A HREF=errno.html>errno</A> is set
+according to the error encountered.
+
+<h3>Errors</h3>
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>		<td><em>fd</em> is not a valid file handle.</td></tr>
+<tr><td>ENOTDIR</td>	<td><em>fd</em> does not refer to a directory.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>buf</em> points to an invalid address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/getpid.html b/os161-1.10/man/syscall/getpid.html
new file mode 100644
index 0000000..3c574e2
--- /dev/null
+++ b/os161-1.10/man/syscall/getpid.html
@@ -0,0 +1,29 @@
+<html>
+<head>
+<title>getpid</title>
+<body bgcolor=#ffffff>
+<h2 align=center>getpid</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+getpid - get process id
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+pid_t<br>
+getpid(void);
+
+<h3>Description</h3>
+
+getpid returns the process id of the current process.
+
+<h3>Errors</h3>
+
+getpid does not fail.
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/index.html b/os161-1.10/man/syscall/index.html
new file mode 100644
index 0000000..97ce46d
--- /dev/null
+++ b/os161-1.10/man/syscall/index.html
@@ -0,0 +1,62 @@
+<html>
+<head>
+<title>OS/161 System calls</title>
+</head>
+<body bgcolor=#ffffff>
+
+<h2 align=center>OS/161 System calls</h2>
+
+<p align=center>
+<A HREF=..>Top</A> |
+<A HREF=../bin>Binaries</A> |
+<A HREF=../sbin>Sysadmin binaries</A> |
+<A HREF=../testbin>Test binaries</A> |
+<A HREF=../libc>C standard library</A> |
+<A HREF=../dev>Device drivers</A> |
+<A HREF=../misc>Miscellaneous</A>
+</p>
+<br>
+
+<ul>
+<li> <A HREF=errno.html>errno</A> - error code reporting
+</ul>
+
+<ul>
+<li> <A HREF=_exit.html>_exit</A> - terminate process
+<li> <A HREF=chdir.html>chdir</A> - change current directory
+<li> <A HREF=close.html>close</A> - close file
+<li> <A HREF=dup2.html>dup2</A> - clone file handles
+<li> <A HREF=execv.html>execv</A> - execute a program
+<li> <A HREF=fork.html>fork</A> - copy the current process
+<li> <A HREF=fstat.html>fstat</A> - get file state information
+<li> <A HREF=fsync.html>fsync</A> - flush filesystem data for a
+   specific file to disk
+<li> <A HREF=ftruncate.html>ftruncate</A> - set size of a file
+<li> <A HREF=__getcwd.html>__getcwd</A> - get name of current working
+   directory (backend)
+<li> <A HREF=getdirentry.html>getdirentry</A> - read filename from directory
+<li> <A HREF=getpid.html>getpid</A> - get process id
+<li> <A HREF=ioctl.html>ioctl</A> - miscellaneous device I/O operations
+<li> <A HREF=link.html>link</A> - create hard link to a file
+<li> <A HREF=lseek.html>lseek</A> - change current position in file
+<li> <A HREF=lstat.html>lstat</A> - get file state information
+<li> <A HREF=mkdir.html>mkdir</A> - create directory
+<li> <A HREF=open.html>open</A> - open a file
+<li> <A HREF=pipe.html>pipe</A> - create pipe object
+<li> <A HREF=read.html>read</A> - read data from file
+<li> <A HREF=readlink.html>readlink</A> - fetch symbolic link contents
+<li> <A HREF=reboot.html>reboot</A> - reboot or halt system
+<li> <A HREF=remove.html>remove</A> - delete (unlink) a file
+<li> <A HREF=rename.html>rename</A> - rename or move a file
+<li> <A HREF=rmdir.html>rmdir</A> - remove directory
+<li> <A HREF=sbrk.html>sbrk</A> - set process break (allocate memory)
+<li> <A HREF=stat.html>stat</A> - get file state information
+<li> <A HREF=symlink.html>symlink</A> - create symbolic link
+<li> <A HREF=sync.html>sync</A> - flush filesystem data to disk
+<li> <A HREF=__time.html>__time</A> - get time of day
+<li> <A HREF=waitpid.html>waitpid</A> - wait for a process to exit
+<li> <A HREF=write.html>write</A> - write data to file
+</ul>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/ioctl.html b/os161-1.10/man/syscall/ioctl.html
new file mode 100644
index 0000000..b9a2c81
--- /dev/null
+++ b/os161-1.10/man/syscall/ioctl.html
@@ -0,0 +1,61 @@
+<html>
+<head>
+<title>ioctl</title>
+<body bgcolor=#ffffff>
+<h2 align=center>ioctl</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+ioctl - miscellaneous device I/O operations
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;sys/ioctl.h&gt;<br>
+<br>
+int<br>
+ioctl(int <em>fd</em>, int <em>code</em>, void *<em>data</em>);
+
+<h3>Description</h3>
+
+ioctl performs an object-specific operation <em>code</em> on the
+object referred to by the file handle <em>fd</em>. The <em>data</em>
+argument may point to supplemental data required or returned by the
+operation. The size of buffer required, if any, and other such matters
+are operation-specific.
+<p>
+
+Traditionally, ioctl is a catchall function for performing operations
+that don't fit neatly into any other model.
+<p>
+
+The ioctl codes are defined in &lt;kern/ioctl.h&gt;, which should be
+included via &lt;sys/ioctl.h&gt; by user-level code. As of this
+writing, the base OS/161 system defines no ioctls. However, it may
+prove useful to implement some, particularly in connection with some
+less conventional possible projects.
+<p>
+
+<h3>Return Values</h3>
+On success, ioctl returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>		<td><em>fd</em> was not a valid file handle.</td></tr>
+<tr><td>EIOCTL</td>		<td><em>code</em> was an invalid ioctl for the
+				object referenced.</td></tr>
+<tr><td>EFAULT</td>		<td><em>data</em> was required by the operation
+				requested, but was an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/link.html b/os161-1.10/man/syscall/link.html
new file mode 100644
index 0000000..9759da0
--- /dev/null
+++ b/os161-1.10/man/syscall/link.html
@@ -0,0 +1,61 @@
+<html>
+<head>
+<title>link</title>
+<body bgcolor=#ffffff>
+<h2 align=center>link</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+link - create hard link to a file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+link(const char *<em>oldname</em>, const char *<em>newname</em>);
+
+<h3>Description</h3>
+
+link creates a new name, <em>newname</em>, for the file referred to by
+<em>oldname</em>. Henceforth, both names are equally valid ways to
+refer to the same file. The file is only deleted when all names are
+removed. This is a "hard link".
+<p>
+
+The creation of the new name is atomic. The two names must be on the
+same filesystem. Directories may not be hard-linked.
+<p>
+
+<h3>Return Values</h3>
+On success, link returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of one of the names did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of one of the names
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>		<td>A non-final component of <em>newname</em>   
+				did not exist.</td></tr>
+<tr><td>ENOENT</td>		<td><em>oldname</em> does not exist.</td></tr>
+<tr><td>EEXIST</td>		<td><em>newname</em> already exists.</td></tr>
+<tr><td>EISDIR</td>		<td><em>oldname</em> is a directory.</td></tr>
+<tr><td>EXDEV</td>		<td>The two names are on different filesystems.</td></tr>
+<tr><td>ENOSPC</td>		<td>The filesystem involved is full.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td>One of the arguments was an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/lseek.html b/os161-1.10/man/syscall/lseek.html
new file mode 100644
index 0000000..debbdb7
--- /dev/null
+++ b/os161-1.10/man/syscall/lseek.html
@@ -0,0 +1,73 @@
+<html>
+<head>
+<title>lseek</title>
+<body bgcolor=#ffffff>
+<h2 align=center>lseek</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+lseek - change current position in file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+off_t<br>
+lseek(int <em>fd</em>, off_t <em>pos</em>, int <em>whence</em>);
+
+<h3>Description</h3>
+
+lseek alters the current seek position of the file handle
+<em>filehandle</em>, seeking to a new position based on <em>pos</em>
+and <em>whence</em>.
+<p>
+
+If <em>whence</em> is
+<ul>
+<li> SEEK_SET, the new position is <em>pos</em>.
+<li> SEEK_CUR, the new position is the current position plus <em>pos</em>.
+<li> SEEK_END, the new position is the position of end-of-file 
+	plus <em>pos</em>.
+<li> anything else, lseek fails.
+</ul>
+
+Note that <em>pos</em> is a signed quantity.
+<p>
+
+It is not meaningful to seek on certain objects (such as the console
+device). All seeks on these objects fail.
+<p>
+
+Seek positions less than zero are invalid. Seek positions beyond EOF
+are legal.
+<p>
+
+Note that each distinct open of a file should have an independent seek
+pointer.
+<p>
+
+<h3>Return Values</h3>
+On success, lseek returns the new position. On error, -1 is returned,
+and <A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>		<td><em>fd</em> is not a valid file handle.</td></tr>
+<tr><td>ESPIPE</td>		<td><em>fd</em> refers to an object which does
+				not support seeking.</td></tr>
+<tr><td>EINVAL</td>		<td><em>whence</em> is invalid.</td></tr>
+<tr><td>EINVAL</td>		<td>The resulting seek position would be negative.</td></tr>
+</table></blockquote>
+
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/lstat.html b/os161-1.10/man/syscall/lstat.html
new file mode 100644
index 0000000..2f6be57
--- /dev/null
+++ b/os161-1.10/man/syscall/lstat.html
@@ -0,0 +1,53 @@
+<html>
+<head>
+<title>lstat</title>
+<body bgcolor=#ffffff>
+<h2 align=center>lstat</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+lstat - get file state information
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;sys/stat.h&gt;<br>
+<br>
+int<br>
+lstat(const char *<em>pathname</em>, struct stat *<em>statbuf</em>);
+
+<h3>Description</h3>
+
+lstat retrieves status information about the file referred to by
+<em>pathname</em> and stores it in the stat structure pointed to
+by <em>statbuf</em>.
+<p>
+
+If <em>pathname</em> refers to a symbolic link, information about the
+link is retrieved rather than about the object the link points to.
+
+<h3>Return Values</h3>
+On success, lstat returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of <em>filename</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>pathname</em>
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>		<td>The named file does not exist.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>statbuf</em> points to an invalid address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/mkdir.html b/os161-1.10/man/syscall/mkdir.html
new file mode 100644
index 0000000..f4a00ea
--- /dev/null
+++ b/os161-1.10/man/syscall/mkdir.html
@@ -0,0 +1,60 @@
+<html>
+<head>
+<title>mkdir</title>
+<body bgcolor=#ffffff>
+<h2 align=center>mkdir</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+mkdir - create directory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;sys/stat.h&gt;<br>
+<br>
+int<br>
+mkdir(const char *<em>pathname</em>, int <em>mode</em>);
+
+<h3>Description</h3>
+
+mkdir creates a directory named <em>name</em>, where <em>name</em> is
+the last filename component in <em>pathname</em>. All the directories
+named in the prefix portion of <em>pathname</em> must exist and must
+in fact be directories, not ordinary files. The name <em>name</em>
+must not already exist. The new directory must be created atomically.
+<p>
+
+The <em>mode</em> argument can be ignored in OS/161.
+<p>
+
+<h3>Return Values</h3>
+On success, mkdir returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of <em>pathname</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>pathname</em>
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>		<td>A non-final component of <em>pathname</em>
+				did not exist.</td></tr>
+<tr><td>EEXIST</td>		<td>An object by the name <em>pathname</em>
+				already exists.</td></tr>
+<tr><td>ENOSPC</td>		<td>The filesystem the directory was to be
+				created on is full.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>pathname</em> was an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/open.html b/os161-1.10/man/syscall/open.html
new file mode 100644
index 0000000..ffcc7a1
--- /dev/null
+++ b/os161-1.10/man/syscall/open.html
@@ -0,0 +1,104 @@
+<html>
+<head>
+<title>open</title>
+<body bgcolor=#ffffff>
+<h2 align=center>open</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+open - open a file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+open(const char *<em>filename</em>, int <em>flags</em>);<br>
+int<br>
+open(const char *<em>filename</em>, int <em>flags</em>, int <em>mode</em>);<br>
+
+<h3>Description</h3>
+
+open opens the file, device, or other kernel object named by the
+pathname <em>filename</em>. The <em>flags</em> argument specifies how
+to open the file. The optional <em>mode</em> argument is only
+meaningful in Unix (or if you choose to implement Unix-style security
+later on) and can be ignored.
+<p>
+
+The flags argument should consist of one of
+<blockquote><table width=90%>
+<tr><td>O_RDONLY</td>	<td>Open for reading only.</td></tr>
+<tr><td>O_WRONLY</td>	<td>Open for writing only.</td></tr>
+<tr><td>O_RDWR</td>		<td>Open for reading and writing.</td></tr>
+</table></blockquote>
+
+It may also have any of the following flags OR'd in:
+<blockquote><table width=90%>
+<tr><td>O_CREAT</td>	<td>Create the file if it doesn't exist.</td></tr>
+<tr><td>O_EXCL</td>		<td>Fail if the file already exists.</td></tr>
+<tr><td>O_TRUNC</td>	<td>Truncate the file to length 0 upon open.</td></tr>
+<tr><td>O_APPEND</td>	<td>Open the file in append mode.</td></tr>
+</table></blockquote>
+
+O_EXCL is only meaningful if O_CREAT is also used.
+<p>
+
+O_APPEND causes all writes to the file to occur at the end of file, no
+matter what gets written to the file by whoever else. (This
+functionality may be optional; consult your course's assignments.)
+<p>
+
+open returns a file handle suitable for passing to 
+<A HREF=read.html>read</A>,
+<A HREF=write.html>write</A>,
+<A HREF=close.html>close</A>,
+etc. This file handle must be greater than or equal to zero.  Note
+that file handles 0 (STDIN_FILENO), 1 (STDOUT_FILENO), and 2
+(STDERR_FILENO) are used in special ways and are typically assumed by
+user-level code to always be open.
+
+<h3>Return Values</h3>
+On success, open returns a nonnegative file handle. On error, -1 is
+returned, and <A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of <em>filename</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>filename</em>
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>		<td>A non-final component of <em>filename</em>
+				did not exist.</td></tr>
+<tr><td>ENOENT</td>		<td>The named file does not exist, and O_CREAT
+				was not specified.</td></tr>
+<tr><td>EEXIST</td>		<td>The named file exists, and O_EXCL was
+				specified.</td></tr>
+<tr><td>EISDIR</td>		<td>The named object is a directory, and it
+				was to be opened for writing.</td></tr>
+<tr><td>EMFILE</td>		<td>The process's file table was full, or a
+				process-specific limit on open files
+				was reached.</td></tr>
+<tr><td>ENFILE</td>		<td>The system file table is full, if such a
+				thing exists, or a system-wide limit
+				on open files was reached.</td></tr>
+<tr><td>ENXIO</td>		<td>The named object is a block device with no
+				mounted filesystem.</td></tr>
+<tr><td>ENOSPC</td>		<td>The file was to be created, and the
+				filesystem involved is full.</td></tr>
+<tr><td>EINVAL</td>		<td><em>flags</em> contained invalid values.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>filename</em> was an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/pipe.html b/os161-1.10/man/syscall/pipe.html
new file mode 100644
index 0000000..1b5cedb
--- /dev/null
+++ b/os161-1.10/man/syscall/pipe.html
@@ -0,0 +1,74 @@
+<html>
+<head>
+<title>pipe</title>
+<body bgcolor=#ffffff>
+<h2 align=center>pipe</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+pipe - create pipe object
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+pipe(int *<em>fds</em>);
+
+<h3>Description</h3>
+
+The pipe call creates an anonymous pipe object in the system, and
+binds it to two file handles in the current process, one for the read
+end and one for the write end. (Pipes are unidirectional.)
+<p>
+
+Data written on the write end may be read from the read end. Once all
+references to the write end are closed, and all remaining data is
+read, further reads return EOF. If all references to the read end are
+closed before the write end is closed, further writes generate
+errors. The pipe object itself is destroyed when all references to
+both ends are closed.
+<p>
+
+<em>fds</em> is a pointer to two integers. A file handle for the read
+end of the pipe is stored in <em>fds</em>[0], and a file handle for
+the write end is stored in <em>fds</em>[1].
+<p>
+
+pipe is most often used in conjunction with <A HREF=dup2.html>dup2</A>
+and <A HREF=fork.html>fork</A> to send the standard output of one
+process to the standard input of another.
+<p>
+
+In POSIX, pipe I/O of data blocks smaller than a standard constant
+PIPE_BUF is guaranteed to be atomic. If you implement pipes, you need
+not necessarily implement POSIX semantics, but you should decide what
+sort of atomicity guarantees you wish to make and specify them
+carefully. 
+
+<h3>Return Values</h3>
+On success, pipe returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EMFILE</td>		<td>The process's file table was full, or a
+				process-specific limit on open files
+				was reached.</td></tr>
+<tr><td>ENFILE</td>		<td>The system file table is full, if such a
+				thing exists, or a system-wide limit
+				on open files was reached.</td></tr>
+<tr><td>EFAULT</td>		<td><em>fds</em> was an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/read.html b/os161-1.10/man/syscall/read.html
new file mode 100644
index 0000000..c8da548
--- /dev/null
+++ b/os161-1.10/man/syscall/read.html
@@ -0,0 +1,67 @@
+<html>
+<head>
+<title>read</title>
+<body bgcolor=#ffffff>
+<h2 align=center>read</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+read - read data from file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+read(int <em>fd</em>, void *<em>buf</em>, size_t <em>buflen</em>);
+
+<h3>Description</h3>
+
+read reads up to <em>buflen</em> bytes from the file specified by
+<em>fd</em>, at the location in the file specified by the current
+seek position of the file, and stores them in the space pointed to
+by <em>buf</em>. The file must be open for reading.
+<p>
+
+The current seek position of the file is advanced by the number of
+bytes read.
+<p>
+
+Each read (or <A HREF=write.html>write</A>) operation is atomic
+relative to other I/O to the same file.
+<p>
+
+<h3>Return Values</h3>
+
+The count of bytes read is returned. This count should be
+positive. A return value of 0 should be construed as signifying
+end-of-file. On error, read returns -1 and sets 
+<A HREF=errno.html>errno</A> to a suitable error code for the error 
+condition encountered.
+<p>
+
+Note that in some cases, particularly on devices, fewer than
+<em>buflen</em> (but greater than zero) bytes may be returned. This
+depends on circumstances and does not necessarily signify
+end-of-file.
+<p>
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>	<td><em>fd</em> is not a valid file descriptor, or was
+			not opened for reading.</td></tr>
+<tr><td>EFAULT</td>	<td>Part or all of the address space pointed to by
+			<em>buf</em> is invalid.</td></tr>
+<tr><td>EIO</td>	<td>A hardware I/O error occurred reading the data.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/readlink.html b/os161-1.10/man/syscall/readlink.html
new file mode 100644
index 0000000..769bcac
--- /dev/null
+++ b/os161-1.10/man/syscall/readlink.html
@@ -0,0 +1,55 @@
+<html>
+<head>
+<title>readlink</title>
+<body bgcolor=#ffffff>
+<h2 align=center>readlink</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+readlink - fetch symbolic link contents
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+readlink(const char *<em>path</em>, char *<em>buf</em>, size_t <em>len</em>);
+
+<h3>Description</h3>
+
+readlink retrieves the contents of the symbolic link named by
+<em>path</em> and places them in the buffer <em>buf</em>. At most
+<em>len</em> bytes are written.
+<p>
+
+readlink does not include a null terminator in <em>buf</em>.
+
+<h3>Return Values</h3>
+
+readlink returns the number of characters transferred. If an error
+occurs, -1 is returned, and <A HREF=errno.html>errno</A> is set
+according to the error encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of <em>filename</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>path</em>
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>		<td>The named file does not exist.</td></tr>
+<tr><td>EINVAL</td>		<td>The named file is not a symlink.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>buf</em> or <em>path</em> points to an 
+				invalid address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/reboot.html b/os161-1.10/man/syscall/reboot.html
new file mode 100644
index 0000000..fbb7e7b
--- /dev/null
+++ b/os161-1.10/man/syscall/reboot.html
@@ -0,0 +1,48 @@
+<html>
+<head>
+<title>reboot</title>
+<body bgcolor=#ffffff>
+<h2 align=center>reboot</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+reboot - reboot or halt system
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+reboot(int <em>code</em>);
+
+<h3>Description</h3>
+
+reboot reboots or shuts down the system. The specific action depends
+on the <em>code</em> passed:
+<blockquote><table width=90%>
+<td width=10%>RB_REBOOT</td>	<td>The system is rebooted.</td></tr>
+<td width=10%>RB_HALT</td>	<td>The system is halted.</td></tr>
+<td width=10%>RB_POWEROFF</td>	<td>The system is powered off.</td></tr>
+</table></blockquote>
+
+<h3>Return Values</h3>
+
+On success, reboot does not return. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EINVAL</td>		<td><em>code</em> was not a valid value.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/remove.html b/os161-1.10/man/syscall/remove.html
new file mode 100644
index 0000000..aaf1cd0
--- /dev/null
+++ b/os161-1.10/man/syscall/remove.html
@@ -0,0 +1,56 @@
+<html>
+<head>
+<title>remove</title>
+<body bgcolor=#ffffff>
+<h2 align=center>remove</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+remove - delete (unlink) a file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+remove(const char *<em>pathname</em>);
+
+<h3>Description</h3>
+
+The name of the file referred to by <em>pathname</em> is removed from
+the filesystem. The actual file itself is not removed until no further
+references to it exist, whether those references are on disk or in
+memory.
+<p>
+
+It is an error for <em>pathname</em> to not specify an existing file
+or to refer to a directory.
+<p>
+
+<h3>Return Values</h3>
+On success, remove returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of <em>filename</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>pathname</em>
+				was not a directory.</td></tr>
+<tr><td>EISDIR</td>		<td><em>pathname</em> referred to a directory.</td></tr>
+<tr><td>ENOENT</td>		<td>The target file did not exist.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td><em>pathname</em> was an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/rename.html b/os161-1.10/man/syscall/rename.html
new file mode 100644
index 0000000..44950cb
--- /dev/null
+++ b/os161-1.10/man/syscall/rename.html
@@ -0,0 +1,97 @@
+<html>
+<head>
+<title>rename</title>
+<body bgcolor=#ffffff>
+<h2 align=center>rename</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+rename - rename or move a file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+rename(const char *<em>oldname</em>, const char *<em>newname</em>);
+
+<h3>Description</h3>
+
+The file (or other object) referenced by <em>oldname</em> is given the
+name <em>newname</em>, and the name <em>oldname</em> is removed. If
+<em>newname</em> already exists, it is removed as well. (The semantics
+for removing files and directories described under 
+<A HREF=remove.html>remove</A> and <A HREF=rmdir.html>rmdir</A>
+must be honored.)
+<p>
+
+If <em>newname</em> exists, it must be a directory if and only if
+<em>oldname</em> also is.
+<p>
+
+If components of the path prefix of <em>newname</em> do not exist or
+are not directories, rename fails. Additionally, <em>oldname</em> and
+<em>newname</em> must refer to names on the same filesystem.
+<p>
+
+If <em>oldname</em> and <em>newname</em> are the same file, rename
+succeeds and the state of the filesystem is not altered.
+<p>
+
+Rename must be atomic; no other process on the system should be able
+to see the filesystem in a state where both (or neither)
+<em>oldname</em> and <em>newname</em> name the file. Additionally, if
+the system crashes, at least one name for the file must remain.
+<p>
+
+If <em>oldname</em> is a directory, <em>newname</em> must not refer to
+a subdirectory of <em>oldname</em>, as this would create a cycle in the
+directory tree.
+<p>
+
+Renaming the "." or ".." entries in directories is prohibited.
+<p>
+
+<h3>Return Values</h3>
+On success, rename returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>		<td>The device prefix of one of the names did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of one of the names
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>		<td>A non-final component of <em>newname</em>   
+				did not exist.</td></tr>
+<tr><td>ENOENT</td>		<td><em>oldname</em> does not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td><em>oldname</em> is a directory, and 
+				<em>newname</em> is not.</td></tr>
+<tr><td>EISDIR</td>		<td><em>oldname</em> is not a directory, and 
+				<em>newname</em> is.</td></tr>
+<tr><td>ENOTEMPTY</td>	<td><em>newname</em> is a directory, and it is
+				not empty.</td>   
+<tr><td>EXDEV</td>		<td>The two names are on different filesystems.</td></tr>
+<tr><td>EINVAL</td>		<td><em>newname</em> is a subdirectory of
+				<em>oldname</em>.</td></tr>
+<tr><td>EINVAL</td>		<td>An attempt was made to rename "."</td></tr>
+<tr><td>ENOSPC</td>		<td>The filesystem involved is full.</td></tr>
+<tr><td>EIO</td>		<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>		<td>One of the arguments was an invalid pointer.</td></tr>
+
+</table></blockquote>
+
+As with rmdir, attempts to rename ".." may generate either EINVAL or
+ENOTEMPTY. 
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/rmdir.html b/os161-1.10/man/syscall/rmdir.html
new file mode 100644
index 0000000..a532fdf
--- /dev/null
+++ b/os161-1.10/man/syscall/rmdir.html
@@ -0,0 +1,77 @@
+<html>
+<head>
+<title>rmdir</title>
+<body bgcolor=#ffffff>
+<h2 align=center>rmdir</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+rmdir - remove directory
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+rmdir(const char *<em>pathname</em>);
+
+<h3>Description</h3>
+
+rmdir removes the directory named by <em>pathname</em>. The directory
+(and all the components in its path prefix) must exist. The directory
+must be empty, except for "." and "..", and may not be the root
+directory of the filesystem.
+<p>
+
+It is invalid to attempt to remove the "." or ".." entries in a
+directory. What rmdir actually removes is a name in some (other)
+directory; removing the "." or ".." <strong>names</strong> would make
+a mess. It is not invalid for a process to remove its own current
+directory, but it does not work to do so by calling rmdir(".").
+<p>
+
+It is impossible in any event to remove a directory named with "..",
+because it is impossible to name a directory with ".." unless it is
+not empty.
+<p>
+
+You must decide what happens if an attempt is made to remove a
+directory that is presently in use (e.g., is being read by ls, or is
+some process's current directory, etc.)
+<p>
+
+The removal must be atomic.
+<p>
+
+<h3>Return Values</h3>
+On success, rmdir returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>	<td>The device prefix of <em>filename</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>pathname</em>
+				was not a directory.</td></tr>
+<tr><td>ENOTDIR</td>	<td><em>pathname</em> referred to an object that
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>	<td>The target directory did not exist.</td></tr>
+<tr><td>EINVAL</td>	<td>An attempt was made to remove "."</td></tr>
+<tr><td>ENOTEMPTY</td>	<td>The target directory was not empty.</td></tr>
+<tr><td>EIO</td>	<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>	<td><em>pathname</em> was an invalid pointer.</td></tr>
+</table></blockquote>
+
+Attempts to remove ".." may generate either EINVAL or ENOTEMPTY.
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/sbrk.html b/os161-1.10/man/syscall/sbrk.html
new file mode 100644
index 0000000..7d7f915
--- /dev/null
+++ b/os161-1.10/man/syscall/sbrk.html
@@ -0,0 +1,88 @@
+<html>
+<head>
+<title>sbrk</title>
+<body bgcolor=#ffffff>
+<h2 align=center>sbrk</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+sbrk - set process break (allocate memory)
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+void *<br>
+sbrk(intptr_t <em>amount</em>);
+
+<h3>Description</h3>
+
+The "break" is the end address of a process's heap region. The sbrk
+call adjusts the "break" by the amount <em>amount</em>. It returns the
+old "break". Thus, to determine the current "break", call sbrk(0).
+<p>
+
+The heap region is initially empty, so at process startup, the
+beginning of the heap region is the same as the end and may thus be
+retrieved using sbrk(0).
+<p>
+
+In OS/161, the initial "break" must be page-aligned, and sbrk only
+need support values of <em>amount</em> that result in page-aligned
+"break" addresses. Other values of <em>amount</em> may be rejected.
+(This may simplify the implementation. On the other hand, you may
+choose to support unaligned values anyway, as that may simplify your
+malloc code.)
+<p>
+
+Traditionally, the initial "break" is specifically defined to be the
+end of the BSS (uninitialized data) region, and any <em>amount</em>,
+page-aligned or not, may legally be used with sbrk.
+<p>
+
+Ordinarily, user-level code should call
+<A HREF=../libc/malloc.html>malloc</A> for memory allocation. The
+sbrk interface is intended only to be the back-end interface for
+malloc. Mixing calls to malloc and sbrk will likely confuse malloc and
+produces undefined behavior.
+<p>
+
+While one can lower the "break" by passing negative values of
+<em>amount</em>, one may not set the end of the heap to an address
+lower than the beginning of the heap. Attempts to do so must be
+rejected. 
+<p>
+
+<h3>Return Values</h3>
+
+On success, sbrk returns the previous value of the "break".  On error,
+((void *)-1) is returned, and <A HREF=errno.html>errno</A> is set
+according to the error encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENOMEM</td>	<td>Sufficient virtual memory to satisfy the
+				request was not available, or the
+				process has reached the limit of the
+				memory it is allowed to allocate.</td></tr>
+<tr><td>EINVAL</td>	<td>The request would move the "break" below
+				its initial value.</td></tr>
+</table></blockquote>
+
+<h3>Restrictions</h3>
+
+While you can return pages that happen to be at the end of the heap to
+the system, there is no way to use the sbrk interface to return unused
+pages in the middle of the heap. If you wish to do this, you will need
+to design a new or supplemental interface.
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/stat.html b/os161-1.10/man/syscall/stat.html
new file mode 100644
index 0000000..65c77c4
--- /dev/null
+++ b/os161-1.10/man/syscall/stat.html
@@ -0,0 +1,50 @@
+<html>
+<head>
+<title>stat</title>
+<body bgcolor=#ffffff>
+<h2 align=center>stat</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+stat - get file state information
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;sys/stat.h&gt;<br>
+<br>
+int<br>
+stat(const char *<em>pathname</em>, struct stat *<em>statbuf</em>);
+
+<h3>Description</h3>
+
+stat retrieves status information about the file referred to by
+<em>pathname</em> and stores it in the stat structure pointed to
+by <em>statbuf</em>.
+
+<h3>Return Values</h3>
+On success, stat returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>	<td>The device prefix of <em>filename</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>pathname</em>
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>	<td>The named file does not exist.</td></tr>
+<tr><td>EIO</td>	<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>	<td><em>statbuf</em> points to an invalid 
+				address.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/symlink.html b/os161-1.10/man/syscall/symlink.html
new file mode 100644
index 0000000..b7eaaf9
--- /dev/null
+++ b/os161-1.10/man/syscall/symlink.html
@@ -0,0 +1,56 @@
+<html>
+<head>
+<title>symlink</title>
+<body bgcolor=#ffffff>
+<h2 align=center>symlink</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+symlink - create symbolic link
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+symlink(const char *<em>oldname</em>, const char *<em>linkname</em>);
+
+<h3>Description</h3>
+
+symlink creates a symbolic link. The symlink itself is named
+<em>linkname</em>, and it points to <em>oldname</em>.
+<p>
+
+<em>oldname</em> need not exist or be on the same filesystem.
+
+<h3>Return Values</h3>
+On success, symlink returns 0. On error, -1 is returned, and
+<A HREF=errno.html>errno</A> is set according to the error
+encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>ENODEV</td>	<td>The device prefix of <em>filename</em> did
+				not exist.</td></tr>
+<tr><td>ENOTDIR</td>	<td>A non-final component of <em>linkname</em>
+				was not a directory.</td></tr>
+<tr><td>ENOENT</td>	<td>A non-final component of <em>linkname</em>
+				did not exist.</td></tr>
+<tr><td>EEXIST</td>	<td><em>linkname</em> already exists.</td></tr>
+<tr><td>ENOSPC</td>	<td>The filesystem that was to hold the link
+				is full.</td></tr>
+<tr><td>EIO</td>	<td>A hard I/O error occurred.</td></tr>
+<tr><td>EFAULT</td>	<td><em>linkname</em> or <em>oldname</em> was
+				an invalid pointer.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/sync.html b/os161-1.10/man/syscall/sync.html
new file mode 100644
index 0000000..746b903
--- /dev/null
+++ b/os161-1.10/man/syscall/sync.html
@@ -0,0 +1,35 @@
+<html>
+<head>
+<title>sync</title>
+<body bgcolor=#ffffff>
+<h2 align=center>sync</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+sync - flush filesystem data to disk
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+void<br>
+sync(void);
+
+<h3>Description</h3>
+
+The sync function forces a write of all dirty filesystem buffers and
+dirty filesystem state to disk.
+<p>
+
+<h3>Return Values</h3>
+
+No value is returned, and sync does not fail.
+
+<h3>Errors</h3>
+
+None.
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/waitpid.html b/os161-1.10/man/syscall/waitpid.html
new file mode 100644
index 0000000..4bbdec1
--- /dev/null
+++ b/os161-1.10/man/syscall/waitpid.html
@@ -0,0 +1,110 @@
+<html>
+<head>
+<title>waitpid</title>
+<body bgcolor=#ffffff>
+<h2 align=center>waitpid</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+waitpid - wait for a process to exit
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;sys/wait.h&gt;<br>
+<br>
+pid_t<br>
+waitpid(pid_t <em>pid</em>, int *<em>status</em>, int <em>options</em>);
+
+<h3>Description</h3>
+
+Wait for the process specified by <em>pid</em> to exit, and return its
+exit code in the integer pointed to by <em>status</em>. If that
+process has exited already, waitpid returns immediately. If that
+process does not exist, waitpid fails.
+<p>
+
+What it means for a process to move from "has exited already" to "does
+not exist", and when this occurs, is something you must decide.
+<p>
+
+If process P is "interested" in the exit code of process Q, process P
+should be able to find out that exit code by calling waitpid, even if
+Q exits somewhat before the time P calls waitpid. As described under
+<A HREF=_exit.html>_exit()</A>, precisely what is meant by "interested"
+is up to you.
+<p>
+
+You might implement restrictions or requirements on who may wait
+for which processes, like Unix does. You might also add a system
+call for one process to express interest in another process's exit
+code. If you do this, be sure to write a man page for the system 
+call, and discuss the rationale for your choices therein in your
+design document.
+<p>
+
+Note that in the absence of restrictions on who may wait for what, it
+is possible to set up situations that may result in deadlock. Your
+system must (of course) in some manner protect itself from these
+situations, either by prohibiting them or by detecting and resolving
+them.
+<p>
+
+In order to make the userlevel code that ships with OS/161 work, assume
+that a parent process is always interested in the exit codes of its
+child processes generated with <A HREF=fork.html>fork()</A>, unless it
+does something special to indicate otherwise.
+<p>
+
+The <em>options</em> argument should be 0. You are not required to
+implement any options. (However, your system should check to make sure
+that options you do not support are not requested.)
+<p>
+
+If you desire, you may implement the Unix option WNOHANG; this causes
+waitpid, when called for a process that has not yet exited, to return
+0 immediately instead of waiting.
+<p>
+
+You may also make up your own options if you find them helpful.
+However, please, document anything you make up.
+<p>
+
+<h3>Return Values</h3>
+
+waitpid returns the process id whose exit status is reported in
+<em>status</em>. In OS/161, this is always the value of <em>pid</em>.
+<p>
+
+If you implement WNOHANG, and WNOHANG is given, and the process
+specified by <em>pid</em> has not yet exited, waitpid returns 0.
+<p>
+
+(In Unix, but not OS/161, you can wait for any of several processes by
+passing magic values of <em>pid</em>, so this return value can
+actually be useful.)
+<p>
+
+On error, -1 is returned, and errno is set to a suitable error code
+for the error condition encountered.
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EINVAL</td>	<td>The <em>options</em> argument requested invalid or
+			unsupported options.</td></tr>
+<tr><td>EFAULT</td>	<td>The <em>status</em> argument was an 
+			invalid pointer.</td></tr>
+</table></blockquote>
+
+The traditional Unix error code for "no such process" is ESRCH,
+although this code is not defined in the OS/161 base system.
+
+</body>
+</html>
diff --git a/os161-1.10/man/syscall/write.html b/os161-1.10/man/syscall/write.html
new file mode 100644
index 0000000..804ccc9
--- /dev/null
+++ b/os161-1.10/man/syscall/write.html
@@ -0,0 +1,72 @@
+<html>
+<head>
+<title>write</title>
+<body bgcolor=#ffffff>
+<h2 align=center>write</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+write - write data to file
+
+<h3>Library</h3>
+Standard C Library (libc, -lc)
+
+<h3>Synopsis</h3>
+#include &lt;unistd.h&gt;<br>
+<br>
+int<br>
+write(int <em>fd</em>, const void *<em>buf</em>, size_t <em>nbytes></em>);
+
+<h3>Description</h3>
+
+write writes up to <em>buflen</em> bytes to the file specified by
+<em>fd</em>, at the location in the file specified by the current
+seek position of the file, taking the data from the space pointed
+to by <em>buf</em>. The file must be open for writing.
+<p>
+
+The current seek position of the file is advanced by the number of
+bytes written.
+<p>
+
+Each write (or <A HREF=read.html>read</A>) operation is atomic
+relative to other I/O to the same file.
+<p>
+
+<h3>Return Values</h3>
+
+The count of bytes written is returned. This count should be
+positive. A return value of 0 means that nothing could be written,
+but that no error occurred; this only occurs at end-of-file on
+fixed-size objects. On error, write returns -1 and sets 
+<A HREF=errno.html>errno</A> to a suitable error code for the error
+condition encountered.
+<p>
+
+Note that in some cases, particularly on devices, fewer than
+<em>buflen</em> (but greater than zero) bytes may be written. This
+depends on circumstances and does not necessarily signify
+end-of-file. In most cases, one should loop to make sure that all
+output has actually been written.
+<p>
+
+<h3>Errors</h3>
+
+The following error codes should be returned under the conditions
+given. Other error codes may be returned for other errors not
+mentioned here.
+
+<blockquote><table width=90%>
+<td width=10%>&nbsp;</td><td>&nbsp;</td></tr>
+<tr><td>EBADF</td>	<td><em>fd</em> is not a valid file descriptor, or was
+			not opened for writing.</td></tr>
+<tr><td>EFAULT</td>	<td>Part or all of the address space pointed to by
+			<em>buf</em> is invalid.</td></tr>
+<tr><td>ENOSPC</td>	<td>There is no free space remaining on the filesystem
+			containing the file.</td></tr>
+<tr><td>EIO</td>	<td>A hardware I/O error occurred writing 
+			the data.</td></tr>
+</table></blockquote>
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/Makefile b/os161-1.10/man/testbin/Makefile
new file mode 100644
index 0000000..38e42ea
--- /dev/null
+++ b/os161-1.10/man/testbin/Makefile
@@ -0,0 +1,6 @@
+# Man pages for /testbin programs
+
+MANDIR=/man/testbin
+
+include ../../defs.mk
+include ../../mk/man.mk
diff --git a/os161-1.10/man/testbin/add.html b/os161-1.10/man/testbin/add.html
new file mode 100644
index 0000000..2a70333
--- /dev/null
+++ b/os161-1.10/man/testbin/add.html
@@ -0,0 +1,29 @@
+<html>
+<head>
+<title>add</title>
+<body bgcolor=#ffffff>
+<h2 align=center>add</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+add - add two numbers
+
+<h3>Synopsis</h3>
+/testbin/add <em>n1</em> <em>n2</em>
+
+<h3>Description</h3>
+
+add prints the sum of the two numbers passed as arguments.
+
+<h3>Requirements</h3>
+
+add uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+add should work properly once the basic system calls are complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/argtest.html b/os161-1.10/man/testbin/argtest.html
new file mode 100644
index 0000000..0215434
--- /dev/null
+++ b/os161-1.10/man/testbin/argtest.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>argtest</title>
+<body bgcolor=#ffffff>
+<h2 align=center>argtest</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+argtest - display arguments passed through execv
+
+<h3>Synopsis</h3>
+/testbin/argtest <em>args</em>
+
+<h3>Description</h3>
+
+argtest prints its arguments. This is likely to be helpful for testing
+execv during the basic system calls assignment.
+
+<h3>Requirements</h3>
+
+argtest uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+argument passing should work once the basic system calls are complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/badcall.html b/os161-1.10/man/testbin/badcall.html
new file mode 100644
index 0000000..679bd03
--- /dev/null
+++ b/os161-1.10/man/testbin/badcall.html
@@ -0,0 +1,53 @@
+<html>
+<head>
+<title>badcall</title>
+<body bgcolor=#ffffff>
+<h2 align=center>badcall</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+badcall - make invalid system calls
+
+<h3>Synopsis</h3>
+/testbin/badcall [<em>test...</em>]
+
+<h3>Description</h3>
+
+badcall contains a variety of tests for system call error conditions
+and error handling. The tests are grouped by system call; all
+available tests for a particular system call are run when that system
+call is selected. 
+<p>
+
+None of the tests should crash the system. If you kill processes when
+system calls fail with EFAULT (a valid thing to do) badcall itself may
+get killed. Otherwise, badcall should not get killed either.
+<p>
+
+Tests may be selected on the command line; if so, all the tests
+selected on the command line will be run in order. If nothing is
+selected on the command line, a menu is printed and tests are prompted
+for.
+<p>
+
+The tests for the individual syscalls are specified with the letters
+`a' through `y'. A single-digit number may also be specified; this
+tests all the system calls that are supposed to work once the
+corresponding assignment is completed. `*' may be used to test
+everything. Use `!' to quit.
+
+<h3>Requirements</h3>
+
+badcall can test every system call. It requires
+<A HREF=../syscall/read.html>read</A> and 
+<A HREF=../syscall/write.html>write</A> itself to work properly, and
+some of the tests may use syscalls other than the ones being tested.
+<p>
+
+At the completion of each assignment, the system should pass the
+tests for the syscalls associated with that (and previous)
+assignments. At no time should anything badcall does crash the
+system. 
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/bigfile.html b/os161-1.10/man/testbin/bigfile.html
new file mode 100644
index 0000000..aa33642
--- /dev/null
+++ b/os161-1.10/man/testbin/bigfile.html
@@ -0,0 +1,33 @@
+<html>
+<head>
+<title>bigfile</title>
+<body bgcolor=#ffffff>
+<h2 align=center>bigfile</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+bigfile - create a large file in small chunks
+
+<h3>Synopsis</h3>
+/testbin/bigfile <em>filename</em> <em>size</em>
+
+<h3>Description</h3>
+
+bigfile creates a file of the specified size in fairly small chunks.
+
+<h3>Requirements</h3>
+
+bigfile uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+bigfile should run on emufs once the basic system calls are complete,
+and should run on SFS once the file system assignment is complete.
+Sufficiently small files should work on SFS even before that point.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/conman.html b/os161-1.10/man/testbin/conman.html
new file mode 100644
index 0000000..ccad49b
--- /dev/null
+++ b/os161-1.10/man/testbin/conman.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>conman</title>
+<body bgcolor=#ffffff>
+<h2 align=center>conman</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+conman - echo typed characters
+
+<h3>Synopsis</h3>
+/testbin/conman [-options] [args]
+
+<h3>Description</h3>
+
+conman echos characters typed on standard input until `q' is pressed.
+
+<h3>Requirements</h3>
+
+conman uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+conman should work once the basic system call assignment is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/crash.html b/os161-1.10/man/testbin/crash.html
new file mode 100644
index 0000000..4d3768f
--- /dev/null
+++ b/os161-1.10/man/testbin/crash.html
@@ -0,0 +1,49 @@
+<html>
+<head>
+<title>crash</title>
+<body bgcolor=#ffffff>
+<h2 align=center>crash</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+crash - commit various exceptions
+
+<h3>Synopsis</h3>
+/testbin/crash [<em>operation</em>]
+
+<h3>Description</h3>
+
+crash will perform any one of fourteen illegal processor operations,
+any one of which should get it killed without causing the whole system
+to crash.
+<p>
+
+The operations are coded `a' through `n' and may be chosen on the
+command line. If no operation is chosen, a menu is displayed and a
+choice solicited.
+<p>
+
+<h3>Restrictions</h3>
+
+Test `f', which writes into the process's own code segment, will only
+cause a processor exception if you implement read-only code segments.
+Since this is not required, it is not required that test `f' pass.
+<p>
+
+However, using test `f' must not under any circumstances corrupt the
+code in the copy of crash on disk!
+
+<h3>Requirements</h3>
+
+crash uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+crash should operate properly once the basic system call assignment is
+complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/ctest.html b/os161-1.10/man/testbin/ctest.html
new file mode 100644
index 0000000..91a2aac
--- /dev/null
+++ b/os161-1.10/man/testbin/ctest.html
@@ -0,0 +1,39 @@
+<html>
+<head>
+<title>ctest</title>
+<body bgcolor=#ffffff>
+<h2 align=center>ctest</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+ctest - cyclic stride-oriented VM test
+
+<h3>Synopsis</h3>
+/testbin/ctest [<em>stride</em>]
+
+<h3>Description</h3>
+
+ctest creates a 1-megabyte array of pointers and sets it up as a
+circular linked list, then traverses the linked list. The linked
+list is set up so each entry points to the one <em>stride</em> entries
+away.
+<p>
+
+The <em>stride</em> argument should be odd, so all elements in the
+list are accessed.
+<p>
+
+The default stride is 477.
+
+<h3>Requirements</h3>
+
+ctest uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+ctest should function properly once the VM assignment is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/dirseek.html b/os161-1.10/man/testbin/dirseek.html
new file mode 100644
index 0000000..51f3380
--- /dev/null
+++ b/os161-1.10/man/testbin/dirseek.html
@@ -0,0 +1,41 @@
+<html>
+<head>
+<title>dirseek</title>
+<body bgcolor=#ffffff>
+<h2 align=center>dirseek</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+dirseek - seek on directories test
+
+<h3>Synopsis</h3>
+/testbin/dirseek
+
+<h3>Description</h3>
+
+dirseek creates a test directory, creates some files in it, and lists
+the directory repeatedly, seeking in a variety of ways (some legal,
+some not).
+
+<h3>Requirements</h3>
+
+dirseek uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/chdir.html>chdir</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/getdirentry.html>getdirentry</A>
+<li> <A HREF=../syscall/lseek.html>lseek</A>
+<li> <A HREF=../syscall/mkdir.html>mkdir</A>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/remove.html>remove</A>
+<li> <A HREF=../syscall/rmdir.html>rmdir</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+dirseek should run (on SFS filesystems) when the file system
+assignment is complete. It will not run on emufs, because emufs does
+not support mkdir or rmdir.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/dirtest.html b/os161-1.10/man/testbin/dirtest.html
new file mode 100644
index 0000000..dd9d9b0
--- /dev/null
+++ b/os161-1.10/man/testbin/dirtest.html
@@ -0,0 +1,33 @@
+<html>
+<head>
+<title>dirtest</title>
+<body bgcolor=#ffffff>
+<h2 align=center>dirtest</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+dirtest - simple subdirectories test
+
+<h3>Synopsis</h3>
+/testbin/dirtest
+
+<h3>Description</h3>
+
+dirtest creates and then removes a series of nested directories.
+
+<h3>Requirements</h3>
+
+dirtest uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/mkdir.html>mkdir</A>
+<li> <A HREF=../syscall/rmdir.html>rmdir</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+dirtest should run (on SFS filesystems) when the file system
+assignment is complete. It will not run on emufs, because emufs does
+not support rmdir.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/f_test.html b/os161-1.10/man/testbin/f_test.html
new file mode 100644
index 0000000..0795929
--- /dev/null
+++ b/os161-1.10/man/testbin/f_test.html
@@ -0,0 +1,51 @@
+<html>
+<head>
+<title>f_test</title>
+<body bgcolor=#ffffff>
+<h2 align=center>f_test</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+f_test - basic concurrent filesystem test
+
+<h3>Synopsis</h3>
+/testbin/f_test [1|2|3]
+
+<h3>Description</h3>
+
+f_test consists of three tests, 1-3, that can be specified on the
+command line. If nothing is specified, all three tests are run.
+<p>
+
+Test 1 writes a large file (a bit over 270k) and reads it back.
+<p>
+
+Test 2 creates and removes a directory tree, rather like
+<A HREF=dirtest.html>dirtest</A>.
+<p>
+
+Test 3 spawns three subprocesses that simultaneously read and write
+the same file.
+<p>
+
+<h3>Requirements</h3>
+
+f_test uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/waitpid.html>waitpid</A>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/mkdir.html>mkdir</A>
+<li> <A HREF=../syscall/rmdir.html>rmdir</A>
+<li> <A HREF=../syscall/remove.html>remove</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+f_test should run correctly once the file system assignment is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/farm.html b/os161-1.10/man/testbin/farm.html
new file mode 100644
index 0000000..eb220ef
--- /dev/null
+++ b/os161-1.10/man/testbin/farm.html
@@ -0,0 +1,47 @@
+<html>
+<head>
+<title>farm</title>
+<body bgcolor=#ffffff>
+<h2 align=center>farm</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+farm - run some hogs and cats
+
+<h3>Synopsis</h3>
+/testbin/farm
+
+<h3>Description</h3>
+
+farm runs three copies of <A HREF=hog.html>hog</A> and one copy of
+<A HREF=../bin/cat.html>/bin/cat</A>.
+<p>
+
+The cat process reads and prints the file <strong>catfile</strong>,
+which you should create in advance.
+
+<h3>Requirements</h3>
+
+farm uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+The cat subprocess spawned by farm uses these additional system calls:
+<ul>
+<li><A HREF=../syscall/open.html>open</A>
+<li><A HREF=../syscall/read.html>read</A>
+<li><A HREF=../syscall/close.html>close</A>
+</ul>
+
+farm is only likely to be useful for testing the scheduler.
+
+<h3>Bugs</h3>
+
+farm does not wait for its child processes to finish.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/faulter.html b/os161-1.10/man/testbin/faulter.html
new file mode 100644
index 0000000..1befaf6
--- /dev/null
+++ b/os161-1.10/man/testbin/faulter.html
@@ -0,0 +1,31 @@
+<html>
+<head>
+<title>faulter</title>
+<body bgcolor=#ffffff>
+<h2 align=center>faulter</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+faulter - commit address fault
+
+<h3>Synopsis</h3>
+/testbin/faulter
+
+<h3>Description</h3>
+
+faulter accesses an invalid memory address, thus crashing. It should
+be killed and not crash the entire system.
+
+<h3>Requirements</h3>
+
+faulter uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+faulter should work properly, that is, get killed with an address
+fault, once the basic system calls assignment is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/filetest.html b/os161-1.10/man/testbin/filetest.html
new file mode 100644
index 0000000..a2abae9
--- /dev/null
+++ b/os161-1.10/man/testbin/filetest.html
@@ -0,0 +1,40 @@
+<html>
+<head>
+<title>filetest</title>
+<body bgcolor=#ffffff>
+<h2 align=center>filetest</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+filetest - basic filesystem test
+
+<h3>Synopsis</h3>
+/testbin/filetest <em>filename</em>
+
+<h3>Description</h3>
+
+filetest tests the filesystem by opening, writing to, and reading from
+a user-specified file.
+
+<h3>Requirements</h3>
+
+filetest uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/remove.html>remove</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+filetest should run correctly on SFS filesystems with the OS/161
+system as shipped. It should continue to work once the file system
+assignment is complete.
+<p>
+
+It will not work in full on emufs, because emufs does not support
+remove(). 
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/forkbomb.html b/os161-1.10/man/testbin/forkbomb.html
new file mode 100644
index 0000000..7ece672
--- /dev/null
+++ b/os161-1.10/man/testbin/forkbomb.html
@@ -0,0 +1,55 @@
+<html>
+<head>
+<title>forkbomb</title>
+<body bgcolor=#ffffff>
+<h2 align=center>forkbomb</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+forkbomb - create hundreds of processes
+
+<h3>Synopsis</h3>
+/testbin/forkbomb
+
+<h3>Description</h3>
+
+forkbomb does
+<pre>
+   while (1) fork();
+</pre>
+
+doing a bit of additional checking similar to that done by 
+<A HREF=forktest.html>forktest</A>.
+<p> 
+
+<strong>
+DO NOT RUN THIS ON A REAL SYSTEM - IT WILL GRIND TO A HALT AND
+PEOPLE WILL COME AFTER YOU WIELDING BASEBALL BATS AND/OR THE AD
+BOARD<sup><font size=-1>*</font></sup>. WE WARNED YOU.
+</strong>
+<p>
+
+<font size=-1><i><sup>*</sup> The Administrative Board of Harvard
+College handles formal disciplinary action.</i></font>
+
+<h3>Requirements</h3>
+
+forkbomb uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/getpid.html>getpid</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+We don't expect your system to withstand this without grinding to
+a halt, but once your basic system calls are complete it shouldn't
+crash. Likewise for after your virtual memory system is complete.
+<p>
+
+Note that this may turn out to be hard to achieve in practice. Don't
+spend much time fixing problems forkbomb triggers that won't arise
+under more normal operation. (If in doubt, consult the course staff.)
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/forktest.html b/os161-1.10/man/testbin/forktest.html
new file mode 100644
index 0000000..1f9f682
--- /dev/null
+++ b/os161-1.10/man/testbin/forktest.html
@@ -0,0 +1,32 @@
+<html>
+<head>
+<title>forktest</title>
+<body bgcolor=#ffffff>
+<h2 align=center>forktest</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+forktest - test fork system call
+
+<h3>Synopsis</h3>
+/testbin/forktest
+
+<h3>Description</h3>
+
+forktest forks a few times and tries to make sure each fork has its
+own data and stack.
+
+<h3>Requirements</h3>
+
+forktest uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/getpid.html>getpid</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+forktest should run successfully once the VM assignment is completed.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/guzzle.html b/os161-1.10/man/testbin/guzzle.html
new file mode 100644
index 0000000..19ce7e7
--- /dev/null
+++ b/os161-1.10/man/testbin/guzzle.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>guzzle</title>
+<body bgcolor=#ffffff>
+<h2 align=center>guzzle</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+guzzle - waste cpu
+
+<h3>Synopsis</h3>
+/testbin/guzzle [<em>character</em>]
+
+<h3>Description</h3>
+
+guzzle burns cpu and periodically prints a character. The default
+character is a plus sign (+). It differs from <A HREF=hog.html>hog</A>
+chiefly in the printing and in that it runs longer.
+
+<h3>Requirements</h3>
+
+guzzle uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+It is only likely to be useful for testing the scheduler.
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/hash.html b/os161-1.10/man/testbin/hash.html
new file mode 100644
index 0000000..3166a83
--- /dev/null
+++ b/os161-1.10/man/testbin/hash.html
@@ -0,0 +1,41 @@
+<html>
+<head>
+<title>hash</title>
+<body bgcolor=#ffffff>
+<h2 align=center>hash</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+hash - compute a simple hash function of a file
+
+<h3>Synopsis</h3>
+/testbin/hash <em>file</em>
+<br>
+host-hash <em>file</em>
+
+<h3>Description</h3>
+
+hash takes a file and computes a hash value for it by adding all the
+bytes in the file together modulo a prime.
+<p>
+
+hash is by default also compiled for the System/161 host OS so you can
+cross-check the answers you get.
+
+<h3>Requirements</h3>
+
+hash uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+Once the basic system calls are complete, hash should work on any file
+the system supports. However, it will probably of most use for testing
+while working on the file system assignment.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/hog.html b/os161-1.10/man/testbin/hog.html
new file mode 100644
index 0000000..8c3b6de
--- /dev/null
+++ b/os161-1.10/man/testbin/hog.html
@@ -0,0 +1,27 @@
+<html>
+<head>
+<title>hog</title>
+<body bgcolor=#ffffff>
+<h2 align=center>hog</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+hog - waste cpu
+
+<h3>Synopsis</h3>
+/testbin/hog
+
+<h3>Description</h3>
+
+hog does nothing but burn cpu. It is not substantially different from
+<A HREF=guzzle.html>guzzle</A>.
+
+<h3>Requirements</h3>
+
+hog uses only the <A HREF=../syscall/_exit.html>_exit</A> system call.
+<p>
+
+It is only likely to be useful for testing the scheduler.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/huge.html b/os161-1.10/man/testbin/huge.html
new file mode 100644
index 0000000..fae1191
--- /dev/null
+++ b/os161-1.10/man/testbin/huge.html
@@ -0,0 +1,33 @@
+<html>
+<head>
+<title>huge</title>
+<body bgcolor=#ffffff>
+<h2 align=center>huge</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+huge - very large VM test
+
+<h3>Synopsis</h3>
+/testbin/huge
+
+<h3>Description</h3>
+
+huge creates an 8 megabyte data array and manipulates it. It will
+hopefully help show up bugs in the VM system.
+<p>
+
+It does not in fact do anything useful if it completes successfully..
+
+<h3>Requirements</h3>
+
+huge uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+huge should run properly once the VM assignment is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/index.html b/os161-1.10/man/testbin/index.html
new file mode 100644
index 0000000..759ad56
--- /dev/null
+++ b/os161-1.10/man/testbin/index.html
@@ -0,0 +1,59 @@
+<html>
+<head>
+<title>OS/161 Test binaries</title>
+</head>
+<body bgcolor=#ffffff>
+
+<h2 align=center>OS/161 Test binaries (/testbin)</h2>
+
+<p align=center>
+<A HREF=..>Top</A> |
+<A HREF=../bin>Binaries</A> |
+<A HREF=../sbin>Sysadmin binaries</A> |
+<A HREF=../libc>C standard library</A> |
+<A HREF=../syscall>System calls</A> |
+<A HREF=../dev>Device drivers</A> |
+<A HREF=../misc>Miscellaneous</A>
+</p>
+<br>
+
+<ul>
+<li> <A HREF=add.html>add</A> - add two numbers
+<li> <A HREF=argtest.html>argtest</A> - display arguments passed through execv
+<li> <A HREF=badcall.html>badcall</A> - make invalid system calls
+<li> <A HREF=bigfile.html>bigfile</A> - create a large file in small chunks
+<li> <A HREF=conman.html>conman</A> - echo typed characters
+<li> <A HREF=crash.html>crash</A> - commit various exceptions
+<li> <A HREF=ctest.html>ctest</A> - cyclic stride-oriented VM test
+<li> <A HREF=dirseek.html>dirseek</A> - seek on directories test
+<li> <A HREF=dirtest.html>dirtest</A> - simple subdirectories test
+<li> <A HREF=f_test.html>f_test</A> - basic concurrent filesystem test
+<li> <A HREF=farm.html>farm</A> - run some hogs and cats
+<li> <A HREF=faulter.html>faulter</A> - commit address fault
+<li> <A HREF=filetest.html>filetest</A> - basic filesystem test
+<li> <A HREF=forkbomb.html>forkbomb</A> - create hundreds of processes
+<li> <A HREF=forktest.html>forktest</A> - test fork system call
+<li> <A HREF=guzzle.html>guzzle</A> - waste cpu
+<li> <A HREF=hash.html>hash</A> - compute a simple hash function of a file
+<li> <A HREF=hog.html>hog</A> - waste cpu
+<li> <A HREF=huge.html>huge</A> - very large VM test
+<li> <A HREF=kitchen.html>kitchen</A> - run some sinks
+<li> <A HREF=malloctest.html>malloctest</A> - some simple tests for 
+   userlevel malloc
+<li> <A HREF=matmult.html>matmult</A> - baseline VM stress test
+<li> <A HREF=palin.html>palin</A> - simple VM test
+<li> <A HREF=randcall.html>randcall</A> - make randomized system calls
+<li> <A HREF=rmdirtest.html>rmdirtest</A> - test removing in-use directories
+<li> <A HREF=rmtest.html>rmtest</A> - test removing open files
+<li> <A HREF=sink.html>sink</A> - accept and throw away console input
+<li> <A HREF=sort.html>sort</A> - large quicksort-based VM test
+<li> <A HREF=sty.html>sty</A> - run some hogs
+<li> <A HREF=tail.html>tail</A> - print part of a file
+<li> <A HREF=tictac.html>tictac</A> - tic-tac-toe game
+<li> <A HREF=triplehuge.html>triplehuge</A> - very very large VM test
+<li> <A HREF=triplemat.html>triplemat</A> - very large VM test
+<li> <A HREF=userthreads.html>userthreads</A> - simple user-level threads test
+</ul>
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/kitchen.html b/os161-1.10/man/testbin/kitchen.html
new file mode 100644
index 0000000..9628991
--- /dev/null
+++ b/os161-1.10/man/testbin/kitchen.html
@@ -0,0 +1,42 @@
+<html>
+<head>
+<title>kitchen</title>
+<body bgcolor=#ffffff>
+<h2 align=center>kitchen</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+kitchen - run some sinks
+
+<h3>Synopsis</h3>
+/testbin/kitchen
+
+<h3>Description</h3>
+
+Runs four copies of <A HREF=sink.html>sink</A>. It may be useful for
+testing concurrent access to the console device. It may also be useful
+for testing job control, if you choose to pursue job control.
+
+<h3>Requirements</h3>
+
+kitchen uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+Additionally, the subprocesses it spawns use the
+<A HREF=../syscall/read.html>read</A> system call.
+<p>
+
+kitchen should function correctly once the basic system calls are
+complete.
+
+<h3>Bugs</h3>
+
+kitchen does not wait for its child processes to exit.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/malloctest.html b/os161-1.10/man/testbin/malloctest.html
new file mode 100644
index 0000000..8dfe9ff
--- /dev/null
+++ b/os161-1.10/man/testbin/malloctest.html
@@ -0,0 +1,64 @@
+<html>
+<head>
+<title>malloctest</title>
+<body bgcolor=#ffffff>
+<h2 align=center>malloctest</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+malloctest - some simple tests for userlevel malloc
+
+<h3>Synopsis</h3>
+/testbin/malloctest [<em>test</em>...]
+
+<h3>Description</h3>
+
+malloctest contains 7 tests, 1-7. These may be run interactively or
+from the command line.
+<p>
+
+Test 1 checks if all the bytes we ask for actually get allocated.
+<p>
+
+Test 2 checks if malloc gracefully handles failing requests. This test
+assumes that malloc will eventually fail if one keeps allocating
+enough memory, instead of promising memory it can't deliver and
+then (perhaps) killing processes when it runs out. More detail
+regarding this condition can be found in comments in the source code.
+<p>
+
+Test 3 also checks if malloc gracefully handles failing requests, and
+thus has the same restrictions as test 2.
+<p>
+
+Test 4 attempts to check if malloc coalesces the free list properly.
+This test is only meant for first-fit, next-fit, or best-fit
+allocators; anything else will most likely confuse it. Running test 4
+after other tests may confuse it as well.
+<p>
+
+Tests 5-7 are a randomized stress test. Test 5 uses pseudorandom seed
+0. Test 6 seeds the random generator from the
+<A HREF=../dev/random.html>random:</A> device. Test 7 prompts you for
+a specific seed.
+<p>
+
+<h3>Requirements</h3>
+
+malloctest uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+malloctest also requires a user-level malloc/free implementation.
+<p>
+
+Your system should pass all the malloctest tests, subject to the
+conditions described above, once your user-level malloc is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/matmult.html b/os161-1.10/man/testbin/matmult.html
new file mode 100644
index 0000000..0e09685
--- /dev/null
+++ b/os161-1.10/man/testbin/matmult.html
@@ -0,0 +1,37 @@
+<html>
+<head>
+<title>matmult</title>
+<body bgcolor=#ffffff>
+<h2 align=center>matmult</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+matmult - baseline VM stress test
+
+<h3>Synopsis</h3>
+/testbin/matmult
+
+<h3>Description</h3>
+
+matmult multiplies two large matrices together and checks the result.
+Hopefully this will help detect bugs in the VM system.
+<p>
+
+The version for OS/161 has been gimmicked to be less efficient
+space-wise than normal matrix multiplication. This allows it to both
+take up an interesting amount of memory and run in a non-boring amount
+of time.
+
+<h3>Requirements</h3>
+
+matmult uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+matmult should run correctly once the VM system assignment is
+complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/palin.html b/os161-1.10/man/testbin/palin.html
new file mode 100644
index 0000000..b03e1d7
--- /dev/null
+++ b/os161-1.10/man/testbin/palin.html
@@ -0,0 +1,37 @@
+<html>
+<head>
+<title>palin</title>
+<body bgcolor=#ffffff>
+<h2 align=center>palin</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+palin - simple VM test
+
+<h3>Synopsis</h3>
+/testbin/palin [-options] [args]
+
+<h3>Description</h3>
+
+palin checks a long string contained within itself for being
+palindromic. The check should pass.
+<p>
+
+The string is not actually all that long and this test does not stress
+the VM in any real sense of the word. However, it might be a useful
+test early on in the debugging phase.
+
+<h3>Requirements</h3>
+
+palin uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+palin should run correctly once the basic system calls are complete,
+and should continue to run correctly once the VM system assignment is
+complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/randcall.html b/os161-1.10/man/testbin/randcall.html
new file mode 100644
index 0000000..35fc35f
--- /dev/null
+++ b/os161-1.10/man/testbin/randcall.html
@@ -0,0 +1,59 @@
+<html>
+<head>
+<title>randcall</title>
+<body bgcolor=#ffffff>
+<h2 align=center>randcall</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+randcall - make randomized system calls
+
+<h3>Synopsis</h3>
+/testbin/randcall [-f] [-c <em>count</em>] [-r <em>seed</em>] <em>callset</em>
+
+<h3>Description</h3>
+
+randcall makes randomized system calls, that is, system calls with
+completely random arguments. The <em>callset</em> determines which
+list of system calls it uses; it is either "all", which does
+everything, or a number that identifies one of the assignments, in
+which case it exercises all the system calls that are supposed to be
+working when that assignment is complete. (If the lists compiled into
+randcall are wrong, contact your course staff.)
+<p>
+
+Ordinarily, in case some of these calls cause process termination,
+randcall forks before making each call. This can be slow, so the -f
+option can be used to suppress this behavior.
+<p>
+
+The -c <em>count</em> option tells randcall to make <em>count</em>
+iterations through the list of calls it's using. (It always goes
+through the list sequentially.) The default count is 100.
+<p>
+
+The -r <em>seed</em> option allows one to set the pseudorandom seed
+used by randcall to generate the call arguments. The default seed is
+0.
+<p>
+
+randcall prints what it's doing, so if it blows up you should be able
+to see what happened.
+<p>
+
+The system calls that do not take arguments are not on any of the call
+lists. Neither is <A HREF=../syscall/reboot.html>reboot</A>, to prevent
+accidental system shutdown.
+
+<h3>Requirements</h3>
+
+randcall should never under any circumstances crash the kernel, no
+matter what call list is in use.
+
+<h3>Bugs</h3>
+
+There should be an option to seed the random generator from 
+<A HREF=../dev/random.html>random:</A>.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/rmdirtest.html b/os161-1.10/man/testbin/rmdirtest.html
new file mode 100644
index 0000000..81a7699
--- /dev/null
+++ b/os161-1.10/man/testbin/rmdirtest.html
@@ -0,0 +1,46 @@
+<html>
+<head>
+<title>rmdirtest</title>
+<body bgcolor=#ffffff>
+<h2 align=center>rmdirtest</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+rmdirtest - test removing in-use directories
+
+<h3>Synopsis</h3>
+/testbin/rmdirtest
+
+<h3>Description</h3>
+
+rmdirtest creates a test directory, goes into it, removes it, and
+attempts to do various operations on it. It tries to check that the
+right things happen, although some cases are beyond its ability to
+test directly (such as whether storage is leaked).
+<p>
+
+Note that while it is not legal to remove the `.' <em>entry</em> in a
+directory, it is perfectly legal to remove a directory by name that
+happens to be some process's (or your own) current working directory.
+<p>
+
+<h3>Requirements</h3>
+
+rmdirtest uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/chdir.html>chdir</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/__getcwd.html>__getcwd</A>
+<li> <A HREF=../syscall/getdirentry.html>getdirentry</A>
+<li> <A HREF=../syscall/mkdir.html>mkdir</A>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/rmdir.html>rmdir</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+rmdirtest should run correctly once the file system assignment is
+complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/rmtest.html b/os161-1.10/man/testbin/rmtest.html
new file mode 100644
index 0000000..24cde75
--- /dev/null
+++ b/os161-1.10/man/testbin/rmtest.html
@@ -0,0 +1,52 @@
+<html>
+<head>
+<title>rmtest</title>
+<body bgcolor=#ffffff>
+<h2 align=center>rmtest</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+rmtest - test removing open files
+
+<h3>Synopsis</h3>
+/testbin/rmtest
+
+<h3>Description</h3>
+
+rmtest deletes a file while it's open and then attempts to do further
+I/O to it, and tries to check that the right things happen.
+
+<h3>Requirements</h3>
+
+rmtest uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/waitpid.html>waitpid</A>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/lseek.html>lseek</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+rmtest also spawns a copy of <A HREF=../bin/rm.html>/bin/rm</A>, which
+uses these system calls:
+<ul>
+<li> <A HREF=../syscall/remove.html>remove</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+rmtest should run correctly once the file system assignment is
+complete.
+
+<h3>Bugs</h3>
+
+There's no particular reason it should use /bin/rm instead of calling
+<A HREF=../syscall/remove.html>remove</A> itself. But I guess it makes
+life more exciting.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/sink.html b/os161-1.10/man/testbin/sink.html
new file mode 100644
index 0000000..4f61926
--- /dev/null
+++ b/os161-1.10/man/testbin/sink.html
@@ -0,0 +1,32 @@
+<html>
+<head>
+<title>sink</title>
+<body bgcolor=#ffffff>
+<h2 align=center>sink</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+sink - accept and throw away console input
+
+<h3>Synopsis</h3>
+/testbin/sink
+
+<h3>Description</h3>
+
+sink reads characters from standard input and throws them away. It is
+perhaps of some use for testing standard input or console devices.
+
+<h3>Requirements</h3>
+
+sink uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+sink should function properly once the basic system calls are
+complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/sort.html b/os161-1.10/man/testbin/sort.html
new file mode 100644
index 0000000..20f42a0
--- /dev/null
+++ b/os161-1.10/man/testbin/sort.html
@@ -0,0 +1,32 @@
+<html>
+<head>
+<title>sort</title>
+<body bgcolor=#ffffff>
+<h2 align=center>sort</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+sort - large quicksort-based VM test
+
+<h3>Synopsis</h3>
+/testbin/sort
+
+<h3>Description</h3>
+
+sort creates an array of 147456 random integers and then sorts it
+using quicksort. This will hopefully help show up bugs in the VM
+system.
+
+<h3>Requirements</h3>
+
+sort uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+sort should run correctly to completion once the VM assignment is
+complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/sty.html b/os161-1.10/man/testbin/sty.html
new file mode 100644
index 0000000..91ffc5e
--- /dev/null
+++ b/os161-1.10/man/testbin/sty.html
@@ -0,0 +1,35 @@
+<html>
+<head>
+<title>sty</title>
+<body bgcolor=#ffffff>
+<h2 align=center>sty</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+sty - run some hogs
+
+<h3>Synopsis</h3>
+/testbin/sty
+
+<h3>Description</h3>
+
+sty runs six copies of <A HREF=hog.html>hog</A>.
+
+<h3>Requirements</h3>
+
+sty uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+sty is only likely to be useful for testing the scheduler.
+
+<h3>Bugs</h3>
+
+sty does not wait for its child processes to finish.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/tail.html b/os161-1.10/man/testbin/tail.html
new file mode 100644
index 0000000..aa9b403
--- /dev/null
+++ b/os161-1.10/man/testbin/tail.html
@@ -0,0 +1,40 @@
+<html>
+<head>
+<title>tail</title>
+<body bgcolor=#ffffff>
+<h2 align=center>tail</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+tail - print part of a file
+
+<h3>Synopsis</h3>
+/testbin/tail <em>file</em> <em>location</em>
+
+<h3>Description</h3>
+
+tail prints the contents of a file starting at offset
+<em>location</em> within it, skipping the beginning.
+<p>
+
+It is somewhat similar in concept to the Unix tail command, but is not
+compatible, which is why it lives in testbin.
+
+<h3>Requirements</h3>
+
+tail uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/open.html>open</A>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/lseek.html>lseek</A>
+<li> <A HREF=../syscall/close.html>close</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+tail should work once the basic system calls are complete, but will
+probably be most useful as a debugging tool while working on the file
+system assignment.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/tictac.html b/os161-1.10/man/testbin/tictac.html
new file mode 100644
index 0000000..54a204a
--- /dev/null
+++ b/os161-1.10/man/testbin/tictac.html
@@ -0,0 +1,30 @@
+<html>
+<head>
+<title>tictac</title>
+<body bgcolor=#ffffff>
+<h2 align=center>tictac</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+tictac - tic-tac-toe game
+
+<h3>Synopsis</h3>
+/testbin/tictac
+
+<h3>Description</h3>
+
+tictac implements a simple version of tic-tac-toe.
+
+<h3>Requirements</h3>
+
+tictac uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/read.html>read</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+tictac should function correctly once the basic system calls are complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/triplehuge.html b/os161-1.10/man/testbin/triplehuge.html
new file mode 100644
index 0000000..9f25126
--- /dev/null
+++ b/os161-1.10/man/testbin/triplehuge.html
@@ -0,0 +1,32 @@
+<html>
+<head>
+<title>triplehuge</title>
+<body bgcolor=#ffffff>
+<h2 align=center>triplehuge</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+triplehuge - very very large VM test
+
+<h3>Synopsis</h3>
+/testbin/triplehuge
+
+<h3>Description</h3>
+
+triplehuge runs three copies of <A HREF=huge.html>huge</A> at once.
+
+<h3>Requirements</h3>
+
+triplehuge uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/waitpid.html>waitpid</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+triplehuge should run properly once the VM assignment is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/triplemat.html b/os161-1.10/man/testbin/triplemat.html
new file mode 100644
index 0000000..05ef788
--- /dev/null
+++ b/os161-1.10/man/testbin/triplemat.html
@@ -0,0 +1,32 @@
+<html>
+<head>
+<title>triplemat</title>
+<body bgcolor=#ffffff>
+<h2 align=center>triplemat</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+triplemat - very large VM test
+
+<h3>Synopsis</h3>
+/testbin/triplemat
+
+<h3>Description</h3>
+
+triplemat runs three copies of <A HREF=matmult.html>matmult</A> at once.
+
+<h3>Requirements</h3>
+
+triplemat uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/waitpid.html>waitpid</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+triplemat should run properly once the VM assignment is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/triplesort.html b/os161-1.10/man/testbin/triplesort.html
new file mode 100644
index 0000000..75f9692
--- /dev/null
+++ b/os161-1.10/man/testbin/triplesort.html
@@ -0,0 +1,32 @@
+<html>
+<head>
+<title>triplesort</title>
+<body bgcolor=#ffffff>
+<h2 align=center>triplesort</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+triplesort - very large VM test
+
+<h3>Synopsis</h3>
+/testbin/triplesort
+
+<h3>Description</h3>
+
+triplesort runs three copies of <A HREF=sort.html>sort</A> at once.
+
+<h3>Requirements</h3>
+
+triplesort uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/fork.html>fork</A>
+<li> <A HREF=../syscall/execv.html>execv</A>
+<li> <A HREF=../syscall/waitpid.html>waitpid</A>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+triplesort should run properly once the VM assignment is complete.
+
+</body>
+</html>
diff --git a/os161-1.10/man/testbin/userthreads.html b/os161-1.10/man/testbin/userthreads.html
new file mode 100644
index 0000000..b4dd7b7
--- /dev/null
+++ b/os161-1.10/man/testbin/userthreads.html
@@ -0,0 +1,37 @@
+<html>
+<head>
+<title>userthreads</title>
+<body bgcolor=#ffffff>
+<h2 align=center>userthreads</h2>
+<h4 align=center>OS/161 Reference Manual</h4>
+
+<h3>Name</h3>
+userthreads - simple user-level threads test
+
+<h3>Synopsis</h3>
+/testbin/userthreads
+
+<h3>Description</h3>
+
+userthreads does simple console I/O from two threads in the same
+process.
+
+<h3>Requirements</h3>
+
+userthreads uses the following system calls:
+<ul>
+<li> <A HREF=../syscall/write.html>write</A>
+<li> <A HREF=../syscall/_exit.html>_exit</A>
+</ul>
+
+It also assumes the existence of a function threadfork(), which takes
+the address of a function to start a new thread at, and makes certain
+other assumptions about thread semantics. See the source file.
+<p>
+
+If implementing user-level threads, part of your responsibility is to
+update the userthreads test to work with the threads package you
+write.
+
+</body>
+</html>
diff --git a/os161-1.10/man/toplevel/Makefile b/os161-1.10/man/toplevel/Makefile
new file mode 100644
index 0000000..00772cd
--- /dev/null
+++ b/os161-1.10/man/toplevel/Makefile
@@ -0,0 +1,6 @@
+# Top level man pages
+
+MANDIR=/man
+
+include ../../defs.mk
+include ../../mk/man.mk
diff --git a/os161-1.10/man/toplevel/index.html b/os161-1.10/man/toplevel/index.html
new file mode 100644
index 0000000..a0d5f22
--- /dev/null
+++ b/os161-1.10/man/toplevel/index.html
@@ -0,0 +1,24 @@
+<html>
+<head>
+<title>OS/161 Manual</title>
+</head>
+<body bgcolor=#ffffff>
+
+<h1 align=center>OS/161 Manual</h1>
+
+<ul>
+<li> <A HREF=bin>Binaries (/bin)</A>
+<li> <A HREF=sbin>Sysadmin binaries (/sbin)</A>
+<li> <A HREF=testbin>Test binaries (/testbin)</A>
+<li> <A HREF=libc>C standard library (libc)</A>
+<li> <A HREF=syscall>System calls</A>
+<li> <A HREF=dev>Device drivers</A>
+<li> <A HREF=misc>Miscellaneous</A>
+</ul>
+
+If System/161 is installed directly in this directory tree, its manual
+is <A HREF=sys161>here</A>. Otherwise, try 
+<A HREF=http://www.courses.fas.harvard.edu/~cs161/System161>here</A>.
+
+</body>
+</html>
diff --git a/os161-1.10/mk/hostprog.mk b/os161-1.10/mk/hostprog.mk
new file mode 100644
index 0000000..edeb434
--- /dev/null
+++ b/os161-1.10/mk/hostprog.mk
@@ -0,0 +1,102 @@
+#
+# OS/161 makefile template for programs to be built on the host OS
+#
+# defs.mk should already have been included.
+# That sets:
+#    OSTREE	  Directory with root of installed OS/161 system
+#    HOST_CC	  C compiler 
+#    HOST_CFLAGS  C compiler flags
+#    HOST_LDCC	  C compiler for linking
+#    HOST_LDFLAGS C compiler flags when linking
+#    HOST_LIBS	  Libraries to link with
+#
+# You should set:
+#    PROG	Name of program to build (host-$(PROG) will be built)
+#    SRCS	.c and .S files that are part of the program
+#
+
+# .ho is a host object
+.SUFFIXES: .ho
+
+#
+# The list of .ho files is the list of .c and .S files with those suffixes
+# changed to .ho.
+#
+HOST_OBJS1=$(SRCS:.c=.ho)
+HOST_OBJS=$(HOST_OBJS1:.S=.ho)
+
+#
+# Default rule - create program.
+#
+all: host-$(PROG)
+
+#
+# Delete everything extraneous.
+#
+clean: hostclean
+hostclean:
+	rm -f *.ho *.ha *~ host-$(PROG)
+
+#
+# Use the -MM argument to gcc to get it to output dependency information.
+# For host versions we use -MM rather than -M so we don't include deps for
+# include files we don't own.
+#
+# The sed command replaces the value of $(OSTREE) - which is some pathname -
+# with the string $(OSTREE). This makes the depend.mk file independent
+# of what $(OSTREE) actually is.
+#
+depend: hostdepend
+hostdepend:
+	$(HOST_CC) $(HOST_CFLAGS) -DHOST -MM $(SRCS) |\
+	  awk '{x=$$0~"^ ";for(i=1;i<=NF;i++){printf "%d %s\n",x,$$i;x=1; }}'|\
+	  sed '/1 \\/d' | awk '{ printf "%s%s", $$1?" \\\n ":"\n", $$2 }' |\
+	  sed 's/\.o/\.ho/' |\
+	  sed 's|$(OSTREE)|$$(OSTREE)|;$$p;$$x' > .deptmp
+	mv -f .deptmp dependh.mk
+include dependh.mk
+
+#
+# [ -d $(OSTREE)/hostbin ] succeeds if $(OSTREE)/hostbin is a directory.
+# (See test(1).) Thus, if $(OSTREE)/hostbin doesn't exist, it will be
+# created.
+#
+install: hostinstall
+hostinstall:
+	[ -d $(OSTREE)/hostbin ] || mkdir $(OSTREE)/hostbin
+	cp host-$(PROG) $(OSTREE)/hostbin
+
+#
+# No tags for host programs.
+#
+tags: hosttags
+hosttags:;
+
+#
+# Link the program.
+# Depend on libhostcompat.
+#
+
+host-$(PROG): $(HOST_OBJS) $(OSTREE)/hostlib/libhostcompat.a
+	$(HOST_LDCC) $(HOST_LDFLAGS) $(HOST_OBJS) $(HOST_LIBS) \
+	  $(OSTREE)/hostlib/libhostcompat.a -o host-$(PROG)
+
+#
+# Generic make rule for compiling .c files into .ho files.
+#
+.c.ho:
+	$(HOST_CC) $(HOST_CFLAGS) -DHOST -c $< -o $@
+
+#
+# Generic make rule for compiling .S files (assembler to be fed through cpp)
+# into .ho files. gcc knows how to do this, so just use it.
+#
+.S.ho:
+	$(HOST_CC) $(HOST_CFLAGS) -DHOST -c $< -o $@
+
+#
+# This tells make that all, clean, depend, install, and tags are not files
+# so it (hopefully) won't become confused if files by those names appear.
+#
+.PHONY: all clean depend install tags
+.PHONY: hostclean hostdepend hostinstall
diff --git a/os161-1.10/mk/lib.mk b/os161-1.10/mk/lib.mk
new file mode 100644
index 0000000..a4ff892
--- /dev/null
+++ b/os161-1.10/mk/lib.mk
@@ -0,0 +1,102 @@
+#
+# OS/161 makefile template for libraries
+#
+# defs.mk should already have been included.
+# That sets:
+#    OSTREE	Directory with root of installed OS/161 system
+#    CC		C compiler 
+#    CFLAGS	C compiler flags
+#    AR		archiver (librarian)
+#    RANLIB	library indexer
+#    TREE_CFLAGS Additional flags to point the toolchain at $(OSTREE)
+#
+# You should set:
+#    LIB	Name of library to build (lib$(LIB).a is created)
+#    SRCS	.c and .S files to build into library.
+#
+# Supports the following rules:
+#
+#    all	Compile and build library
+#    clean	Erase generated files
+#    depend	Update make dependency information
+#    install	Install library in OS/161 system library directory
+#    tags	Update "tags" database
+#
+
+
+#
+# The list of .o files is the list of .c and .S files with those suffixes
+# changed to .o.
+#
+OBJS1=$(SRCS:.c=.o)
+OBJS=$(OBJS1:.S=.o)
+
+#
+# Default rule - create library.
+#
+all: lib$(LIB).a
+
+#
+# Delete everything extraneous.
+#
+clean:
+	rm -f *.o *.a *~
+
+#
+# Use the -M argument to gcc to get it to output dependency information.
+# Note that we use -M, which includes deps for #include <...> files,
+# rather than -MM, which doesn't. This is because we are the operating
+# system: the #include <...> files are part of our project and we may 
+# well change them!
+#
+# The sed command replaces the value of $(OSTREE) - which is some pathname -
+# with the string $(OSTREE). This makes the depend.mk file independent
+# of what $(OSTREE) actually is.
+#
+depend:
+	$(CC) $(TREE_CFLAGS) $(CFLAGS) -M $(SRCS) |\
+	  awk '{x=$$0~"^ ";for(i=1;i<=NF;i++){printf "%d %s\n",x,$$i;x=1; }}'|\
+	  sed '/1 \\/d' | awk '{ printf "%s%s", $$1?" \\\n ":"\n", $$2 }' |\
+	  sed 's|$(OSTREE)|$$(OSTREE)|;$$p;$$x' > depend.mk
+include depend.mk
+
+#
+# [ -d $(OSTREE)/lib ] succeeds if $(OSTREE)/lib is a directory.
+# (See test(1).) Thus, if $(OSTREE)/lib doesn't exist, it will be
+# created.
+#
+install:
+	[ -d $(OSTREE)/lib ] || mkdir $(OSTREE)/lib
+	cp lib$(LIB).a $(OSTREE)/lib
+
+#
+# Run ctags to update the tags database.
+#
+tags:
+	ctags -wtd $(SRCS)
+
+#
+# Create the library.
+#
+lib$(LIB).a: $(OBJS)
+	$(AR) -cruv lib$(LIB).a $(OBJS)
+	$(RANLIB) lib$(LIB).a
+
+#
+# Generic make rule for compiling .c files into .o files.
+#
+.c.o:
+	$(CC) $(TREE_CFLAGS) $(CFLAGS) -c $<
+
+#
+# Generic make rule for compiling .S files (assembler to be fed through cpp)
+# into .o files. gcc knows how to do this, so just use it.
+#
+.S.o:
+	$(CC) $(TREE_CFLAGS) $(CFLAGS) -c $<
+
+#
+# This tells make that all, clean, depend, install, and tags are not files
+# so it (hopefully) won't become confused if files by those names appear.
+#
+.PHONY: all clean depend install tags
diff --git a/os161-1.10/mk/man.mk b/os161-1.10/mk/man.mk
new file mode 100644
index 0000000..6034f69
--- /dev/null
+++ b/os161-1.10/mk/man.mk
@@ -0,0 +1,42 @@
+#
+# OS/161 makefile template for man pages.
+#
+# defs.mk should already have been included.
+# That sets:
+#    OSTREE	Directory with root of installed OS/161 system
+#
+# You should set:
+#    MANDIR	Directory to install pages in, as if the system were
+#       	installed in /, such as "/man/bin" or "/man/sbin".
+#		(We prepend $(OSTREE) for you.)
+#
+# All .html files are installed.
+#
+
+#
+# Default rule: do nothing.
+# If we were generating some pages, we'd build them here.
+#
+all: ;
+
+# Clean: all we delete are old editor backups
+clean:
+	rm -f *~
+
+# Depend, tags: nothing to do
+depend tags: ;
+
+#
+# Install. This does all the work.
+#
+install:
+	[ -d $(OSTREE)$(MANDIR) ] || mkdir $(OSTREE)$(MANDIR)
+	chmod a+rx $(OSTREE)$(MANDIR)
+	cp *.html $(OSTREE)$(MANDIR)
+	chmod a+r $(OSTREE)$(MANDIR)/*.html
+
+#
+# This tells make that all, clean, depend, install, and tags are not files
+# so it (hopefully) won't become confused if files by those names appear.
+#
+.PHONY: all clean depend install tags
diff --git a/os161-1.10/mk/prog.mk b/os161-1.10/mk/prog.mk
new file mode 100644
index 0000000..8b8a62a
--- /dev/null
+++ b/os161-1.10/mk/prog.mk
@@ -0,0 +1,108 @@
+#
+# OS/161 makefile template for programs
+#
+# defs.mk should already have been included.
+# That sets:
+#    OSTREE	Directory with root of installed OS/161 system
+#    CC		C compiler 
+#    CFLAGS	C compiler flags
+#    LDCC	C compiler for linking
+#    LDFLAGS	C compiler flags when linking
+#    LIBS	Libraries to link with
+#    TREE_CFLAGS,
+#    TREE_LDFLAGS,
+#    TREE_LIBS	Additional flags/libs to point the toolchain at $(OSTREE)
+#
+# You should set:
+#    PROG	Name of program to build
+#    SRCS	.c and .S files that are part of the program
+#    BINDIR	Directory to install program in, as if the system were
+#       	installed in /, such as "/bin" or "/sbin".
+#		(We prepend $(OSTREE) for you.)
+#
+
+
+#
+# The list of .o files is the list of .c and .S files with those suffixes
+# changed to .o.
+#
+OBJS1=$(SRCS:.c=.o)
+OBJS=$(OBJS1:.S=.o)
+
+#
+# Default rule - create program.
+#
+all: $(PROG)
+
+#
+# Delete everything extraneous.
+#
+clean: progclean
+progclean:
+	rm -f *.o *.a *~ $(PROG)
+
+#
+# Use the -M argument to gcc to get it to output dependency information.
+# Note that we use -M, which includes deps for #include <...> files,
+# rather than -MM, which doesn't. This is because we are the operating
+# system: the #include <...> files are part of our project and we may 
+# well change them!
+#
+# The sed command replaces the value of $(OSTREE) - which is some pathname -
+# with the string $(OSTREE). This makes the depend.mk file independent
+# of what $(OSTREE) actually is.
+#
+depend: progdepend
+progdepend:
+	$(CC) $(TREE_CFLAGS) $(CFLAGS) -M $(SRCS) |\
+	  awk '{x=$$0~"^ ";for(i=1;i<=NF;i++){printf "%d %s\n",x,$$i;x=1; }}'|\
+	  sed '/1 \\/d' | awk '{ printf "%s%s", $$1?" \\\n ":"\n", $$2 }' |\
+	  sed 's|$(OSTREE)|$$(OSTREE)|;$$p;$$x' > .deptmp
+	mv -f .deptmp depend.mk
+include depend.mk
+
+#
+# [ -d $(OSTREE)/$(BINDIR) ] succeeds if $(OSTREE)/$(BINDIR) is a directory.
+# (See test(1).) Thus, if $(OSTREE)/$(BINDIR) doesn't exist, it will be
+# created.
+#
+install: proginstall
+proginstall:
+	[ -d $(OSTREE)$(BINDIR) ] || mkdir $(OSTREE)$(BINDIR)
+	cp $(PROG) $(OSTREE)$(BINDIR)
+
+#
+# Run ctags to update the tags database.
+#
+tags: progtags
+progtags:
+	ctags -wtd $(SRCS) *.h
+
+#
+# Link the program.
+# Explicitly depend on crt0.o (the startup code) and libc.a (the C library).
+#
+
+$(PROG): $(OBJS) $(OSTREE)/lib/crt0.o $(OSTREE)/lib/libc.a
+	$(LDCC) $(TREE_LDFLAGS) $(LDFLAGS) $(OBJS) $(LIBS) $(TREE_LIBS) \
+	   -o $(PROG)
+
+#
+# Generic make rule for compiling .c files into .o files.
+#
+.c.o:
+	$(CC) $(TREE_CFLAGS) $(CFLAGS) -c $<
+
+#
+# Generic make rule for compiling .S files (assembler to be fed through cpp)
+# into .o files. gcc knows how to do this, so just use it.
+#
+.S.o:
+	$(CC) $(TREE_CFLAGS) $(CFLAGS) -c $<
+
+#
+# This tells make that all, clean, depend, install, and tags are not files
+# so it (hopefully) won't become confused if files by those names appear.
+#
+.PHONY: all clean depend install tags
+.PHONY: progclean progdepend proginstall
\ No newline at end of file
diff --git a/os161-1.10/sbin/Makefile b/os161-1.10/sbin/Makefile
new file mode 100644
index 0000000..4ed707d
--- /dev/null
+++ b/os161-1.10/sbin/Makefile
@@ -0,0 +1,18 @@
+#
+# Makefile for src/sbin (sources for programs installed in /sbin)
+#
+
+include ../defs.mk
+
+all depend tags clean install:
+	(cd reboot && $(MAKE) $@)
+	(cd halt && $(MAKE) $@)
+	(cd poweroff && $(MAKE) $@)
+	(cd mksfs && $(MAKE) $@)
+	(cd dumpsfs && $(MAKE) $@)
+
+clean: cleanhere
+cleanhere:
+	rm -f *~
+
+.PHONY: all depend tags clean cleanhere install
diff --git a/os161-1.10/sbin/dumpsfs/.cvsignore b/os161-1.10/sbin/dumpsfs/.cvsignore
new file mode 100644
index 0000000..8d3029a
--- /dev/null
+++ b/os161-1.10/sbin/dumpsfs/.cvsignore
@@ -0,0 +1,3 @@
+dumpsfs
+host-dumpsfs
+*.ho
diff --git a/os161-1.10/sbin/dumpsfs/Makefile b/os161-1.10/sbin/dumpsfs/Makefile
new file mode 100644
index 0000000..1324a83
--- /dev/null
+++ b/os161-1.10/sbin/dumpsfs/Makefile
@@ -0,0 +1,24 @@
+# Makefile for dumpsfs
+
+SRCS=dumpsfs.c disk.c support.c
+PROG=dumpsfs
+BINDIR=/sbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+include ../../mk/hostprog.mk
+
+all depend progdepend hostdepend: disk.c disk.h support.c support.h
+
+disk.c:
+	ln -s ../mksfs/disk.c .
+
+disk.h:
+	ln -s ../mksfs/disk.h .
+
+support.c:
+	ln -s ../mksfs/support.c .
+
+support.h:
+	ln -s ../mksfs/support.h .
+
diff --git a/os161-1.10/sbin/dumpsfs/depend.mk b/os161-1.10/sbin/dumpsfs/depend.mk
new file mode 100644
index 0000000..6f2f559
--- /dev/null
+++ b/os161-1.10/sbin/dumpsfs/depend.mk
@@ -0,0 +1,37 @@
+
+dumpsfs.o: \
+ dumpsfs.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/assert.h \
+ $(OSTREE)/include/limits.h \
+ $(OSTREE)/include/kern/limits.h \
+ $(OSTREE)/include/err.h \
+ support.h \
+ $(OSTREE)/include/kern/sfs.h \
+ disk.h
+disk.o: \
+ disk.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/assert.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/fcntl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h \
+ support.h \
+ disk.h
+support.o: \
+ support.c
diff --git a/os161-1.10/sbin/dumpsfs/dependh.mk b/os161-1.10/sbin/dumpsfs/dependh.mk
new file mode 100644
index 0000000..a23239e
--- /dev/null
+++ b/os161-1.10/sbin/dumpsfs/dependh.mk
@@ -0,0 +1,13 @@
+
+dumpsfs.ho: \
+ dumpsfs.c \
+ support.h \
+ $(OSTREE)/hostinclude/kern/sfs.h \
+ $(OSTREE)/hostinclude/hostcompat.h \
+ disk.h
+disk.ho: \
+ disk.c \
+ support.h \
+ disk.h
+support.ho: \
+ support.c
diff --git a/os161-1.10/sbin/dumpsfs/dumpsfs.c b/os161-1.10/sbin/dumpsfs/dumpsfs.c
new file mode 100644
index 0000000..51c675f
--- /dev/null
+++ b/os161-1.10/sbin/dumpsfs/dumpsfs.c
@@ -0,0 +1,148 @@
+#include <sys/types.h>
+#include <string.h>
+#include <stdio.h>
+#include <assert.h>
+#include <limits.h>
+#include <err.h>
+
+#include "support.h"
+#include "kern/sfs.h"
+
+
+#ifdef HOST
+
+#include <netinet/in.h> // for arpa/inet.h
+#include <arpa/inet.h>  // for ntohl
+#include "hostcompat.h"
+#define SWAPL(x) ntohl(x)
+#define SWAPS(x) ntohs(x)
+
+#else
+
+#define SWAPL(x) (x)
+#define SWAPS(x) (x)
+
+#endif
+
+#include "disk.h"
+
+static
+u_int32_t
+dumpsb(void)
+{
+	struct sfs_super sp;
+	diskread(&sp, SFS_SB_LOCATION);
+	if (SWAPL(sp.sp_magic) != SFS_MAGIC) {
+		errx(1, "Not an sfs filesystem");
+	}
+	sp.sp_volname[sizeof(sp.sp_volname)-1] = 0;
+	printf("Volume name: %-40s  %u blocks\n", sp.sp_volname, 
+	       SWAPL(sp.sp_nblocks));
+
+	return SWAPL(sp.sp_nblocks);
+}
+
+static
+void
+dodirblock(u_int32_t block)
+{
+	struct sfs_dir sds[SFS_BLOCKSIZE/sizeof(struct sfs_dir)];
+	int nsds = SFS_BLOCKSIZE/sizeof(struct sfs_dir);
+	int i;
+
+	diskread(&sds, block);
+
+	printf("    [block %u]\n", block);
+	for (i=0; i<nsds; i++) {
+		u_int32_t ino = SWAPL(sds[i].sfd_ino);
+		if (ino==SFS_NOINO) {
+			printf("        [free entry]\n");
+		}
+		else {
+			sds[i].sfd_name[SFS_NAMELEN-1] = 0; /* just in case */
+			printf("        %u %s\n", ino, sds[i].sfd_name);
+		}
+	}
+}
+
+static
+void
+dumpdir(u_int32_t ino)
+{
+	struct sfs_inode sfi;
+	u_int32_t ib[SFS_DBPERIDB];
+	int nentries, i;
+	u_int32_t block, nblocks=0;
+
+	diskread(&sfi, ino);
+
+	nentries = SWAPL(sfi.sfi_size) / sizeof(struct sfs_dir);
+	if (SWAPL(sfi.sfi_size) % sizeof(struct sfs_dir) != 0) {
+		warnx("Warning: dir size is not a multiple of dir entry size");
+	}
+	printf("Directory %u: %d entries\n", ino, nentries);
+
+	for (i=0; i<SFS_NDIRECT; i++) {
+		block = SWAPL(sfi.sfi_direct[i]);
+		if (block) {
+			dodirblock(block);
+			nblocks++;
+		}
+	}
+	if (SWAPL(sfi.sfi_indirect)) {
+		diskread(&ib, SWAPL(sfi.sfi_indirect));
+		for (i=0; i<SFS_DBPERIDB; i++) {
+			block = SWAPL(ib[i]);
+			if (block) {
+				dodirblock(block);
+				nblocks++;
+			}
+		}
+	}
+	printf("    %u blocks in directory\n", nblocks);
+}
+
+static
+void
+dumpbits(u_int32_t fsblocks)
+{
+	u_int32_t nblocks = SFS_BITBLOCKS(fsblocks);
+	u_int32_t i, j;
+	char data[SFS_BLOCKSIZE];
+
+	printf("Freemap: %u blocks (%u %u %u)\n", nblocks, SFS_BITMAPSIZE(fsblocks), fsblocks, SFS_BLOCKBITS);
+
+	for (i=0; i<nblocks; i++) {
+		diskread(data, SFS_MAP_LOCATION+i);
+		for (j=0; j<SFS_BLOCKSIZE; j++) {
+			printf("%02x", (unsigned char)data[j]);
+			if (j%32==31) {
+				printf("\n");
+			}
+		}
+	}
+	printf("\n");
+}
+
+int
+main(int argc, char **argv)
+{
+	u_int32_t nblocks;
+
+#ifdef HOST
+	hostcompat_init(argc, argv);
+#endif
+
+	if (argc!=2) {
+		errx(1, "Usage: dumpsfs device/diskfile");
+	}
+
+	opendisk(argv[1]);
+	nblocks = dumpsb();
+	dumpbits(nblocks);
+	dumpdir(SFS_ROOT_LOCATION);
+
+	closedisk();
+
+	return 0;
+}
diff --git a/os161-1.10/sbin/halt/.cvsignore b/os161-1.10/sbin/halt/.cvsignore
new file mode 100644
index 0000000..3736b63
--- /dev/null
+++ b/os161-1.10/sbin/halt/.cvsignore
@@ -0,0 +1 @@
+halt
diff --git a/os161-1.10/sbin/halt/Makefile b/os161-1.10/sbin/halt/Makefile
new file mode 100644
index 0000000..930989c
--- /dev/null
+++ b/os161-1.10/sbin/halt/Makefile
@@ -0,0 +1,9 @@
+# Makefile for halt
+
+SRCS=halt.c
+PROG=halt
+BINDIR=/sbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/sbin/halt/depend.mk b/os161-1.10/sbin/halt/depend.mk
new file mode 100644
index 0000000..451ea93
--- /dev/null
+++ b/os161-1.10/sbin/halt/depend.mk
@@ -0,0 +1,9 @@
+
+halt.o: \
+ halt.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
diff --git a/os161-1.10/sbin/halt/halt.c b/os161-1.10/sbin/halt/halt.c
new file mode 100644
index 0000000..d314478
--- /dev/null
+++ b/os161-1.10/sbin/halt/halt.c
@@ -0,0 +1,15 @@
+#include <unistd.h>
+
+/*
+ * halt - shut down system, do not reboot, do not turn off power.
+ * Usage: halt
+ *
+ * Just calls reboot() with the RB_HALT flag.
+ */
+
+int
+main()
+{
+	reboot(RB_HALT);
+	return 0;
+}
diff --git a/os161-1.10/sbin/mksfs/.cvsignore b/os161-1.10/sbin/mksfs/.cvsignore
new file mode 100644
index 0000000..ad2f297
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/.cvsignore
@@ -0,0 +1,3 @@
+mksfs
+host-mksfs
+*.ho
diff --git a/os161-1.10/sbin/mksfs/Makefile b/os161-1.10/sbin/mksfs/Makefile
new file mode 100644
index 0000000..fddf7d5
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/Makefile
@@ -0,0 +1,9 @@
+# Makefile for mksfs
+
+SRCS=mksfs.c disk.c support.c
+PROG=mksfs
+BINDIR=/sbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+include ../../mk/hostprog.mk
diff --git a/os161-1.10/sbin/mksfs/depend.mk b/os161-1.10/sbin/mksfs/depend.mk
new file mode 100644
index 0000000..5a3827c
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/depend.mk
@@ -0,0 +1,36 @@
+
+mksfs.o: \
+ mksfs.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/assert.h \
+ $(OSTREE)/include/limits.h \
+ $(OSTREE)/include/kern/limits.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h \
+ support.h \
+ $(OSTREE)/include/kern/sfs.h \
+ disk.h
+disk.o: \
+ disk.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/assert.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/fcntl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h \
+ support.h \
+ disk.h
+support.o: \
+ support.c
diff --git a/os161-1.10/sbin/mksfs/dependh.mk b/os161-1.10/sbin/mksfs/dependh.mk
new file mode 100644
index 0000000..400e712
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/dependh.mk
@@ -0,0 +1,13 @@
+
+mksfs.ho: \
+ mksfs.c \
+ support.h \
+ $(OSTREE)/hostinclude/kern/sfs.h \
+ $(OSTREE)/hostinclude/hostcompat.h \
+ disk.h
+disk.ho: \
+ disk.c \
+ support.h \
+ disk.h
+support.ho: \
+ support.c
diff --git a/os161-1.10/sbin/mksfs/disk.c b/os161-1.10/sbin/mksfs/disk.c
new file mode 100644
index 0000000..62e3ef8
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/disk.c
@@ -0,0 +1,151 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <assert.h>
+#include <string.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <err.h>
+
+#include "support.h"
+#include "disk.h"
+
+#define HOSTSTRING "System/161 Disk Image"
+#define BLOCKSIZE  512
+
+#ifndef EINTR
+#define EINTR 0
+#endif
+
+static int fd=-1;
+static u_int32_t nblocks;
+
+void
+opendisk(const char *path)
+{
+	struct stat statbuf;
+
+	assert(fd<0);
+	fd = open(path, O_RDWR);
+	if (fd<0) {
+		err(1, "%s", path);
+	}
+	if (fstat(fd, &statbuf)) {
+		err(1, "%s: fstat", path);
+	}
+
+	nblocks = statbuf.st_size / BLOCKSIZE;
+
+#ifdef HOST
+	nblocks--;
+
+	{
+		char buf[64];
+		int len;
+
+		do {
+			len = read(fd, buf, sizeof(buf)-1);
+			if (len < 0 && (errno==EINTR || errno==EAGAIN)) {
+				continue;
+			}
+		} while (0);
+
+		buf[len] = 0;
+		buf[strlen(HOSTSTRING)] = 0;
+
+		if (strcmp(buf, HOSTSTRING)) {
+			errx(1, "%s: Not a System/161 disk image", path);
+		}
+	}
+#endif
+}
+
+u_int32_t
+diskblocksize(void)
+{
+	assert(fd>=0);
+	return BLOCKSIZE;
+}
+
+u_int32_t
+diskblocks(void)
+{
+	assert(fd>=0);
+	return nblocks;
+}
+
+void
+diskwrite(const void *data, u_int32_t block)
+{
+	const char *cdata = data;
+	u_int32_t tot=0;
+	int len;
+
+	assert(fd>=0);
+
+#ifdef HOST
+	// skip over disk file header
+	block++;
+#endif
+
+	if (lseek(fd, block*BLOCKSIZE, SEEK_SET)<0) {
+		err(1, "lseek");
+	}
+
+	while (tot < BLOCKSIZE) {
+		len = write(fd, cdata + tot, BLOCKSIZE - tot);
+		if (len < 0) {
+			if (errno==EINTR || errno==EAGAIN) {
+				continue;
+			}
+			err(1, "write");
+		}
+		if (len==0) {
+			err(1, "write returned 0?");
+		}
+		tot += len;
+	}
+}
+
+void
+diskread(void *data, u_int32_t block)
+{
+	char *cdata = data;
+	u_int32_t tot=0;
+	int len;
+
+	assert(fd>=0);
+
+#ifdef HOST
+	// skip over disk file header
+	block++;
+#endif
+
+	if (lseek(fd, block*BLOCKSIZE, SEEK_SET)<0) {
+		err(1, "lseek");
+	}
+
+	while (tot < BLOCKSIZE) {
+		len = read(fd, cdata + tot, BLOCKSIZE - tot);
+		if (len < 0) {
+			if (errno==EINTR || errno==EAGAIN) {
+				continue;
+			}
+			err(1, "read");
+		}
+		if (len==0) {
+			err(1, "unexpected EOF in mid-sector");
+		}
+		tot += len;
+	}
+}
+
+void
+closedisk(void)
+{
+	assert(fd>=0);
+	if (close(fd)) {
+		err(1, "close");
+	}
+	fd = -1;
+}
diff --git a/os161-1.10/sbin/mksfs/disk.h b/os161-1.10/sbin/mksfs/disk.h
new file mode 100644
index 0000000..1c2e4e4
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/disk.h
@@ -0,0 +1,9 @@
+void opendisk(const char *path);
+
+u_int32_t diskblocksize(void);
+u_int32_t diskblocks(void);
+
+void diskwrite(const void *data, u_int32_t block);
+void diskread(void *data, u_int32_t block);
+
+void closedisk(void);
diff --git a/os161-1.10/sbin/mksfs/mksfs.c b/os161-1.10/sbin/mksfs/mksfs.c
new file mode 100644
index 0000000..27ff9d6
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/mksfs.c
@@ -0,0 +1,165 @@
+#include <sys/types.h>
+#include <string.h>
+#include <assert.h>
+#include <limits.h>
+#include <err.h>
+
+#include "support.h"
+#include "kern/sfs.h"
+
+
+#ifdef HOST
+
+#include <netinet/in.h> // for arpa/inet.h
+#include <arpa/inet.h>  // for ntohl
+#include "hostcompat.h"
+#define SWAPL(x) ntohl(x)
+#define SWAPS(x) ntohs(x)
+
+#else
+
+#define SWAPL(x) (x)
+#define SWAPS(x) (x)
+
+#endif
+
+#include "disk.h"
+
+#define MAXBITBLOCKS 32
+
+static
+void
+check(void)
+{
+	assert(sizeof(struct sfs_super)==SFS_BLOCKSIZE);
+	assert(sizeof(struct sfs_inode)==SFS_BLOCKSIZE);
+	assert(SFS_BLOCKSIZE % sizeof(struct sfs_dir) == 0);
+}
+
+static
+void
+writesuper(const char *volname, u_int32_t nblocks)
+{
+	struct sfs_super sp;
+
+	bzero((void *)&sp, sizeof(sp));
+
+	if (strlen(volname) >= SFS_VOLNAME_SIZE) {
+		errx(1, "Volume name %s too long", volname);
+	}
+
+	sp.sp_magic = SWAPL(SFS_MAGIC);
+	sp.sp_nblocks = SWAPL(nblocks);
+	strcpy(sp.sp_volname, volname);
+
+	diskwrite(&sp, SFS_SB_LOCATION);
+}
+
+static
+void
+writerootdir(void)
+{
+	struct sfs_inode sfi;
+
+	bzero((void *)&sfi, sizeof(sfi));
+
+	sfi.sfi_size = SWAPL(0);
+	sfi.sfi_type = SWAPS(SFS_TYPE_DIR);
+	sfi.sfi_linkcount = SWAPS(1);
+
+	diskwrite(&sfi, SFS_ROOT_LOCATION);
+}
+
+static char bitbuf[MAXBITBLOCKS*SFS_BLOCKSIZE];
+
+static
+void
+doallocbit(u_int32_t bit)
+{
+	u_int32_t byte = bit/CHAR_BIT;
+	unsigned char mask = (1<<(bit % CHAR_BIT));
+
+	assert((bitbuf[byte] & mask) == 0);
+	bitbuf[byte] |= mask;
+}
+
+static
+void
+writebitmap(u_int32_t fsblocks)
+{
+
+	u_int32_t nbits = SFS_BITMAPSIZE(fsblocks);
+	u_int32_t nblocks = SFS_BITBLOCKS(fsblocks);
+	char *ptr;
+	u_int32_t i;
+
+	if (nblocks > MAXBITBLOCKS) {
+		errx(1, "Filesystem too large "
+		     "- increase MAXBITBLOCKS and recompile");
+	}
+
+	doallocbit(SFS_SB_LOCATION);
+	doallocbit(SFS_ROOT_LOCATION);
+	for (i=0; i<nblocks; i++) {
+		doallocbit(SFS_MAP_LOCATION+i);
+	}
+	for (i=fsblocks; i<nbits; i++) {
+		doallocbit(i);
+	}
+
+	for (i=0; i<nblocks; i++) {
+		ptr = bitbuf + i*SFS_BLOCKSIZE;
+		diskwrite(ptr, SFS_MAP_LOCATION+i);
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	u_int32_t size, blocksize;
+	char *volname, *s;
+
+#ifdef HOST
+	hostcompat_init(argc, argv);
+#endif
+
+	if (argc!=3) {
+		errx(1, "Usage: mksfs device/diskfile volume-name");
+	}
+
+	check();
+
+	volname = argv[2];
+
+	/* Remove one trailing colon from volname, if present */
+	s = strchr(volname, ':');
+	if (s != NULL) {
+		if (strlen(s)!=1) {
+			errx(1, "Illegal volume name %s", volname);
+		}
+		*s = 0;
+	}
+
+	/* Don't allow slashes */
+	s = strchr(volname, '/');
+	if (s != NULL) {
+		errx(1, "Illegal volume name %s", volname);
+	}
+
+	opendisk(argv[1]);
+	blocksize = diskblocksize();
+
+	if (blocksize!=SFS_BLOCKSIZE) {
+		errx(1, "Device has wrong blocksize %u (should be %u)\n",
+		     blocksize, SFS_BLOCKSIZE);
+	}
+	size = diskblocks();
+
+	writesuper(volname, size);
+	writerootdir();
+	writebitmap(size);
+
+	closedisk();
+
+	return 0;
+}
diff --git a/os161-1.10/sbin/mksfs/support.c b/os161-1.10/sbin/mksfs/support.c
new file mode 100644
index 0000000..92a7c95
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/support.c
@@ -0,0 +1,5 @@
+/*
+ * This file doesn't actually do anything any more, but I'm going to
+ * leave it here for now (and leave the mechanisms in place for building
+ * it) in case it's wanted again later on.
+ */
diff --git a/os161-1.10/sbin/mksfs/support.h b/os161-1.10/sbin/mksfs/support.h
new file mode 100644
index 0000000..6d52892
--- /dev/null
+++ b/os161-1.10/sbin/mksfs/support.h
@@ -0,0 +1,35 @@
+
+#ifdef __osf__
+/* Digital Unix (aka Compaq Tru64) */
+#define HAS_NO_SIZED_TYPES
+#endif
+
+#if defined(__sun__) && defined(__svr4__)
+/* Solaris */
+#define HAS_NO_SIZED_TYPES
+#endif
+
+/*
+ * Some systems don't have u_int32_t, u_int16_t, or u_int8_t.
+ * (Sometime this should be changed so it gets probed by the configure script.)
+ */
+
+#ifdef HAS_NO_SIZED_TYPES
+
+#if defined(__alpha__) || defined(__alpha)
+/* Alpha processor: lp64 */
+typedef unsigned int u_int32_t;
+typedef unsigned short u_int16_t;
+typedef unsigned char u_int8_t;
+
+#elif defined(__sparc__)
+/* Sparc processor: 32-bit or lp64 */
+typedef unsigned int u_int32_t;
+typedef unsigned short u_int16_t;
+typedef unsigned char u_int8_t;
+
+#else
+#error "HAS_NO_SIZED_TYPES defined and I don't know what the sizes should be"
+#endif
+
+#endif
diff --git a/os161-1.10/sbin/poweroff/.cvsignore b/os161-1.10/sbin/poweroff/.cvsignore
new file mode 100644
index 0000000..808dda8
--- /dev/null
+++ b/os161-1.10/sbin/poweroff/.cvsignore
@@ -0,0 +1 @@
+poweroff
diff --git a/os161-1.10/sbin/poweroff/Makefile b/os161-1.10/sbin/poweroff/Makefile
new file mode 100644
index 0000000..eee9a04
--- /dev/null
+++ b/os161-1.10/sbin/poweroff/Makefile
@@ -0,0 +1,9 @@
+# Makefile for poweroff
+
+SRCS=poweroff.c
+PROG=poweroff
+BINDIR=/sbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/sbin/poweroff/depend.mk b/os161-1.10/sbin/poweroff/depend.mk
new file mode 100644
index 0000000..566e6fb
--- /dev/null
+++ b/os161-1.10/sbin/poweroff/depend.mk
@@ -0,0 +1,9 @@
+
+poweroff.o: \
+ poweroff.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
diff --git a/os161-1.10/sbin/poweroff/poweroff.c b/os161-1.10/sbin/poweroff/poweroff.c
new file mode 100644
index 0000000..c5aba1e
--- /dev/null
+++ b/os161-1.10/sbin/poweroff/poweroff.c
@@ -0,0 +1,15 @@
+#include <unistd.h>
+
+/*
+ * poweroff - shut down system and turn off power.
+ * Usage: poweroff
+ *
+ * Just calls reboot() with the RB_POWEROFF flag.
+ */
+
+int
+main()
+{
+	reboot(RB_POWEROFF);
+	return 0;
+}
diff --git a/os161-1.10/sbin/reboot/.cvsignore b/os161-1.10/sbin/reboot/.cvsignore
new file mode 100644
index 0000000..b4c99da
--- /dev/null
+++ b/os161-1.10/sbin/reboot/.cvsignore
@@ -0,0 +1 @@
+reboot
diff --git a/os161-1.10/sbin/reboot/Makefile b/os161-1.10/sbin/reboot/Makefile
new file mode 100644
index 0000000..f3c3e0d
--- /dev/null
+++ b/os161-1.10/sbin/reboot/Makefile
@@ -0,0 +1,9 @@
+# Makefile for reboot
+
+SRCS=reboot.c
+PROG=reboot
+BINDIR=/sbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/sbin/reboot/depend.mk b/os161-1.10/sbin/reboot/depend.mk
new file mode 100644
index 0000000..bdbe5b1
--- /dev/null
+++ b/os161-1.10/sbin/reboot/depend.mk
@@ -0,0 +1,9 @@
+
+reboot.o: \
+ reboot.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
diff --git a/os161-1.10/sbin/reboot/reboot.c b/os161-1.10/sbin/reboot/reboot.c
new file mode 100644
index 0000000..0d5a628
--- /dev/null
+++ b/os161-1.10/sbin/reboot/reboot.c
@@ -0,0 +1,15 @@
+#include <unistd.h>
+
+/*
+ * reboot - shut down system and reboot it.
+ * Usage: reboot
+ *
+ * Just calls reboot() with the RB_REBOOT flag.
+ */
+
+int
+main()
+{
+	reboot(RB_REBOOT);
+	return 0;
+}
diff --git a/os161-1.10/testbin/Makefile b/os161-1.10/testbin/Makefile
new file mode 100644
index 0000000..312cda1
--- /dev/null
+++ b/os161-1.10/testbin/Makefile
@@ -0,0 +1,46 @@
+#
+# Makefile for src/testbin (sources for programs installed in /testbin)
+#
+
+include ../defs.mk
+
+all depend tags clean install:
+	(cd add && $(MAKE) $@)
+	(cd argtest && $(MAKE) $@)
+	(cd badcall && $(MAKE) $@)
+	(cd bigfile && $(MAKE) $@)
+	(cd conman && $(MAKE) $@)
+	(cd crash && $(MAKE) $@)
+	(cd ctest && $(MAKE) $@)
+	(cd dirconc && $(MAKE) $@)
+	(cd dirseek && $(MAKE) $@)
+	(cd dirtest && $(MAKE) $@)
+	(cd f_test && $(MAKE) $@)
+	(cd farm && $(MAKE) $@)
+	(cd faulter && $(MAKE) $@)
+	(cd filetest && $(MAKE) $@)
+	(cd forkbomb && $(MAKE) $@)
+	(cd forktest && $(MAKE) $@)
+	(cd guzzle && $(MAKE) $@)
+	(cd hash && $(MAKE) $@)
+	(cd hog && $(MAKE) $@)
+	(cd huge && $(MAKE) $@)
+	(cd kitchen && $(MAKE) $@)
+	(cd matmult && $(MAKE) $@)
+	(cd palin && $(MAKE) $@)
+	(cd parallelvm && $(MAKE) $@)
+	(cd randcall && $(MAKE) $@)
+	(cd rmdirtest && $(MAKE) $@)
+	(cd rmtest && $(MAKE) $@)
+	(cd sink && $(MAKE) $@)
+	(cd sort && $(MAKE) $@)
+	(cd sty && $(MAKE) $@)
+	(cd tail && $(MAKE) $@)
+	(cd tictac && $(MAKE) $@)
+	(cd triplehuge && $(MAKE) $@)
+	(cd triplemat && $(MAKE) $@)
+	(cd triplesort && $(MAKE) $@)
+
+# But not:
+#    malloctest     (no malloc/free until you write it)
+#    userthreads    (no support in kernel API in base system)
diff --git a/os161-1.10/testbin/add/.cvsignore b/os161-1.10/testbin/add/.cvsignore
new file mode 100644
index 0000000..76d4bb8
--- /dev/null
+++ b/os161-1.10/testbin/add/.cvsignore
@@ -0,0 +1 @@
+add
diff --git a/os161-1.10/testbin/add/Makefile b/os161-1.10/testbin/add/Makefile
new file mode 100644
index 0000000..cc8ee00
--- /dev/null
+++ b/os161-1.10/testbin/add/Makefile
@@ -0,0 +1,9 @@
+# Makefile for add
+
+SRCS=add.c
+PROG=add
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/add/add.c b/os161-1.10/testbin/add/add.c
new file mode 100644
index 0000000..258a5d1
--- /dev/null
+++ b/os161-1.10/testbin/add/add.c
@@ -0,0 +1,28 @@
+/*
+ * Simple program to add two numbers (given in as arguments). Used to
+ * test argument passing to child processes.
+ *
+ * Intended for the basic system calls assignment; this should work
+ * once execv() argument handling is implemented.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <err.h>
+
+int
+main(int argc, char *argv[])
+{
+	int i, j;
+
+	if (argc != 3) {
+		errx(1, "Usage: add num1 num2");
+	}
+
+	i = atoi(argv[1]);
+	j = atoi(argv[2]);
+
+	printf("Answer: %d\n", i+j);
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/add/depend.mk b/os161-1.10/testbin/add/depend.mk
new file mode 100644
index 0000000..0de8861
--- /dev/null
+++ b/os161-1.10/testbin/add/depend.mk
@@ -0,0 +1,10 @@
+
+add.o: \
+ add.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/argtest/.cvsignore b/os161-1.10/testbin/argtest/.cvsignore
new file mode 100644
index 0000000..6cf5a3f
--- /dev/null
+++ b/os161-1.10/testbin/argtest/.cvsignore
@@ -0,0 +1 @@
+argtest
diff --git a/os161-1.10/testbin/argtest/Makefile b/os161-1.10/testbin/argtest/Makefile
new file mode 100644
index 0000000..a563598
--- /dev/null
+++ b/os161-1.10/testbin/argtest/Makefile
@@ -0,0 +1,9 @@
+# Makefile for argtest
+
+SRCS=argtest.c
+PROG=argtest
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/argtest/argtest.c b/os161-1.10/testbin/argtest/argtest.c
new file mode 100644
index 0000000..86cf497
--- /dev/null
+++ b/os161-1.10/testbin/argtest/argtest.c
@@ -0,0 +1,28 @@
+/*
+ * Program to test argument passing: it displays the argc and all
+ * of argv, and then exits.
+ *
+ * Intended for the basic system calls assignment. This may help
+ * debugging the argument handling of execv().
+ */
+
+#include <stdio.h>
+
+int
+main(int argc, char *argv[])
+{
+	const char *tmp;
+	int i;
+
+	printf("argc: %d\n", argc);
+
+	for (i=0; i<=argc; i++) {
+		tmp = argv[i];
+		if (tmp==NULL) {
+			tmp = "[NULL]";
+		}
+		printf("argv[%d]: %s\n", i, tmp);
+	}
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/argtest/depend.mk b/os161-1.10/testbin/argtest/depend.mk
new file mode 100644
index 0000000..ec3a3f4
--- /dev/null
+++ b/os161-1.10/testbin/argtest/depend.mk
@@ -0,0 +1,8 @@
+
+argtest.o: \
+ argtest.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/badcall/.cvsignore b/os161-1.10/testbin/badcall/.cvsignore
new file mode 100644
index 0000000..9d78a31
--- /dev/null
+++ b/os161-1.10/testbin/badcall/.cvsignore
@@ -0,0 +1 @@
+badcall
diff --git a/os161-1.10/testbin/badcall/Makefile b/os161-1.10/testbin/badcall/Makefile
new file mode 100644
index 0000000..e67af68
--- /dev/null
+++ b/os161-1.10/testbin/badcall/Makefile
@@ -0,0 +1,40 @@
+# Makefile for badcall
+
+SRCS=\
+	bad_execv.c \
+	bad_waitpid.c \
+	bad_open.c \
+	bad_read.c \
+	bad_write.c \
+	bad_close.c \
+	bad_reboot.c \
+	bad_sbrk.c \
+	bad_ioctl.c \
+	bad_lseek.c \
+	bad_fsync.c \
+	bad_ftruncate.c \
+	bad_stat.c \
+	bad_remove.c \
+	bad_rename.c \
+	bad_link.c \
+	bad_mkdir.c \
+	bad_rmdir.c \
+	bad_chdir.c \
+	bad_getdirentry.c \
+	bad_symlink.c \
+	bad_readlink.c \
+	bad_dup2.c \
+	bad_pipe.c \
+	bad_time.c \
+	bad_getcwd.c \
+	common_buf.c \
+	common_fds.c \
+	common_path.c \
+	driver.c
+
+PROG=badcall
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/badcall/bad_chdir.c b/os161-1.10/testbin/badcall/bad_chdir.c
new file mode 100644
index 0000000..463232a
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_chdir.c
@@ -0,0 +1,31 @@
+/*
+ * Invalid calls to chdir()
+ */
+
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "test.h"
+
+static
+void
+chdir_empty(void)
+{
+	int rv;
+
+	/*
+	 * This is actually valid by some interpretations.
+	 */
+
+	rv = chdir("");
+	report_test2(rv, errno, EINVAL, 0, "chdir to empty string");
+}
+
+void
+test_chdir(void)
+{
+	test_chdir_path();
+	chdir_empty();
+}
+
diff --git a/os161-1.10/testbin/badcall/bad_close.c b/os161-1.10/testbin/badcall/bad_close.c
new file mode 100644
index 0000000..629db3f
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_close.c
@@ -0,0 +1,11 @@
+/*
+ * Invalid calls to close()
+ */
+
+#include "test.h"
+
+void
+test_close(void)
+{
+	test_close_fd();
+}
diff --git a/os161-1.10/testbin/badcall/bad_dup2.c b/os161-1.10/testbin/badcall/bad_dup2.c
new file mode 100644
index 0000000..449390d
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_dup2.c
@@ -0,0 +1,98 @@
+/*
+ * Invalid calls to dup2
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+dup2_fd2(int fd, const char *desc)
+{
+	int rv;
+
+	rv = dup2(STDIN_FILENO, fd);
+	report_test(rv, errno, EBADF, desc);
+
+	if (rv != -1) {
+		close(fd);	/* just in case */
+	}
+}
+
+static
+void
+dup2_self(void)
+{
+	struct stat sb;
+	int rv;
+	int testfd;
+
+	/* use fd that isn't in use */
+	testfd = CLOSED_FD;
+
+	rv = dup2(STDIN_FILENO, testfd);
+	if (rv == -1) {
+		warn("UH-OH: couldn't copy stdin");
+		return;
+	}
+
+	rv = dup2(testfd, testfd);
+	if (rv == testfd) {
+		warnx("passed: dup2 to same fd");
+	}
+	else if (rv<0) {
+		warn("FAILURE: dup2 to same fd: error");
+	}
+	else {
+		warnx("FAILURE: dup2 to same fd: returned %d instead", rv);
+	}
+
+	rv = fstat(testfd, &sb);
+	if (rv==0) {
+		warnx("passed: fstat fd after dup2 to itself");
+	}
+	else if (errno!=EUNIMP && errno!=ENOSYS) {
+		warn("FAILURE: fstat fd after dup2 to itself");
+	}
+	else {
+		/* no support for fstat; try lseek */
+		rv = lseek(testfd, 0, SEEK_CUR);
+		if (rv==0 || (rv==-1 && errno==ESPIPE)) {
+			warnx("passed: lseek fd after dup2 to itself");
+		}
+		else {
+			warn("FAILURE: lseek fd after dup2 to itself");
+		}
+	}
+
+	close(testfd);
+}
+
+void
+test_dup2(void)
+{
+	/* This does the first fd. */
+	test_dup2_fd();
+
+	/* Any interesting cases added here should also go in common_fds.c */
+	dup2_fd2(-1, "dup2 to -1");
+	dup2_fd2(-5, "dup2 to -5");
+	dup2_fd2(IMPOSSIBLE_FD, "dup2 to impossible fd");
+#ifdef OPEN_MAX
+	dup2_fd2(OPEN_MAX, "dup2 to OPEN_MAX");
+#else
+	warnx("Warning: OPEN_MAX not defined - test skipped");
+#endif
+
+	dup2_self();
+}
diff --git a/os161-1.10/testbin/badcall/bad_execv.c b/os161-1.10/testbin/badcall/bad_execv.c
new file mode 100644
index 0000000..e02312c
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_execv.c
@@ -0,0 +1,128 @@
+/*
+ * bad calls to execv()
+ */
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+int
+exec_common_fork(void)
+{
+	int pid, rv, status;
+
+	pid = fork();
+	if (pid<0) {
+		warn("UH-OH: fork failed");
+		return -1;
+	}
+	
+	if (pid==0) {
+		/* child */
+		return 0;
+	}
+
+	rv = waitpid(pid, &status, 0);
+	if (rv == -1) {
+		warn("UH-OH: waitpid failed");
+		return -1;
+	}
+	if (status != MAGIC_STATUS) {
+		warnx("FAILURE: wrong exit code of subprocess");
+	}
+	return 1;
+}
+
+static
+void
+exec_badprog(const void *prog, const char *desc)
+{
+	int rv;
+	char *args[2];
+	args[0] = (char *)"foo";
+	args[1] = NULL;
+
+	if (exec_common_fork() != 0) {
+		return;
+	}
+
+	rv = execv(prog, args);
+	report_test(rv, errno, EFAULT, desc);
+	exit(MAGIC_STATUS);
+}
+
+static
+void
+exec_emptyprog(void)
+{
+	int rv;
+	char *args[2];
+	args[0] = (char *)"foo";
+	args[1] = NULL;
+
+	if (exec_common_fork() != 0) {
+		return;
+	}
+
+	rv = execv("", args);
+	report_test2(rv, errno, EINVAL, EISDIR, "exec the empty string");
+	exit(MAGIC_STATUS);
+}
+
+static
+void
+exec_badargs(void *args, const char *desc)
+{
+	int rv;
+
+	if (exec_common_fork() != 0) {
+		return;
+	}
+
+	rv = execv("/bin/true", args);
+	report_test(rv, errno, EFAULT, desc);
+	exit(MAGIC_STATUS);
+}
+
+static
+void
+exec_onearg(void *ptr, const char *desc)
+{
+	int rv;
+
+	char *args[3];
+	args[0] = (char *)"foo";
+	args[1] = (char *)ptr;
+	args[2] = NULL;
+
+	if (exec_common_fork() != 0) {
+		return;
+	}
+
+	rv = execv("/bin/true", args);
+	report_test(rv, errno, EFAULT, desc);
+	exit(MAGIC_STATUS);
+}
+
+void
+test_execv(void)
+{
+	exec_badprog(NULL, "exec NULL");
+	exec_badprog(INVAL_PTR, "exec invalid pointer");
+	exec_badprog(KERN_PTR, "exec kernel pointer");
+
+	exec_emptyprog();
+
+	exec_badargs(NULL, "exec /bin/true with NULL arglist");
+	exec_badargs(INVAL_PTR, "exec /bin/true with invalid pointer arglist");
+	exec_badargs(KERN_PTR, "exec /bin/true with kernel pointer arglist");
+
+	exec_onearg(INVAL_PTR, "exec /bin/true with invalid pointer arg");
+	exec_onearg(KERN_PTR, "exec /bin/true with kernel pointer arg");
+}
diff --git a/os161-1.10/testbin/badcall/bad_fsync.c b/os161-1.10/testbin/badcall/bad_fsync.c
new file mode 100644
index 0000000..597a56b
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_fsync.c
@@ -0,0 +1,12 @@
+/*
+ * fsync
+ */
+
+#include "test.h"
+
+void
+test_fsync(void)
+{
+	test_fsync_fd();
+}
+
diff --git a/os161-1.10/testbin/badcall/bad_ftruncate.c b/os161-1.10/testbin/badcall/bad_ftruncate.c
new file mode 100644
index 0000000..c080853
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_ftruncate.c
@@ -0,0 +1,60 @@
+/*
+ * ftruncate
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+ftruncate_fd_device(void)
+{
+	int rv, fd;
+
+	fd = open("null:", O_RDWR);
+	if (fd<0) {
+		warn("UH-OH: opening null: failed");
+		return;
+	}
+
+	rv = ftruncate(fd, 6);
+	report_test(rv, errno, EINVAL, "ftruncate on device");
+
+	close(fd);
+}
+
+static
+void
+ftruncate_size_neg(void)
+{
+	int rv, fd;
+
+	fd = open_testfile(0);
+	if (fd<0) {
+		return;
+	}
+
+	rv = ftruncate(fd, -60);
+	report_test(rv, errno, EINVAL, "ftruncate to negative size");
+
+	close(fd);
+	remove(TESTFILE);
+}
+
+void
+test_ftruncate(void)
+{
+	test_ftruncate_fd();
+
+	ftruncate_fd_device();
+	ftruncate_size_neg();
+}
diff --git a/os161-1.10/testbin/badcall/bad_getcwd.c b/os161-1.10/testbin/badcall/bad_getcwd.c
new file mode 100644
index 0000000..9b070fc
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_getcwd.c
@@ -0,0 +1,11 @@
+/*
+ * __getcwd
+ */
+
+#include "test.h"
+
+void
+test_getcwd(void)
+{
+	test_getcwd_buf();
+}
diff --git a/os161-1.10/testbin/badcall/bad_getdirentry.c b/os161-1.10/testbin/badcall/bad_getdirentry.c
new file mode 100644
index 0000000..591049e
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_getdirentry.c
@@ -0,0 +1,12 @@
+/*
+ * getdirentry
+ */
+
+#include "test.h"
+
+void
+test_getdirentry(void)
+{
+	test_getdirentry_fd();
+	test_getdirentry_buf();
+}
diff --git a/os161-1.10/testbin/badcall/bad_ioctl.c b/os161-1.10/testbin/badcall/bad_ioctl.c
new file mode 100644
index 0000000..36c2a7b
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_ioctl.c
@@ -0,0 +1,73 @@
+/*
+ * ioctl 
+ */
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+one_ioctl_badbuf(int fd, int code, const char *codename,
+		 void *ptr, const char *ptrdesc)
+{
+	char desc[128];
+	int rv;
+
+	snprintf(desc, sizeof(desc), "ioctl %s with %s", codename, ptrdesc);
+	rv = ioctl(fd, code, ptr);
+	report_test(rv, errno, EFAULT, desc);
+}
+
+static
+void
+any_ioctl_badbuf(int fd, int code, const char *codename)
+{
+	one_ioctl_badbuf(fd, code, codename, NULL, "NULL pointer");
+	one_ioctl_badbuf(fd, code, codename, INVAL_PTR, "invalid pointer");
+	one_ioctl_badbuf(fd, code, codename, KERN_PTR, "kernel pointer");
+}
+
+#define IOCTL(fd, sym) any_ioctl_badbuf(fd, sym, #sym)
+
+static
+void
+ioctl_badbuf(void)
+{
+	/*
+	 * Since we don't actually define any ioctls, this code won't
+	 * actually run. But if you do define ioctls, turn these tests
+	 * on for those that actually use the data buffer argument for
+	 * anything.
+	 */
+
+	/* IOCTL(STDIN_FILENO, TIOCGETA); */
+
+
+	/* suppress gcc warning */
+	(void)any_ioctl_badbuf;
+}
+
+static
+void
+ioctl_badcode(void)
+{
+	int rv;
+	rv = ioctl(STDIN_FILENO, NONEXIST_IOCTL, NULL);
+	report_test(rv, errno, EIOCTL, "invalid ioctl");
+}
+
+void
+test_ioctl(void)
+{
+	test_ioctl_fd();
+
+	/* Since we don't actually define any ioctls, this is not meaningful */
+	ioctl_badcode();
+	ioctl_badbuf();
+}
diff --git a/os161-1.10/testbin/badcall/bad_link.c b/os161-1.10/testbin/badcall/bad_link.c
new file mode 100644
index 0000000..80168d6
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_link.c
@@ -0,0 +1,52 @@
+/*
+ * link
+ */
+
+#include <unistd.h>
+#include <errno.h>
+
+#include "test.h"
+
+static
+void
+link_dir(void)
+{
+	int rv;
+	rv = link(".", TESTDIR);
+	report_test(rv, errno, EINVAL, "hard link of .");
+	if (rv==0) {
+		/* this might help recover... maybe */
+		remove(TESTDIR);
+	}
+}
+
+static
+void
+link_empty1(void)
+{
+	int rv;
+	rv = link("", TESTDIR);
+	report_test(rv, errno, EINVAL, "hard link of empty string");
+}
+
+static
+void
+link_empty2(void)
+{
+	int rv;
+	if (create_testdir()<0) {
+		return;
+	}
+	rv = link(TESTDIR, "");
+	report_test(rv, errno, EINVAL, "hard link to empty string");
+	rmdir(TESTDIR);
+}
+
+void
+test_link(void)
+{
+	test_link_paths();
+	link_dir();
+	link_empty1();
+	link_empty2();
+}
diff --git a/os161-1.10/testbin/badcall/bad_lseek.c b/os161-1.10/testbin/badcall/bad_lseek.c
new file mode 100644
index 0000000..7297238
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_lseek.c
@@ -0,0 +1,214 @@
+/*
+ * lseek
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+lseek_fd_device(void)
+{
+	int fd, rv;
+
+	fd = open("null:", O_RDONLY);
+	if (fd<0) {
+		warn("UH-OH: opening null: failed");
+		return;
+	}
+
+	rv = lseek(fd, 309, SEEK_SET);
+	report_test(rv, errno, ESPIPE, "lseek on device");
+
+	close(fd);
+}
+
+static
+void
+lseek_file_stdin(void)
+{
+	int fd, fd2, rv, status;
+	const char slogan[] = "There ain't no such thing as a free lunch";
+	size_t len = strlen(slogan);
+	pid_t pid;
+
+	/* fork so we don't affect our own stdin */
+	pid = fork();
+	if (pid<0) {
+		warn("UH-OH: fork failed");
+		return;
+	}
+	else if (pid!=0) {
+		/* parent */
+		rv = waitpid(pid, &status, 0);
+		if (rv<0) {
+			warn("UH-OH: waitpid failed");
+		}
+		if (status!=0) {
+			warn("UH-OH: subprocess exited with code %d", status);
+		}
+		return;
+	}
+
+	/* child */
+
+	fd = open_testfile(NULL);
+	if (fd<0) {
+		_exit(0);
+	}
+
+	/* 
+	 * Move file to stdin.
+	 * Use stdin (rather than stdout or stderr) to maximize the
+	 * chances of detecting any special-case handling of fds 0-2.
+	 * (Writing to stdin is fine as long as it's open for write,
+	 * and it will be.)
+	 */
+	fd2 = dup2(fd, STDIN_FILENO);
+	if (fd2<0) {
+		warn("UH-OH: dup2 to stdin failed");
+		close(fd);
+		remove(TESTFILE);
+		_exit(0);
+	}
+	if (fd2 != STDIN_FILENO) {
+		warn("UH-OH: dup2 returned wrong file handle");
+		close(fd);
+		remove(TESTFILE);
+		_exit(0);
+	}
+	close(fd);
+
+	rv = write(STDIN_FILENO, slogan, len);
+	if (rv<0) {
+		warn("UH-OH: write to %s (via stdin) failed", TESTFILE);
+		remove(TESTFILE);
+		_exit(0);
+	}
+
+	if ((unsigned)rv != len) {
+		warnx("UH-OH: write to %s (via stdin) got short count",
+		      TESTFILE);
+		remove(TESTFILE);
+		_exit(0);
+	}
+
+	rv = lseek(STDIN_FILENO, 0, SEEK_SET);
+	report_test(rv, errno, 0, "lseek stdin when open on file (try 1)");
+
+	rv = lseek(STDIN_FILENO, 0, SEEK_END);
+	report_test(rv, errno, 0, "lseek stdin when open on file (try 2)");
+
+	remove(TESTFILE);
+	_exit(0);
+}
+
+static
+void
+lseek_loc_negative(void)
+{
+	int fd, rv;
+
+	fd = open_testfile(NULL);
+	if (fd<0) {
+		return;
+	}
+
+	rv = lseek(fd, -309, SEEK_SET);
+	report_test(rv, errno, EINVAL, "lseek to negative offset");
+
+	close(fd);
+	remove(TESTFILE);
+}
+
+static
+void
+lseek_whence_inval(void)
+{
+	int fd, rv;
+
+	fd = open_testfile(0);
+	if (fd<0) {
+		return;
+	}
+
+	rv = lseek(fd, 0, 3594);
+	report_test(rv, errno, EINVAL, "lseek with invalid whence code");
+
+	close(fd);
+	remove(TESTFILE);
+}
+
+static
+void
+lseek_loc_pasteof(void)
+{
+	const char *message = "blahblah";
+	int fd;
+	off_t pos;
+
+	fd = open_testfile(message);
+	if (fd<0) {
+		return;
+	}
+
+	pos = lseek(fd, 5340, SEEK_SET);
+	if (pos == -1) {
+		warn("FAILURE: lseek past EOF failed");
+		goto out;
+	}
+	if (pos != 5340) {
+		warnx("FAILURE: lseek to 5340 got offset %ld", (long) pos);
+		goto out;
+	}
+
+	pos = lseek(fd, -50, SEEK_CUR);
+	if (pos == -1) {
+		warn("FAILURE: small seek beyond EOF failed");
+		goto out;
+	}
+	if (pos != 5290) {
+		warnx("FAILURE: SEEK_CUR to 5290 got offset %ld", (long) pos);
+		goto out;
+	}
+
+	pos = lseek(fd, 0, SEEK_END);
+	if (pos == -1) {
+		warn("FAILURE: seek to EOF failed");
+		goto out;
+	}
+
+	if (pos != (off_t) strlen(message)) {
+		warnx("FAILURE: seek to EOF got %ld (should be %d)", 
+		      (long) pos, strlen(message));
+		goto out;
+	}
+
+	warnx("passed: seek past/to EOF");
+
+    out:
+	close(fd);
+	remove(TESTFILE);
+	return;
+}
+
+void
+test_lseek(void)
+{
+	test_lseek_fd();
+
+	lseek_fd_device();
+	lseek_file_stdin();
+	lseek_loc_negative();
+	lseek_loc_pasteof();
+	lseek_whence_inval();
+}
diff --git a/os161-1.10/testbin/badcall/bad_mkdir.c b/os161-1.10/testbin/badcall/bad_mkdir.c
new file mode 100644
index 0000000..036ae11
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_mkdir.c
@@ -0,0 +1,54 @@
+/*
+ * mkdir
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+mkdir_dot(void)
+{
+	int rv;
+
+	rv = mkdir(".", 0775);
+	report_test(rv, errno, EEXIST, "mkdir .");
+}
+
+static
+void
+mkdir_dotdot(void)
+{
+	int rv;
+
+	rv = mkdir("..", 0775);
+	report_test(rv, errno, EEXIST, "mkdir ..");
+}
+
+static
+void
+mkdir_empty(void)
+{
+	int rv;
+	rv = mkdir("", 0775);
+	report_test(rv, errno, EINVAL, "mkdir of empty string");
+}
+
+void
+test_mkdir(void)
+{
+	test_mkdir_path();
+
+	mkdir_dot();
+	mkdir_dotdot();
+	mkdir_empty();
+}
diff --git a/os161-1.10/testbin/badcall/bad_open.c b/os161-1.10/testbin/badcall/bad_open.c
new file mode 100644
index 0000000..88b238b
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_open.c
@@ -0,0 +1,46 @@
+/*
+ * invalid calls to open()
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+open_badflags(void)
+{
+	int fd;
+
+	fd = open("null:", 309842);
+	report_test(fd, errno, EINVAL, "open null: with bad flags");
+}
+
+static
+void
+open_empty(void)
+{
+	int rv;
+	rv = open("", O_RDONLY);
+	report_test2(rv, errno, 0, EINVAL, "open empty string");
+	if (rv>=0) {
+		close(rv);
+	}
+}
+
+void
+test_open(void)
+{
+	test_open_path();
+
+	open_badflags();
+	open_empty();
+}
diff --git a/os161-1.10/testbin/badcall/bad_pipe.c b/os161-1.10/testbin/badcall/bad_pipe.c
new file mode 100644
index 0000000..b4a8552
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_pipe.c
@@ -0,0 +1,49 @@
+/*
+ * pipe
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+pipe_badptr(void *ptr, const char *desc)
+{
+	int rv;
+
+	rv = pipe(ptr);
+	report_test(rv, errno, EFAULT, desc);
+}
+
+static
+void
+pipe_unaligned(void)
+{
+	int fds[3], rv;
+	char *ptr;
+
+	ptr = (char *)&fds[0];
+	ptr++;
+
+	rv = pipe((int *)ptr);
+	report_survival(rv, errno, "pipe with unaligned pointer");
+}
+
+void
+test_pipe(void)
+{
+	pipe_badptr(NULL, "pipe with NULL pointer");
+	pipe_badptr(INVAL_PTR, "pipe with invalid pointer");
+	pipe_badptr(KERN_PTR, "pipe with kernel pointer");
+
+	pipe_unaligned();
+}
diff --git a/os161-1.10/testbin/badcall/bad_read.c b/os161-1.10/testbin/badcall/bad_read.c
new file mode 100644
index 0000000..ec3ce8c
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_read.c
@@ -0,0 +1,13 @@
+/*
+ * Invalid calls to read()
+ */
+
+#include "test.h"
+
+void
+test_read(void)
+{
+	test_read_fd();
+	test_read_buf();
+}
+
diff --git a/os161-1.10/testbin/badcall/bad_readlink.c b/os161-1.10/testbin/badcall/bad_readlink.c
new file mode 100644
index 0000000..d889eed
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_readlink.c
@@ -0,0 +1,57 @@
+/*
+ * readlink
+ */
+
+#include <unistd.h>
+#include <errno.h>
+
+#include "test.h"
+
+static
+void
+readlink_file(void)
+{
+	char buf[128];
+	int fd, rv;
+
+	fd = open_testfile("the question contains an invalid assumption");
+	if (fd<0) {
+		return;
+	}
+	close(fd);
+	rv = readlink(TESTFILE, buf, sizeof(buf));
+	report_test(rv, errno, EINVAL, "readlink on file");
+	remove(TESTFILE);
+}
+
+static
+void
+readlink_dir(void)
+{
+	char buf[128];
+	int rv;
+	rv = readlink(".", buf, sizeof(buf));
+	report_test(rv, errno, EISDIR, "readlink on .");
+}
+
+static
+void
+readlink_empty(void)
+{
+	char buf[128];
+	int rv;
+	rv = readlink("", buf, sizeof(buf));
+	report_test2(rv, errno, EISDIR, EINVAL, "readlink on empty string");
+}
+
+void
+test_readlink(void)
+{
+	test_readlink_path();
+	test_readlink_buf();
+
+	readlink_file();
+	readlink_dir();
+	readlink_empty();
+}
+
diff --git a/os161-1.10/testbin/badcall/bad_reboot.c b/os161-1.10/testbin/badcall/bad_reboot.c
new file mode 100644
index 0000000..ebeeb62
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_reboot.c
@@ -0,0 +1,32 @@
+/*
+ * Invalid calls to reboot()
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+reboot_badflags(void)
+{
+	int rv;
+
+	warnx("NOTICE: if this kills the system, it's a failure.");
+	rv = reboot(15353);
+	report_test(rv, errno, EINVAL, "reboot with invalid flags");
+}
+
+void
+test_reboot(void)
+{
+	reboot_badflags();
+}
diff --git a/os161-1.10/testbin/badcall/bad_remove.c b/os161-1.10/testbin/badcall/bad_remove.c
new file mode 100644
index 0000000..9d3b29e
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_remove.c
@@ -0,0 +1,68 @@
+/*
+ * remove
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+remove_dir(void)
+{
+	int rv;
+
+	if (create_testdir() < 0) {
+		return;
+	}
+
+	rv = remove(TESTDIR);
+	report_test(rv, errno, EISDIR, "remove() on a directory");
+	rmdir(TESTDIR);
+}
+
+static
+void
+remove_dot(void)
+{
+	int rv;
+	rv = remove(".");
+	report_test2(rv, errno, EISDIR, EINVAL, "remove() on .");
+}
+
+static
+void
+remove_dotdot(void)
+{
+	int rv;
+	rv = remove("..");
+	report_test2(rv, errno, EISDIR, EINVAL, "remove() on ..");
+}
+
+static
+void
+remove_empty(void)
+{
+	int rv;
+	rv = remove("");
+	report_test2(rv, errno, EISDIR, EINVAL, "remove() on empty string");
+}
+
+void
+test_remove(void)
+{
+	test_remove_path();
+
+	remove_dir();
+	remove_dot();
+	remove_dotdot();
+	remove_empty();
+}
diff --git a/os161-1.10/testbin/badcall/bad_rename.c b/os161-1.10/testbin/badcall/bad_rename.c
new file mode 100644
index 0000000..2bbb98f
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_rename.c
@@ -0,0 +1,72 @@
+/*
+ * rename
+ */
+
+#include <unistd.h>
+#include <errno.h>
+
+#include "test.h"
+
+static
+void
+rename_dot(void)
+{
+	int rv;
+	rv = rename(".", TESTDIR);
+	report_test(rv, errno, EINVAL, "rename .");
+	if (rv==0) {
+		/* oops... put it back */
+		rename(TESTDIR, ".");
+	}
+}
+
+static
+void
+rename_dotdot(void)
+{
+	int rv;
+	rv = rename("..", TESTDIR);
+	report_test(rv, errno, EINVAL, "rename ..");
+	if (rv==0) {
+		/* oops... put it back */
+		rename(TESTDIR, "..");
+	}
+}
+
+static
+void
+rename_empty1(void)
+{
+	int rv;
+	rv = rename("", TESTDIR);
+	report_test2(rv, errno, EISDIR, EINVAL, "rename empty string");
+	if (rv==0) {
+		/* don't try to remove it */
+		rename(TESTDIR, TESTDIR "-foo");
+	}
+}
+
+static
+void
+rename_empty2(void)
+{
+	int rv;
+	if (create_testdir()<0) {
+		return;
+	}
+	rv = rename(TESTDIR, "");
+	report_test2(rv, errno, EISDIR, EINVAL, "rename to empty string");
+	rmdir(TESTDIR);
+}
+
+void
+test_rename(void)
+{
+	test_rename_paths();
+
+	rename_dot();
+	rename_dotdot();
+	rename_empty1();
+	rename_empty2();
+}
+
diff --git a/os161-1.10/testbin/badcall/bad_rmdir.c b/os161-1.10/testbin/badcall/bad_rmdir.c
new file mode 100644
index 0000000..51bbcba
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_rmdir.c
@@ -0,0 +1,68 @@
+/*
+ * rmdir
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+rmdir_file(void)
+{
+	int rv;
+	if (create_testfile()<0) {
+		return;
+	}
+	rv = rmdir(TESTFILE);
+	report_test(rv, errno, ENOTDIR, "rmdir a file");
+	remove(TESTFILE);
+}
+
+static
+void
+rmdir_dot(void)
+{
+	int rv;
+
+	rv = rmdir(".");
+	report_test(rv, errno, EINVAL, "rmdir .");
+}
+
+static
+void
+rmdir_dotdot(void)
+{
+	int rv;
+
+	rv = rmdir("..");
+	report_test2(rv, errno, EINVAL, ENOTEMPTY, "rmdir ..");
+}
+
+static
+void
+rmdir_empty(void)
+{
+	int rv;
+	rv = rmdir("");
+	report_test(rv, errno, EINVAL, "rmdir empty string");
+}
+
+void
+test_rmdir(void)
+{
+	test_rmdir_path();
+
+	rmdir_file();
+	rmdir_dot();
+	rmdir_dotdot();
+	rmdir_empty();
+}
diff --git a/os161-1.10/testbin/badcall/bad_sbrk.c b/os161-1.10/testbin/badcall/bad_sbrk.c
new file mode 100644
index 0000000..5cd949b
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_sbrk.c
@@ -0,0 +1,108 @@
+/*
+ * sbrk
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+int
+try_sbrk(long val)
+{
+	void *rv;
+	rv = sbrk(val);
+	if (rv==(void *)-1) {
+		return errno;
+	}
+	return 0;
+}
+
+static
+void
+enforce_sbrk(long val, const char *desc, int err)
+{
+	int e;
+
+	e = try_sbrk(val);
+	if (e != err && e==0) {
+		warnx("FAILURE: sbrk(%s): no error", desc);
+		return;
+	}
+	if (e != err) {
+		errno = e;
+		warn("FAILURE: sbrk(%s): wrong error", desc);
+		return;
+	}
+	warnx("passed: sbrk(%s)", desc);
+}
+
+static
+void
+sbrk_bigpos(void)
+{
+	enforce_sbrk(4096*1024*256, "huge positive", ENOMEM);
+}
+
+static
+void
+sbrk_bigneg(void)
+{
+	enforce_sbrk(-4096*1024*256, "huge negative", EINVAL);
+}
+
+static
+void
+sbrk_neg(void)
+{
+	enforce_sbrk(-8192, "too-large negative", EINVAL);
+}
+
+static
+void
+sbrk_unalignedpos(void)
+{
+	switch (try_sbrk(17)) {
+	    case 0:
+	    case EINVAL:
+		warnx("passed: sbrk(unaligned positive)");
+		break;
+	    default:
+		warn("FAILURE: sbrk(unaligned positive): wrong error");
+		break;
+	}
+}
+
+static
+void
+sbrk_unalignedneg(void)
+{
+	switch (try_sbrk(17)) {
+	    case 0:
+	    case EINVAL:
+		warnx("passed: sbrk(unaligned negative)");
+		break;
+	    default:
+		warn("FAILURE: sbrk(unaligned negative): wrong error");
+		break;
+	}
+}
+
+void
+test_sbrk(void)
+{
+	sbrk_neg();
+	sbrk_bigpos();
+	sbrk_bigneg();
+	sbrk_unalignedpos();
+	sbrk_unalignedneg();
+}
+
diff --git a/os161-1.10/testbin/badcall/bad_stat.c b/os161-1.10/testbin/badcall/bad_stat.c
new file mode 100644
index 0000000..3e10d8e
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_stat.c
@@ -0,0 +1,101 @@
+/*
+ * Bad calls to fstat, lstat, and stat
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+////////////////////////////////////////////////////////////
+
+static
+int
+badbuf_fstat(struct stat *sb)
+{
+	return fstat(STDIN_FILENO, sb);
+}
+
+static
+int
+badbuf_lstat(struct stat *sb)
+{
+	return lstat("null:", sb);
+}
+
+static
+int
+badbuf_stat(struct stat *sb)
+{
+	return stat("null:", sb);
+}
+
+static
+void
+common_badbuf(int (*statfunc)(struct stat *), void *ptr,
+	      const char *call, const char *ptrdesc)
+{
+	int rv;
+	char mydesc[128];
+
+	snprintf(mydesc, sizeof(mydesc), "%s with %s buf", call, ptrdesc);
+	rv = statfunc(ptr);
+	report_test(rv, errno, EFAULT, mydesc);
+}
+
+static
+void
+any_badbuf(int (*statfunc)(struct stat *), const char *call)
+{
+	common_badbuf(statfunc, NULL, call, "NULL");
+	common_badbuf(statfunc, INVAL_PTR, call, "invalid pointer");
+	common_badbuf(statfunc, KERN_PTR, call, "kernel pointer");
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+any_empty(int (*statfunc)(const char *, struct stat *), const char *call)
+{
+	struct stat sb;
+	char desc[128];
+	int rv;
+
+	snprintf(desc, sizeof(desc), "%s on empty string", call);
+	rv = statfunc("", &sb);
+	report_test2(rv, errno, 0, EINVAL, desc);
+}
+
+////////////////////////////////////////////////////////////
+
+void
+test_fstat(void)
+{
+	test_fstat_fd();
+	any_badbuf(badbuf_fstat, "fstat");
+}
+
+void
+test_lstat(void)
+{
+	test_lstat_path();
+	any_empty(lstat, "stat");
+	any_badbuf(badbuf_lstat, "lstat");
+}
+
+void
+test_stat(void)
+{
+	test_stat_path();
+	any_empty(stat, "stat");
+	any_badbuf(badbuf_stat, "stat");
+}
+
diff --git a/os161-1.10/testbin/badcall/bad_symlink.c b/os161-1.10/testbin/badcall/bad_symlink.c
new file mode 100644
index 0000000..c670740
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_symlink.c
@@ -0,0 +1,35 @@
+/*
+ * symlink
+ */
+
+#include <unistd.h>
+#include <errno.h>
+
+#include "test.h"
+
+static
+void
+symlink_empty1(void)
+{
+	int rv;
+	rv = symlink("", TESTLINK);
+	report_test2(rv, errno, 0, EINVAL, "symlink -> empty string");
+	remove(TESTLINK);
+}
+
+static
+void
+symlink_empty2(void)
+{
+	int rv;
+	rv = symlink("foo", "");
+	report_test(rv, errno, EINVAL, "symlink named empty string");
+}
+
+void
+test_symlink(void)
+{
+	test_symlink_paths();
+	symlink_empty1();
+	symlink_empty2();
+}
diff --git a/os161-1.10/testbin/badcall/bad_time.c b/os161-1.10/testbin/badcall/bad_time.c
new file mode 100644
index 0000000..9ec3725
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_time.c
@@ -0,0 +1,45 @@
+/*
+ * __time
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+time_badsecs(void *ptr, const char *desc)
+{
+	int rv;
+
+	rv = __time(ptr, NULL);
+	report_test(rv, errno, EFAULT, desc);
+}
+
+static
+void
+time_badnsecs(void *ptr, const char *desc)
+{
+	int rv;
+
+	rv = __time(NULL, ptr);
+	report_test(rv, errno, EFAULT, desc);
+}
+
+void
+test_time(void)
+{
+	time_badsecs(INVAL_PTR, "__time with invalid seconds pointer");
+	time_badsecs(KERN_PTR, "__time with kernel seconds pointer");
+
+	time_badnsecs(INVAL_PTR, "__time with invalid nsecs pointer");
+	time_badnsecs(KERN_PTR, "__time with kernel nsecs pointer");
+}
diff --git a/os161-1.10/testbin/badcall/bad_waitpid.c b/os161-1.10/testbin/badcall/bad_waitpid.c
new file mode 100644
index 0000000..35e32a9
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_waitpid.c
@@ -0,0 +1,259 @@
+/*
+ * bad calls to waitpid()
+ */
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+void
+wait_badpid(int pid, const char *desc)
+{
+	int rv, x;
+	rv = waitpid(pid, &x, 0);
+	report_test2(rv, errno, EINVAL, NOSUCHPID_ERROR, desc);
+}
+
+static
+void
+wait_badstatus(void *ptr, const char *desc)
+{
+	int rv, pid, x;
+
+	pid = fork();
+	if (pid<0) {
+		warn("UH-OH: fork failed");
+		return;
+	}
+	if (pid==0) {
+		exit(0);
+	}
+
+	rv = waitpid(pid, ptr, 0);
+	report_test(rv, errno, EFAULT, desc);
+	waitpid(pid, &x, 0);
+}
+
+static
+void
+wait_unaligned(void)
+{
+	int rv, pid, x;
+	int status[2];	/* will have integer alignment */
+	char *ptr;
+
+	pid = fork();
+	if (pid<0) {
+		warn("UH-OH: fork failed");
+		return;
+	}
+	if (pid==0) {
+		exit(0);
+	}
+
+	/* start with proper integer alignment */
+	ptr = (char *)(&status[0]);
+
+	/* generate improper alignment on platforms with restrictions*/
+	ptr++;
+
+	rv = waitpid(pid, (int *)ptr, 0);
+	report_survival(rv, errno, "wait with unaligned status");
+	if (rv<0) {
+		waitpid(pid, &x, 0);
+	}
+}
+
+static
+void
+wait_badflags(void)
+{
+	int rv, x, pid;
+
+	pid = fork();
+	if (pid<0) {
+		warn("UH-OH: fork failed");
+		return;
+	}
+	if (pid==0) {
+		exit(0);
+	}
+
+	rv = waitpid(pid, &x, 309429);
+	report_test(rv, errno, EINVAL, "wait with bad flags");
+	waitpid(pid, &x, 0);
+}
+
+static
+void
+wait_self(void)
+{
+	int rv, x;
+	rv = waitpid(getpid(), &x, 0);
+	report_survival(rv, errno, "wait for self");
+}
+
+static
+void
+wait_parent(void)
+{
+	int mypid, childpid, rv, x;
+
+	mypid = getpid();
+	childpid = fork();
+	if (childpid<0) {
+		warn("UH-OH: can't fork");
+		return;
+	}
+	if (childpid==0) {
+		/* Child. Wait for parent. */
+		rv = waitpid(mypid, &x, 0);
+		report_survival(rv, errno, "wait for parent (from child)");
+		_exit(0);
+	}
+	rv = waitpid(childpid, &x, 0);
+	report_survival(rv, errno, "wait for parent test (from parent)");
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+wait_siblings_child(void)
+{
+	int pids[2], mypid, otherpid, fd, rv, x;
+
+	mypid = getpid();
+
+	fd = open(TESTFILE, O_RDONLY);
+	if (fd<0) {
+		warn("UH-OH: child process (pid %d) can't open %s",
+		     mypid, TESTFILE);
+		return;
+	}
+
+	/*
+	 * Busy-wait until the parent writes the pids into the file.
+	 * This sucks, but there's not a whole lot else we can do.
+	 */
+	do {
+		rv = lseek(fd, 0, SEEK_SET);
+		if (rv<0) {
+			warn("UH-OH: child process (pid %d) lseek error",
+			     mypid);
+			return;
+		}
+		rv = read(fd, pids, sizeof(pids));
+		if (rv<0) {
+			warn("UH-OH: child process (pid %d) read error",
+			     mypid);
+			return;
+		}
+	} while (rv < (int)sizeof(pids));
+
+	if (mypid==pids[0]) {
+		otherpid = pids[1];
+	}
+	else if (mypid==pids[1]) {
+		otherpid = pids[0];
+	}
+	else {
+		warn("UH-OH: child process (pid %d) got garbage in comm file",
+		     mypid);
+		return;
+	}
+	close(fd);
+
+	rv = waitpid(otherpid, &x, 0);
+	report_survival(rv, errno, "sibling wait");
+}
+
+static
+void
+wait_siblings(void)
+{
+	int pids[2], fd, rv, x;
+
+	/* Note: this may also blow up if FS synchronization is substandard */
+
+	fd = open_testfile(NULL);
+	if (fd<0) {
+		return;
+	}
+
+	pids[0] = fork();
+	if (pids[0]<0) {
+		warn("UH-OH: can't fork");
+		return;
+	}
+	if (pids[0]==0) {
+		close(fd);
+		wait_siblings_child();
+		_exit(0);
+	}
+
+	pids[1] = fork();
+	if (pids[1]<0) {
+		warn("UH-OH: can't fork");
+		/* abandon the other child process :( */
+		return;
+	}
+	if (pids[1]==0) {
+		close(fd);
+		wait_siblings_child();
+		_exit(0);
+	}
+
+	rv = write(fd, pids, sizeof(pids));
+	if (rv < 0) {
+		warn("UH-OH: write error on %s", TESTFILE);
+		/* abandon child procs :( */
+		return;
+	}
+	if (rv != (int)sizeof(pids)) {
+		warnx("UH-OH: write error on %s: short count", TESTFILE);
+		/* abandon child procs :( */
+		return;
+	}
+
+	rv = waitpid(pids[0], &x, 0);
+	if (rv<0) {
+		warnx("UH-OH: error waiting for child 0 (pid %d)", pids[0]);
+	}
+	rv = waitpid(pids[1], &x, 0);
+	if (rv<0) {
+		warnx("UH-OH: error waiting for child 1 (pid %d)", pids[1]);
+	}
+	warnx("passed: siblings wait for each other");
+	close(fd);
+	remove(TESTFILE);
+}
+
+////////////////////////////////////////////////////////////
+
+void
+test_waitpid(void)
+{
+	wait_badpid(-8, "wait for pid -8");
+	wait_badpid(-1, "wait for pid -1");
+	wait_badpid(0, "pid zero");
+	wait_badpid(NONEXIST_PID, "nonexistent pid");
+
+	wait_badstatus(NULL, "wait with NULL status");
+	wait_badstatus(INVAL_PTR, "wait with invalid pointer status");
+	wait_badstatus(KERN_PTR, "wait with kernel pointer status");
+
+	wait_unaligned();
+
+	wait_badflags();
+
+	wait_self();
+	wait_parent();
+	wait_siblings();
+}
diff --git a/os161-1.10/testbin/badcall/bad_write.c b/os161-1.10/testbin/badcall/bad_write.c
new file mode 100644
index 0000000..c63298a
--- /dev/null
+++ b/os161-1.10/testbin/badcall/bad_write.c
@@ -0,0 +1,12 @@
+/*
+ * Invalid calls to write()
+ */
+
+#include "test.h"
+
+void
+test_write(void)
+{
+	test_write_fd();
+	test_write_buf();
+}
diff --git a/os161-1.10/testbin/badcall/common_buf.c b/os161-1.10/testbin/badcall/common_buf.c
new file mode 100644
index 0000000..1b1a6bf
--- /dev/null
+++ b/os161-1.10/testbin/badcall/common_buf.c
@@ -0,0 +1,191 @@
+/*
+ * Calls with invalid transfer buffers
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static int buf_fd;
+
+struct buftest {
+	int (*setup)(void);
+	int (*op)(void *);
+	void (*cleanup)(void);
+	const char *name;
+};
+
+////////////////////////////////////////////////////////////
+
+static
+int
+read_setup(void)
+{
+	buf_fd = open_testfile("i do not like green eggs and ham");
+	if (buf_fd<0) {
+		return -1;
+	}
+	return 0;
+}
+
+static
+int
+read_badbuf(void *buf)
+{
+	return read(buf_fd, buf, 128);
+}
+
+static
+void
+read_cleanup(void)
+{
+	close(buf_fd);
+	remove(TESTFILE);
+}
+
+//////////
+
+static
+int
+write_setup(void)
+{
+	buf_fd = open_testfile(NULL);
+	if (buf_fd<0) {
+		return -1;
+	}
+	return 0;
+}
+
+static
+int
+write_badbuf(void *ptr)
+{
+	return write(buf_fd, ptr, 128);
+}
+
+static
+void
+write_cleanup(void)
+{
+	close(buf_fd);
+	remove(TESTFILE);
+}
+
+//////////
+
+static
+int
+getdirentry_setup(void)
+{
+	buf_fd = open(".", O_RDONLY);
+	if (buf_fd < 0) {
+		warn("UH-OH: couldn't open .");
+		return -1;
+	}
+	return 0;
+}
+
+static
+int
+getdirentry_badbuf(void *ptr)
+{
+	return getdirentry(buf_fd, ptr, 1024);
+}
+
+static
+void
+getdirentry_cleanup(void)
+{
+	close(buf_fd);
+}
+
+//////////
+
+static
+int
+readlink_setup(void)
+{
+	return create_testlink();
+}
+
+static
+int
+readlink_badbuf(void *buf)
+{
+	return readlink(TESTLINK, buf, 168);
+}
+
+static
+void
+readlink_cleanup(void)
+{
+	remove(TESTLINK);
+}
+
+//////////
+
+static int getcwd_setup(void) { return 0; }
+static void getcwd_cleanup(void) {}
+
+static
+int
+getcwd_badbuf(void *buf)
+{
+	return __getcwd(buf, 408);
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+common_badbuf(struct buftest *info, void *buf, const char *bufdesc)
+{
+	char mydesc[128];
+	int rv;
+
+	snprintf(mydesc, sizeof(mydesc), "%s with %s buffer", 
+		 info->name, bufdesc);
+	info->setup();
+	rv = info->op(buf);
+	report_test(rv, errno, EFAULT, mydesc);
+	info->cleanup();
+}
+
+static
+void
+any_badbuf(struct buftest *info)
+{
+	common_badbuf(info, NULL, "NULL");
+	common_badbuf(info, INVAL_PTR, "invalid");
+	common_badbuf(info, KERN_PTR, "kernel-space");
+}
+
+////////////////////////////////////////////////////////////
+
+#define T(call) \
+  void					\
+  test_##call##_buf(void)		\
+  {					\
+  	static struct buftest info = {	\
+  		call##_setup,		\
+  		call##_badbuf,		\
+  		call##_cleanup,		\
+  		#call,			\
+	};				\
+   	any_badbuf(&info);		\
+  }
+
+T(read);
+T(write);
+T(getdirentry);
+T(readlink);
+T(getcwd);
diff --git a/os161-1.10/testbin/badcall/common_fds.c b/os161-1.10/testbin/badcall/common_fds.c
new file mode 100644
index 0000000..2bb4b1c
--- /dev/null
+++ b/os161-1.10/testbin/badcall/common_fds.c
@@ -0,0 +1,174 @@
+/*
+ * Calls with invalid fds
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+
+static
+int
+read_badfd(int fd)
+{
+	char buf[128];
+	return read(fd, buf, sizeof(buf));
+}
+
+static
+int
+write_badfd(int fd)
+{
+	char buf[128];
+	memset(buf, 'a', sizeof(buf));
+	return write(fd, buf, sizeof(buf));
+}
+
+
+static
+int
+close_badfd(int fd)
+{
+	return close(fd);
+}
+
+static
+int
+ioctl_badfd(int fd)
+{
+	return ioctl(fd, 0, NULL);
+}
+
+static
+int
+lseek_badfd(int fd)
+{
+	return lseek(fd, 0, SEEK_SET);
+}
+
+static
+int
+fsync_badfd(int fd)
+{
+	return fsync(fd);
+}
+
+static
+int
+ftruncate_badfd(int fd)
+{
+	return ftruncate(fd, 60);
+}
+
+static
+int
+fstat_badfd(int fd)
+{
+	struct stat sb;
+	return fstat(fd, &sb);
+}
+
+static
+int
+getdirentry_badfd(int fd)
+{
+	char buf[32];
+	return getdirentry(fd, buf, sizeof(buf));
+}
+
+static
+int
+dup2_badfd(int fd)
+{
+	/* use the +1 to avoid doing dup2(CLOSED_FD, CLOSED_FD) */
+	return dup2(fd, CLOSED_FD+1);
+}
+
+static
+void
+dup2_cleanup(void)
+{
+	close(CLOSED_FD+1);
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+any_badfd(int (*func)(int fd), void (*cleanup)(void), const char *callname,
+	  int fd, const char *fddesc)
+{
+	char fulldesc[128];
+	int rv;
+
+	snprintf(fulldesc, sizeof(fulldesc), "%s using %s", callname, fddesc);
+	rv = func(fd);
+	report_test(rv, errno, EBADF, fulldesc);
+	if (cleanup) {
+		cleanup();
+	}
+}
+
+static
+void
+runtest(int (*func)(int fd), void (*cleanup)(void), const char *callname)
+{
+	/*
+	 * If adding cases, also see bad_dup2.c
+	 */
+
+	/* basic invalid case: fd -1 */
+	any_badfd(func, cleanup, callname, -1, "fd -1");
+
+	/* also try -5 in case -1 is special somehow */
+	any_badfd(func, cleanup, callname, -5, "fd -5");
+
+	/* try a fd we know is closed */
+	any_badfd(func, cleanup, callname, CLOSED_FD, "closed fd");
+
+	/* try a positive fd we know is out of range */
+	any_badfd(func, cleanup, callname, IMPOSSIBLE_FD, "impossible fd");
+
+	/* test for off-by-one errors */
+#ifdef OPEN_MAX
+	any_badfd(func, cleanup, callname, OPEN_MAX, "fd OPEN_MAX");
+#else
+	warnx("Warning: OPEN_MAX not defined, test skipped");
+#endif
+}
+
+////////////////////////////////////////////////////////////
+
+#define T(call) \
+  void                                          \
+  test_##call##_fd(void)                        \
+  {                                             \
+   	runtest(call##_badfd, NULL, #call);     \
+  }
+
+#define TC(call) \
+  void                                          \
+  test_##call##_fd(void)                        \
+  {                                             \
+   	runtest(call##_badfd, call##_cleanup, #call);\
+  }
+
+T(read);
+T(write);
+T(close);
+T(ioctl);
+T(lseek);
+T(fsync);
+T(ftruncate);
+T(fstat);
+T(getdirentry);
+TC(dup2);
diff --git a/os161-1.10/testbin/badcall/common_path.c b/os161-1.10/testbin/badcall/common_path.c
new file mode 100644
index 0000000..72a6510
--- /dev/null
+++ b/os161-1.10/testbin/badcall/common_path.c
@@ -0,0 +1,183 @@
+/*
+ * Calls with invalid pathnames
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+static
+int
+open_badpath(const char *path)
+{
+	return open(path, O_RDONLY);
+}
+
+static
+int
+remove_badpath(const char *path)
+{
+	return remove(path);
+}
+
+static
+int
+rename_badpath1(const char *path)
+{
+	return rename(path, TESTFILE);
+}
+
+static
+int
+rename_badpath2(const char *path)
+{
+	return rename(TESTFILE, path);
+}
+
+static
+int
+link_badpath1(const char *path)
+{
+	return link(path, TESTFILE);
+}
+
+static
+int
+link_badpath2(const char *path)
+{
+	return link(TESTFILE, path);
+}
+
+static
+int
+mkdir_badpath(const char *path)
+{
+	return mkdir(path, 0775);
+}
+
+static
+int
+rmdir_badpath(const char *path)
+{
+	return rmdir(path);
+}
+
+static
+int
+chdir_badpath(const char *path)
+{
+	return chdir(path);
+}
+
+static
+int
+symlink_badpath1(const char *path)
+{
+	return symlink(path, TESTFILE);
+}
+
+static
+int
+symlink_badpath2(const char *path)
+{
+	return symlink(TESTFILE, path);
+}
+
+static
+int
+readlink_badpath(const char *path)
+{
+	char buf[128];
+	return readlink(path, buf, sizeof(buf));
+}
+
+static
+int
+lstat_badpath(const char *name)
+{
+	struct stat sb;
+	return lstat(name, &sb);
+}
+
+static
+int
+stat_badpath(const char *name)
+{
+	struct stat sb;
+	return stat(name, &sb);
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+common_badpath(int (*func)(const char *path), int mk, int rm, const char *path,
+	       const char *call, const char *pathdesc)
+{
+	char mydesc[128];
+	int rv;
+
+	if (mk) {
+		if (create_testfile()<0) {
+			return;
+		}
+	}
+
+	snprintf(mydesc, sizeof(mydesc), "%s with %s path", call, pathdesc);
+	rv = func(path);
+	report_test(rv, errno, EFAULT, mydesc);
+
+	if (mk || rm) {
+		remove(TESTFILE);
+	}
+}
+
+static
+void
+any_badpath(int (*func)(const char *path), const char *call, int mk, int rm)
+{
+	common_badpath(func, mk, rm, NULL, call, "NULL");
+	common_badpath(func, mk, rm, INVAL_PTR, call, "invalid-pointer");
+	common_badpath(func, mk, rm, KERN_PTR, call, "kernel-pointer");
+}
+
+////////////////////////////////////////////////////////////
+
+/* functions with one pathname */
+#define T(call) \
+  void                                  \
+  test_##call##_path(void)              \
+  {                                     \
+   	any_badpath(call##_badpath, #call, 0, 0); \
+  }
+
+T(open);
+T(remove);
+T(mkdir);
+T(rmdir);
+T(chdir);
+T(readlink);
+T(stat);
+T(lstat);
+
+/* functions with two pathnames */
+#define T2(call) \
+  void                                  \
+  test_##call##_paths(void)             \
+  {                                     \
+   	any_badpath(call##_badpath1, #call "(arg1)", 0, 1); \
+   	any_badpath(call##_badpath2, #call "(arg2)", 1, 1); \
+  }
+
+T2(rename);
+T2(link);
+T2(symlink);
diff --git a/os161-1.10/testbin/badcall/config.h b/os161-1.10/testbin/badcall/config.h
new file mode 100644
index 0000000..4a4d207
--- /dev/null
+++ b/os161-1.10/testbin/badcall/config.h
@@ -0,0 +1,38 @@
+/*
+ * Note: if the assumptions in the constants below are violated by
+ * your system design, please change the values as necessary. Don't
+ * change stuff in the .c files, or disable tests, without consulting
+ * the course staff first.
+ */
+
+#if defined(__mips__)
+#define KERN_PTR	((void *)0x80000000)	/* addr within kernel */
+#define INVAL_PTR	((void *)0x40000000)	/* addr not part of program */
+#else
+#error "Please fix this"
+#endif
+
+/*
+ * We assume CLOSED_FD is a legal fd that won't be open when we're running.
+ * CLOSED_FD+1 should also be legal and not open.
+ */
+#define CLOSED_FD		10
+
+/* We assume IMPOSSIBLE_FD is a fd that is completely not allowed. */
+#define IMPOSSIBLE_FD		1234567890
+
+/* We assume this pid won't exist while we're running. Change as needed. */
+#define NONEXIST_PID		34000
+
+/* The symbolic error code for no such process (ESRCH in unix) */
+#ifdef ESRCH
+#define NOSUCHPID_ERROR		ESRCH
+#else
+#define NOSUCHPID_ERROR		EINVAL
+#endif
+
+/* An arbitrary process exit code that hopefully won't occur by accident */
+#define MAGIC_STATUS		107
+
+/* An ioctl that doesn't exist */
+#define NONEXIST_IOCTL		12345
diff --git a/os161-1.10/testbin/badcall/depend.mk b/os161-1.10/testbin/badcall/depend.mk
new file mode 100644
index 0000000..3a64c26
--- /dev/null
+++ b/os161-1.10/testbin/badcall/depend.mk
@@ -0,0 +1,433 @@
+
+bad_execv.o: \
+ bad_execv.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h \
+ config.h \
+ test.h
+bad_waitpid.o: \
+ bad_waitpid.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h \
+ config.h \
+ test.h
+bad_open.o: \
+ bad_open.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_read.o: \
+ bad_read.c \
+ test.h
+bad_write.o: \
+ bad_write.c \
+ test.h
+bad_close.o: \
+ bad_close.c \
+ test.h
+bad_reboot.o: \
+ bad_reboot.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_sbrk.o: \
+ bad_sbrk.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_ioctl.o: \
+ bad_ioctl.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/ioctl.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ config.h \
+ test.h
+bad_lseek.o: \
+ bad_lseek.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_fsync.o: \
+ bad_fsync.c \
+ test.h
+bad_ftruncate.o: \
+ bad_ftruncate.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_stat.o: \
+ bad_stat.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_remove.o: \
+ bad_remove.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_rename.o: \
+ bad_rename.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ test.h
+bad_link.o: \
+ bad_link.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ test.h
+bad_mkdir.o: \
+ bad_mkdir.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_rmdir.o: \
+ bad_rmdir.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_chdir.o: \
+ bad_chdir.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h \
+ test.h
+bad_getdirentry.o: \
+ bad_getdirentry.c \
+ test.h
+bad_symlink.o: \
+ bad_symlink.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ test.h
+bad_readlink.o: \
+ bad_readlink.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ test.h
+bad_dup2.o: \
+ bad_dup2.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/limits.h \
+ $(OSTREE)/include/kern/limits.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_pipe.o: \
+ bad_pipe.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_time.o: \
+ bad_time.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+bad_getcwd.o: \
+ bad_getcwd.c \
+ test.h
+common_buf.o: \
+ common_buf.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/limits.h \
+ $(OSTREE)/include/kern/limits.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+common_fds.o: \
+ common_fds.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/limits.h \
+ $(OSTREE)/include/kern/limits.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+common_path.o: \
+ common_path.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/limits.h \
+ $(OSTREE)/include/kern/limits.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
+driver.o: \
+ driver.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ config.h \
+ test.h
diff --git a/os161-1.10/testbin/badcall/driver.c b/os161-1.10/testbin/badcall/driver.c
new file mode 100644
index 0000000..d56021b
--- /dev/null
+++ b/os161-1.10/testbin/badcall/driver.c
@@ -0,0 +1,288 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#include "config.h"
+#include "test.h"
+
+////////////////////////////////////////////////////////////
+
+static
+int
+finderror(int rv, int error)
+{
+	if (rv==-1) {
+		return error;
+	}
+	else {
+		return 0;
+	}
+}
+
+void
+report_survival(int rv, int error, const char *desc)
+{
+	/* allow any error as long as we survive */
+	errno = finderror(rv, error);
+	warn("passed: %s", desc);
+}
+
+void
+report_test(int rv, int error, int right_error, const char *desc)
+{
+	int goterror = finderror(rv, error);
+
+	if (goterror == right_error) {
+		warnx("passed: %s", desc);
+	}
+	else if (goterror == EUNIMP || goterror == ENOSYS) {
+		warnx("------: %s (unimplemented)", desc);
+	}
+	else {
+		errno = goterror;
+		warn("FAILURE: %s", desc);
+	}
+}
+
+void
+report_test2(int rv, int error, int okerr1, int okerr2, const char *desc)
+{
+	int goterror = finderror(rv, error);
+	if (goterror == okerr1 || goterror == okerr2) {
+		warnx("passed: %s", desc);
+	}
+	else if (goterror == EUNIMP || goterror == ENOSYS) {
+		warnx("------: %s (unimplemented)", desc);
+	}
+	else {
+		errno = goterror;
+		warn("FAILURE: %s", desc);
+	}
+}
+
+////////////////////////////////////////////////////////////
+
+int
+open_testfile(const char *string)
+{
+	int fd, rv;
+	size_t len;
+
+	fd = open(TESTFILE, O_RDWR|O_CREAT|O_TRUNC);
+	if (fd<0) {
+		warn("UH-OH: creating %s: failed", TESTFILE);
+		return -1;
+	}
+
+	if (string) {
+		len = strlen(string);
+		rv = write(fd, string, len);
+		if (rv<0) {
+			warn("UH-OH: write to %s failed", TESTFILE);
+			close(fd);
+			remove(TESTFILE);
+			return -1;
+		}
+		if ((unsigned)rv != len) {
+			warnx("UH-OH: write to %s got short count", TESTFILE);
+			close(fd);
+			remove(TESTFILE);
+			return -1;
+		}
+		rv = lseek(fd, 0, SEEK_SET);
+		if (rv<0) {
+			warn("UH-OH: rewind of %s failed", TESTFILE);
+			close(fd);
+			remove(TESTFILE);
+			return -1;
+		}
+	}
+	return fd;
+}
+
+int
+create_testfile(void)
+{
+	int fd, rv;
+
+	fd = open_testfile(NULL);
+	if (fd<0) {
+		return -1;
+	}
+
+	rv = close(fd);
+	if (rv<0) {
+		warn("UH-OH: closing %s failed", TESTFILE);
+		return -1;
+	}
+
+	return 0;
+}
+
+int
+create_testdir(void)
+{
+	int rv;
+	rv = mkdir(TESTDIR, 0775);
+	if (rv<0) {
+		warn("UH-OH: mkdir %s failed", TESTDIR);
+		return -1;
+	}
+	return 0;
+}
+
+int
+create_testlink(void)
+{
+	int rv;
+	rv = symlink("blahblah", TESTLINK);
+	if (rv<0) {
+		warn("UH-OH: making symlink %s failed", TESTLINK);
+		return -1;
+	}
+	return 0;
+}
+
+////////////////////////////////////////////////////////////
+
+static
+struct {
+	int ch;
+	int asst;
+	const char *name;
+	void (*f)(void);
+} ops[] = {
+	{ 'a', 2, "execv",		test_execv },
+	{ 'b', 2, "waitpid",		test_waitpid },
+	{ 'c', 2, "open",		test_open },
+	{ 'd', 2, "read",		test_read },
+	{ 'e', 2, "write",		test_write },
+	{ 'f', 2, "close",		test_close },
+	{ 'g', 0, "reboot",		test_reboot },
+	{ 'h', 3, "sbrk",		test_sbrk },
+	{ 'i', 5, "ioctl",		test_ioctl },
+	{ 'j', 2, "lseek",		test_lseek },
+	{ 'k', 4, "fsync",		test_fsync },
+	{ 'l', 4, "ftruncate",		test_ftruncate },
+	{ 'm', 4, "fstat",		test_fstat },
+	{ 'n', 4, "remove",		test_remove },
+	{ 'o', 4, "rename",		test_rename },
+	{ 'p', 5, "link",		test_link },
+	{ 'q', 4, "mkdir",		test_mkdir },
+	{ 'r', 4, "rmdir",		test_rmdir },
+	{ 's', 2, "chdir",		test_chdir },
+	{ 't', 4, "getdirentry",	test_getdirentry },
+	{ 'u', 5, "symlink",		test_symlink },
+	{ 'v', 5, "readlink",		test_readlink },
+	{ 'w', 2, "dup2",		test_dup2 },
+	{ 'x', 5, "pipe",		test_pipe },
+	{ 'y', 5, "__time",		test_time },
+	{ 'z', 2, "__getcwd",		test_getcwd },
+	{ '{', 5, "stat",		test_stat },
+	{ '|', 5, "lstat",		test_lstat },
+	{ 0, 0, NULL, NULL }
+};
+
+#define LOWEST  'a'
+#define HIGHEST '|'
+
+static
+void
+menu(void)
+{
+	int i;
+	for (i=0; ops[i].name; i++) {
+		printf("[%c] %-24s", ops[i].ch, ops[i].name);
+		if (i%2==1) {
+			printf("\n");
+		}
+	}
+	if (i%2==1) {
+		printf("\n");
+	}
+	printf("[1] %-24s", "asst1");
+	printf("[2] %-24s\n", "asst2");
+	printf("[3] %-24s", "asst3");
+	printf("[4] %-24s\n", "asst4");
+	printf("[*] %-24s", "all");
+	printf("[!] %-24s\n", "quit");
+}
+
+static
+void
+runit(int op)
+{
+	int i, k;
+
+	if (op=='!') {
+		exit(0);
+	}
+
+	if (op=='?') {
+		menu();
+		return;
+	}
+
+	if (op=='*') {
+		for (i=0; ops[i].name; i++) {
+			printf("[%s]\n", ops[i].name);
+			ops[i].f();
+		}
+		return;
+	}
+
+	if (op>='1' && op <= '4') {
+		k = op-'0';
+		for (i=0; ops[i].name; i++) {
+			if (ops[i].asst <= k) {
+				printf("[%s]\n", ops[i].name);
+				ops[i].f();
+			}
+		}
+		return;
+	}
+
+	if (op < LOWEST || op > HIGHEST) {
+		printf("Invalid request %c\n", op);
+		return;
+	}
+
+	ops[op-'a'].f();
+}
+	
+int
+main(int argc, char **argv)
+{
+	int op, i, j;
+
+	printf("[%c-%c, 1-4, *, ?=menu, !=quit]\n", LOWEST, HIGHEST);
+
+	if (argc > 1) {
+		for (i=1; i<argc; i++) {
+			for (j=0; argv[i][j]; j++) {
+				printf("Choose: %c\n",
+				       argv[i][j]);
+				runit(argv[i][j]);
+			}
+		}
+	}
+	else {
+		menu();
+		while (1) {
+			printf("Choose: ");
+			op = getchar();
+			if (op==EOF) {
+				break;
+			}
+			printf("%c\n", op);
+			runit(op);
+		}
+	}
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/badcall/test.h b/os161-1.10/testbin/badcall/test.h
new file mode 100644
index 0000000..6aa2f15
--- /dev/null
+++ b/os161-1.10/testbin/badcall/test.h
@@ -0,0 +1,74 @@
+#define TESTFILE "badcallfile"
+#define TESTDIR  "badcalldir"
+#define TESTLINK "badcalllink"
+
+/* driver.c */
+void report_survival(int rv, int error, const char *desc);
+void report_test(int rv, int error, int right_error, const char *desc);
+void report_test2(int rv, int error, int okerr1, int okerr2, const char *desc);
+int open_testfile(const char *str);
+int create_testfile(void);
+int create_testdir(void);
+int create_testlink(void);
+
+/* common_buf.c */
+void test_read_buf(void);
+void test_write_buf(void);
+void test_getdirentry_buf(void);
+void test_getcwd_buf(void);
+void test_readlink_buf(void);
+
+/* common_fds.c */
+void test_read_fd(void);
+void test_write_fd(void);
+void test_close_fd(void);
+void test_ioctl_fd(void);
+void test_lseek_fd(void);
+void test_fsync_fd(void);
+void test_ftruncate_fd(void);
+void test_fstat_fd(void);
+void test_getdirentry_fd(void);
+void test_dup2_fd(void);
+
+/* common_path.c */
+void test_open_path(void);
+void test_remove_path(void);
+void test_rename_paths(void);
+void test_link_paths(void);
+void test_mkdir_path(void);
+void test_rmdir_path(void);
+void test_chdir_path(void);
+void test_symlink_paths(void);
+void test_readlink_path(void);
+void test_stat_path(void);
+void test_lstat_path(void);
+
+/* bad_*.c */
+void test_execv(void);
+void test_waitpid(void);
+void test_open(void);
+void test_read(void);
+void test_write(void);
+void test_close(void);
+void test_reboot(void);
+void test_sbrk(void);
+void test_ioctl(void);
+void test_lseek(void);
+void test_fsync(void);
+void test_ftruncate(void);
+void test_fstat(void);		/* in bad_stat.c */
+void test_remove(void);
+void test_rename(void);
+void test_link(void);
+void test_mkdir(void);
+void test_rmdir(void);
+void test_chdir(void);
+void test_getdirentry(void);
+void test_symlink(void);
+void test_readlink(void);
+void test_dup2(void);
+void test_pipe(void);
+void test_time(void);
+void test_getcwd(void);
+void test_stat(void);
+void test_lstat(void);		/* in bad_stat.c */
diff --git a/os161-1.10/testbin/bigfile/.cvsignore b/os161-1.10/testbin/bigfile/.cvsignore
new file mode 100644
index 0000000..f4a5e05
--- /dev/null
+++ b/os161-1.10/testbin/bigfile/.cvsignore
@@ -0,0 +1 @@
+bigfile
diff --git a/os161-1.10/testbin/bigfile/Makefile b/os161-1.10/testbin/bigfile/Makefile
new file mode 100644
index 0000000..babe367
--- /dev/null
+++ b/os161-1.10/testbin/bigfile/Makefile
@@ -0,0 +1,9 @@
+# Makefile for bigfile
+
+SRCS=bigfile.c
+PROG=bigfile
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/bigfile/bigfile.c b/os161-1.10/testbin/bigfile/bigfile.c
new file mode 100644
index 0000000..b2b0414
--- /dev/null
+++ b/os161-1.10/testbin/bigfile/bigfile.c
@@ -0,0 +1,53 @@
+/*
+ * Create a large file in small increments.
+ *
+ * Should work on emufs (emu0:) once the basic system calls are done,
+ * and should work on SFS when the file system assignment is
+ * done. Sufficiently small files should work on SFS even before that
+ * assignment.
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <err.h>
+
+static char buffer[100];
+
+int
+main(int argc, char *argv[])
+{
+	const char *filename;
+	int i, size;
+	int fileid;
+	int len;
+
+	if (argc != 3) {
+		errx(1, "Usage: bigfile <filename> <size>");
+	}
+
+	filename = argv[1];
+	size = atoi(argv[2]);
+
+	printf("Creating a file of size %d\n", size);
+
+	fileid = open(filename, O_WRONLY|O_CREAT|O_TRUNC);
+	if (fileid < 0) {
+		err(1, "%s: create", filename);
+	}
+
+	i=0;
+	while (i<size) {
+		snprintf(buffer, sizeof(buffer), "%-10d", i);
+		len = write(fileid, buffer, strlen(buffer));
+		if (len<0) {
+			err(1, "%s: write", filename);
+		}
+		i += len;
+	}	
+
+	close(fileid);
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/bigfile/depend.mk b/os161-1.10/testbin/bigfile/depend.mk
new file mode 100644
index 0000000..7158550
--- /dev/null
+++ b/os161-1.10/testbin/bigfile/depend.mk
@@ -0,0 +1,14 @@
+
+bigfile.o: \
+ bigfile.c \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/conman/.cvsignore b/os161-1.10/testbin/conman/.cvsignore
new file mode 100644
index 0000000..e078f74
--- /dev/null
+++ b/os161-1.10/testbin/conman/.cvsignore
@@ -0,0 +1 @@
+conman
diff --git a/os161-1.10/testbin/conman/Makefile b/os161-1.10/testbin/conman/Makefile
new file mode 100644
index 0000000..2358a0f
--- /dev/null
+++ b/os161-1.10/testbin/conman/Makefile
@@ -0,0 +1,9 @@
+# Makefile for conman
+
+SRCS=conman.c
+PROG=conman
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/conman/conman.c b/os161-1.10/testbin/conman/conman.c
new file mode 100644
index 0000000..b46fdb7
--- /dev/null
+++ b/os161-1.10/testbin/conman/conman.c
@@ -0,0 +1,28 @@
+/*
+ * conman.c
+ *
+ * Echoes characters until a 'q' is read.
+ * This should work once the basic system calls are implemented.
+ */
+
+#include <unistd.h>
+#include <err.h>
+
+int
+main() {
+	char ch=0;
+	int len;
+
+	while (ch!='q') {
+		len = read(STDIN_FILENO, &ch, 1);
+		if (len < 0) {
+			err(1, "stdin: read");
+		}
+		if (len==0) {
+			/* EOF */
+			break;
+		}
+		write(STDOUT_FILENO, &ch, 1);
+	}
+	return 0;
+}
diff --git a/os161-1.10/testbin/conman/depend.mk b/os161-1.10/testbin/conman/depend.mk
new file mode 100644
index 0000000..1f4394d
--- /dev/null
+++ b/os161-1.10/testbin/conman/depend.mk
@@ -0,0 +1,11 @@
+
+conman.o: \
+ conman.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/crash/.cvsignore b/os161-1.10/testbin/crash/.cvsignore
new file mode 100644
index 0000000..0bc3798
--- /dev/null
+++ b/os161-1.10/testbin/crash/.cvsignore
@@ -0,0 +1 @@
+crash
diff --git a/os161-1.10/testbin/crash/Makefile b/os161-1.10/testbin/crash/Makefile
new file mode 100644
index 0000000..215246a
--- /dev/null
+++ b/os161-1.10/testbin/crash/Makefile
@@ -0,0 +1,9 @@
+# Makefile for crash
+
+SRCS=crash.c
+PROG=crash
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/crash/crash.c b/os161-1.10/testbin/crash/crash.c
new file mode 100644
index 0000000..d722805
--- /dev/null
+++ b/os161-1.10/testbin/crash/crash.c
@@ -0,0 +1,240 @@
+/*
+ * crash.c
+ *
+ * 	Commit a variety of exceptions, primarily address faults.
+ *
+ * Once the basic system calls assignment is complete, none of these
+ * should crash the kernel.
+ *
+ * They should all, however, terminate this program, except for the
+ * one that writes to the code segment. (That one won't cause program
+ * termination until/unless you implement read-only segments in your
+ * VM system.)
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <err.h>
+
+#if defined(__mips__)
+#define KERNEL_ADDR	0x80000000
+#define INVAL_ADDR	0x40000000
+#define INSN_TYPE	u_int32_t
+#define INVAL_INSN	0x0000003f
+#else
+#error "Please fix this"
+#endif
+
+typedef void (*func)(void);
+
+static
+void
+read_from_null(void)
+{
+	int *null = NULL;
+	volatile int x;
+	x = *null;
+}
+
+static
+void
+read_from_inval(void)
+{
+	int *ptr = (int *) INVAL_ADDR;
+	volatile int x;
+	x = *ptr;
+}
+
+static
+void
+read_from_kernel(void)
+{
+	int *ptr = (int *) KERNEL_ADDR;
+	volatile int x;
+	x = *ptr;
+}
+
+static
+void
+write_to_null(void)
+{
+	int *null = NULL;
+	*null = 6;
+}
+
+static
+void
+write_to_inval(void)
+{
+	int *ptr = (int *) INVAL_ADDR;
+	*ptr = 8;
+}
+
+static
+void
+write_to_code(void)
+{
+	INSN_TYPE *x = (INSN_TYPE *)write_to_code;
+	*x = INVAL_INSN;
+}
+
+static
+void
+write_to_kernel(void)
+{
+	int *ptr = (int *) KERNEL_ADDR;
+	*ptr = 8;
+}
+
+static
+void
+jump_to_null(void)
+{
+	func f = NULL;
+	f();
+}
+
+static
+void
+jump_to_inval(void)
+{
+	func f = (func) INVAL_ADDR;
+	f();
+}
+
+static
+void
+jump_to_kernel(void)
+{
+	func f = (func) KERNEL_ADDR;
+	f();
+}
+
+
+static
+void
+illegal_instruction(void)
+{
+#if defined(__mips__)
+	asm(".long 0x0000003f");
+#else
+#error "Please fix this"
+#endif
+}
+
+static
+void
+alignment_error(void)
+{
+	int x;
+	int *ptr = &x;
+	int *badptr = (int *)(((char *)ptr)+1);
+
+	volatile int j;
+	j = *badptr;
+}
+
+static
+void
+divide_by_zero(void)
+{
+	volatile int x = 6;
+	volatile int z = 0;
+	volatile int a;
+
+	a = x/z;
+}
+
+static
+void
+mod_by_zero(void)
+{
+	volatile int x = 6;
+	volatile int z = 0;
+	volatile int a;
+
+	a = x%z;
+}
+
+static
+void
+recurse_inf(void)
+{
+	volatile char buf[16];
+	buf[0] = 0;
+	recurse_inf();
+}
+
+
+static
+struct {
+	int ch;
+	const char *name;
+	func f;
+} ops[] = {
+	{ 'a', "read from NULL",		read_from_null },
+	{ 'b', "read from invalid address",	read_from_inval },
+	{ 'c', "read from kernel address",	read_from_kernel },
+	{ 'd', "write to NULL",			write_to_null },
+	{ 'e', "write to invalid address",	write_to_inval },
+	{ 'f', "write to code segment",		write_to_code },
+	{ 'g', "write to kernel address",	write_to_kernel },
+	{ 'h', "jump to NULL",			jump_to_null },
+	{ 'i', "jump to invalid address",	jump_to_inval },
+	{ 'j', "jump to kernel address",	jump_to_kernel },
+	{ 'k', "alignment error",		alignment_error },
+	{ 'l', "illegal instruction",		illegal_instruction },
+	{ 'm', "divide by zero",		divide_by_zero },
+	{ 'n', "mod by zero",			mod_by_zero },
+	{ 'o', "Recurse infinitely",		recurse_inf },
+	{ 0, NULL, NULL }
+};
+
+int
+main(int argc, char **argv)
+{
+	int op, i, status;
+	pid_t pid;
+
+	if (argc == 2) {
+		op = argv[1][0];
+	}
+	else {
+		for (i=0; ops[i].name; i++) {
+			printf("[%c] %s\n", ops[i].ch, ops[i].name);
+		}
+		printf("[*] Run everything (in subprocesses)\n");
+		printf("Note: [f] may not cause an exception on some "
+		       "platforms, in which\ncase it'll appear to fail.\n");
+
+		printf("Choose: ");
+		op = getchar();
+	}
+
+	if (op=='*') {
+		for (i=0; ops[i].name; i++) {
+			printf("Running: [%c] %s\n", ops[i].ch, ops[i].name);
+			pid = fork();
+			if (pid<0) {
+				/* error */
+				warn("fork");
+			}
+			else if (pid==0) {
+				/* child */
+				ops[i].f();
+				printf("I wasn't killed - test fails!\n");
+				_exit(1);
+			}
+			waitpid(pid, &status, 0);
+			printf("Exit %d\n", status);
+		}
+	}
+	else {
+		/* intentionally don't check if op is in bounds :) */
+		ops[op-'a'].f();
+
+		printf("I wasn't killed - test fails!\n");
+	}
+  
+	return 0;
+}
diff --git a/os161-1.10/testbin/crash/depend.mk b/os161-1.10/testbin/crash/depend.mk
new file mode 100644
index 0000000..6ac8823
--- /dev/null
+++ b/os161-1.10/testbin/crash/depend.mk
@@ -0,0 +1,12 @@
+
+crash.o: \
+ crash.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/ctest/.cvsignore b/os161-1.10/testbin/ctest/.cvsignore
new file mode 100644
index 0000000..2d7a7ab
--- /dev/null
+++ b/os161-1.10/testbin/ctest/.cvsignore
@@ -0,0 +1 @@
+ctest
diff --git a/os161-1.10/testbin/ctest/Makefile b/os161-1.10/testbin/ctest/Makefile
new file mode 100644
index 0000000..8eccee4
--- /dev/null
+++ b/os161-1.10/testbin/ctest/Makefile
@@ -0,0 +1,9 @@
+# Makefile for ctest
+
+SRCS=ctest.c
+PROG=ctest
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/ctest/ctest.c b/os161-1.10/testbin/ctest/ctest.c
new file mode 100644
index 0000000..2e53548
--- /dev/null
+++ b/os161-1.10/testbin/ctest/ctest.c
@@ -0,0 +1,72 @@
+/*
+ * Performance test from former 161 prof. Brad Chen
+ * Stresses VM.
+ *
+ * Intended for the VM assignment. This should run successfully on a
+ * variety of strides when the VM system is complete. Strides that are
+ * not a multiple of 2 work better; see below.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+/*
+ * SIZE is the amount of memory used.
+ * DEFAULT is the default stride.
+ * Note that SIZE and DEFAULT should be relatively prime.
+ */
+#define SIZE      (1024*1024/sizeof(struct entry))
+#define DEFAULT   477
+
+struct entry {
+	struct entry *e;
+};
+
+struct entry array[SIZE];
+
+int
+main(int argc, char **argv)
+{
+	struct entry *e;
+	unsigned i, stride;
+
+	stride = DEFAULT;
+	if (argc == 2) {
+		stride = atoi(argv[1]);
+	}
+	if (stride <= 0 || argc > 2) {
+		printf("Usage: ctest [stridesize]\n");
+		printf("   stridesize should not be a multiple of 2.\n");
+		return 1;
+	}
+
+	printf("Starting ctest: stride %d\n", stride);
+	
+	/*
+	 * Generate a huge linked list, with each entry pointing to
+	 * the slot STRIDE entries above it. As long as STRIDE and SIZE
+	 * are relatively prime, this will put all the entries on one
+	 * list. Otherwise you will get multiple disjoint lists. (All
+	 * these lists will be circular.)
+	 */
+	for (i=0; i<SIZE; i++) {
+		array[i].e = &array[(i+stride) % SIZE];
+	}
+
+	/*
+	 * Traverse the list. We stop after hitting each element once.
+	 *
+	 * (If STRIDE was even, this will hit some elements more than 
+	 * once and others not at all.)
+	 */
+	e = &array[0];
+	for (i=0; i<SIZE; i++) {
+		if (i % stride == 0) {
+			putchar('.');
+		}
+		e = e->e;
+	}
+
+	printf("\nDone!\n");
+	return 0;
+}
diff --git a/os161-1.10/testbin/ctest/depend.mk b/os161-1.10/testbin/ctest/depend.mk
new file mode 100644
index 0000000..e2a65ad
--- /dev/null
+++ b/os161-1.10/testbin/ctest/depend.mk
@@ -0,0 +1,9 @@
+
+ctest.o: \
+ ctest.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h
diff --git a/os161-1.10/testbin/dirconc/.cvsignore b/os161-1.10/testbin/dirconc/.cvsignore
new file mode 100644
index 0000000..04b4163
--- /dev/null
+++ b/os161-1.10/testbin/dirconc/.cvsignore
@@ -0,0 +1 @@
+dirconc
diff --git a/os161-1.10/testbin/dirconc/Makefile b/os161-1.10/testbin/dirconc/Makefile
new file mode 100644
index 0000000..bf9e420
--- /dev/null
+++ b/os161-1.10/testbin/dirconc/Makefile
@@ -0,0 +1,9 @@
+# Makefile for dirconc
+
+SRCS=dirconc.c
+PROG=dirconc
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/dirconc/depend.mk b/os161-1.10/testbin/dirconc/depend.mk
new file mode 100644
index 0000000..e8767da
--- /dev/null
+++ b/os161-1.10/testbin/dirconc/depend.mk
@@ -0,0 +1,18 @@
+
+dirconc.o: \
+ dirconc.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/wait.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h
diff --git a/os161-1.10/testbin/dirconc/dirconc.c b/os161-1.10/testbin/dirconc/dirconc.c
new file mode 100644
index 0000000..db4b81d
--- /dev/null
+++ b/os161-1.10/testbin/dirconc/dirconc.c
@@ -0,0 +1,341 @@
+/*
+ * Concurrent directory operations test.
+ *
+ * Your system should survive this (without leaving a corrupted file
+ * system behind) once the file system assignment is complete.
+ */
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+
+#define NTRIES    100	/* loop count */
+#define NPROCS    5	/* actually totals 4x this +1 processes */
+
+#define TESTDIR   "dirconc"
+#define NNAMES    4
+#define NAMESIZE  32
+
+#ifndef HOST
+/* OS/161 doesn't support the Unix exit status macros */
+#define WIFSIGNALED(status)	((void)(status), 0)
+#define WTERMSIG(status)	((void)(status), 0)
+#define WIFEXITED(status)	((void)(status), 1)
+#define WEXITSTATUS(status)	(status)
+#endif
+
+////////////////////////////////////////////////////////////
+
+static const char *const names[NNAMES] = {
+	"aaaa", 
+	"bbbb",
+	"cccc", 
+	"dddd",
+};
+
+static
+void
+choose_name(char *buf, size_t len)
+{
+	const char *a, *b, *c;
+
+	a = names[random()%NNAMES];
+	if (random()%2==0) {
+		snprintf(buf, len, "%s", a);
+		return;
+	}
+	b = names[random()%NNAMES];
+	if (random()%2==0) {
+		snprintf(buf, len, "%s/%s", a, b);
+		return;
+	}
+	c = names[random()%NNAMES];
+	snprintf(buf, len, "%s/%s/%s", a, b, c);
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * The purpose of this is to be atomic. In our world, straight
+ * printf tends not to be.
+ */
+static
+void
+#ifdef __GNUC__
+	__attribute__((__format__(__printf__, 1, 2)))
+#endif
+say(const char *fmt, ...)
+{
+	char buf[512];
+	va_list ap;
+	va_start(ap, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+	write(STDOUT_FILENO, buf, strlen(buf));
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+dorename(const char *name1, const char *name2)
+{
+	if (rename(name1, name2) < 0) {
+		switch (errno) {
+		    case ENOENT:
+		    case ENOTEMPTY:
+		    case EINVAL:
+			break;
+		    default:
+			say("pid %d: rename %s -> %s: %s\n", 
+			    getpid(), name1, name2, strerror(errno));
+			break;
+		}
+	}
+}
+
+static
+void
+domkdir(const char *name)
+{
+	if (mkdir(name, 0775)<0) {
+		switch (errno) {
+		    case ENOENT:
+		    case EEXIST:
+			break;
+		    default:
+			say("pid %d: mkdir %s: %s\n",
+			    getpid(), name, strerror(errno));
+			break;
+		}
+	}
+}
+
+static
+void
+dormdir(const char *name)
+{
+	if (rmdir(name)<0) {
+		switch (errno) {
+		    case ENOENT:
+		    case ENOTEMPTY:
+			break;
+		    default:
+			say("pid %d: rmdir %s: %s\n",
+			    getpid(), name, strerror(errno));
+			break;
+		}
+	}
+}
+
+static
+void
+cleanup_rmdir(const char *name)
+{
+	if (rmdir(name)<0) {
+		switch (errno) {
+		    case ENOENT:
+			break;
+		    default:
+			say("cleanup (pid %d): rmdir %s: %s\n",
+			    getpid(), name, strerror(errno));
+			break;
+		}
+	}
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+rename_proc(void)
+{
+	char name1[NAMESIZE], name2[NAMESIZE];
+	int ct;
+	
+	for (ct=0; ct<NTRIES; ct++) {
+		choose_name(name1, sizeof(name1));
+		choose_name(name2, sizeof(name2));
+		say("pid %2d: rename %s -> %s\n", (int)getpid(), name1, name2);
+		dorename(name1, name2);
+	}
+}
+
+static
+void
+mkdir_proc(void)
+{
+	char name[NAMESIZE];
+	int ct;
+	
+	for (ct=0; ct<NTRIES; ct++) {
+		choose_name(name, sizeof(name));
+		say("pid %2d: mkdir  %s\n", (int)getpid(), name);
+		domkdir(name);
+	}
+}
+
+static
+void
+rmdir_proc(void)
+{
+	char name[NAMESIZE];
+	int ct;
+
+	for (ct=0; ct<NTRIES; ct++) {
+		choose_name(name, sizeof(name));
+		say("pid %2d: rmdir  %s\n", (int)getpid(), name);
+		dormdir(name);
+	}
+}
+
+////////////////////////////////////////////////////////////
+
+static
+pid_t
+dofork(void (*func)(void))
+{
+	pid_t pid;
+
+	pid = fork();
+	if (pid < 0) {
+		say("fork: %s\n", strerror(errno));
+		return -1;
+	}
+	if (pid == 0) {
+		/* child */
+		func();
+		exit(0);
+	}
+	return pid;
+}
+
+static
+void
+run(void)
+{
+	pid_t pids[NPROCS*4], wp;
+	int i, status;
+
+	for (i=0; i<NPROCS; i++) {
+		pids[i*4] = dofork(mkdir_proc);
+		pids[i*4+1] = dofork(mkdir_proc);
+		pids[i*4+2] = dofork(rename_proc);
+		pids[i*4+3] = dofork(rmdir_proc);
+	}
+	
+	for (i=0; i<NPROCS*4; i++) {
+		if (pids[i]>=0) {
+			wp = waitpid(pids[i], &status, 0);
+			if (wp<0) {
+				say("waitpid %d: %s\n", (int) pids[i], 
+				    strerror(errno));
+			}
+			else if (WIFSIGNALED(status)) {
+				say("pid %d: signal %d\n", (int) pids[i],
+				    WTERMSIG(status));
+			}
+			else if (WIFEXITED(status) && WEXITSTATUS(status)!=0) {
+				say("pid %d: exit %d\n", (int) pids[i], 
+				    WEXITSTATUS(status));
+			}
+		}
+	}
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+setup(const char *fs)
+{
+	if (chdir(fs)<0) {
+		say("chdir: %s: %s\n", fs, strerror(errno));
+		exit(1);
+	}
+	if (mkdir(TESTDIR, 0775)<0) {
+		say("mkdir: %s: %s\n", TESTDIR, strerror(errno));
+		exit(1);
+	}
+	if (chdir(TESTDIR)<0) {
+		say("chdir: %s: %s\n", TESTDIR, strerror(errno));
+		exit(1);
+	}
+}
+
+static
+void
+recursive_cleanup(const char *sofar, int depth)
+{
+	char buf[NAMESIZE*32];
+	int i;
+	
+	for (i=0; i<NNAMES; i++) {
+		snprintf(buf, sizeof(buf), "%s/%s", sofar, names[i]);
+		if (rmdir(buf)<0) {
+			if (errno==ENOTEMPTY) {
+				recursive_cleanup(buf, depth+1);
+				cleanup_rmdir(buf);
+			}
+			else if (errno!=ENOENT) {
+				say("cleanup (pid %d): rmdir %s: %s\n", 
+				    getpid(), buf, strerror(errno));
+			}
+		}
+	}
+}
+
+static
+void
+cleanup(void)
+{
+	recursive_cleanup(".", 0);
+	
+	chdir("..");
+	cleanup_rmdir(TESTDIR);
+}
+
+////////////////////////////////////////////////////////////
+
+int
+main(int argc, char *argv[])
+{
+	const char *fs;
+	long seed = 0;
+	
+	say("Concurrent directory ops test\n");
+	
+	if (argc==0 || argv==NULL) {
+		say("Warning: argc is 0 - assuming you mean to run on lhd1: "
+		    "with seed 0\n");
+		fs = "lhd1:";
+	}
+	else if (argc==2) {
+		fs = argv[1];
+	}
+	else if (argc==3) {
+		fs = argv[1];
+		seed = atoi(argv[2]);
+	}
+	else {
+		say("Usage: dirconc filesystem [random-seed]\n");
+		exit(1);
+	}
+	
+	srandom(seed);
+	setup(fs);
+	say("Starting in %s/%s\n", fs, TESTDIR);
+	
+	run();
+	
+	say("Cleaning up\n");
+	cleanup();
+	
+	return 0;
+}
diff --git a/os161-1.10/testbin/dirseek/.cvsignore b/os161-1.10/testbin/dirseek/.cvsignore
new file mode 100644
index 0000000..d51fc93
--- /dev/null
+++ b/os161-1.10/testbin/dirseek/.cvsignore
@@ -0,0 +1 @@
+dirseek
diff --git a/os161-1.10/testbin/dirseek/Makefile b/os161-1.10/testbin/dirseek/Makefile
new file mode 100644
index 0000000..9278d31
--- /dev/null
+++ b/os161-1.10/testbin/dirseek/Makefile
@@ -0,0 +1,9 @@
+# Makefile for dirseek
+
+SRCS=dirseek.c
+PROG=dirseek
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/dirseek/depend.mk b/os161-1.10/testbin/dirseek/depend.mk
new file mode 100644
index 0000000..f2bf933
--- /dev/null
+++ b/os161-1.10/testbin/dirseek/depend.mk
@@ -0,0 +1,16 @@
+
+dirseek.o: \
+ dirseek.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/dirseek/dirseek.c b/os161-1.10/testbin/dirseek/dirseek.c
new file mode 100644
index 0000000..8ad9f76
--- /dev/null
+++ b/os161-1.10/testbin/dirseek/dirseek.c
@@ -0,0 +1,526 @@
+/*
+ * dirseek.c
+ *
+ *      Tests seeking on directories (both legally and illegally).
+ *
+ *      Makes a test subdirectory in the current directory.
+ *
+ *      Intended for the file system assignment. Should run (on SFS)
+ *      when that assignment is complete.
+ *
+ *      Note: checks a few things that are not _strictly_ guaranteed
+ *      by the official semantics of getdirentry() but that are more
+ *      or less necessary in a sane implementation, like that the
+ *      current seek position returned after seeking is the same
+ *      position that was requested. If you believe your
+ *      implementation is legal and the the test is rejecting it
+ *      gratuitously, please contact the course staff.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <err.h>
+
+#define TESTDIR "seektestdir"
+
+static struct {
+	const char *name;
+	int make_it;
+	off_t pos;
+} testfiles[] = {
+	{ ".", 		0, -1 },
+	{ "..",		0, -1 },
+	{ "ridcully",	1, -1 },
+	{ "weatherwax",	1, -1 },
+	{ "ogg",	1, -1 },
+	{ "vorbis",	1, -1 },
+	{ "verence",	1, -1 },
+	{ "magrat",	1, -1 },
+	{ "agnes",	1, -1 },
+	{ "rincewind",	1, -1 },
+	{ "angua",	1, -1 },
+	{ "cherry",	1, -1 },
+	{ "dorfl",	1, -1 },
+	{ "nobby",	1, -1 },
+	{ "carrot",	1, -1 },
+	{ "vimes",	1, -1 },
+	{ "detritus",	1, -1 },
+	{ "twoflower",	1, -1 },
+	{ "teatime",	1, -1 },
+	{ "qu",		1, -1 },
+	{ NULL, 0, 0 }
+};
+
+/************************************************************/
+/* Test code                                                */
+/************************************************************/
+
+static int dirfd;
+
+static
+int
+findentry(const char *name)
+{
+	int i;
+
+	for (i=0; testfiles[i].name; i++) {
+		if (!strcmp(testfiles[i].name, name)) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+static
+void
+openit(void)
+{
+	dirfd = open(".", O_RDONLY);
+	if (dirfd < 0) {
+		err(1, ".: open");
+	}
+}
+
+static
+void
+closeit(void)
+{
+	if (close(dirfd)<0) {
+		err(1, ".: close");
+	}
+	dirfd = -1;
+}
+
+static
+void
+readit(void)
+{
+	char buf[4096];
+	off_t pos;
+	int len;
+	int n, i, ix;
+
+	for (i=0; testfiles[i].name; i++) {
+		testfiles[i].pos = -1;
+	}
+
+	pos = lseek(dirfd, 0, SEEK_CUR);
+	if (pos < 0) {
+		errx(1, ".: lseek(0, SEEK_CUR)");
+	}
+	n = 0;
+
+	while ((len = getdirentry(dirfd, buf, sizeof(buf)-1)) > 0) {
+
+		if ((unsigned)len >= sizeof(buf)-1) {
+			errx(1, ".: entry %d: getdirentry returned "
+			     "invalid length %d", n, len);
+		}
+		buf[len] = 0;
+		ix = findentry(buf);
+		if (ix < 0) {
+			errx(1, ".: entry %d: getdirentry returned "
+			     "unexpected name %s", n, buf);
+		}
+
+		if (testfiles[ix].pos >= 0) {
+			errx(1, ".: entry %d: getdirentry returned "
+			     "%s a second time", n, buf);
+		}
+
+		testfiles[ix].pos = pos;
+		
+		pos = lseek(dirfd, 0, SEEK_CUR);
+		if (pos < 0) {
+			errx(1, ".: lseek(0, SEEK_CUR)");
+		}
+		n++;
+	}
+	if (len<0) {
+		err(1, ".: entry %d: getdirentry", n);
+	}
+
+	for (i=0; testfiles[i].name; i++) {
+		if (testfiles[i].pos < 0) {
+			errx(1, ".: getdirentry failed to return %s",
+			     testfiles[i].name);
+		}
+	}
+	if (i!=n) {
+		/*
+		 * If all of the other checks have passed, this should not
+		 * be able to fail. But... just in case I forgot something
+		 * or there's a bug...
+		 */
+
+		errx(1, ".: getdirentry returned %d names, not %d (huh...?)",
+		     n, i);
+	}
+}
+	
+static
+void
+firstread(void)
+{
+	off_t pos;
+
+	pos = lseek(dirfd, 0, SEEK_CUR);
+	if (pos < 0) {
+		errx(1, ".: lseek(0, SEEK_CUR)");
+	}
+	if (pos != 0) {
+		errx(1, ".: File position after open not 0");
+	}
+
+	printf("Scanning directory...\n");
+
+	readit();
+}
+
+static
+void
+doreadat0(void)
+{
+	off_t pos;
+
+	printf("Rewinding directory and reading it again...\n");
+
+	pos = lseek(dirfd, 0, SEEK_SET);
+	if (pos < 0) {
+		err(1, ".: lseek(0, SEEK_SET)");
+	}
+	if (pos != 0) {
+		errx(1, ".: lseek(0, SEEK_SET) returned %ld", (long) pos);
+	}
+
+	readit();
+}
+
+static
+void
+readone(const char *shouldbe)
+{
+	char buf[4096];
+	int len;
+
+	len = getdirentry(dirfd, buf, sizeof(buf)-1);
+	if (len < 0) {
+		err(1, ".: getdirentry");
+	}
+	if ((unsigned)len >= sizeof(buf)-1) {
+		errx(1, ".: getdirentry returned invalid length %d", len);
+	}
+	buf[len] = 0;
+
+	if (strcmp(buf, shouldbe)) {
+		errx(1, ".: getdirentry returned %s (expected %s)",
+		     buf, shouldbe);
+	}
+}
+
+static
+void
+doreadone(int which)
+{
+	off_t pos;
+	pos = lseek(dirfd, testfiles[which].pos, SEEK_SET);
+	if (pos<0) {
+		err(1, ".: lseek(%ld, SEEK_SET)", (long) testfiles[which].pos);
+	}
+	if (pos != testfiles[which].pos) {
+		errx(1, ".: lseek(%ld, SEEK_SET) returned %ld",
+		     (long) testfiles[which].pos, (long) pos);
+	}
+
+	readone(testfiles[which].name);
+}
+
+static
+void
+readallonebyone(void)
+{
+	int i;
+
+	printf("Trying to read each entry again...\n");
+	for (i=0; testfiles[i].name; i++) {
+		doreadone(i);
+	}
+}
+
+static
+void
+readallrandomly(void)
+{
+	int n, i, x;
+
+	printf("Trying to read a bunch of entries randomly...\n");
+
+	for (i=0; testfiles[i].name; i++);
+	n = i;
+
+	srandom(39584);
+	for (i=0; i<512; i++) {
+		x = (int)(random()%n);
+		doreadone(x);
+	}
+}
+
+static
+void
+readateof(void)
+{
+	char buf[4096];
+	int len;
+
+	len = getdirentry(dirfd, buf, sizeof(buf)-1);
+	if (len < 0) {
+		err(1, ".: at EOF: getdirentry");
+	}
+	if (len==0) {
+		return;
+	}
+	if ((unsigned)len >= sizeof(buf)-1) {
+		errx(1, ".: at EOF: getdirentry returned "
+		     "invalid length %d", len);
+	}
+	buf[len] = 0;
+	errx(1, ".: at EOF: got unexpected name %s", buf);
+}
+
+static
+void
+doreadateof(void)
+{
+	off_t pos;
+	int i;
+
+	printf("Trying to read after going to EOF...\n");
+
+	pos = lseek(dirfd, 0, SEEK_END);
+	if (pos<0) {
+		err(1, ".: lseek(0, SEEK_END)");
+	}
+
+	for (i=0; testfiles[i].name; i++) {
+		if (pos <= testfiles[i].pos) {
+			errx(1, ".: EOF position %ld below position %ld of %s",
+			     pos, testfiles[i].pos, testfiles[i].name);
+		}
+	}
+
+	readateof();
+}
+
+static
+void
+inval_read(void)
+{
+	char buf[4096];
+	int len;
+
+	len = getdirentry(dirfd, buf, sizeof(buf)-1);
+
+	/* Any result is ok, as long as the system doesn't crash */
+	(void)len;
+}
+
+static
+void
+dobadreads(void)
+{
+	off_t pos, pos2, eof;
+	int valid, i, k=0;
+
+	printf("Trying some possibly invalid reads...\n");
+
+	eof = lseek(dirfd, 0, SEEK_END);
+	if (eof < 0) {
+		err(1, ".: lseek(0, SEEK_END)");
+	}
+
+	for (pos=0; pos < eof; pos++) {
+		valid = 0;
+		for (i=0; testfiles[i].name; i++) {
+			if (pos==testfiles[i].pos) {
+				valid = 1;
+			}
+		}
+		if (valid) {
+			/* don't try offsets that are known to be valid */
+			continue;
+		}
+
+		pos2 = lseek(dirfd, pos, SEEK_SET);
+		if (pos2 < 0) {
+			/* this is ok */
+		}
+		else {
+			inval_read();
+			k++;
+		}
+	}
+
+	if (k>0) {
+		printf("Survived %d invalid reads...\n", k);
+	}
+	else {
+		printf("Couldn't find any invalid offsets to try...\n");
+	}
+
+	printf("Trying to read beyond EOF...\n");
+	pos2 = lseek(dirfd, eof + 1000, SEEK_SET);
+	if (pos2 < 0) {
+		/* this is ok */
+	}
+	else {
+		inval_read();
+	}
+}
+
+static
+void
+dotest(void)
+{
+	printf("Opening directory...\n");
+	openit();
+
+	printf("Running tests...\n");
+
+	/* read the whole directory */
+	firstread();
+
+	/* make sure eof behaves right */
+	readateof();
+
+	/* read all the filenames again by seeking */
+	readallonebyone();
+
+	/* try reading at eof */
+	doreadateof();
+
+	/* read a bunch of the filenames over and over again */
+	readallrandomly();
+
+	/* rewind and read the whole thing again, to make sure that works */
+	doreadat0();
+
+	/* do invalid reads */
+	dobadreads();
+
+	/* rewind again to make sure the invalid attempts didn't break it */
+	doreadat0();
+
+	printf("Closing directory...\n");
+	closeit();
+}
+
+/************************************************************/
+/* Setup code                                               */
+/************************************************************/
+
+static
+void
+mkfile(const char *name)
+{
+	int fd, i, r;
+	static const char message[] = "The turtle moves!\n";
+	char buf[32*sizeof(message)+1];
+
+	buf[0]=0;
+	for (i=0; i<32; i++) {
+		strcat(buf, message);
+	}
+
+	/* Use O_EXCL, because we know the file shouldn't already be there */
+	fd = open(name, O_WRONLY|O_CREAT|O_EXCL, 0664);
+	if (fd<0) {
+		err(1, "%s: create", name);
+	}
+
+	r = write(fd, buf, strlen(buf));
+	if (r<0) {
+		err(1, "%s: write", name);
+	}
+	if ((unsigned)r != strlen(buf)) {
+		errx(1, "%s: short write (%d bytes)", name, r);
+	}
+
+	if (close(fd)<0) {
+		err(1, "%s: close", name);
+	}
+}
+
+static
+void
+setup(void)
+{
+	int i;
+
+	printf("Making directory %s...\n", TESTDIR);
+
+	/* Create a directory */
+	if (mkdir(TESTDIR, 0775)<0) {
+		err(1, "%s: mkdir", TESTDIR);
+	}
+
+	/* Switch to it */
+	if (chdir(TESTDIR)<0) {
+		err(1, "%s: chdir", TESTDIR);
+	}
+
+	printf("Making some files...\n");
+
+	/* Populate it */
+	for (i=0; testfiles[i].name; i++) {
+		if (testfiles[i].make_it) {
+			mkfile(testfiles[i].name);
+		}
+		testfiles[i].pos = -1;
+	}
+}
+
+static
+void
+cleanup(void)
+{
+	int i;
+
+	printf("Cleaning up...\n");
+
+	/* Remove the files */
+	for (i=0; testfiles[i].name; i++) {
+		if (testfiles[i].make_it) {
+			if (remove(testfiles[i].name)<0) {
+				err(1, "%s: remove", testfiles[i].name);
+			}
+		}
+	}
+
+	/* Leave the dir */
+	if (chdir("..")<0) {
+		err(1, "..: chdir");
+	}
+
+	/* Remove the dir */
+	if (rmdir(TESTDIR)<0) {
+		err(1, "%s: rmdir", TESTDIR);
+	}
+}
+
+
+int
+main()
+{
+	setup();
+
+	/* Do the whole thing twice */
+	dotest();
+	dotest();
+
+	cleanup();
+	return 0;
+}
diff --git a/os161-1.10/testbin/dirtest/.cvsignore b/os161-1.10/testbin/dirtest/.cvsignore
new file mode 100644
index 0000000..b0ab54b
--- /dev/null
+++ b/os161-1.10/testbin/dirtest/.cvsignore
@@ -0,0 +1 @@
+dirtest
diff --git a/os161-1.10/testbin/dirtest/Makefile b/os161-1.10/testbin/dirtest/Makefile
new file mode 100644
index 0000000..8c7d088
--- /dev/null
+++ b/os161-1.10/testbin/dirtest/Makefile
@@ -0,0 +1,9 @@
+# Makefile for dirtest
+
+SRCS=dirtest.c
+PROG=dirtest
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/dirtest/depend.mk b/os161-1.10/testbin/dirtest/depend.mk
new file mode 100644
index 0000000..345fa42
--- /dev/null
+++ b/os161-1.10/testbin/dirtest/depend.mk
@@ -0,0 +1,15 @@
+
+dirtest.o: \
+ dirtest.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/dirtest/dirtest.c b/os161-1.10/testbin/dirtest/dirtest.c
new file mode 100644
index 0000000..e018738
--- /dev/null
+++ b/os161-1.10/testbin/dirtest/dirtest.c
@@ -0,0 +1,57 @@
+/*
+ * dirtest.c
+ *
+ * 	Tests your hierarchical directory implementation by creating
+ * 	and deleting directories.
+ *
+ *      Works in the current directory.
+ *
+ *      Intended for the file system assignment. Should run (on SFS)
+ *      when that assignment is complete.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <err.h>
+
+#define MAXLEVELS       5
+
+int
+main(void)
+{
+	int i;
+	const char *onename = "testdir";
+	char dirname[512];
+
+	strcpy(dirname, onename);
+
+	for (i=0; i<MAXLEVELS; i++) {
+		printf("Creating directory: %s\n", dirname);
+
+		if (mkdir(dirname, 0755)) {
+			err(1, "%s: mkdir", dirname);
+		}
+		
+		strcat(dirname, "/");
+		strcat(dirname, onename);
+	}
+
+	printf("Passed directory creation test.\n");
+
+	for (i=0; i<MAXLEVELS; i++) {
+		dirname[strlen(dirname) - strlen(onename) - 1] = 0;
+
+		printf("Removing directory: %s\n", dirname);
+
+		if (rmdir(dirname)) {
+			err(1, "%s: rmdir", dirname);
+		}
+	}
+	printf("Passed directory removal test.\n");
+
+	return 0;
+}
+
diff --git a/os161-1.10/testbin/f_test/.cvsignore b/os161-1.10/testbin/f_test/.cvsignore
new file mode 100644
index 0000000..2e7e786
--- /dev/null
+++ b/os161-1.10/testbin/f_test/.cvsignore
@@ -0,0 +1 @@
+f_test
diff --git a/os161-1.10/testbin/f_test/Makefile b/os161-1.10/testbin/f_test/Makefile
new file mode 100644
index 0000000..44593a0
--- /dev/null
+++ b/os161-1.10/testbin/f_test/Makefile
@@ -0,0 +1,9 @@
+# Makefile for f_test
+
+SRCS=f_test.c f_read.c f_write.c
+PROG=f_test
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/f_test/depend.mk b/os161-1.10/testbin/f_test/depend.mk
new file mode 100644
index 0000000..c8f7278
--- /dev/null
+++ b/os161-1.10/testbin/f_test/depend.mk
@@ -0,0 +1,40 @@
+
+f_test.o: \
+ f_test.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ f_hdr.h
+f_read.o: \
+ f_read.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ f_hdr.h
+f_write.o: \
+ f_write.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/err.h \
+ f_hdr.h
diff --git a/os161-1.10/testbin/f_test/f_hdr.h b/os161-1.10/testbin/f_test/f_hdr.h
new file mode 100644
index 0000000..f459f75
--- /dev/null
+++ b/os161-1.10/testbin/f_test/f_hdr.h
@@ -0,0 +1,2 @@
+void subproc_read(void);
+void subproc_write(void);
diff --git a/os161-1.10/testbin/f_test/f_read.c b/os161-1.10/testbin/f_test/f_read.c
new file mode 100644
index 0000000..4315321
--- /dev/null
+++ b/os161-1.10/testbin/f_test/f_read.c
@@ -0,0 +1,77 @@
+/*
+ * f_read.c
+ *
+ *	This used to be a separate binary, because it came from Nachos
+ *	and nachos didn't support fork(). However, in OS/161 there's
+ *	no reason to make it a separate binary; doing so just makes
+ *	the test flaky.
+ *
+ *
+ * 	it will start reading from a given file, concurrently
+ * 	with other instances of f_read and f_write.
+ *
+ */
+
+#define SectorSize   512
+
+#define TMULT        50
+#define FSIZE        ((SectorSize + 1) * TMULT)
+
+#define FNAME        "f-testfile"
+#define READCHAR     'r'
+#define WRITECHAR    'w'
+
+#include <stdio.h>
+#include <unistd.h>
+#include <err.h>
+#include "f_hdr.h"
+
+static char buffer[SectorSize + 1];
+
+static
+void
+check_buffer(void)
+{
+	int i;
+	char ch = buffer[0];
+
+	for (i = 1; i < SectorSize + 1; i++) {
+		if (buffer[i] != ch) {
+			errx(1, "Read error: %s", buffer);
+		}
+	}
+	
+	putchar(ch);
+}
+
+void
+subproc_read(void)
+{
+	int fd;
+	int i, res;
+      
+	printf("File Reader starting ...\n\n");
+
+	fd = open(FNAME, O_RDONLY);
+	if (fd < 0) {
+		err(1, "%s: open", FNAME);
+	}
+
+	for (i=0; i<TMULT; i++) {
+		res = read(fd, buffer, SectorSize + 1);
+		if (res < 0) {
+			err(1, "%s: read", FNAME);
+		}
+
+		// yield();
+
+		if (res != SectorSize + 1) {
+			errx(1, "%s: read: short count", FNAME);
+		}
+		check_buffer();
+	}
+
+	close(fd);
+
+	printf("File Read exited successfully!\n");
+}
diff --git a/os161-1.10/testbin/f_test/f_test.c b/os161-1.10/testbin/f_test/f_test.c
new file mode 100644
index 0000000..7e60f59
--- /dev/null
+++ b/os161-1.10/testbin/f_test/f_test.c
@@ -0,0 +1,313 @@
+/*
+ * Razvan Surdulescu
+ * abhi shelat
+ * April 28 1997
+ * 
+ * Test suite for Nachos HW4--The Filesystem
+ *
+ * Modified by dholland 1/31/2001 for OS/161
+ *
+ * This should run successfully (on SFS) when the file system
+ * assignment is complete.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <err.h>
+#include "f_hdr.h"
+
+#define SECTOR_SIZE  512
+
+
+#define BUFFER_SIZE  (2 * SECTOR_SIZE + 1)
+#define BIGFILE_SIZE (270 * BUFFER_SIZE)
+#define BIGFILE_NAME "large-f"
+
+#define LETTER(x) ('a' + (x % 31))
+
+char fbuffer[BUFFER_SIZE];
+char ibuffer[32];
+
+
+#define DIR_DEPTH      8
+#define DIR_NAME       "/t"
+#define DIRFILE_NAME   "a"
+
+
+#define FNAME        "f-testfile"
+#define TMULT        50
+#define FSIZE        ((SECTOR_SIZE + 1) * TMULT)
+
+#define READCHAR     'r'
+#define WRITECHAR    'w'
+
+char cbuffer[SECTOR_SIZE + 1];
+
+
+/* ===================================================
+
+ */
+
+static
+pid_t
+forkoff(void (*func)(void))
+{
+	pid_t pid = fork();
+	switch (pid) {
+	    case -1:
+		warn("fork");
+		return -1;
+	    case 0: 
+		func();
+		_exit(0);
+	    default: break;
+	}
+	return pid;
+}
+
+static
+void
+dowait(int pid)
+{
+	int status;
+
+	if (waitpid(pid, &status, 0)<0) {
+		warn("waitpid for %d", pid);
+	}
+	else if (status != 0) {
+		warn("pid %d: exit %d", pid, status);
+	}
+}
+
+/* ===================================================
+	
+ */
+
+void
+big_file(int size)
+{
+	int i, j, fileid;
+	
+	printf("[BIGFILE] test starting :\n");
+	printf("\tCreating a file of size: %d\n", size);
+	
+	fileid = open(BIGFILE_NAME, O_WRONLY|O_CREAT|O_TRUNC, 0664);
+	if (fileid < 0) {
+		err(1, "[BIGFILE]: %s: open for write", BIGFILE_NAME);
+	}	
+	
+	for(i = 0; i < BUFFER_SIZE; i++) {
+		fbuffer[i] = LETTER(i);
+	}
+
+	printf("\tWriting to file.\n");
+	for (i = 0; i < size; i += BUFFER_SIZE) {
+		write(fileid, fbuffer, BUFFER_SIZE);
+
+		if (!(i % (10 * BUFFER_SIZE))) {
+			printf("\rBW : %d", i);
+		}
+	}
+
+	printf("\n\tReading from file.\n");
+	close(fileid);
+
+	fileid = open(BIGFILE_NAME, O_RDONLY);
+	if (fileid < 0) {
+		err(1, "[BIGFILE]: %s: open for read", BIGFILE_NAME);
+	}
+	
+	for (i = 0; i < size; i += BUFFER_SIZE) {
+		j = read(fileid, fbuffer, BUFFER_SIZE);
+		if (j<0) {
+			err(1, "[BIGFILE]: read");
+		}
+		if (j != BUFFER_SIZE) {
+			errx(1, "[BIGFILE]: read: only %d bytes", j);
+		}
+	}
+
+	if (!(i % (10 * BUFFER_SIZE))) {
+		printf("\rBR : %d", i);
+	}
+
+	/* Check to see that the data is consistent : */
+	for (j = 0; j < BUFFER_SIZE; j++) {
+		if (fbuffer[j] != LETTER(j)) {
+			errx(1, "[BIGFILE] : Failed read check : "
+			     "inconsistent data read: %d", i+j);
+		}
+	}
+
+
+	close(fileid);
+	if (remove(BIGFILE_NAME)) {
+		err(1, "[BIGFILE]: %s: remove", BIGFILE_NAME);
+	}
+
+	printf("\n[BIGFILE] : Success!\n");
+}
+
+/* ===================================================
+
+ */
+
+void
+concur(void)
+{
+	int i, fd;
+	int r1, r2, w1;
+
+	printf("Spawning 2 readers, 1 writer.\n");
+
+
+	fd = open(FNAME, O_WRONLY|O_CREAT|O_TRUNC, 0664);
+	if (fd < 0) {
+		err(1, "[CONCUR]: %s: open", FNAME);
+	}
+
+	printf("Initializing test file: ");
+
+	for (i = 0; i < SECTOR_SIZE + 1; i++) {
+		cbuffer[i] = READCHAR;
+	}
+
+	for (i = 0; i < TMULT; i++) {
+		write(fd, cbuffer, SECTOR_SIZE + 1);
+	}
+
+
+	close(fd);
+
+	printf("Done initializing. Starting processes...\n");
+
+	r1 = forkoff(subproc_read);
+	w1 = forkoff(subproc_write);
+	r2 = forkoff(subproc_read);
+
+	printf("Waiting for processes.\n");
+
+	dowait(r1);
+	dowait(r2);
+	dowait(w1);
+
+	if (remove(FNAME)) {
+		err(1, "[CONCUR]: %s: remove", FNAME);
+	}
+	 
+	printf("[CONCUR] Done!\n");
+}
+
+/* ===================================================
+	
+ */
+
+void
+dir_test(int depth)
+{
+	int i, fd;
+	char tmp[] = DIR_NAME;
+	char fmp[] = DIRFILE_NAME;
+	char dirname[64];
+
+	strcpy(dirname, ".");
+
+	for (i = 0; i < depth; i++) {
+		strcat(dirname, tmp);
+		
+		printf("\tCreating dir : %s\n", dirname);
+
+		if (mkdir(dirname, 0775) < 0) {
+			err(1, "[DIRTEST]: %s: mkdir", dirname);
+		}
+
+		strcat(dirname, fmp);
+		printf("\tCreating file: %s\n", dirname);
+
+		fd = open(dirname, O_WRONLY|O_CREAT|O_TRUNC, 0664);
+		if (fd<0) {
+			err(1, "[DIRTEST]: %s: open", dirname);
+		}
+
+		dirname[strlen(dirname) - strlen(fmp)] = '\0';
+	}
+
+	printf("[DIRTEST] : Passed directory creation test.\n");
+
+	for (i = 0; i < depth; i++) {
+		strcat(dirname, fmp);
+
+		printf("\tDeleting file: %s\n", dirname);
+		  
+		if (remove(dirname)) {
+			 err(1, "[DIRTEST]: %s: remove", dirname);
+		}
+
+		dirname[strlen(dirname) - strlen(fmp)] = '\0';
+		printf("\tRemoving dir : %s\n", dirname);
+
+		if (rmdir(dirname)) {
+			err(1, "[DIRTEST]: %s: rmdir", dirname);
+		}
+
+		dirname[strlen(dirname) - strlen(tmp)] = '\0';
+	}
+
+	printf("[DIRTEST] : Passed directory removal test.\n");
+	printf("[DIRTEST] : Success!\n");
+}
+
+/* ===================================================
+
+ */
+
+#define   RUNBIGFILE  0x1
+#define   RUNDIRTEST  0x2
+#define   RUNCONCUR   0x4
+#define   RUNTHEMALL  (RUNBIGFILE | RUNDIRTEST | RUNCONCUR) 
+
+int
+main(int argc, char * argv[])
+{
+	int tv = 0;
+
+	if (argc > 1) {
+		if (*argv[1]=='1') {
+			tv = RUNBIGFILE;
+		}
+		else if (*argv[1]=='2') {
+			tv = RUNDIRTEST;
+		}
+		else if (*argv[1]=='3') {
+			tv = RUNCONCUR;
+		}
+	} 
+	else {
+		tv = RUNTHEMALL;
+	}
+	 
+	if (tv & RUNBIGFILE) {
+		printf("[BIGFILE] : Run #1\n");
+		big_file(BIGFILE_SIZE); 
+		printf("[BIGFILE] : Run #2\n");
+		big_file(BIGFILE_SIZE);
+	}
+	 
+	if (tv & RUNDIRTEST) {
+		printf("[DIRTEST] : Run #1\n");
+		dir_test(DIR_DEPTH);
+		printf("[DIRTEST] : Run #2\n");
+		dir_test(DIR_DEPTH);
+	}
+	 
+	if (tv & RUNCONCUR) {
+		printf("[CONCUR]\n");
+		concur();
+	}
+	return 0;
+}
+
+
diff --git a/os161-1.10/testbin/f_test/f_write.c b/os161-1.10/testbin/f_test/f_write.c
new file mode 100644
index 0000000..0fa3661
--- /dev/null
+++ b/os161-1.10/testbin/f_test/f_write.c
@@ -0,0 +1,56 @@
+/*
+ * f_write.c
+ *
+ *	This used to be a separate binary, because it came from Nachos
+ *	and nachos didn't support fork(). However, in OS/161 there's
+ *	no reason to make it a separate binary; doing so just makes
+ *	the test flaky.
+ *
+ *
+ * 	It will start writing into a file, concurrently with
+ * 	one or more instances of f_read.
+ *
+ */
+
+#define SectorSize   512
+
+#define TMULT        50
+#define FSIZE        ((SectorSize + 1) * TMULT)
+
+#define FNAME        "f-testfile"
+#define READCHAR     'r'
+#define WRITECHAR    'w'
+
+#include <unistd.h>
+#include <stdio.h>
+#include <err.h>
+#include "f_hdr.h"
+
+static char buffer[SectorSize + 1];
+
+void
+subproc_write(void)
+{
+	int fd;
+	int i;
+
+	for (i=0; i < SectorSize + 1; i++) {
+		buffer[i] = WRITECHAR;
+	}
+  
+	printf("File Writer starting ...\n");
+
+	fd = open(FNAME, O_WRONLY);
+	if (fd < 0) {
+		err(1, "%s: open", FNAME);
+	}
+
+	for (i=0; i<TMULT; i++) {
+		// yield();
+		write(fd, buffer, SectorSize + 1);
+	}
+
+	close(fd);
+
+	printf("File Write exited successfully!\n");
+}
diff --git a/os161-1.10/testbin/farm/.cvsignore b/os161-1.10/testbin/farm/.cvsignore
new file mode 100644
index 0000000..19cfff4
--- /dev/null
+++ b/os161-1.10/testbin/farm/.cvsignore
@@ -0,0 +1 @@
+farm
diff --git a/os161-1.10/testbin/farm/Makefile b/os161-1.10/testbin/farm/Makefile
new file mode 100644
index 0000000..f9b70f1
--- /dev/null
+++ b/os161-1.10/testbin/farm/Makefile
@@ -0,0 +1,9 @@
+# Makefile for farm
+
+SRCS=farm.c
+PROG=farm
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/farm/depend.mk b/os161-1.10/testbin/farm/depend.mk
new file mode 100644
index 0000000..1852367
--- /dev/null
+++ b/os161-1.10/testbin/farm/depend.mk
@@ -0,0 +1,11 @@
+
+farm.o: \
+ farm.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/farm/farm.c b/os161-1.10/testbin/farm/farm.c
new file mode 100644
index 0000000..1e668ca
--- /dev/null
+++ b/os161-1.10/testbin/farm/farm.c
@@ -0,0 +1,79 @@
+/*
+ * farm.c
+ *
+ * 	Run a bunch of cpu pigs and one cat.
+ *      The file it cats is "catfile". This should be created in advance.
+ *
+ * This test should itself run correctly when the basic system calls
+ * are complete. It may be helpful for scheduler performance analysis.
+ */
+
+#include <unistd.h>
+#include <err.h>
+
+static char *hargv[2] = { (char *)"hog", NULL };
+static char *cargv[3] = { (char *)"cat", (char *)"catfile", NULL };
+
+#define MAXPROCS  6
+static int pids[MAXPROCS], npids;
+
+static
+void
+spawnv(const char *prog, char **argv)
+{
+	int pid = fork();
+	switch (pid) {
+	    case -1:
+		err(1, "fork");
+	    case 0:
+		/* child */
+		execv(prog, argv);
+		err(1, "%s", prog);
+	    default:
+		/* parent */
+		pids[npids++] = pid;
+		break;
+	}
+}
+
+static
+void
+waitall(void)
+{
+	int i, status;
+	for (i=0; i<npids; i++) {
+		if (waitpid(pids[i], &status, 0)<0) {
+			warn("waitpid for %d", pids[i]);
+		}
+		else if (status != 0) {
+			warnx("pid %d: exit %d", pids[i], status);
+		}
+	}
+}
+
+static
+void
+hog(void)
+{
+	spawnv("/testbin/hog", hargv);
+}
+
+static
+void
+cat(void)
+{
+	spawnv("/bin/cat", cargv);
+}
+
+int
+main()
+{
+	hog();
+	hog();
+	hog();
+	cat();
+
+	waitall();
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/faulter/.cvsignore b/os161-1.10/testbin/faulter/.cvsignore
new file mode 100644
index 0000000..94cdc70
--- /dev/null
+++ b/os161-1.10/testbin/faulter/.cvsignore
@@ -0,0 +1 @@
+faulter
diff --git a/os161-1.10/testbin/faulter/Makefile b/os161-1.10/testbin/faulter/Makefile
new file mode 100644
index 0000000..054a2cb
--- /dev/null
+++ b/os161-1.10/testbin/faulter/Makefile
@@ -0,0 +1,9 @@
+# Makefile for faulter
+
+SRCS=faulter.c
+PROG=faulter
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/faulter/depend.mk b/os161-1.10/testbin/faulter/depend.mk
new file mode 100644
index 0000000..83d5abb
--- /dev/null
+++ b/os161-1.10/testbin/faulter/depend.mk
@@ -0,0 +1,8 @@
+
+faulter.o: \
+ faulter.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/faulter/faulter.c b/os161-1.10/testbin/faulter/faulter.c
new file mode 100644
index 0000000..c266253
--- /dev/null
+++ b/os161-1.10/testbin/faulter/faulter.c
@@ -0,0 +1,23 @@
+/*
+ * faulter.c
+ *
+ * 	Tries to access an illegal address.
+ *
+ * When the system calls assignment is complete, this should run and
+ * get killed without causing the kernel to panic.
+ */
+
+#include <stdio.h>
+
+#define REALLY_BIG_ADDRESS	0x40000000
+
+int
+main(void) 
+{
+	volatile int i;
+
+	printf("\nEntering the faulter program - I should die immediately\n");
+	i = *(int *)REALLY_BIG_ADDRESS;    
+	printf("I didn't get killed!  Program has a bug\n");
+	return 0;
+}
diff --git a/os161-1.10/testbin/filetest/.cvsignore b/os161-1.10/testbin/filetest/.cvsignore
new file mode 100644
index 0000000..c226a80
--- /dev/null
+++ b/os161-1.10/testbin/filetest/.cvsignore
@@ -0,0 +1 @@
+filetest
diff --git a/os161-1.10/testbin/filetest/Makefile b/os161-1.10/testbin/filetest/Makefile
new file mode 100644
index 0000000..80c78bd
--- /dev/null
+++ b/os161-1.10/testbin/filetest/Makefile
@@ -0,0 +1,9 @@
+# Makefile for filetest
+
+SRCS=filetest.c
+PROG=filetest
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/filetest/depend.mk b/os161-1.10/testbin/filetest/depend.mk
new file mode 100644
index 0000000..55c745c
--- /dev/null
+++ b/os161-1.10/testbin/filetest/depend.mk
@@ -0,0 +1,13 @@
+
+filetest.o: \
+ filetest.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/filetest/filetest.c b/os161-1.10/testbin/filetest/filetest.c
new file mode 100644
index 0000000..c45b50a
--- /dev/null
+++ b/os161-1.10/testbin/filetest/filetest.c
@@ -0,0 +1,71 @@
+/*
+ * filetest.c
+ *
+ * 	Tests the filesystem by opening, writing to and reading from a 
+ * 	user specified file.
+ *
+ * This should run (on SFS) even before the file system assignment is started.
+ * It should also continue to work once said assignment is complete.
+ * It will not run fully on emufs, because emufs does not support remove().
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <err.h>
+
+int
+main(int argc, char *argv[])
+{
+	static char writebuf[40] = "Twiddle dee dee, Twiddle dum dum.......\n";
+	static char readbuf[41];
+
+	int fd, rv;
+
+	if (argc!=2) {
+		errx(1, "Usage: filetest <filename>");
+	}
+
+	fd = open(argv[1], O_WRONLY|O_CREAT|O_TRUNC, 0664);
+	if (fd<0) {
+		err(1, "%s: open for write", argv[1]);
+	}
+
+
+	rv = write(fd, writebuf, 40);
+	if (rv<0) {
+		err(1, "%s: write", argv[1]);
+	}
+
+	rv = close(fd);
+	if (rv<0) {
+		err(1, "%s: close (1st time)", argv[1]);
+	}
+
+	fd = open(argv[1], O_RDONLY);
+	if (fd<0) { 
+		err(1, "%s: open for read", argv[1]);
+	}
+
+	rv = read(fd, readbuf, 40);
+	if (rv<0) {
+		err(1, "%s: read", argv[1]);
+	}
+	rv = close(fd);
+	if (rv<0) {
+		err(1, "%s: close (2nd time)", argv[1]);
+	}
+	/* ensure null termination */
+	readbuf[40] = 0;
+
+	if (strcmp(readbuf, writebuf)) {
+		errx(1, "Buffer data mismatch!");
+	}
+
+	rv = remove(argv[1]);
+	if (rv<0) {
+		err(1, "%s: remove", argv[1]);
+	}
+	printf("Passed filetest.\n");
+	return 0;
+}
diff --git a/os161-1.10/testbin/forkbomb/.cvsignore b/os161-1.10/testbin/forkbomb/.cvsignore
new file mode 100644
index 0000000..ff61c6e
--- /dev/null
+++ b/os161-1.10/testbin/forkbomb/.cvsignore
@@ -0,0 +1 @@
+forkbomb
diff --git a/os161-1.10/testbin/forkbomb/Makefile b/os161-1.10/testbin/forkbomb/Makefile
new file mode 100644
index 0000000..28ed02d
--- /dev/null
+++ b/os161-1.10/testbin/forkbomb/Makefile
@@ -0,0 +1,9 @@
+# Makefile for forkbomb
+
+SRCS=forkbomb.c
+PROG=forkbomb
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/forkbomb/depend.mk b/os161-1.10/testbin/forkbomb/depend.mk
new file mode 100644
index 0000000..dbe3742
--- /dev/null
+++ b/os161-1.10/testbin/forkbomb/depend.mk
@@ -0,0 +1,11 @@
+
+forkbomb.o: \
+ forkbomb.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/forkbomb/forkbomb.c b/os161-1.10/testbin/forkbomb/forkbomb.c
new file mode 100644
index 0000000..7e8dab8
--- /dev/null
+++ b/os161-1.10/testbin/forkbomb/forkbomb.c
@@ -0,0 +1,47 @@
+/*
+ * forkbomb - apply malthus to an operating system ;-)
+ *
+ * DO NOT RUN THIS ON A REAL SYSTEM - IT WILL GRIND TO A HALT AND
+ * PEOPLE WILL COME AFTER YOU WIELDING BASEBALL BATS OR THE AD
+ * BOARD(*). WE WARNED YOU.
+ *
+ * We don't expect your system to withstand this without grinding to
+ * a halt, but once your basic system calls are complete it shouldn't
+ * crash. Likewise for after your virtual memory system is complete.
+ *
+ * (...at least in an ideal world. However, it can be difficult to
+ * handle all the loose ends involved. Heroic measures are not
+ * expected. If in doubt, talk to the course staff.)
+ *
+ *
+ * (*) The Administrative Board of Harvard College handles formal
+ * disciplinary action.
+ */
+
+#include <unistd.h>
+#include <err.h>
+
+static volatile int pid;
+
+int
+main()
+{
+	int i;
+
+	while (1) {
+		fork();
+
+		pid = getpid();
+
+		/* Make sure each fork has its own address space. */
+		for (i=0; i<300; i++) {
+			volatile int seenpid;
+			seenpid = pid;
+			if (seenpid != getpid()) {
+				errx(1, "pid mismatch (%d, should be %d) "
+				     "- your vm is broken!", 
+				     seenpid, getpid());
+			}
+		}
+	}
+}
diff --git a/os161-1.10/testbin/forktest/.cvsignore b/os161-1.10/testbin/forktest/.cvsignore
new file mode 100644
index 0000000..95a1730
--- /dev/null
+++ b/os161-1.10/testbin/forktest/.cvsignore
@@ -0,0 +1 @@
+forktest
diff --git a/os161-1.10/testbin/forktest/Makefile b/os161-1.10/testbin/forktest/Makefile
new file mode 100644
index 0000000..d9becf3
--- /dev/null
+++ b/os161-1.10/testbin/forktest/Makefile
@@ -0,0 +1,9 @@
+# Makefile for forktest
+
+SRCS=forktest.c
+PROG=forktest
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/forktest/depend.mk b/os161-1.10/testbin/forktest/depend.mk
new file mode 100644
index 0000000..c41f367
--- /dev/null
+++ b/os161-1.10/testbin/forktest/depend.mk
@@ -0,0 +1,14 @@
+
+forktest.o: \
+ forktest.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/forktest/forktest.c b/os161-1.10/testbin/forktest/forktest.c
new file mode 100644
index 0000000..50624df
--- /dev/null
+++ b/os161-1.10/testbin/forktest/forktest.c
@@ -0,0 +1,155 @@
+/*
+ * forktest - test fork().
+ *
+ * This should work correctly when fork is implemented.
+ *
+ * It should also continue to work after subsequent assignments, most
+ * notably after implementing the virtual memory system.
+ */
+
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <err.h>
+
+/*
+ * This is used by all processes, to try to help make sure all
+ * processes have a distinct address space.
+ */
+static volatile int mypid;
+
+/*
+ * Helper function for fork that prints a warning on error.
+ */
+static
+int
+dofork(void)
+{
+	int pid;
+	pid = fork();
+	if (pid < 0) {
+		warn("fork");
+	}
+	return pid;
+}
+
+/*
+ * Check to make sure each process has its own address space. Write
+ * the pid into the data segment and read it back repeatedly, making
+ * sure it's correct every time.
+ */
+static
+void
+check(void)
+{
+	int i;
+
+	mypid = getpid();
+	
+	/* Make sure each fork has its own address space. */
+	for (i=0; i<800; i++) {
+		volatile int seenpid;
+		seenpid = mypid;
+		if (seenpid != getpid()) {
+			errx(1, "pid mismatch (%d, should be %d) "
+			     "- your vm is broken!", 
+			     seenpid, getpid());
+		}
+	}
+}
+
+/*
+ * Wait for a child process.
+ *
+ * This assumes dowait is called the same number of times as dofork
+ * and passed its results in reverse order. Any forks that fail send
+ * us -1 and are ignored. The first 0 we see indicates the fork that
+ * generated the current process; that means it's time to exit. Only
+ * the parent of all the processes returns from the chain of dowaits.
+ */
+static
+void
+dowait(int nowait, int pid)
+{
+	int x;
+
+	if (pid<0) {
+		/* fork in question failed; just return */
+		return;
+	}
+	if (pid==0) {
+		/* in the fork in question we were the child; exit */
+		exit(0);
+	}
+
+	if (!nowait) {
+		if (waitpid(pid, &x, 0)<0) {
+			warn("waitpid");
+		}
+		else if (x!=0) {
+			warnx("pid %d: exit %d", pid, x);
+		}
+	}
+}
+
+/*
+ * Actually run the test.
+ */
+static
+void
+test(int nowait)
+{
+	int pid0, pid1, pid2, pid3;
+
+	/*
+	 * Caution: This generates processes geometrically.
+	 *
+	 * It is unrolled to encourage gcc to registerize the pids,
+	 * to prevent wait/exit problems if fork corrupts memory.
+	 */
+
+	pid0 = dofork();
+	putchar('0');
+	check();
+	pid1 = dofork();
+	putchar('1');
+	check();
+	pid2 = dofork();
+	putchar('2');
+	check();
+	pid3 = dofork();
+	putchar('3');
+	check();
+
+	/*
+	 * These must be called in reverse order to avoid waiting
+	 * improperly.
+	 */
+	dowait(nowait, pid3);
+	dowait(nowait, pid2);
+	dowait(nowait, pid1);
+	dowait(nowait, pid0);
+
+	putchar('\n');
+}
+
+int
+main(int argc, char *argv[])
+{
+	int nowait=0;
+
+	if (argc==2 && !strcmp(argv[1], "-w")) {
+		nowait=1;
+	}
+	else if (argc!=1 && argc!=0) {
+		warnx("usage: forktest [-w]");
+		return 1;
+	}
+	warnx("Starting.");
+
+	test(nowait);
+
+	warnx("Complete.");
+	return 0;
+}
diff --git a/os161-1.10/testbin/guzzle/.cvsignore b/os161-1.10/testbin/guzzle/.cvsignore
new file mode 100644
index 0000000..9f72ee6
--- /dev/null
+++ b/os161-1.10/testbin/guzzle/.cvsignore
@@ -0,0 +1 @@
+guzzle
diff --git a/os161-1.10/testbin/guzzle/Makefile b/os161-1.10/testbin/guzzle/Makefile
new file mode 100644
index 0000000..af6b348
--- /dev/null
+++ b/os161-1.10/testbin/guzzle/Makefile
@@ -0,0 +1,9 @@
+# Makefile for guzzle
+
+SRCS=guzzle.c
+PROG=guzzle
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/guzzle/depend.mk b/os161-1.10/testbin/guzzle/depend.mk
new file mode 100644
index 0000000..37c69c9
--- /dev/null
+++ b/os161-1.10/testbin/guzzle/depend.mk
@@ -0,0 +1,11 @@
+
+guzzle.o: \
+ guzzle.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
diff --git a/os161-1.10/testbin/guzzle/guzzle.c b/os161-1.10/testbin/guzzle/guzzle.c
new file mode 100644
index 0000000..956ba65
--- /dev/null
+++ b/os161-1.10/testbin/guzzle/guzzle.c
@@ -0,0 +1,33 @@
+/*
+ * guzzle: Sit in the background in a long loop and display 
+ * characters on the console occasionally.
+ *
+ * This is intended to help with scheduler testing.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+
+#define  TOP     1<<25  /* real long loop */
+
+/* This program is a ridiculous, compute-bound program */
+/* We should schedule this at low priorities. */
+
+int
+main(int argc, char *argv[])
+{
+	volatile int i;
+	int ch = '+';
+
+	if (argc == 2) {
+		ch = argv[1][0];
+	}
+
+	for (i=0; i<TOP; i++) {	/* tight loop */
+				/* that eats up cycles */
+		if ( (i%10000) == 0) {
+			putchar(ch);
+		}
+	}
+	return 0;
+}
diff --git a/os161-1.10/testbin/hash/.cvsignore b/os161-1.10/testbin/hash/.cvsignore
new file mode 100644
index 0000000..2db4617
--- /dev/null
+++ b/os161-1.10/testbin/hash/.cvsignore
@@ -0,0 +1,3 @@
+hash
+host-hash
+*.ho
diff --git a/os161-1.10/testbin/hash/Makefile b/os161-1.10/testbin/hash/Makefile
new file mode 100644
index 0000000..1350486
--- /dev/null
+++ b/os161-1.10/testbin/hash/Makefile
@@ -0,0 +1,10 @@
+# Makefile for hash
+
+SRCS=hash.c
+PROG=hash
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+include ../../mk/hostprog.mk
+
diff --git a/os161-1.10/testbin/hash/depend.mk b/os161-1.10/testbin/hash/depend.mk
new file mode 100644
index 0000000..227e234
--- /dev/null
+++ b/os161-1.10/testbin/hash/depend.mk
@@ -0,0 +1,13 @@
+
+hash.o: \
+ hash.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/fcntl.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/hash/dependh.mk b/os161-1.10/testbin/hash/dependh.mk
new file mode 100644
index 0000000..d495ef2
--- /dev/null
+++ b/os161-1.10/testbin/hash/dependh.mk
@@ -0,0 +1,4 @@
+
+hash.ho: \
+ hash.c \
+ $(OSTREE)/hostinclude/hostcompat.h
diff --git a/os161-1.10/testbin/hash/hash.c b/os161-1.10/testbin/hash/hash.c
new file mode 100644
index 0000000..2ba39df
--- /dev/null
+++ b/os161-1.10/testbin/hash/hash.c
@@ -0,0 +1,54 @@
+/*
+ * hash: Takes a file and computes a "hash" value by adding together all
+ * the values in the file mod some largish prime.
+ *
+ * Once the basic system calls are complete, this should work on any
+ * file the system supports. However, it's probably of most use for
+ * testing your file system code.
+ *
+ * This should really be replaced with a real hash, like MD5 or SHA-1.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <err.h>
+
+#ifdef HOST
+#include "hostcompat.h"
+#endif
+
+#define HASHP 104729
+
+int
+main(int argc, char *argv[])
+{
+	int fd;
+	char readbuf[1];
+	int j = 0;
+
+#ifdef HOST
+	hostcompat_init(argc, argv);
+#endif
+
+	if (argc != 2) {
+		errx(1, "Usage: hash filename");
+	}
+	
+	fd = open(argv[1], O_RDONLY, 0664);
+	
+	if (fd<0) { 
+		err(1, "%s", argv[1]);
+	}
+
+	for (;;) {
+		if (read(fd, readbuf, 1) <= 0) break;
+		j = ((j*8) + (int) readbuf[0]) % HASHP;
+	}
+
+	close(fd);
+	
+	printf("Hash : %d\n", j);
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/hog/.cvsignore b/os161-1.10/testbin/hog/.cvsignore
new file mode 100644
index 0000000..615fb52
--- /dev/null
+++ b/os161-1.10/testbin/hog/.cvsignore
@@ -0,0 +1 @@
+hog
diff --git a/os161-1.10/testbin/hog/Makefile b/os161-1.10/testbin/hog/Makefile
new file mode 100644
index 0000000..4fcf987
--- /dev/null
+++ b/os161-1.10/testbin/hog/Makefile
@@ -0,0 +1,9 @@
+# Makefile for hog
+
+SRCS=hog.c
+PROG=hog
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/hog/depend.mk b/os161-1.10/testbin/hog/depend.mk
new file mode 100644
index 0000000..fb65ead
--- /dev/null
+++ b/os161-1.10/testbin/hog/depend.mk
@@ -0,0 +1,3 @@
+
+hog.o: \
+ hog.c
diff --git a/os161-1.10/testbin/hog/hog.c b/os161-1.10/testbin/hog/hog.c
new file mode 100644
index 0000000..a3ee980
--- /dev/null
+++ b/os161-1.10/testbin/hog/hog.c
@@ -0,0 +1,17 @@
+/*
+ * hog.c
+ * 	Spawned by several other user programs to test time-slicing.
+ *
+ * This does not differ from guzzle in any important way.
+ */
+
+int
+main(void)
+{
+	volatile int i;
+
+	for (i=0; i<50000; i++)
+		;
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/huge/.cvsignore b/os161-1.10/testbin/huge/.cvsignore
new file mode 100644
index 0000000..db01d07
--- /dev/null
+++ b/os161-1.10/testbin/huge/.cvsignore
@@ -0,0 +1 @@
+huge
diff --git a/os161-1.10/testbin/huge/Makefile b/os161-1.10/testbin/huge/Makefile
new file mode 100644
index 0000000..1f5e02a
--- /dev/null
+++ b/os161-1.10/testbin/huge/Makefile
@@ -0,0 +1,9 @@
+# Makefile for huge
+
+SRCS=huge.c
+PROG=huge
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/huge/depend.mk b/os161-1.10/testbin/huge/depend.mk
new file mode 100644
index 0000000..e67cda0
--- /dev/null
+++ b/os161-1.10/testbin/huge/depend.mk
@@ -0,0 +1,9 @@
+
+huge.o: \
+ huge.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h
diff --git a/os161-1.10/testbin/huge/huge.c b/os161-1.10/testbin/huge/huge.c
new file mode 100644
index 0000000..7f06842
--- /dev/null
+++ b/os161-1.10/testbin/huge/huge.c
@@ -0,0 +1,55 @@
+/* 
+ * huge.c
+ *
+ * 	Tests the VM system by accessing a large array (sparse) that
+ *	cannot fit into memory.
+ *
+ * When the VM system assignment is done, your system should be able
+ * to run this successfully.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define PageSize	4096
+#define NumPages	512
+
+int sparse[NumPages][PageSize];	/* use only the first element in the row */
+
+int
+main()
+{
+	int i,j;
+
+	printf("Entering the huge program - I will stress test your VM\n");
+
+	/* move number in so that sparse[i][0]=i */
+	for (i=0; i<NumPages; i++) {
+		sparse[i][0]=i;
+	}
+	
+	printf("stage [1] done\n");
+	
+	/* increment each location 5 times */
+	for (j=0; j<5; j++) {
+		for (i=0; i<NumPages; i++) {
+			sparse[i][0]++;
+		}
+		printf("stage [2.%d] done\n", j);
+	}
+	
+	printf("stage [2] done\n");
+	
+	/* check if the numbers are sane */
+	for (i=NumPages-1; i>=0; i--) {
+		if (sparse[i][0]!=i+5) {
+			printf("BAD NEWS!!! - your VM mechanism has a bug!\n");
+			exit(1);
+		}
+	}
+	
+	printf("You passed!\n");
+	
+	return 0;
+}
+
diff --git a/os161-1.10/testbin/kitchen/.cvsignore b/os161-1.10/testbin/kitchen/.cvsignore
new file mode 100644
index 0000000..ebc85a5
--- /dev/null
+++ b/os161-1.10/testbin/kitchen/.cvsignore
@@ -0,0 +1 @@
+kitchen
diff --git a/os161-1.10/testbin/kitchen/Makefile b/os161-1.10/testbin/kitchen/Makefile
new file mode 100644
index 0000000..7969e5a
--- /dev/null
+++ b/os161-1.10/testbin/kitchen/Makefile
@@ -0,0 +1,9 @@
+# Makefile for kitchen
+
+SRCS=kitchen.c
+PROG=kitchen
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/kitchen/depend.mk b/os161-1.10/testbin/kitchen/depend.mk
new file mode 100644
index 0000000..e0108c4
--- /dev/null
+++ b/os161-1.10/testbin/kitchen/depend.mk
@@ -0,0 +1,11 @@
+
+kitchen.o: \
+ kitchen.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/kitchen/kitchen.c b/os161-1.10/testbin/kitchen/kitchen.c
new file mode 100644
index 0000000..476950a
--- /dev/null
+++ b/os161-1.10/testbin/kitchen/kitchen.c
@@ -0,0 +1,63 @@
+/*
+ * kitchen.c
+ *
+ * 	Run a bunch of sinks (only).
+ *
+ * This tests concurrent read access to the console driver.
+ */
+
+#include <unistd.h>
+#include <err.h>
+
+static char *sargv[2] = { (char *)"sink", NULL };
+
+#define MAXPROCS  6
+static int pids[MAXPROCS], npids;
+
+static
+void
+sink(void)
+{
+	int pid = fork();
+	switch (pid) {
+	    case -1:
+		err(1, "fork");
+	    case 0:
+		/* child */
+		execv("/testbin/sink", sargv);
+		err(1, "/testbin/sink");
+	    default:
+		/* parent */
+		pids[npids++] = pid;
+		break;
+	}
+}
+
+static
+void
+waitall(void)
+{
+	int i, status;
+	for (i=0; i<npids; i++) {
+		if (waitpid(pids[i], &status, 0)<0) {
+			warn("waitpid for %d", pids[i]);
+		}
+		else if (status != 0) {
+			warnx("pid %d: exit %d", pids[i], status);
+		}
+	}
+}
+
+
+int
+main(void)
+{
+	sink();
+	sink();
+	sink();
+	sink();
+
+	waitall();
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/malloctest/.cvsignore b/os161-1.10/testbin/malloctest/.cvsignore
new file mode 100644
index 0000000..ae7a704
--- /dev/null
+++ b/os161-1.10/testbin/malloctest/.cvsignore
@@ -0,0 +1 @@
+malloctest
diff --git a/os161-1.10/testbin/malloctest/Makefile b/os161-1.10/testbin/malloctest/Makefile
new file mode 100644
index 0000000..fd17a23
--- /dev/null
+++ b/os161-1.10/testbin/malloctest/Makefile
@@ -0,0 +1,9 @@
+# Makefile for malloctest
+
+SRCS=malloctest.c
+PROG=malloctest
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/malloctest/depend.mk b/os161-1.10/testbin/malloctest/depend.mk
new file mode 100644
index 0000000..d446f45
--- /dev/null
+++ b/os161-1.10/testbin/malloctest/depend.mk
@@ -0,0 +1,14 @@
+
+malloctest.o: \
+ malloctest.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/fcntl.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/malloctest/malloctest.c b/os161-1.10/testbin/malloctest/malloctest.c
new file mode 100644
index 0000000..5188bda
--- /dev/null
+++ b/os161-1.10/testbin/malloctest/malloctest.c
@@ -0,0 +1,658 @@
+/* 
+ * malloctest.c
+ *
+ * This program contains a variety of tests for malloc and free.
+ * XXX most tests leak on error.
+ *
+ * These tests (subject to restrictions and limitations noted below) should
+ * work once user-level malloc is implemented.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <err.h>
+
+
+#define _PATH_RANDOM   "random:"
+
+#define SMALLSIZE   72
+#define MEDIUMSIZE  896
+#define BIGSIZE     16384
+#define HUGESIZE    (1024 * 1024 * 1024)
+
+/* Maximum amount of space per block we allow for indexing structures */
+#define OVERHEAD         32
+
+/* Point past which we assume something else is going on */
+#define ABSURD_OVERHEAD  256
+
+static
+int
+geti(void)
+{
+	int val=0;
+	int ch, digits=0;
+
+	while (1) {
+		ch = getchar();
+		if (ch=='\n' || ch=='\r') {
+			putchar('\n');
+			break;
+		}
+		else if ((ch=='\b' || ch==127) && digits>0) {
+			printf("\b \b");
+			val = val/10;
+			digits--;
+		}
+		else if (ch>='0' && ch<='9') {
+			putchar(ch);
+			val = val*10 + (ch-'0');
+			digits++;
+		}
+		else {
+			putchar('\a');
+		}
+	}
+
+	if (digits==0) {
+		return -1;
+	}
+	return val;
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Fill a block of memory with a test pattern.
+ */
+static
+void
+markblock(volatile void *ptr, size_t size, unsigned bias, int doprint)
+{
+	size_t n, i;
+	unsigned long *pl;
+	unsigned long val;
+
+	pl = (unsigned long *)ptr;
+	n = size / sizeof(unsigned long);
+
+	for (i=0; i<n; i++) {
+		val = ((unsigned long)i ^ (unsigned long)bias);
+		pl[i] = val;
+		if (doprint && (i%64==63)) {
+			printf(".");
+		}
+	}
+	if (doprint) {
+		printf("\n");
+	}
+}
+
+/*
+ * Check a block marked with markblock()
+ */
+static
+int
+checkblock(volatile void *ptr, size_t size, unsigned bias, int doprint)
+{
+	size_t n, i;
+	unsigned long *pl;
+	unsigned long val;
+
+	pl = (unsigned long *)ptr;
+	n = size / sizeof(unsigned long);
+
+	for (i=0; i<n; i++) {
+		val = ((unsigned long)i ^ (unsigned long)bias);
+		if (pl[i] != val) {
+			if (doprint) {
+				printf("\n");
+			}
+			printf("FAILED: data mismatch at offset %lu of block "
+			       "at 0x%lx: %lu vs. %lu\n",
+			       (unsigned long) (i*sizeof(unsigned long)),
+			       (unsigned long)(uintptr_t)pl,
+			       pl[i], val);
+			return -1;
+		}
+		if (doprint && (i%64==63)) {
+			printf(".");
+		}
+	}
+	if (doprint) {
+		printf("\n");
+	}
+
+	return 0;
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Test 1
+ *
+ * This test checks if all the bytes we asked for are getting
+ * allocated.
+ */
+
+static
+void
+test1(void)
+{
+	volatile unsigned *x;
+
+	printf("*** Malloc test 1 ***\n");
+	printf("Allocating %u bytes\n", BIGSIZE);
+	x = malloc(BIGSIZE);
+	if (x==NULL) {
+		printf("FAILED: malloc failed\n");
+		return;
+	}
+
+	markblock(x, BIGSIZE, 0, 0);
+	if (checkblock(x, BIGSIZE, 0, 0)) {
+		printf("FAILED: data corrupt\n");
+		return;
+	}
+
+	free((void *)x);
+
+	printf("Passed malloc test 1.\n");
+}
+
+
+////////////////////////////////////////////////////////////
+
+/* 
+ * Test 2
+ *
+ * Tests if malloc gracefully handles failing requests.
+ *
+ * This test assumes that one of the following conditions holds:
+ *    1. swap is not overcommitted; or
+ *    2. user processes are limited to some maximum size, and enough
+ *       swap exists to hold a maximal user process.
+ *
+ * That is, it assumes that malloc returns NULL when out of memory,
+ * and that the process will not be killed for running out of
+ * memory/swap at other times.
+ *
+ * If mallocing more memory than the system can actually provide
+ * backing for succeeds, this test will blow up. That's ok, but please
+ * provide a way to switch on one of the above conditions so this test
+ * can be run.
+ *
+ * This test works by trying a huge malloc, and then trying
+ * successively smaller mallocs until one works. Then it touches the
+ * whole block to make sure the memory is actually successfully
+ * allocated. Then it frees the block and allocates it again, which
+ * should succeed.
+ *
+ * Note that this test may give spurious failures if anything else is
+ * running at the same time and changing the amount of memory
+ * available.
+ */
+
+static
+void
+test2(void)
+{
+	volatile unsigned *x;
+	size_t size;
+	
+	printf("Entering malloc test 2.\n");
+	printf("Make sure you read and understand the comment in malloctest.c "
+	       "that\nexplains the conditions this test assumes.\n\n");
+
+	printf("Testing how much memory we can allocate:\n");
+	
+	for (size = HUGESIZE; (x = malloc(size))==NULL; size = size/2) {
+		printf("  %9lu bytes: failed\n", (unsigned long) size);
+	}
+	printf("  %9lu bytes: succeeded\n", (unsigned long) size);
+
+	printf("Passed part 1\n");
+
+	printf("Touching all the words in the block.\n");
+	markblock(x, size, 0, 1);
+
+	printf("Validating the words in the block.\n");
+	if (checkblock(x, size, 0, 1)) {
+		printf("FAILED: data corrupt\n");
+		return;
+	}
+	printf("Passed part 2\n");
+
+
+	printf("Freeing the block\n");
+	free((void *)x);
+	printf("Passed part 3\n");
+	printf("Allocating another block\n");
+	
+	x = malloc(size);
+	if (x==NULL) {
+		printf("FAILED: free didn't return the memory?\n");
+		return;
+	}
+	free((void *)x);
+
+	printf("Passed malloc test 2.\n");
+}
+
+
+////////////////////////////////////////////////////////////
+
+/* 
+ * Test 3
+ *
+ * Tests if malloc gracefully handles failing requests.
+ *
+ * This test assumes the same conditions as test 2.
+ *
+ * This test works by mallocing a lot of small blocks in a row until
+ * malloc starts failing.
+ */
+
+struct test3 {
+	struct test3 *next;
+	char junk[(SMALLSIZE - sizeof(struct test3 *))];
+};
+
+static
+void
+test3(void)
+{
+	struct test3 *list = NULL, *tmp;
+	size_t tot=0;
+	int ct=0, failed=0;
+	void *x;
+
+	printf("Entering malloc test 3.\n");
+	printf("Make sure you read and understand the comment in malloctest.c "
+	       "that\nexplains the conditions this test assumes.\n\n");
+
+	printf("Testing how much memory we can allocate:\n");
+
+	while ((tmp = malloc(sizeof(struct test3))) != NULL) {
+
+		tmp->next = list;
+		list = tmp;
+
+		tot += sizeof(struct test3);
+
+		markblock(list->junk, sizeof(list->junk), (uintptr_t)list, 0);
+
+		ct++;
+		if (ct%128==0) {
+			printf(".");
+		}
+	}
+
+	printf("Allocated %lu bytes\n", (unsigned long) tot);
+
+	printf("Trying some more allocations which I expect to fail...\n");
+
+	x = malloc(SMALLSIZE);
+	if (x != NULL) {
+		printf("FAILED: malloc(%u) succeeded\n", SMALLSIZE);
+		return;
+	}
+
+	x = malloc(MEDIUMSIZE);
+	if (x != NULL) {
+		printf("FAILED: malloc(%u) succeeded\n", MEDIUMSIZE);
+		return;
+	}
+
+	x = malloc(BIGSIZE);
+	if (x != NULL) {
+		printf("FAILED: malloc(%u) succeeded\n", BIGSIZE);
+		return;
+	}
+
+	printf("Ok, now I'm going to free everything...\n");
+
+	while (list != NULL) {
+		tmp = list->next;
+
+		if (checkblock(list->junk, sizeof(list->junk), 
+			       (uintptr_t)list, 0)) {
+			failed = 1;
+		}
+
+		free(list);
+		list = tmp;
+	}
+
+	if (failed) {
+		printf("FAILED: data corruption\n");
+		return;
+	}
+
+	printf("Let me see if I can allocate some more now...\n");
+
+	x = malloc(MEDIUMSIZE);
+	if (x == NULL) {
+		printf("FAIL: Nope, I couldn't.\n");
+		return;
+	}
+	free(x);
+	
+	printf("Passed malloc test 3\n");
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Test 4
+ *
+ * Tries to test in detail if malloc coalesces the free list properly.
+ *
+ * This test will likely fail if something other than a basic first-fit/
+ * next-fit/best-fit algorithm is used.
+ */
+
+static
+void
+test4(void)
+{
+	void *x, *y, *z;
+	unsigned long lx, ly, lz, overhead, zsize;
+
+	printf("Entering malloc test 4.\n");
+	printf("This test is intended for first/best-fit based mallocs.\n");
+	printf("This test may not work correctly if run after other tests.\n");
+
+	printf("Testing free list coalescing:\n");
+
+	x = malloc(SMALLSIZE);
+	if (x==NULL) {
+		printf("FAILED: malloc(%u) failed\n", SMALLSIZE);
+		return;
+	}
+
+	y = malloc(MEDIUMSIZE);
+	if (y==NULL) {
+		printf("FAILED: malloc(%u) failed\n", MEDIUMSIZE);
+		return;
+	}
+
+	if (sizeof(unsigned long) < sizeof(void *)) {
+		printf("Buh? I can't fit a void * in an unsigned long\n");
+		printf("ENVIRONMENT FAILED...\n");
+		return;
+	}
+
+	lx = (unsigned long)x;
+	ly = (unsigned long)y;
+
+	printf("x is 0x%lx; y is 0x%lx\n", lx, ly);
+
+	/*
+	 * The memory should look something like this:
+	 *
+	 *     OXXXOYYYYYYYYYYY
+	 *
+	 * where O are optional overhead (indexing) blocks.
+	 */
+
+	/* This is obviously wrong. */
+	if (lx == ly) {
+		printf("FAIL: x == y\n");
+		return;
+	}
+
+	/*
+	 * Check for overlap. It is sufficient to check if the start
+	 * of each block is within the other block. (If the end of a
+	 * block is within the other block, either the start is too,
+	 * or the other block's start is within the first block.)
+	 */
+	if (lx < ly && lx + SMALLSIZE > ly) {
+		printf("FAIL: y starts within x\n");
+		return;
+	}
+	if (ly < lx && ly + MEDIUMSIZE > lx) {
+		printf("FAIL: x starts within y\n");
+		return;
+	}
+
+	/*
+	 * If y is lower than x, some memory scheme we don't
+	 * understand is in use, or else there's already stuff on the
+	 * free list.
+	 */
+	if (ly < lx) {
+		printf("TEST UNSUITABLE: y is below x\n");
+		return;
+	}
+
+	/*
+	 * Compute the space used by index structures.
+	 */
+	overhead = ly - (lx + SMALLSIZE);
+	printf("Apparent block overhead: %lu\n", overhead);
+
+	if (overhead > ABSURD_OVERHEAD) {
+		printf("TEST UNSUITABLE: block overhead absurdly large.\n");
+		return;
+	}
+	if (overhead > OVERHEAD) {
+		printf("FAIL: block overhead is too large.\n");
+		return;
+	}
+
+	printf("Freeing blocks...\n");
+	free(x);
+	free(y);
+
+	zsize = SMALLSIZE + MEDIUMSIZE + overhead;
+
+	printf("Now allocating %lu bytes... should reuse the space.\n", zsize);
+	z = malloc(zsize);
+	if (z == NULL) {
+		printf("FAIL: Allocation failed...\n");
+		return;
+	}
+
+	lz = (unsigned long) z;
+
+	printf("z is 0x%lx (x was 0x%lx, y 0x%lx)\n", lz, lx, ly);
+
+	if (lz==lx) {
+		printf("Passed.\n");
+	}
+	else {
+		printf("Failed.\n");
+	}
+
+	free(z);
+}
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Test 5/6/7
+ *
+ * Generally beats on malloc/free.
+ *
+ * Test 5 uses random seed 0.
+ * Test 6 seeds the random number generator from random:.
+ * Test 7 asks for a seed.
+ */
+
+static
+void
+test567(int testno, unsigned long seed)
+{
+	static const int sizes[8] = { 13, 17, 69, 176, 433, 871, 1150, 6060 };
+	
+	void *ptrs[32];
+	int psizes[32];
+	int i, n, size, failed=0;
+
+	srandom(seed);
+	printf("Seeded random number generator with %lu.\n", seed);
+
+	for (i=0; i<32; i++) {
+		ptrs[i] = NULL;
+		psizes[i] = 0;
+	}
+
+	for (i=0; i<100000; i++) {
+		n = random()%32;
+		if (ptrs[n] == NULL) {
+			size = sizes[random()%8];
+			ptrs[n] = malloc(size);
+			psizes[n] = size;
+			if (ptrs[n] == NULL) {
+				printf("\nmalloc %u failed\n", size);
+				failed = 1;
+				break;
+			}
+			markblock(ptrs[n], size, n, 0);
+		}
+		else {
+			size = psizes[n];
+			if (checkblock(ptrs[n], size, n, 0)) {
+				failed = 1;
+				break;
+			}
+			free(ptrs[n]);
+			ptrs[n] = NULL;
+			psizes[n] = 0;
+		}
+		if (i%256==0) {
+			printf(".");
+		}
+	}
+	printf("\n");
+
+	for (i=0; i<32; i++) {
+		if (ptrs[i] != NULL) {
+			free(ptrs[i]);
+		}
+	}
+
+	if (failed) {
+		printf("FAILED malloc test %d\n", testno);
+	}
+	else {
+		printf("Passed malloc test %d\n", testno);
+	}
+}
+
+static
+void
+test5(void)
+{
+	printf("Beginning malloc test 5\n");
+	test567(5, 0);
+}
+
+static
+void
+test6(void)
+{
+	int fd, len;
+	unsigned long seed;
+
+	printf("Beginning malloc test 6\n");
+
+	fd = open(_PATH_RANDOM, O_RDONLY);
+	if (fd < 0) {
+		err(1, "%s", _PATH_RANDOM);
+	}
+	len = read(fd, &seed, sizeof(seed));
+	if (len < 0) {
+		err(1, "%s", _PATH_RANDOM);
+	}
+	else if (len < (int)sizeof(seed)) {
+		errx(1, "%s: Short read", _PATH_RANDOM);
+	}
+	close(fd);
+
+	test567(6, seed);
+}
+
+static
+void
+test7(void)
+{
+	unsigned long seed;
+
+	printf("Beginning malloc test 7\n");
+
+	printf("Enter random seed: ");
+	seed = geti();
+
+	test567(7, seed);
+}
+
+////////////////////////////////////////////////////////////
+
+static struct {
+	int num;
+	const char *desc;
+	void (*func)(void);
+} tests[] = {
+	{ 1, "Simple allocation test", test1 },
+	{ 2, "Allocate all memory in a big chunk", test2 },
+	{ 3, "Allocate all memory in small chunks", test3 },
+	{ 4, "Free list coalescing test (first/next/best-fit only)", test4 },
+	{ 5, "Stress test", test5 },
+	{ 6, "Randomized stress test", test6 },
+	{ 7, "Stress test with particular seed", test7 },
+	{ -1, NULL, NULL }
+};
+
+static
+int
+dotest(int tn)
+{
+	int i;
+	for (i=0; tests[i].num>=0; i++) {
+		if (tests[i].num == tn) {
+			tests[i].func();
+			return 0;
+		}
+	}
+	return -1;
+}
+
+int
+main(int argc, char *argv[])
+{
+	int i, tn, menu=1;
+
+	if (argc > 1) {
+		for (i=1; i<argc; i++) {
+			dotest(atoi(argv[i]));
+		}
+		return 0;
+	}
+
+	while (1) {
+		if (menu) {
+			for (i=0; tests[i].num>=0; i++) {
+				printf("  %2d  %s\n", tests[i].num, 
+				       tests[i].desc);
+			}
+			menu = 0;
+		}
+		printf("malloctest: ");
+		tn = geti();
+		if (tn < 0) {
+			break;
+		}
+
+		if (dotest(tn)) {
+			menu = 1;
+		}
+	}
+
+	return 0;
+}
+
diff --git a/os161-1.10/testbin/matmult/.cvsignore b/os161-1.10/testbin/matmult/.cvsignore
new file mode 100644
index 0000000..d2da3eb
--- /dev/null
+++ b/os161-1.10/testbin/matmult/.cvsignore
@@ -0,0 +1 @@
+matmult
diff --git a/os161-1.10/testbin/matmult/Makefile b/os161-1.10/testbin/matmult/Makefile
new file mode 100644
index 0000000..25e64f6
--- /dev/null
+++ b/os161-1.10/testbin/matmult/Makefile
@@ -0,0 +1,9 @@
+# Makefile for matmult
+
+SRCS=matmult.c
+PROG=matmult
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/matmult/depend.mk b/os161-1.10/testbin/matmult/depend.mk
new file mode 100644
index 0000000..745d5a0
--- /dev/null
+++ b/os161-1.10/testbin/matmult/depend.mk
@@ -0,0 +1,11 @@
+
+matmult.o: \
+ matmult.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/matmult/matmult-orig.c b/os161-1.10/testbin/matmult/matmult-orig.c
new file mode 100644
index 0000000..651617b
--- /dev/null
+++ b/os161-1.10/testbin/matmult/matmult-orig.c
@@ -0,0 +1,59 @@
+/* matmult-orig.c 
+ *    Test program to do matrix multiplication on large arrays.
+ *
+ *    Intended to stress virtual memory system.
+ *
+ *    This is the original CS161 matmult program. Unfortunately,
+ *    because matrix multiplication is order N^2 in space and N^3 in
+ *    time, when this is made large enough to be an interesting VM
+ *    test, it becomes so large that it takes hours to run.
+ *
+ *    So you probably want to just run matmult, which has been
+ *    gimmicked up to be order N^3 in space and thus have a tolerable
+ *    running time. This version is provided for reference only.
+ *
+ *    Once the VM assignment is complete your system should be able to
+ *    survive this, if you have the patience to run it.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+
+#define Dim 	360	/* sum total of the arrays doesn't fit in 
+			 * physical memory 
+			 */
+
+#define RIGHT  46397160		/* correct answer */
+
+int A[Dim][Dim];
+int B[Dim][Dim];
+int C[Dim][Dim];
+
+int
+main()
+{
+    int i, j, k, r;
+
+    for (i = 0; i < Dim; i++)		/* first initialize the matrices */
+	for (j = 0; j < Dim; j++) {
+	     A[i][j] = i;
+	     B[i][j] = j;
+	     C[i][j] = 0;
+	}
+
+    for (i = 0; i < Dim; i++)		/* then multiply them together */
+	for (j = 0; j < Dim; j++)
+            for (k = 0; k < Dim; k++)
+		 C[i][j] += A[i][k] * B[k][j];
+
+    printf("matmult-orig finished.\n");
+    r = C[Dim-1][Dim-1];
+    printf("answer is: %d (should be %d)\n", r, RIGHT);
+    if (r != RIGHT) {
+	    printf("FAILED\n");
+    }
+    else {
+	    printf("Passed.\n");
+    }
+    return 0;
+}
diff --git a/os161-1.10/testbin/matmult/matmult.c b/os161-1.10/testbin/matmult/matmult.c
new file mode 100644
index 0000000..304e2b0
--- /dev/null
+++ b/os161-1.10/testbin/matmult/matmult.c
@@ -0,0 +1,61 @@
+/* matmult.c 
+ *    Test program to do matrix multiplication on large arrays.
+ *
+ *    This version uses a storage-inefficient technique to get a
+ *    shorter running time for the same memory usage.
+ *
+ *    Intended to stress virtual memory system.
+ *
+ *    Once the VM system assignment is complete your system should be
+ *    able to survive this.
+ */
+
+#include <unistd.h>
+#include <stdio.h>
+
+#define Dim 	72	/* sum total of the arrays doesn't fit in 
+			 * physical memory 
+			 */
+
+#define RIGHT  8772192		/* correct answer */
+
+int A[Dim][Dim];
+int B[Dim][Dim];
+int C[Dim][Dim];
+int T[Dim][Dim][Dim];
+
+int
+main()
+{
+    int i, j, k, r;
+
+    for (i = 0; i < Dim; i++)		/* first initialize the matrices */
+	for (j = 0; j < Dim; j++) {
+	     A[i][j] = i;
+	     B[i][j] = j;
+	     C[i][j] = 0;
+	}
+
+    for (i = 0; i < Dim; i++)		/* then multiply them together */
+	for (j = 0; j < Dim; j++)
+            for (k = 0; k < Dim; k++)
+		T[i][j][k] = A[i][k] * B[k][j];
+
+    for (i = 0; i < Dim; i++)
+	for (j = 0; j < Dim; j++)
+            for (k = 0; k < Dim; k++)
+		C[i][j] += T[i][j][k];
+
+    r = 0;
+    for (i = 0; i < Dim; i++)
+	    r += C[i][i];
+
+    printf("matmult finished.\n");
+    printf("answer is: %d (should be %d)\n", r, RIGHT);
+    if (r != RIGHT) {
+	    printf("FAILED\n");
+	    return 1;
+    }
+    printf("Passed.\n");
+    return 0;
+}
diff --git a/os161-1.10/testbin/palin/.cvsignore b/os161-1.10/testbin/palin/.cvsignore
new file mode 100644
index 0000000..8780542
--- /dev/null
+++ b/os161-1.10/testbin/palin/.cvsignore
@@ -0,0 +1 @@
+palin
diff --git a/os161-1.10/testbin/palin/Makefile b/os161-1.10/testbin/palin/Makefile
new file mode 100644
index 0000000..0ce9c2e
--- /dev/null
+++ b/os161-1.10/testbin/palin/Makefile
@@ -0,0 +1,9 @@
+# Makefile for palin
+
+SRCS=palin.c
+PROG=palin
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/palin/depend.mk b/os161-1.10/testbin/palin/depend.mk
new file mode 100644
index 0000000..3145f2e
--- /dev/null
+++ b/os161-1.10/testbin/palin/depend.mk
@@ -0,0 +1,9 @@
+
+palin.o: \
+ palin.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/string.h
diff --git a/os161-1.10/testbin/palin/palin.c b/os161-1.10/testbin/palin/palin.c
new file mode 100644
index 0000000..e166a10
--- /dev/null
+++ b/os161-1.10/testbin/palin/palin.c
@@ -0,0 +1,169 @@
+/*
+
+	Test suite.
+
+	This program takes the palindrome below and checks if it's
+	a palindrome or not. It will hopefully exhibit an interesting
+	page fault pattern.
+
+	The palindrome was taken from 
+
+	http://www.cs.brown.edu/people/nfp/palindrome.html
+
+	This is not large enough to really stress the VM system, but
+	might be useful for testing in the early stages of the VM
+	assignment.
+*/
+
+/*
+A man, a plan, a caret, a ban, a myriad, a sum, a lac, a liar, a hoop,
+a pint, a catalpa, a gas, an oil, a bird, a yell, a vat, a caw, a pax,
+a wag, a tax, a nay, a ram, a cap, a yam, a gay, a tsar, a wall, a
+car, a luger, a ward, a bin, a woman, a vassal, a wolf, a tuna, a nit,
+a pall, a fret, a watt, a bay, a daub, a tan, a cab, a datum, a gall, 
+a hat, a fag, a zap, a say, a jaw, a lay, a wet, a gallop, a tug, a
+trot, a trap, a tram, a torr, a caper, a top, a tonk, a toll, a ball, 
+a fair, a sax, a minim, a tenor, a bass, a passer, a capital, a rut, 
+an amen, a ted, a cabal, a tang, a sun, an ass, a maw, a sag, a jam, 
+a dam, a sub, a salt, an axon, a sail, an ad, a wadi, a radian, a
+room, a rood, a rip, a tad, a pariah, a revel, a reel, a reed, a pool,
+a plug, a pin, a peek, a parabola, a dog, a pat, a cud, a nu, a fan, 
+a pal, a rum, a nod, an eta, a lag, an eel, a batik, a mug, a mot, a
+nap, a maxim, a mood, a leek, a grub, a gob, a gel, a drab, a citadel,
+a total, a cedar, a tap, a gag, a rat, a manor, a bar, a gal, a cola, 
+a pap, a yaw, a tab, a raj, a gab, a nag, a pagan, a bag, a jar, a
+bat, a way, a papa, a local, a gar, a baron, a mat, a rag, a gap, a
+tar, a decal, a tot, a led, a tic, a bard, a leg, a bog, a burg, a
+keel, a doom, a mix, a map, an atom, a gum, a kit, a baleen, a gala, 
+a ten, a don, a mural, a pan, a faun, a ducat, a pagoda, a lob, a rap,
+a keep, a nip, a gulp, a loop, a deer, a leer, a lever, a hair, a pad,
+a tapir, a door, a moor, an aid, a raid, a wad, an alias, an ox, an
+atlas, a bus, a madam, a jag, a saw, a mass, an anus, a gnat, a lab, 
+a cadet, an em, a natural, a tip, a caress, a pass, a baronet, a
+minimax, a sari, a fall, a ballot, a knot, a pot, a rep, a carrot, 
+a mart, a part, a tort, a gut, a poll, a gateway, a law, a jay, a sap,
+a zag, a fat, a hall, a gamut, a dab, a can, a tabu, a day, a batt, 
+a waterfall, a patina, a nut, a flow, a lass, a van, a mow, a nib, 
+a draw, a regular, a call, a war, a stay, a gam, a yap, a cam, a ray, 
+an ax, a tag, a wax, a paw, a cat, a valley, a drib, a lion, a saga, 
+a plat, a catnip, a pooh, a rail, a calamus, a dairyman, a bater, 
+a canal - Panama! 
+*/
+
+/* The palindrome below is a quadruple concatenation of the above */
+
+#include <stdio.h>
+#include <string.h>
+
+char palindrome[8000] = 
+"amanaplanacaretabanamyriadasumalacaliarahoopapintacatalpaagasanoil"
+"abirdayellavatacawapaxawagataxanayaramacapayamagayatsarawalla"
+"caralugerawardabinawomanavassalawolfatunaanitapallafretawattabaya"
+"daubatanacabadatumagallahatafagazapasayajawalayawetagallopatuga"
+"trotatrapatramatorracaperatopatonkatollaballafairasaxaminimatenora"
+"bassapasseracapitalarutanamenatedacabalatangasunanassamawasaga"
+"jamadamasubasaltanaxonasailanadawadiaradianaroomaroodaripatada"
+"pariaharevelareelareedapoolaplugapinapeekaparabolaadogapatacudanua"
+"fanapalarumanodanetaalaganeelabatikamugamotanapamaximamooda"
+"leekagrubagobageladrabacitadelatotalacedaratapagagaratamanorabara"
+"galacolaapapayawatabarajagabanagapaganabagajarabatawayapapaa"
+"localagarabaronamataragagapataradecalatotaledaticabardalegaboga"
+"burgakeeladoomamixamapanatomagumakitabaleenagalaatenadonamurala"
+"panafaunaducatapagodaalobarapakeepanipagulpaloopadeeraleeralevera"
+"hairapadatapiradooramooranaidaraidawadanaliasanoxanatlasabusamadam"
+"ajagasawamassananusagnatalabacadetanemanaturalatipacaressapassa"
+"baronetaminimaxasariafallaballotaknotapotarepacarrotamartapartatorta"
+"gutapollagatewayalawajayasapazagafatahallagamutadabacanatabuaday"
+"abattawaterfallapatinaanutaflowalassavanamowanibadrawaregularacalla"
+"warastayagamayapacamarayanaxatagawaxapawacatavalleyadribaliona"
+"sagaaplatacatnipapooharailacalamusadairymanabateracanalpanama"
+"amanaplanacaretabanamyriadasumalacaliarahoopapintacatalpaagasanoil"
+"abirdayellavatacawapaxawagataxanayaramacapayamagayatsarawalla"
+"caralugerawardabinawomanavassalawolfatunaanitapallafretawattabaya"
+"daubatanacabadatumagallahatafagazapasayajawalayawetagallopatuga"
+"trotatrapatramatorracaperatopatonkatollaballafairasaxaminimatenora"
+"bassapasseracapitalarutanamenatedacabalatangasunanassamawasaga"
+"jamadamasubasaltanaxonasailanadawadiaradianaroomaroodaripatada"
+"pariaharevelareelareedapoolaplugapinapeekaparabolaadogapatacudanua"
+"fanapalarumanodanetaalaganeelabatikamugamotanapamaximamooda"
+"leekagrubagobageladrabacitadelatotalacedaratapagagaratamanorabara"
+"galacolaapapayawatabarajagabanagapaganabagajarabatawayapapaa"
+"localagarabaronamataragagapataradecalatotaledaticabardalegaboga"
+"burgakeeladoomamixamapanatomagumakitabaleenagalaatenadonamurala"
+"panafaunaducatapagodaalobarapakeepanipagulpaloopadeeraleeralevera"
+"hairapadatapiradooramooranaidaraidawadanaliasanoxanatlasabusamadam"
+"ajagasawamassananusagnatalabacadetanemanaturalatipacaressapassa"
+"baronetaminimaxasariafallaballotaknotapotarepacarrotamartapartatorta"
+"gutapollagatewayalawajayasapazagafatahallagamutadabacanatabuaday"
+"abattawaterfallapatinaanutaflowalassavanamowanibadrawaregularacalla"
+"warastayagamayapacamarayanaxatagawaxapawacatavalleyadribaliona"
+"sagaaplatacatnipapooharailacalamusadairymanabateracanalpanama"
+"amanaplanacaretabanamyriadasumalacaliarahoopapintacatalpaagasanoil"
+"abirdayellavatacawapaxawagataxanayaramacapayamagayatsarawalla"
+"caralugerawardabinawomanavassalawolfatunaanitapallafretawattabaya"
+"daubatanacabadatumagallahatafagazapasayajawalayawetagallopatuga"
+"trotatrapatramatorracaperatopatonkatollaballafairasaxaminimatenora"
+"bassapasseracapitalarutanamenatedacabalatangasunanassamawasaga"
+"jamadamasubasaltanaxonasailanadawadiaradianaroomaroodaripatada"
+"pariaharevelareelareedapoolaplugapinapeekaparabolaadogapatacudanua"
+"fanapalarumanodanetaalaganeelabatikamugamotanapamaximamooda"
+"leekagrubagobageladrabacitadelatotalacedaratapagagaratamanorabara"
+"galacolaapapayawatabarajagabanagapaganabagajarabatawayapapaa"
+"localagarabaronamataragagapataradecalatotaledaticabardalegaboga"
+"burgakeeladoomamixamapanatomagumakitabaleenagalaatenadonamurala"
+"panafaunaducatapagodaalobarapakeepanipagulpaloopadeeraleeralevera"
+"hairapadatapiradooramooranaidaraidawadanaliasanoxanatlasabusamadam"
+"ajagasawamassananusagnatalabacadetanemanaturalatipacaressapassa"
+"baronetaminimaxasariafallaballotaknotapotarepacarrotamartapartatorta"
+"gutapollagatewayalawajayasapazagafatahallagamutadabacanatabuaday"
+"abattawaterfallapatinaanutaflowalassavanamowanibadrawaregularacalla"
+"warastayagamayapacamarayanaxatagawaxapawacatavalleyadribaliona"
+"sagaaplatacatnipapooharailacalamusadairymanabateracanalpanama"
+"amanaplanacaretabanamyriadasumalacaliarahoopapintacatalpaagasanoil"
+"abirdayellavatacawapaxawagataxanayaramacapayamagayatsarawalla"
+"caralugerawardabinawomanavassalawolfatunaanitapallafretawattabaya"
+"daubatanacabadatumagallahatafagazapasayajawalayawetagallopatuga"
+"trotatrapatramatorracaperatopatonkatollaballafairasaxaminimatenora"
+"bassapasseracapitalarutanamenatedacabalatangasunanassamawasaga"
+"jamadamasubasaltanaxonasailanadawadiaradianaroomaroodaripatada"
+"pariaharevelareelareedapoolaplugapinapeekaparabolaadogapatacudanua"
+"fanapalarumanodanetaalaganeelabatikamugamotanapamaximamooda"
+"leekagrubagobageladrabacitadelatotalacedaratapagagaratamanorabara"
+"galacolaapapayawatabarajagabanagapaganabagajarabatawayapapaa"
+"localagarabaronamataragagapataradecalatotaledaticabardalegaboga"
+"burgakeeladoomamixamapanatomagumakitabaleenagalaatenadonamurala"
+"panafaunaducatapagodaalobarapakeepanipagulpaloopadeeraleeralevera"
+"hairapadatapiradooramooranaidaraidawadanaliasanoxanatlasabusamadam"
+"ajagasawamassananusagnatalabacadetanemanaturalatipacaressapassa"
+"baronetaminimaxasariafallaballotaknotapotarepacarrotamartapartatorta"
+"gutapollagatewayalawajayasapazagafatahallagamutadabacanatabuaday"
+"abattawaterfallapatinaanutaflowalassavanamowanibadrawaregularacalla"
+"warastayagamayapacamarayanaxatagawaxapawacatavalleyadribaliona"
+"sagaaplatacatnipapooharailacalamusadairymanabateracanalpanama";
+
+int
+main()
+{
+	char *start, *end;
+	
+	printf("Welcome to the palindrome tester!\n");
+	printf("I will take a large palindrome and test it.\n");
+	printf("Here it is:\n");
+	printf("%s\n", palindrome);
+
+	printf("Testing...");
+	/* skip to end */
+	end = palindrome+strlen(palindrome);
+	end--;
+
+	for (start = palindrome; start <= end; start++, end--) {
+		putchar('.');
+		if (*start != *end) {
+			printf("NOT a palindrome\n");
+			return 0;
+		}
+	}
+	
+	printf("IS a palindrome\n");
+	return 0;
+}
diff --git a/os161-1.10/testbin/parallelvm/.cvsignore b/os161-1.10/testbin/parallelvm/.cvsignore
new file mode 100644
index 0000000..8ac5d85
--- /dev/null
+++ b/os161-1.10/testbin/parallelvm/.cvsignore
@@ -0,0 +1 @@
+parallelvm
diff --git a/os161-1.10/testbin/parallelvm/Makefile b/os161-1.10/testbin/parallelvm/Makefile
new file mode 100644
index 0000000..62c5c19
--- /dev/null
+++ b/os161-1.10/testbin/parallelvm/Makefile
@@ -0,0 +1,9 @@
+# Makefile for parallelvm
+
+SRCS=parallelvm.c
+PROG=parallelvm
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/parallelvm/depend.mk b/os161-1.10/testbin/parallelvm/depend.mk
new file mode 100644
index 0000000..00862ec
--- /dev/null
+++ b/os161-1.10/testbin/parallelvm/depend.mk
@@ -0,0 +1,15 @@
+
+parallelvm.o: \
+ parallelvm.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/wait.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/parallelvm/parallelvm.c b/os161-1.10/testbin/parallelvm/parallelvm.c
new file mode 100644
index 0000000..fa65e50
--- /dev/null
+++ b/os161-1.10/testbin/parallelvm/parallelvm.c
@@ -0,0 +1,258 @@
+/*
+ * parallelvm.c: highly parallelized VM stress test.
+ *
+ * This test probably won't run with only 512k of physical memory
+ * (unless maybe if you have a *really* gonzo VM system) because each
+ * of its processes needs to allocate a kernel stack, and those add up
+ * quickly.
+ */
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <err.h>
+
+#define NJOBS    24
+
+#define DIM      35
+#define NMATS    11
+#define JOBSIZE  ((NMATS+1)*DIM*DIM*sizeof(int))
+
+static const int right_answers[NJOBS] = {
+        -1337312809,
+	356204544,
+	-537881911,
+	-65406976,
+	1952063315,
+	-843894784,
+	1597000869,
+	-993925120,
+	838840559,
+        -1616928768,
+	-182386335,
+	-364554240,
+	251084843,
+	-61403136,
+	295326333,
+	1488013312,
+	1901440647,
+	0,
+        -1901440647,
+        -1488013312,
+	-295326333,
+	61403136,
+	-251084843,
+	364554240,
+};
+
+////////////////////////////////////////////////////////////
+
+struct matrix {
+	int m_data[DIM][DIM];
+};
+
+////////////////////////////////////////////////////////////
+
+/*
+ * Use this instead of just calling printf so we know each printout
+ * is atomic; this prevents the lines from getting intermingled.
+ */
+static
+void
+say(const char *fmt, ...)
+{
+	char buf[256];
+	va_list ap;
+	va_start(ap, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+	write(STDOUT_FILENO, buf, strlen(buf));
+}
+
+////////////////////////////////////////////////////////////
+
+static
+void
+multiply(struct matrix *res, const struct matrix *m1, const struct matrix *m2)
+{
+	int i, j, k;
+
+	for (i=0; i<DIM; i++) {
+		for (j=0; j<DIM; j++) {
+			int val=0;
+			for (k=0; k<DIM; k++) {
+				val += m1->m_data[i][k]*m2->m_data[k][j];
+			}
+			res->m_data[i][j] = val;
+		}
+	}
+}
+
+static
+void
+addeq(struct matrix *m1, const struct matrix *m2)
+{
+	int i, j;
+	for (i=0; i<DIM; i++) {
+		for (j=0; j<DIM; j++) {
+			m1->m_data[i][j] += m2->m_data[i][j];
+		}
+	}
+}
+
+static
+int
+trace(const struct matrix *m1)
+{
+	int i, t=0;
+	for (i=0; i<DIM; i++) {
+		t += m1->m_data[i][i];
+	}
+	return t;
+}
+
+////////////////////////////////////////////////////////////
+
+static struct matrix mats[NMATS];
+
+static
+void
+populate_initial_matrixes(int mynum)
+{
+	int i,j;
+	struct matrix *m = &mats[0];
+	for (i=0; i<DIM; i++) {
+		for (j=0; j<DIM; j++) {
+			m->m_data[i][j] = mynum+i-2*j;
+		}
+	}
+	
+	multiply(&mats[1], &mats[0], &mats[0]);
+}
+
+static
+void
+compute(int n)
+{
+	struct matrix tmp;
+	int i, j;
+
+	for (i=0,j=n-1; i<j; i++,j--) {
+		multiply(&tmp, &mats[i], &mats[j]);
+		addeq(&mats[n], &tmp);
+	}
+}
+
+static
+void
+computeall(int mynum)
+{
+	int i;
+	populate_initial_matrixes(mynum);
+	for (i=2; i<NMATS; i++) {
+		compute(i);
+	}
+}
+
+static
+int
+answer(void)
+{
+	return trace(&mats[NMATS-1]);
+}
+
+static
+void
+go(int mynum)
+{
+	int r;
+
+	say("Process %d (pid %d) starting computation...\n", mynum, 
+	    (int) getpid());
+
+	computeall(mynum);
+	r = answer();
+
+	if (r != right_answers[mynum]) {
+		say("Process %d answer %d: FAILED, should be %d\n", 
+		    mynum, r, right_answers[mynum]);
+		exit(1);
+	}
+	say("Process %d answer %d: passed\n", mynum, r);
+	exit(0);
+}
+
+////////////////////////////////////////////////////////////
+
+static
+int
+status_is_failure(int status)
+{
+#ifdef HOST
+	/* Proper interpretation of Unix exit status */
+	if (WIFSIGNALED(status)) {
+		return 1;
+	}
+	if (!WIFEXITED(status)) {
+		/* ? */
+		return 1;
+	}
+	status = WEXITSTATUS(status);
+#endif
+	return status != 0;
+}
+
+static
+void
+makeprocs(void)
+{
+	int i, status, failcount;
+	pid_t pids[NJOBS];
+
+	printf("Job size approximately %lu bytes\n", (unsigned long) JOBSIZE);
+	printf("Forking %d jobs; total load %luk\n", NJOBS,
+	       (unsigned long) (NJOBS * JOBSIZE)/1024);
+
+	for (i=0; i<NJOBS; i++) {
+		pids[i] = fork();
+		if (pids[i]<0) {
+			warn("fork");
+		}
+		if (pids[i]==0) {
+			/* child */
+			go(i);
+		}
+	}
+
+	failcount=0;
+	for (i=0; i<NJOBS; i++) {
+		if (pids[i]<0) {
+			failcount++;
+		}
+		else {
+			if (waitpid(pids[i], &status, 0)<0) {
+				err(1, "waitpid");
+			}
+			if (status_is_failure(status)) {
+				failcount++;
+			}
+		}
+	}
+
+	if (failcount>0) {
+		printf("%d subprocesses failed\n", failcount);
+		exit(1);
+	}
+	printf("Test complete\n");
+}
+
+int
+main()
+{
+	makeprocs();
+	return 0;
+}
diff --git a/os161-1.10/testbin/randcall/.cvsignore b/os161-1.10/testbin/randcall/.cvsignore
new file mode 100644
index 0000000..6054405
--- /dev/null
+++ b/os161-1.10/testbin/randcall/.cvsignore
@@ -0,0 +1,2 @@
+calls.c
+randcall
diff --git a/os161-1.10/testbin/randcall/Makefile b/os161-1.10/testbin/randcall/Makefile
new file mode 100644
index 0000000..4e38d0b
--- /dev/null
+++ b/os161-1.10/testbin/randcall/Makefile
@@ -0,0 +1,19 @@
+# Makefile for badcall
+
+SRCS=calls.c main.c
+PROG=randcall
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
+calls.c: gencalls.sh callspecs.txt
+	./gencalls.sh callspecs.txt > calls.c
+
+depend progdepend: predepend
+predepend:
+	$(MAKE) calls.c
+
+clean: myclean
+myclean:
+	rm -f calls.c
diff --git a/os161-1.10/testbin/randcall/callspecs.txt b/os161-1.10/testbin/randcall/callspecs.txt
new file mode 100644
index 0000000..ab42e52
--- /dev/null
+++ b/os161-1.10/testbin/randcall/callspecs.txt
@@ -0,0 +1,26 @@
+2 execv		ptr	ptr
+2 waitpid	int	ptr	int
+2 open		ptr	int	int
+2 read		int	ptr	size
+2 write		int	ptr	size
+2 close		int
+5 ioctl		int	int	ptr
+2 lseek		int	off	int
+4 fsync		int
+4 ftruncate	int	off
+4 fstat		int	ptr
+4 remove	ptr
+4 rename	ptr	ptr
+5 link		ptr	ptr
+4 mkdir		ptr	int
+4 rmdir		ptr
+2 chdir		ptr
+4 getdirentry	int	ptr	size
+5 symlink	ptr	ptr
+5 readlink	ptr	ptr	size
+2 dup2		int	int
+5 pipe		ptr
+5 __time	ptr	ptr
+2 __getcwd	ptr	size
+5 stat		ptr	ptr
+5 lstat		ptr	ptr
diff --git a/os161-1.10/testbin/randcall/depend.mk b/os161-1.10/testbin/randcall/depend.mk
new file mode 100644
index 0000000..1f2d367
--- /dev/null
+++ b/os161-1.10/testbin/randcall/depend.mk
@@ -0,0 +1,29 @@
+
+calls.o: \
+ calls.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/assert.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h \
+ extern.h
+main.o: \
+ main.c \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/string.h \
+ extern.h
diff --git a/os161-1.10/testbin/randcall/extern.h b/os161-1.10/testbin/randcall/extern.h
new file mode 100644
index 0000000..c1888a4
--- /dev/null
+++ b/os161-1.10/testbin/randcall/extern.h
@@ -0,0 +1,7 @@
+
+void *randptr(void);
+int randint(void);
+off_t randoff(void);
+size_t randsize(void);
+
+void trycalls(int asst, int dofork, int count);
diff --git a/os161-1.10/testbin/randcall/gencalls.sh b/os161-1.10/testbin/randcall/gencalls.sh
new file mode 100755
index 0000000..91627c1
--- /dev/null
+++ b/os161-1.10/testbin/randcall/gencalls.sh
@@ -0,0 +1,143 @@
+#!/bin/sh
+#
+# gencalls.sh - generate calls.c and calls.h
+#
+# Usage: gencalls.sh callspecs-file
+
+if [ "x$1" = x ]; then
+    echo "Usage: $0 callspecs-file"
+    exit 1
+fi
+
+awk < $1 '
+
+    BEGIN {
+	type["ptr"] = "void *";
+	type["int"] = "int";
+	type["off"] = "off_t";
+	type["size"] = "size_t";
+	fmt["ptr"] = "%p";
+	fmt["int"] = "%d";
+	fmt["off"] = "%ld";
+	fmt["size"] = "%lu";
+	cast["ptr"] = "";
+	cast["int"] = "";
+	cast["off"] = "(long)";
+	cast["size"] = "(unsigned long)";
+
+	printf "/* Automatically generated file; do not edit */\n";
+	printf "#include <sys/types.h>\n";
+	printf "#include <sys/stat.h>\n";
+	printf "#include <assert.h>\n";
+	printf "#include <unistd.h>\n";
+	printf "#include <stdio.h>\n";
+	printf "#include <stdlib.h>\n";
+	printf "#include <errno.h>\n";
+	printf "#include <err.h>\n";
+	printf "\n";
+	printf "#include \"extern.h\"\n";
+	printf "\n";
+
+	printf "typedef void (*tryfunc)(int dofork);\n";
+	printf "\n";
+
+	n=0;
+    }
+
+    {
+	printf "static\n";
+	printf "void\n";
+	printf "try_%s(int dofork)\n", $2;
+	printf "{\n";
+	for (i=3; i<=NF; i++) {
+	    printf "\t%s a%d = rand%s();\n", type[$i], i-3, $i;
+	}
+	printf "\tint result, pid, status;\n";
+	printf "\tchar buf[128];\n";
+	printf "\n";
+
+	printf "\tsnprintf(buf, sizeof(buf), \"%s(", $2;
+	for (i=3; i<=NF; i++) {
+	    printf "%s", fmt[$i];
+	    if (i<NF) printf ", ";
+	}
+	printf ")\",\n\t\t";
+	for (i=3; i<=NF; i++) {
+	    printf "%s(a%d)", cast[$i], i-3;
+	    if (i<NF) printf ", ";
+	}
+	printf ");\n";
+	printf"\tprintf(\"%%-47s\", buf);\n";
+	#printf "\tfflush(stdout);\n";
+	printf "\n";
+
+	printf "\tpid = dofork ? fork() : 0;\n";
+	printf "\tif (pid<0) {\n";
+	printf "\t\terr(1, \"fork\");\n";
+	printf "\t}\n";
+	printf "\tif (pid>0) {\n";
+	printf "\t\twaitpid(pid, &status, 0);\n";
+	printf "\t\treturn;\n";
+	printf "\t}\n";
+	printf "\n";
+
+	printf "\tresult = %s(", $2;
+	for (i=3; i<=NF; i++) {
+	    printf "a%d", i-3;
+	    if (i<NF) printf ", ";
+	}
+	printf ");\n";
+
+	printf "\tprintf(\" result %%d, errno %%d\\n\", result, errno);\n";
+	printf "\tif (dofork) {\n";
+	printf "\t\texit(0);\n";
+	printf "\t}\n";
+
+	printf "}\n";
+	printf "\n";
+
+	asst[$2] = $1;
+	all[n++] = $2;
+    }
+
+    END {
+	for (a=2; a<=5; a++) {
+	    printf "static tryfunc funcs%d[] = {\n", a;
+	    for (i=0; i<n; i++) {
+		if (asst[all[i]] <= a) {
+		    printf "\ttry_%s,\n", all[i];
+		}
+	    }
+	    printf "\tNULL\n";
+	    printf "};\n";
+	    printf "\n";
+	}
+
+	printf "static tryfunc *tables[4] = {\n";
+	printf "\tfuncs2,\n";
+	printf "\tfuncs3,\n";
+	printf "\tfuncs4,\n";
+	printf "\tfuncs5,\n";
+	printf "};\n";
+	printf "\n";
+
+	printf "void\n";
+	printf "trycalls(int asst, int dofork, int count)\n"
+	printf "{\n";
+	printf "\ttryfunc *list;\n";
+	printf "\tint i, j;\n";
+	printf "\n";
+
+	printf "\tassert(asst>=2 && asst<=5);\n";
+	printf "\tlist = tables[asst-2];\n";
+	printf "\n";
+
+	printf "\tfor (i=0; i<count; i++) {\n";
+	printf "\t\tfor (j=0; list[j]; j++) {\n";
+	printf "\t\t\t(*list[j])(dofork);\n";
+	printf "\t\t}\n";
+	printf "\t}\n";
+	printf "}\n";
+	printf "\n";
+    }
+'
diff --git a/os161-1.10/testbin/randcall/main.c b/os161-1.10/testbin/randcall/main.c
new file mode 100644
index 0000000..8b63a3e
--- /dev/null
+++ b/os161-1.10/testbin/randcall/main.c
@@ -0,0 +1,137 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "extern.h"
+
+static
+void
+randchar(char *c)
+{
+#if RAND_MAX != 0x7fffffff
+#error "This code assumes RAND_MAX is 0x7fffffff"
+#endif
+
+	static long lbits = 0;
+	static long lnum = 0;
+
+	long bit;
+	int ct = 0;
+
+	*c = 0;
+
+	while (ct < CHAR_BIT) {
+		if (lnum==0) {
+			lbits = random();
+			lnum = 31;
+		}
+
+		bit = lbits & 1;
+		if (bit) {
+			(*c) |= 1;
+		}
+		(*c) <<= 1;
+		ct++;
+		lbits >>= 1;
+		lnum--;
+	}
+}
+
+static
+void
+fillrand(void *p, size_t len)
+{
+	size_t i;
+	char *cp = p;
+	for (i=0; i<len; i++) {
+		randchar(&cp[i]);
+	}
+}
+
+void *
+randptr(void)
+{
+	void *x;
+	fillrand(&x, sizeof(x));
+	return x;
+}
+
+int
+randint(void)
+{
+	int x;
+	fillrand(&x, sizeof(x));
+	return x;
+}
+
+off_t
+randoff(void)
+{
+	off_t x;
+	fillrand(&x, sizeof(x));
+	return x;
+}
+
+size_t
+randsize(void)
+{
+	size_t x;
+	fillrand(&x, sizeof(x));
+	return x;
+}
+
+static
+void
+usage(void)
+{
+	printf("Usage: randcall [-f] [-c count] [-r seed] 2|3|4|all\n");
+	printf("   -f   suppress forking\n");
+	printf("   -c   set iteration count (default 100)\n");
+	printf("   -r   set pseudorandom seed (default 0)\n");
+	exit(1);
+}
+
+int
+main(int argc, char *argv[])
+{
+	int count=100, seed = 0, dofork = 1;
+	int an, i;
+
+	for (i=1; i<argc; i++) {
+		if (!strcmp(argv[i], "-f")) {
+			dofork = 0;
+		}
+		else if (!strcmp(argv[i], "-c") && i<argc-1) {
+			count = atoi(argv[++i]);
+		}
+		else if (!strcmp(argv[i], "-r") && i<argc-1) {
+			seed = atoi(argv[++i]);
+		}
+		else if (argv[i][0] == '-') {
+			usage();
+		}
+		else {
+			break;
+		}
+	}
+	if (i != argc-1) {
+		usage();
+	}
+
+	if (!strcmp(argv[i], "all")) {
+		an = 5;
+	}
+	else {
+		an = atoi(argv[i]);
+		if (an <2 || an > 4) {
+			usage();
+		}
+	}
+
+	printf("Seed: %d  Count: %d\n", seed, count);
+
+	srandom(seed);
+	trycalls(an, dofork, count);
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/rmdirtest/.cvsignore b/os161-1.10/testbin/rmdirtest/.cvsignore
new file mode 100644
index 0000000..528c8a7
--- /dev/null
+++ b/os161-1.10/testbin/rmdirtest/.cvsignore
@@ -0,0 +1 @@
+rmdirtest
diff --git a/os161-1.10/testbin/rmdirtest/Makefile b/os161-1.10/testbin/rmdirtest/Makefile
new file mode 100644
index 0000000..89df9dc
--- /dev/null
+++ b/os161-1.10/testbin/rmdirtest/Makefile
@@ -0,0 +1,9 @@
+# Makefile for rmdirtest
+
+SRCS=rmdirtest.c
+PROG=rmdirtest
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/rmdirtest/depend.mk b/os161-1.10/testbin/rmdirtest/depend.mk
new file mode 100644
index 0000000..36d4f39
--- /dev/null
+++ b/os161-1.10/testbin/rmdirtest/depend.mk
@@ -0,0 +1,20 @@
+
+rmdirtest.o: \
+ rmdirtest.c \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/sys/stat.h \
+ $(OSTREE)/include/kern/stat.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/fcntl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/limits.h \
+ $(OSTREE)/include/kern/limits.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/rmdirtest/rmdirtest.c b/os161-1.10/testbin/rmdirtest/rmdirtest.c
new file mode 100644
index 0000000..bfc73a1
--- /dev/null
+++ b/os161-1.10/testbin/rmdirtest/rmdirtest.c
@@ -0,0 +1,375 @@
+/*
+ * rmdirtest.c
+ *
+ *      Tests file system synchronization and directory implementation by
+ *      removing the current directory under itself and then trying to do
+ *      things. It's ok for most of those things to fail, but the system
+ *      shouldn't crash.
+ */
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <limits.h>
+#include <err.h>
+
+
+static const char testdir[] = "testdir";
+static char startpoint[PATH_MAX - sizeof(testdir)];
+
+/*
+ * Create the test directory, and change into it, remembering
+ * where we came from.
+ */
+
+static
+void
+startup(void)
+{
+	if (getcwd(startpoint, sizeof(startpoint))==NULL) {
+		err(1, "getcwd (not in test dir)");
+	}
+
+	if (mkdir(testdir, 0775) < 0) {
+		err(1, "%s: mkdir", testdir);
+	}
+
+	if (chdir(testdir) < 0) {
+		err(1, "%s: chdir", testdir);
+	}
+}
+
+/*
+ * Remove the test directory.
+ *
+ * Note that even though it's the current directory, we can't do it
+ * with rmdir(".") - what that would try to do is remove the "." entry
+ * from the current directory, which is justifiably prohibited.
+ */
+
+static
+void
+killdir(void)
+{
+	char tmp[PATH_MAX];
+
+	snprintf(tmp, sizeof(tmp), "%s/%s", startpoint, testdir);
+	if (rmdir(tmp)<0) {
+		err(1, "%s: rmdir", tmp);
+	}
+}
+
+/*
+ * Leave the test directory and go back to where we came from, so we
+ * can try again.
+ */
+
+static
+void
+finish(void)
+{
+	if (chdir(startpoint)<0) {
+		err(1, "%s: chdir", startpoint);
+	}
+}
+
+/*************************************************************/
+
+/*
+ * Basic test - just try removing the directory without doing anything
+ * evil.
+ */
+static
+void
+test1(void)
+{
+	printf("Making %s\n", testdir);
+	startup();
+
+	printf("Removing %s while in it\n", testdir);
+	killdir();
+
+	printf("Leaving the test directory\n");
+	finish();
+}
+
+/*
+ * Now do it while we also have the directory open.
+ */
+
+static
+void
+test2(void)
+{
+	int fd;
+
+	printf("Now trying with the directory open...\n");
+	startup();
+	fd = open(".", O_RDONLY);
+	if (fd<0) {
+		err(1, ".: open");
+	}
+	killdir();
+	finish();
+
+	/* close *after* leaving, just for excitement */
+	if (close(fd)<0) {
+		err(1, "removed %s: close", testdir);
+	}
+}
+
+/*
+ * Now see if . and .. work after rmdir.
+ */
+
+static
+void
+test3(void)
+{
+	char buf[PATH_MAX];
+	int fd;
+
+	printf("Checking if . exists after rmdir\n");
+	startup();
+	killdir();
+
+	fd = open(".", O_RDONLY);
+	if (fd<0) {
+		switch (errno) {
+		    case EINVAL:
+		    case EIO:
+		    case ENOENT:
+			break;
+		    default:
+			err(1, ".");
+			break;
+		}
+	}
+	else {
+		close(fd);
+	}
+
+	fd = open("..", O_RDONLY);
+	if (fd<0) {
+		switch (errno) {
+		    case EINVAL:
+		    case EIO:
+		    case ENOENT:
+			break;
+		    default:
+			err(1, "..");
+			break;
+		}
+	}
+	else {
+		warnx("..: openable after rmdir - might be bad");
+		close(fd);
+	}
+
+	snprintf(buf, sizeof(buf), "../%s", testdir);
+	fd = open(buf, O_RDONLY);
+	if (fd<0) {
+		switch (errno) {
+		    case EINVAL:
+		    case EIO:
+		    case ENOENT:
+			break;
+		    default:
+			err(1, "%s", buf);
+			break;
+		}
+	}
+	else {
+		errx(1, "%s: works after rmdir", buf);
+	}
+
+	finish();
+}
+
+/*
+ * Now try to create files.
+ */
+
+static
+void
+test4(void)
+{
+	char buf[4096];
+	int fd;
+
+	printf("Checking if creating files works after rmdir...\n");
+	startup();
+	killdir();
+
+	fd = open("newfile", O_WRONLY|O_CREAT|O_TRUNC, 0664);
+	if (fd<0) {
+		switch (errno) {
+		    case EINVAL:
+		    case EIO:
+		    case ENOENT:
+			break;
+		    default:
+			err(1, "%s", buf);
+			break;
+		}
+	}
+	else {
+		warnx("newfile: creating files after rmdir works");
+		warnx("(this is only ok if the space gets reclaimed)");
+
+		/*
+		 * Waste a bunch of space so we'll be able to tell
+		 */
+		memset(buf, 'J', sizeof(buf));
+		write(fd, buf, sizeof(buf));
+		write(fd, buf, sizeof(buf));
+		write(fd, buf, sizeof(buf));
+		write(fd, buf, sizeof(buf));
+		close(fd);
+	}
+
+	finish();
+}
+
+/*
+ * Now try to create directories.
+ */
+
+static
+void
+test5(void)
+{
+	printf("Checking if creating subdirs works after rmdir...\n");
+	startup();
+	killdir();
+
+	if (mkdir("newdir", 0775)<0) {
+		switch (errno) {
+		    case EINVAL:
+		    case EIO:
+		    case ENOENT:
+			break;
+		    default:
+			err(1, "mkdir in removed dir");
+			break;
+		}
+	}
+	else {
+		warnx("newfile: creating directories after rmdir works");
+		warnx("(this is only ok if the space gets reclaimed)");
+
+		/*
+		 * Waste a bunch of space so we'll be able to tell
+		 */
+		mkdir("newdir/t0", 0775);
+		mkdir("newdir/t1", 0775);
+		mkdir("newdir/t2", 0775);
+		mkdir("newdir/t3", 0775);
+		mkdir("newdir/t4", 0775);
+		mkdir("newdir/t5", 0775);
+	}
+
+	finish();
+}
+
+/*
+ * Now try listing the directory.
+ */
+static
+void
+test6(void)
+{
+	char buf[PATH_MAX];
+	int fd, len;
+
+	printf("Now trying to list the directory...\n");
+	startup();
+	fd = open(".", O_RDONLY);
+	if (fd<0) {
+		err(1, ".: open");
+	}
+	killdir();
+
+	while ((len = getdirentry(fd, buf, sizeof(buf)-1))>0) {
+		if ((unsigned)len >= sizeof(buf)-1) {
+			errx(1, ".: getdirentry: returned invalid length");
+		}
+		buf[len] = 0;
+		if (!strcmp(buf, ".") || !strcmp(buf, "..")) {
+			/* these are allowed to appear */
+			continue;
+		}
+		errx(1, ".: getdirentry: returned unexpected name %s", buf);
+	}
+	if (len==0) {
+		/* EOF - ok */
+	}
+	else { /* len < 0 */
+		switch (errno) {
+		    case EINVAL:
+		    case EIO:
+			break;
+		    default:
+			err(1, ".: getdirentry");
+			break;
+		}
+	}
+
+	finish();
+
+	/* close *after* leaving, just for excitement */
+	if (close(fd)<0) {
+		err(1, "removed %s: close", testdir);
+	}
+}
+
+/*
+ * Try getcwd.
+ */
+static
+void
+test7(void)
+{
+	char buf[PATH_MAX];
+
+	startup();
+	killdir();
+	if (getcwd(buf, sizeof(buf))==NULL) {
+		switch (errno) {
+		    case EINVAL:
+		    case EIO:
+		    case ENOENT:
+			break;
+		    default:
+			err(1, "getcwd after removing %s", testdir);
+			break;
+		}
+	}
+	else {
+		errx(1, "getcwd after removing %s: succeeded (got %s)",
+		     testdir, buf);
+	}
+
+	finish();
+}
+
+/**************************************************************/
+
+int
+main(void)
+{
+	test1();
+	test2();
+	test3();
+	test4();
+	test5();
+	test6();
+	test7();
+
+	printf("Whew... survived.\n");
+	return 0;
+}
diff --git a/os161-1.10/testbin/rmtest/.cvsignore b/os161-1.10/testbin/rmtest/.cvsignore
new file mode 100644
index 0000000..d1c3b5c
--- /dev/null
+++ b/os161-1.10/testbin/rmtest/.cvsignore
@@ -0,0 +1 @@
+rmtest
diff --git a/os161-1.10/testbin/rmtest/Makefile b/os161-1.10/testbin/rmtest/Makefile
new file mode 100644
index 0000000..90f6a76
--- /dev/null
+++ b/os161-1.10/testbin/rmtest/Makefile
@@ -0,0 +1,9 @@
+# Makefile for rmtest
+
+SRCS=rmtest.c
+PROG=rmtest
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/rmtest/depend.mk b/os161-1.10/testbin/rmtest/depend.mk
new file mode 100644
index 0000000..449be7e
--- /dev/null
+++ b/os161-1.10/testbin/rmtest/depend.mk
@@ -0,0 +1,16 @@
+
+rmtest.o: \
+ rmtest.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/errno.h \
+ $(OSTREE)/include/kern/errno.h \
+ $(OSTREE)/include/err.h
diff --git a/os161-1.10/testbin/rmtest/rmtest.c b/os161-1.10/testbin/rmtest/rmtest.c
new file mode 100644
index 0000000..7c2e5ca
--- /dev/null
+++ b/os161-1.10/testbin/rmtest/rmtest.c
@@ -0,0 +1,130 @@
+/*
+ * rmtest.c
+ *
+ * 	Tests file system synchronization by deleting an open file and
+ * 	then attempting to read it.
+ *
+ * This should run correctly when the file system assignment is complete.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <err.h>
+
+#define TEST        "rmdata"
+#define TESTDATA    "I wish I was a headlight. -- Jerry Garcia"
+#define TESTLEN     (sizeof(TESTDATA)-1)
+
+static
+void
+dorm(int fd)
+{
+	/*
+	 * This used to spawn a copy of /bin/rm, but that's silly.
+	 * However, we will do the remove() from a subprocess, so
+	 * that various kinds of improper hacks to make this test
+	 * run won't work.
+	 *
+	 * Close the file in the subprocess, for similar reasons.
+	 */
+
+	pid_t pid;
+	int status;
+
+	pid = fork();
+	if (pid<0) {
+		err(1, "fork");
+	}
+	if (pid==0) {
+		/* child process */
+		close(fd);
+		if (remove(TEST)) {
+			err(1, "%s: remove", TEST);
+		}
+		_exit(0);
+	}
+	/* parent process */
+	if (waitpid(pid, &status, 0)<0) {
+		err(1, "waitpid");
+	}
+	if (status) {
+		warnx("child process exited with code %d", status);
+	}
+}
+
+int 
+same(const char *a, const char *b, int len)
+{
+	while (len-- > 0) {
+		if (*a++ != *b++) return 0;
+	}
+	return 1;
+}
+
+int
+main()
+{
+	int file, len;
+	char buf[TESTLEN];
+
+	/* create test data file */
+	file = open(TEST, O_WRONLY | O_CREAT | O_TRUNC, 0664);
+	write(file, TESTDATA, TESTLEN);
+	close(file);
+
+	/* make sure the data is there */
+	file = open(TEST, O_RDONLY);
+	len = read(file, buf, TESTLEN);
+	if (len < 0) {
+		warn("read: before deletion");
+	}
+	else if (len < (int)TESTLEN) {
+		warnx("read: before deletion: short count %d", len);
+	}
+	if (!same(buf, TESTDATA, TESTLEN)) {
+		errx(1, "Failed: data read back was not the same");
+	}
+
+	/* rewind the file */
+	if (lseek(file, 0, SEEK_SET)) {
+		err(1, "lseek");
+	}
+
+	/* now spawn our killer and wait for it to do its work */
+	dorm(file);
+
+	/* we should be still able to read the data */
+	memset(buf, '\0', TESTLEN);
+	len = read(file, buf, TESTLEN);
+	if (len < 0) {
+		warn("read: after deletion");
+	}
+	else if (len < (int)TESTLEN) {
+		warnx("read: after deletion: short count %d", len);
+	}
+
+	if (!same(buf, TESTDATA, TESTLEN)) {
+		errx(1, "Failed: data read after deletion was not the same");
+	}
+
+	/* ok, close the file and it should go away */
+	close(file);
+
+	/* try to open it again */
+	file = open(TEST, O_RDONLY);
+	if (file >= 0) {
+		close(file);
+		errx(1, "Failed: the file could still be opened");
+	}
+
+	if (errno!=ENOENT) {
+		err(1, "Unexpected error reopening the file");
+	}
+
+	printf("Succeeded!\n");
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/sink/.cvsignore b/os161-1.10/testbin/sink/.cvsignore
new file mode 100644
index 0000000..9773313
--- /dev/null
+++ b/os161-1.10/testbin/sink/.cvsignore
@@ -0,0 +1 @@
+sink
diff --git a/os161-1.10/testbin/sink/Makefile b/os161-1.10/testbin/sink/Makefile
new file mode 100644
index 0000000..10e4d9d
--- /dev/null
+++ b/os161-1.10/testbin/sink/Makefile
@@ -0,0 +1,9 @@
+# Makefile for sink
+
+SRCS=sink.c
+PROG=sink
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/sink/depend.mk b/os161-1.10/testbin/sink/depend.mk
new file mode 100644
index 0000000..b88468f
--- /dev/null
+++ b/os161-1.10/testbin/sink/depend.mk
@@ -0,0 +1,11 @@
+
+sink.o: \
+ sink.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/sink/sink.c b/os161-1.10/testbin/sink/sink.c
new file mode 100644
index 0000000..4b9ecc6
--- /dev/null
+++ b/os161-1.10/testbin/sink/sink.c
@@ -0,0 +1,30 @@
+/*
+ * sink.c
+ *
+ * 	Accept console input (or rather, stdin) and throw it away.
+ *
+ * This should work once the basic system calls are complete.
+ */
+
+#include <unistd.h>
+#include <err.h>
+
+int
+main(void)
+{
+	char ch=0;
+	int r;
+
+	while (ch!='q') {
+		r = read(STDIN_FILENO, &ch, 1);
+		if (r<0) {
+			err(1, "stdin");
+		}
+		if (r==0) {
+			/* EOF */
+			break;
+		}
+	}
+
+	return 0;
+}
diff --git a/os161-1.10/testbin/sort/.cvsignore b/os161-1.10/testbin/sort/.cvsignore
new file mode 100644
index 0000000..ff6c75e
--- /dev/null
+++ b/os161-1.10/testbin/sort/.cvsignore
@@ -0,0 +1 @@
+sort
diff --git a/os161-1.10/testbin/sort/Makefile b/os161-1.10/testbin/sort/Makefile
new file mode 100644
index 0000000..0396777
--- /dev/null
+++ b/os161-1.10/testbin/sort/Makefile
@@ -0,0 +1,9 @@
+# Makefile for sort
+
+SRCS=sort.c
+PROG=sort
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/sort/depend.mk b/os161-1.10/testbin/sort/depend.mk
new file mode 100644
index 0000000..9ee1d08
--- /dev/null
+++ b/os161-1.10/testbin/sort/depend.mk
@@ -0,0 +1,10 @@
+
+sort.o: \
+ sort.c \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/string.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/sort/sort.c b/os161-1.10/testbin/sort/sort.c
new file mode 100644
index 0000000..e83517b
--- /dev/null
+++ b/os161-1.10/testbin/sort/sort.c
@@ -0,0 +1,106 @@
+/* sort.c 
+ *    Test program to sort a large number of integers.
+ *
+ *    Intention is to stress virtual memory system.
+ *
+ *    Once the virtual memory assignment is complete, your system
+ *    should survive this.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <err.h>
+
+/* Larger than physical memory */
+#define SIZE  (144*1024)
+
+
+/*
+ * Quicksort.
+ *
+ * This used to be a bubble sort, which was ok but slow in nachos with
+ * 4k of memory and SIZE of 1024. However, with SIZE of 147,456 bubble
+ * sort is completely unacceptable.
+ *
+ * Also, quicksort has somewhat more interesting memory usage patterns.
+ */
+
+static
+void
+sort(int *arr, int size)
+{
+	static int tmp[SIZE];
+	int pivot, i, j, k;
+
+	if (size<2) {
+		return;
+	}
+
+	pivot = size/2;
+	sort(arr, pivot);
+	sort(&arr[pivot], size-pivot);
+
+	i = 0;
+	j = pivot;
+	k = 0;
+	while (i<pivot && j<size) {
+		if (arr[i] < arr[j]) {
+			tmp[k++] = arr[i++];
+		}
+		else {
+			tmp[k++] = arr[j++];
+		}
+	}
+	while (i<pivot) {
+		tmp[k++] = arr[i++];
+	}
+	while (j<size) {
+		tmp[k++] = arr[j++];
+	}
+
+	memcpy(arr, tmp, size*sizeof(int));
+}
+
+////////////////////////////////////////////////////////////
+
+static int A[SIZE];
+
+static
+void
+initarray(void)
+{
+	int i;
+
+	/*
+	 * Initialize the array, with pseudo-random but deterministic contents.
+	 */
+	srandom(533);
+
+	for (i = 0; i < SIZE; i++) {		
+		A[i] = random();
+	}
+}
+
+static
+void
+check(void)
+{
+	int i;
+
+	for (i=0; i<SIZE-1; i++) {
+		if (A[i] > A[i+1]) {
+			errx(1, "Failed: A[%d] is %d, A[%d] is %d", 
+			     i, A[i], i+1, A[i+1]);
+		}
+	}
+	warnx("Passed.");
+}
+
+int
+main(void)
+{
+	initarray();
+	sort(A, SIZE);
+	check();
+	return 0;
+}
diff --git a/os161-1.10/testbin/sty/.cvsignore b/os161-1.10/testbin/sty/.cvsignore
new file mode 100644
index 0000000..1fd8996
--- /dev/null
+++ b/os161-1.10/testbin/sty/.cvsignore
@@ -0,0 +1 @@
+sty
diff --git a/os161-1.10/testbin/sty/Makefile b/os161-1.10/testbin/sty/Makefile
new file mode 100644
index 0000000..e7ce919
--- /dev/null
+++ b/os161-1.10/testbin/sty/Makefile
@@ -0,0 +1,9 @@
+# Makefile for sty
+
+SRCS=sty.c
+PROG=sty
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/sty/depend.mk b/os161-1.10/testbin/sty/depend.mk
new file mode 100644
index 0000000..f041ddc
--- /dev/null
+++ b/os161-1.10/testbin/sty/depend.mk
@@ -0,0 +1,11 @@
+
+sty.o: \
+ sty.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/sty/sty.c b/os161-1.10/testbin/sty/sty.c
new file mode 100644
index 0000000..140eddf
--- /dev/null
+++ b/os161-1.10/testbin/sty/sty.c
@@ -0,0 +1,64 @@
+/*
+ * sty.c
+ *
+ * 	Run a bunch of cpu pigs.
+ *
+ * This test should itself run correctly when the basic system calls
+ * are complete. It may be helpful for scheduler performance analysis.
+ */
+
+#include <unistd.h>
+#include <err.h>
+
+static char *hargv[2] = { (char *)"hog", NULL };
+
+#define MAXPROCS  6
+static int pids[MAXPROCS], npids;
+
+static
+void
+hog(void)
+{
+	int pid = fork();
+	switch (pid) {
+	    case -1:
+		err(1, "fork");
+	    case 0:
+		/* child */
+		execv("/testbin/hog", hargv);
+		err(1, "/testbin/hog");
+	    default:
+		/* parent */
+		pids[npids++] = pid;
+		break;
+	}
+}
+
+static
+void
+waitall(void)
+{
+	int i, status;
+	for (i=0; i<npids; i++) {
+		if (waitpid(pids[i], &status, 0)<0) {
+			warn("waitpid for %d", pids[i]);
+		}
+		else if (status != 0) {
+			warnx("pid %d: exit %d", pids[i], status);
+		}
+	}
+}
+
+int
+main()
+{
+	hog();
+	hog();
+	hog();
+	hog();
+	hog();
+	hog();
+
+	waitall();
+	return 0;
+}
diff --git a/os161-1.10/testbin/tail/.cvsignore b/os161-1.10/testbin/tail/.cvsignore
new file mode 100644
index 0000000..e84fa9b
--- /dev/null
+++ b/os161-1.10/testbin/tail/.cvsignore
@@ -0,0 +1 @@
+tail
diff --git a/os161-1.10/testbin/tail/Makefile b/os161-1.10/testbin/tail/Makefile
new file mode 100644
index 0000000..2dad2a5
--- /dev/null
+++ b/os161-1.10/testbin/tail/Makefile
@@ -0,0 +1,9 @@
+# Makefile for tail
+
+SRCS=tail.c
+PROG=tail
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/tail/depend.mk b/os161-1.10/testbin/tail/depend.mk
new file mode 100644
index 0000000..909395b
--- /dev/null
+++ b/os161-1.10/testbin/tail/depend.mk
@@ -0,0 +1,12 @@
+
+tail.o: \
+ tail.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdlib.h \
+ $(OSTREE)/include/err.h \
+ $(OSTREE)/include/stdarg.h
diff --git a/os161-1.10/testbin/tail/tail.c b/os161-1.10/testbin/tail/tail.c
new file mode 100644
index 0000000..504584d
--- /dev/null
+++ b/os161-1.10/testbin/tail/tail.c
@@ -0,0 +1,52 @@
+/*
+ * tail.c
+ *
+ * 	Outputs a file beginning at a specific location.
+ *	Usage: tail <file> <location>
+ *
+ * This may be useful for testing during the file system assignment.
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <err.h>
+
+#define BUFSIZE 1000
+
+/* Put buffer in data space.  We know that the program should allocate as */
+/* much data space as required, but stack space is tight. */
+
+char buffer[BUFSIZE];
+
+static
+void
+tail(int file, off_t where, const char *filename)
+{
+	int len;
+
+	if (lseek(file, where, SEEK_SET)<0) {
+		err(1, "%s", filename);
+	}
+	
+	while ((len = read(file, buffer, sizeof(buffer))) > 0) {
+		write(STDOUT_FILENO, buffer, len);
+	}
+}
+
+int
+main(int argc, char **argv)
+{
+	int file;
+
+	if (argc < 2) {
+		errx(1, "Usage: tail <file> <location>");
+	}
+	file = open(argv[1], O_RDONLY);
+	if (file < 0) {
+		err(1, "%s", argv[1]);
+	}
+	tail(file, atoi(argv[2]), argv[1]);
+	close(file);
+	return 0;
+}
+
diff --git a/os161-1.10/testbin/tictac/.cvsignore b/os161-1.10/testbin/tictac/.cvsignore
new file mode 100644
index 0000000..f9296dc
--- /dev/null
+++ b/os161-1.10/testbin/tictac/.cvsignore
@@ -0,0 +1 @@
+tictac
diff --git a/os161-1.10/testbin/tictac/Makefile b/os161-1.10/testbin/tictac/Makefile
new file mode 100644
index 0000000..3064879
--- /dev/null
+++ b/os161-1.10/testbin/tictac/Makefile
@@ -0,0 +1,9 @@
+# Makefile for tictac
+
+SRCS=tictac.c
+PROG=tictac
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/tictac/depend.mk b/os161-1.10/testbin/tictac/depend.mk
new file mode 100644
index 0000000..49fe0cc
--- /dev/null
+++ b/os161-1.10/testbin/tictac/depend.mk
@@ -0,0 +1,11 @@
+
+tictac.o: \
+ tictac.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h
diff --git a/os161-1.10/testbin/tictac/tictac.c b/os161-1.10/testbin/tictac/tictac.c
new file mode 100644
index 0000000..85653e8
--- /dev/null
+++ b/os161-1.10/testbin/tictac/tictac.c
@@ -0,0 +1,370 @@
+/*
+ * These are some constants we use in our program.
+ * EMPTY is used to indicate empty spaces in the board.
+ * X_MARKER and O_MARKER are used to indicate where each
+ *	players has moved
+ * DIM indicates the size of the board.  For now
+ * we assume a conventional 3x3 playing board.
+ *
+ * This should work once the basic system calls are complete.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+
+#define NEWLINE 012
+#define	EMPTY		0
+#define X_PLAYER	1
+#define	O_PLAYER	2
+#define X_MARKER	1
+#define	O_MARKER	2
+#define DIM		3
+#define	DIMCHAR		"2"
+#define MAXSTRING	100
+
+typedef enum { FALSE, TRUE } bool;
+
+/* Function Declarations */
+bool ask_yesno(const char *msg);
+bool do_move(int player);
+void initialize_board(void);
+bool is_win(int x, int y);
+int  read_string(char *buf, int length);
+void print_board(void);
+void print_instructions(void);
+bool win_column(int y, int marker);
+bool win_diag_left(int x, int y, int marker);
+bool win_diag_right(int x, int y, int marker);
+bool win_row(int x, int marker);
+bool Strcmp(const char *a, const char *b);
+
+
+/*
+ * The board is gloabally defined.
+ */
+int board[DIM][DIM];
+
+/* Console I/O routines */
+
+int
+main()
+{
+	bool win = FALSE;
+	int move, max_moves;
+	int player;
+
+	print_instructions();
+	max_moves = DIM * DIM;	/* Maximum number of moves in a game */
+
+	while (TRUE) {
+		initialize_board();
+		for (move = 1; move <= max_moves; move++) {
+			player = move % 2 == 0 ? 2 : 1;
+			win = do_move(player);
+			print_board();
+			if (win) {
+				printf("Player %d, you WON!\n\n", player);
+				break;		/* out of for loop */
+			}
+		}
+		/*
+		 * If we got here by falling through the loop, then it is a
+		 * tie game.
+		 */
+		if (!win)
+			printf("Tie Game!\n\n");
+		if (!ask_yesno("Do you wish to play again?"))
+			break;			/* out of while loop */
+	}
+	return 0;
+}
+
+/*
+ * print_instructions
+ * Displays the instructions for the game.
+ * Input
+ *	None
+ * Output
+ *	None
+ * Error
+ *	None
+ */
+void
+print_instructions(void)
+{
+	printf("Welcome to tic-tac-toe!\n");
+	printf("Player 1 always plays X and player 2 always play O\n");
+	printf("Good luck!\n\n\n");
+}
+
+void
+/*
+ * print_board
+ * Display the DIM by DIM board.
+ * Input
+ *	None.
+ * Output
+ *	None.
+ * Errors
+ *	None.
+ */
+print_board(void)
+{
+	int i, j;
+
+	/* Print labels across the top */
+	printf("\n    0  1  2\n");
+
+	for (i = 0; i < DIM; i++) {
+		/* Print row labels */
+		printf(" %d ", i);
+		for (j = 0; j < DIM; j++) {
+			switch (board[i][j]) {
+				case EMPTY: printf("   "); break;
+				case X_MARKER: printf(" X "); break;
+				case O_MARKER: printf(" O "); break;
+				default: printf("???"); break;
+			}
+		}
+		printf("\n");
+	}
+	printf("\n");
+}
+
+/*
+ * ask_yesno (taken from histo.c)
+ * This function prints out the message and asks the user to respond
+ * with either a yes or a no.  It continues asking the questions until
+ * a valid reply is encountered and returns TRUE/FALSE indicating
+ * the answer (True for yes, false for no).
+ *
+ * Input
+ *	Question to be asked.
+ * Output
+ *	TRUE if response is yes
+ *	FALSE if response is no
+ * Error
+ *	None
+ */
+bool
+ask_yesno(const char *msg)
+{
+	char answer[MAXSTRING];
+
+	while (TRUE) {
+		printf("%s [yes/no] ", msg);
+		if (read_string(answer, MAXSTRING) < 0)
+			return(FALSE);
+		if (Strcmp(answer, "yes"))
+			return(TRUE);
+		else if (Strcmp(answer, "no"))
+			return(FALSE);
+		else
+			printf("Please answer either yes or no\n");
+	}
+}
+
+/*
+ * do_move
+ * Processes one player move.  The player enters a row and column
+ * and we have to determine if the square is valid (on the board)
+ * and that there is no mark already there.  We continue to ask
+ * for row/column pairs until we receive a valid combination.
+ * Then we mark the board, check for a win, and return.
+ *
+ * Input
+ *	player		Indicates which player (1 or 2) is moving
+ * Output
+ *	TRUE if this move won the game.
+ *	FALSE if this move did not win the game.
+ * Error
+ *	None
+ */
+bool
+do_move(int player)
+{
+	int x, y;
+	bool first;
+	char answer[MAXSTRING];
+	char cx;
+
+	first = TRUE;
+	printf("Player %d (%c), your move\n", player, 
+	       player == X_PLAYER ? 'X' : 'O');
+	
+	while (TRUE) {
+		printf("Which row [0-%d]: ", DIM-1);
+		if (read_string(answer, MAXSTRING) < 0)
+			return(FALSE);
+		cx = answer[0];
+		x = cx - '0';
+		if (x < 0 || x >= DIM) {
+			printf("Invalid row; must be >= 0 and < %d\n", DIM-1);
+			continue;
+		}
+		printf("Which column [0-%d]: ", DIM-1);
+		if (read_string(answer, MAXSTRING) < 0)
+			return(FALSE);
+		cx = answer[0];
+		y = cx - '0';
+		if (y < 0 || y >= DIM) {
+			printf("Invalid column; must be >= 0 and < %d\n",
+				DIM-1);
+			continue;
+		}
+
+		if (board[x][y] != EMPTY) {
+			printf("That location is occupied; please try again\n");
+			print_board();
+		} else
+			break;
+	}
+	board[x][y] = player == X_PLAYER ? X_MARKER : O_MARKER;
+
+	return(is_win(x, y));
+
+}
+
+/*
+ * is_win
+ * Checks if the move into position x, y created a tic-tac-toe.
+ * There are four possible ways to win -- horizontal, vertical,
+ * and the two diagonals; check each one using a separate routine.
+ * 
+ * Four routines for checking the wins are:
+ * win_row	The horizontal spots are all the same as this current mark.
+ * win_column	The vertical spots are all the same as this current mark.
+ * win_diag_left	The diagonal spots from left to right are all the
+ * 			same as the current mark.
+ * win_diag_right	The diagonal spots from right to left are all the
+ * 			same as the current mark.
+ *
+ * Input (for all routines)
+ *	x x coordinate
+ *	y y coordinate
+ *	marker the value just placed on the board.
+ * Output
+ *	TRUE if player won
+ *	FALSE otherwise
+ */
+bool
+is_win(int x, int y)
+{
+	int marker;
+
+	marker = board[x][y];
+
+	/*
+	 * Note that C "short circuit evaluation".  As soon as any one
+	 * of these functions returns TRUE, we know that the expression
+	 * is true.  Therefore, we can return TRUE without executing
+	 * any of the other routines.
+	 */
+	return(win_row(x, marker) || win_column(y, marker) ||
+	    win_diag_left(x, y, marker) || win_diag_right(x, y, marker));
+}
+
+/*
+ * Four helper functions for determining a win.
+ */
+bool
+win_column(int y, int marker)
+{
+	int i;
+	for (i = 0; i < DIM; i++)
+		if (board[i][y] != marker)
+			return(FALSE);
+	return(TRUE);
+}
+
+bool
+win_row(int x, int marker)
+{
+	int i;
+	for (i = 0; i < DIM; i++)
+		if (board[x][i] != marker)
+			return(FALSE);
+	return(TRUE);
+}	
+
+bool
+win_diag_left(int x, int y, int marker)
+{
+	int i;
+
+	/* Check that move is on the diagonal */
+	if (x != y)
+		return(FALSE);
+
+	for (i = 0; i < DIM; i++)
+		if (board[i][i] != marker)
+			return(FALSE);
+	return(TRUE);
+}
+
+bool
+win_diag_right(int x, int y, int marker)
+{
+	int i;
+
+	/* Check that move is on the diagonal */
+	if (x + y != DIM - 1)
+		return(FALSE);
+	for (i = 0; i < DIM; i++)
+		if (board[i][DIM - 1 - i] != marker)
+			return(FALSE);
+	return(TRUE);
+}
+
+void
+initialize_board(void)
+{
+	int i, j;
+
+	for (i = 0; i < DIM; i++)
+		for (j = 0; j < DIM; j++)
+			board[i][j] = EMPTY;
+}
+
+int
+read_string(char *buf, int length)
+{
+	int	char_read;
+	int	i;
+
+	i = 0;
+	while ((char_read = getchar()) != EOF && char_read != NEWLINE && 
+	    i < length) {
+		buf[i] = (char) char_read;
+		i++;
+		putchar(char_read);
+	}
+
+	if (char_read == EOF)
+		return(-1);
+
+	/*
+	 * If the input overflows the buffer, just cut it short
+	 * at length - 1 characters.
+	 */
+	if (i >= length)
+		i--;
+	buf[i] = 0;
+	return(i);
+}
+
+bool
+Strcmp(const char *a, const char *b)
+{
+	if (a == NULL)
+		return(b == NULL);
+	if (b == NULL)
+		return(FALSE);
+
+	while (*a && *b)
+		if (*a++ != *b++)
+			return(FALSE);
+
+	return(*a == *b);
+
+}
diff --git a/os161-1.10/testbin/triplehuge/.cvsignore b/os161-1.10/testbin/triplehuge/.cvsignore
new file mode 100644
index 0000000..c71c2c6
--- /dev/null
+++ b/os161-1.10/testbin/triplehuge/.cvsignore
@@ -0,0 +1 @@
+triplehuge
diff --git a/os161-1.10/testbin/triplehuge/Makefile b/os161-1.10/testbin/triplehuge/Makefile
new file mode 100644
index 0000000..4060ee5
--- /dev/null
+++ b/os161-1.10/testbin/triplehuge/Makefile
@@ -0,0 +1,9 @@
+# Makefile for triplehuge
+
+SRCS=triplehuge.c triple.c
+PROG=triplehuge
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/triplehuge/depend.mk b/os161-1.10/testbin/triplehuge/depend.mk
new file mode 100644
index 0000000..7878d48
--- /dev/null
+++ b/os161-1.10/testbin/triplehuge/depend.mk
@@ -0,0 +1,16 @@
+
+triplehuge.o: \
+ triplehuge.c \
+ triple.h
+triple.o: \
+ triple.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ triple.h
diff --git a/os161-1.10/testbin/triplehuge/triple.c b/os161-1.10/testbin/triplehuge/triple.c
new file mode 100644
index 0000000..2d93555
--- /dev/null
+++ b/os161-1.10/testbin/triplehuge/triple.c
@@ -0,0 +1,76 @@
+/*
+ * triple.c
+ *
+ * 	Runs three copies of some subprogram.
+ */
+
+#include <stdio.h>
+#include <unistd.h>
+#include <err.h>
+#include "triple.h"
+
+static
+pid_t
+spawnv(const char *prog, char **argv)
+{
+	pid_t pid = fork();
+	switch (pid) {
+	    case -1:
+		err(1, "fork");
+	    case 0:
+		/* child */
+		execv(prog, argv);
+		err(1, "%s: execv", prog);
+	    default:
+		/* parent */
+		break;
+	}
+	return pid;
+}
+
+static
+int
+dowait(int index, int pid)
+{
+	int status;
+
+	if (waitpid(pid, &status, 0)<0) {
+		warn("waitpid for copy #%d (pid %d)", index, pid);
+		return 1;
+	}
+	else if (status != 0) {
+		warnx("copy #%d (pid %d): exit %d", index, pid, status);
+		return 1;
+	}
+	return 0;
+}
+
+void
+triple(const char *prog)
+{
+	pid_t pids[3];
+	int i, failures = 0;
+	char *args[2];
+
+	/* set up the argv */
+	args[0]=(char *)prog;
+	args[1]=NULL;
+
+	warnx("Starting: running three copies of %s...", prog);
+
+	for (i=0; i<3; i++) {
+		pids[i]=spawnv(args[0], args);
+	}
+
+	for (i=0; i<3; i++) {
+		failures += dowait(i, pids[i]);
+	}
+
+	if (failures > 0) {
+		warnx("%d failures", failures);
+	}
+	else {
+		warnx("Congratulations! You passed.");
+	}
+}
+
diff --git a/os161-1.10/testbin/triplehuge/triple.h b/os161-1.10/testbin/triplehuge/triple.h
new file mode 100644
index 0000000..21019ba
--- /dev/null
+++ b/os161-1.10/testbin/triplehuge/triple.h
@@ -0,0 +1 @@
+void triple(const char *prog);
diff --git a/os161-1.10/testbin/triplehuge/triplehuge.c b/os161-1.10/testbin/triplehuge/triplehuge.c
new file mode 100644
index 0000000..bdc2c11
--- /dev/null
+++ b/os161-1.10/testbin/triplehuge/triplehuge.c
@@ -0,0 +1,18 @@
+/*
+ * triplehuge.c
+ *
+ * 	Calls three copies of "huge".
+ *
+ * When the VM assignment is complete, your system should survive this.
+ */
+
+#include "triple.h"
+
+int
+main()
+{
+	triple("/testbin/huge");
+	return 0;
+}
+
+
diff --git a/os161-1.10/testbin/triplemat/.cvsignore b/os161-1.10/testbin/triplemat/.cvsignore
new file mode 100644
index 0000000..449fcd7
--- /dev/null
+++ b/os161-1.10/testbin/triplemat/.cvsignore
@@ -0,0 +1 @@
+triplemat
diff --git a/os161-1.10/testbin/triplemat/Makefile b/os161-1.10/testbin/triplemat/Makefile
new file mode 100644
index 0000000..a9b9021
--- /dev/null
+++ b/os161-1.10/testbin/triplemat/Makefile
@@ -0,0 +1,20 @@
+# Makefile for triplemat
+
+SRCS=triplemat.c triple.c
+PROG=triplemat
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
+progdepend: triple.c triple.h
+
+triple.c:
+	ln -s ../triplehuge/triple.c .
+
+triple.h:
+	ln -s ../triplehuge/triple.h .
+
+clean: cleanhere
+cleanhere:
+	rm -f triple.c triple.h
diff --git a/os161-1.10/testbin/triplemat/depend.mk b/os161-1.10/testbin/triplemat/depend.mk
new file mode 100644
index 0000000..2b1a546
--- /dev/null
+++ b/os161-1.10/testbin/triplemat/depend.mk
@@ -0,0 +1,16 @@
+
+triplemat.o: \
+ triplemat.c \
+ triple.h
+triple.o: \
+ triple.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ triple.h
diff --git a/os161-1.10/testbin/triplemat/triplemat.c b/os161-1.10/testbin/triplemat/triplemat.c
new file mode 100644
index 0000000..f084a00
--- /dev/null
+++ b/os161-1.10/testbin/triplemat/triplemat.c
@@ -0,0 +1,17 @@
+/*
+ * triplemat.c
+ *
+ * 	Calls three matmult programs.
+ *
+ * When the VM assignment is complete, your system should survive this.
+ */
+
+#include "triple.h"
+
+int
+main()
+{
+	triple("/testbin/matmult");
+	return 0;
+}
+
diff --git a/os161-1.10/testbin/triplesort/.cvsignore b/os161-1.10/testbin/triplesort/.cvsignore
new file mode 100644
index 0000000..dd26b14
--- /dev/null
+++ b/os161-1.10/testbin/triplesort/.cvsignore
@@ -0,0 +1 @@
+triplesort
diff --git a/os161-1.10/testbin/triplesort/Makefile b/os161-1.10/testbin/triplesort/Makefile
new file mode 100644
index 0000000..d2143a2
--- /dev/null
+++ b/os161-1.10/testbin/triplesort/Makefile
@@ -0,0 +1,20 @@
+# Makefile for triplesort
+
+SRCS=triplesort.c triple.c
+PROG=triplesort
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
+progdepend: triple.c triple.h
+
+triple.c:
+	ln -s ../triplehuge/triple.c .
+
+triple.h:
+	ln -s ../triplehuge/triple.h .
+
+clean: cleanhere
+cleanhere:
+	rm -f triple.c triple.h
diff --git a/os161-1.10/testbin/triplesort/depend.mk b/os161-1.10/testbin/triplesort/depend.mk
new file mode 100644
index 0000000..c0f7cf0
--- /dev/null
+++ b/os161-1.10/testbin/triplesort/depend.mk
@@ -0,0 +1,16 @@
+
+triplesort.o: \
+ triplesort.c \
+ triple.h
+triple.o: \
+ triple.c \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/err.h \
+ triple.h
diff --git a/os161-1.10/testbin/triplesort/triplesort.c b/os161-1.10/testbin/triplesort/triplesort.c
new file mode 100644
index 0000000..ef516cf
--- /dev/null
+++ b/os161-1.10/testbin/triplesort/triplesort.c
@@ -0,0 +1,17 @@
+/*
+ * triplesort.c
+ *
+ * 	Calls three copies of /testbin/sort.
+ *
+ * When the VM assignment is complete, your system should survive this.
+ */
+
+#include "triple.h"
+
+int
+main()
+{
+	triple("/testbin/sort");
+	return 0;
+}
+
diff --git a/os161-1.10/testbin/userthreads/.cvsignore b/os161-1.10/testbin/userthreads/.cvsignore
new file mode 100644
index 0000000..a834ebd
--- /dev/null
+++ b/os161-1.10/testbin/userthreads/.cvsignore
@@ -0,0 +1 @@
+userthreads
diff --git a/os161-1.10/testbin/userthreads/Makefile b/os161-1.10/testbin/userthreads/Makefile
new file mode 100644
index 0000000..f6ae7c3
--- /dev/null
+++ b/os161-1.10/testbin/userthreads/Makefile
@@ -0,0 +1,9 @@
+# Makefile for userthreads
+
+SRCS=userthreads.c
+PROG=userthreads
+BINDIR=/testbin
+
+include ../../defs.mk
+include ../../mk/prog.mk
+
diff --git a/os161-1.10/testbin/userthreads/depend.mk b/os161-1.10/testbin/userthreads/depend.mk
new file mode 100644
index 0000000..8686286
--- /dev/null
+++ b/os161-1.10/testbin/userthreads/depend.mk
@@ -0,0 +1,12 @@
+
+userthreads.o: \
+ userthreads.c \
+ $(OSTREE)/include/unistd.h \
+ $(OSTREE)/include/sys/types.h \
+ $(OSTREE)/include/machine/types.h \
+ $(OSTREE)/include/kern/types.h \
+ $(OSTREE)/include/kern/unistd.h \
+ $(OSTREE)/include/kern/ioctl.h \
+ $(OSTREE)/include/stdio.h \
+ $(OSTREE)/include/stdarg.h \
+ $(OSTREE)/include/machine/stdarg.h
diff --git a/os161-1.10/testbin/userthreads/userthreads.c b/os161-1.10/testbin/userthreads/userthreads.c
new file mode 100644
index 0000000..3a8e8e1
--- /dev/null
+++ b/os161-1.10/testbin/userthreads/userthreads.c
@@ -0,0 +1,81 @@
+/*
+ * Test multiple user level threads inside a process. The program
+ * forks 3 threads off 2 to functions, each of which displays a string
+ * every once in a while.
+ *
+ * This won't do much of anything unless you implement user-level
+ * threads.
+ *
+ * It also makes various assumptions about the thread API. In
+ * particular, it believes (1) that you create a thread by calling
+ * "threadfork()" and passing the address for execution of the new
+ * thread to begin at, (2) that if the parent thread exits any child
+ * threads will keep running, and (3) child threads will exit if they
+ * return from the function they started in. If any or all of these
+ * assumptions are not met by your user-level threads, you will need
+ * to patch this test accordingly.
+ *
+ * This is also a rather basic test and you'll probably want to write
+ * some more of your own.
+ */
+
+
+#include <unistd.h>
+#include <stdio.h>
+
+#define NTHREADS  3
+#define MAX       1<<25
+
+/* counter for the loop in the threads : 
+   This variable is shared and incremented by each 
+   thread during his computation */
+volatile int count = 0;
+
+/* the 2 threads : */
+void ThreadRunner(void);
+void BladeRunner(void);
+
+int
+main(int argc, char *argv[])
+{
+    int i;
+
+    (void)argc;
+    (void)argv;
+
+    for (i=0; i<NTHREADS; i++) {
+	if (i)
+	    threadfork(ThreadRunner);
+        else
+	    threadfork(BladeRunner);
+    }
+
+    printf("Parent has left.\n");
+    return 0;
+}
+
+/* multiple threads will simply print out the global variable.
+   Even though there is no synchronization, we should get some 
+   random results.
+*/
+
+void
+BladeRunner()
+{
+    while (count < MAX) {
+	if (count % 500 == 0)
+	    printf("Blade ");
+	count++;
+    }
+}
+
+void
+ThreadRunner()
+{
+    while (count < MAX) {
+	if (count % 513 == 0)
+	    printf(" Runner\n");
+	count++;
+    }
+}
+    
